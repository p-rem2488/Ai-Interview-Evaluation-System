function WF(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in t)){const i=Object.getOwnPropertyDescriptor(r,s);i&&Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=n(s);fetch(s.href,i)}})();var _D=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function bC(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function xC(t){if(Object.prototype.hasOwnProperty.call(t,"__esModule"))return t;var e=t.default;if(typeof e=="function"){var n=function r(){var s=!1;try{s=this instanceof r}catch{}return s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(r){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}),n}var XI={exports:{}},_2={},YI={exports:{}},Wn={};var ID;function BY(){if(ID)return Wn;ID=1;var t=Symbol.for("react.element"),e=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),o=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),d=Symbol.iterator;function f(Y){return Y===null||typeof Y!="object"?null:(Y=d&&Y[d]||Y["@@iterator"],typeof Y=="function"?Y:null)}var m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,y={};function v(Y,re,Te){this.props=Y,this.context=re,this.refs=y,this.updater=Te||m}v.prototype.isReactComponent={},v.prototype.setState=function(Y,re){if(typeof Y!="object"&&typeof Y!="function"&&Y!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,Y,re,"setState")},v.prototype.forceUpdate=function(Y){this.updater.enqueueForceUpdate(this,Y,"forceUpdate")};function b(){}b.prototype=v.prototype;function x(Y,re,Te){this.props=Y,this.context=re,this.refs=y,this.updater=Te||m}var $=x.prototype=new b;$.constructor=x,g($,v.prototype),$.isPureReactComponent=!0;var S=Array.isArray,E=Object.prototype.hasOwnProperty,L={current:null},R={key:!0,ref:!0,__self:!0,__source:!0};function D(Y,re,Te){var Pe,de={},ge=null,Re=null;if(re!=null)for(Pe in re.ref!==void 0&&(Re=re.ref),re.key!==void 0&&(ge=""+re.key),re)E.call(re,Pe)&&!R.hasOwnProperty(Pe)&&(de[Pe]=re[Pe]);var Oe=arguments.length-2;if(Oe===1)de.children=Te;else if(1<Oe){for(var Ve=Array(Oe),We=0;We<Oe;We++)Ve[We]=arguments[We+2];de.children=Ve}if(Y&&Y.defaultProps)for(Pe in Oe=Y.defaultProps,Oe)de[Pe]===void 0&&(de[Pe]=Oe[Pe]);return{$$typeof:t,type:Y,key:ge,ref:Re,props:de,_owner:L.current}}function A(Y,re){return{$$typeof:t,type:Y.type,key:re,ref:Y.ref,props:Y.props,_owner:Y._owner}}function F(Y){return typeof Y=="object"&&Y!==null&&Y.$$typeof===t}function P(Y){var re={"=":"=0",":":"=2"};return"$"+Y.replace(/[=:]/g,function(Te){return re[Te]})}var K=/\/+/g;function j(Y,re){return typeof Y=="object"&&Y!==null&&Y.key!=null?P(""+Y.key):re.toString(36)}function se(Y,re,Te,Pe,de){var ge=typeof Y;(ge==="undefined"||ge==="boolean")&&(Y=null);var Re=!1;if(Y===null)Re=!0;else switch(ge){case"string":case"number":Re=!0;break;case"object":switch(Y.$$typeof){case t:case e:Re=!0}}if(Re)return Re=Y,de=de(Re),Y=Pe===""?"."+j(Re,0):Pe,S(de)?(Te="",Y!=null&&(Te=Y.replace(K,"$&/")+"/"),se(de,re,Te,"",function(We){return We})):de!=null&&(F(de)&&(de=A(de,Te+(!de.key||Re&&Re.key===de.key?"":(""+de.key).replace(K,"$&/")+"/")+Y)),re.push(de)),1;if(Re=0,Pe=Pe===""?".":Pe+":",S(Y))for(var Oe=0;Oe<Y.length;Oe++){ge=Y[Oe];var Ve=Pe+j(ge,Oe);Re+=se(ge,re,Te,Ve,de)}else if(Ve=f(Y),typeof Ve=="function")for(Y=Ve.call(Y),Oe=0;!(ge=Y.next()).done;)ge=ge.value,Ve=Pe+j(ge,Oe++),Re+=se(ge,re,Te,Ve,de);else if(ge==="object")throw re=String(Y),Error("Objects are not valid as a React child (found: "+(re==="[object Object]"?"object with keys {"+Object.keys(Y).join(", ")+"}":re)+"). If you meant to render a collection of children, use an array instead.");return Re}function fe(Y,re,Te){if(Y==null)return Y;var Pe=[],de=0;return se(Y,Pe,"","",function(ge){return re.call(Te,ge,de++)}),Pe}function me(Y){if(Y._status===-1){var re=Y._result;re=re(),re.then(function(Te){(Y._status===0||Y._status===-1)&&(Y._status=1,Y._result=Te)},function(Te){(Y._status===0||Y._status===-1)&&(Y._status=2,Y._result=Te)}),Y._status===-1&&(Y._status=0,Y._result=re)}if(Y._status===1)return Y._result.default;throw Y._result}var ye={current:null},oe={transition:null},ue={ReactCurrentDispatcher:ye,ReactCurrentBatchConfig:oe,ReactCurrentOwner:L};function _e(){throw Error("act(...) is not supported in production builds of React.")}return Wn.Children={map:fe,forEach:function(Y,re,Te){fe(Y,function(){re.apply(this,arguments)},Te)},count:function(Y){var re=0;return fe(Y,function(){re++}),re},toArray:function(Y){return fe(Y,function(re){return re})||[]},only:function(Y){if(!F(Y))throw Error("React.Children.only expected to receive a single React element child.");return Y}},Wn.Component=v,Wn.Fragment=n,Wn.Profiler=s,Wn.PureComponent=x,Wn.StrictMode=r,Wn.Suspense=l,Wn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ue,Wn.act=_e,Wn.cloneElement=function(Y,re,Te){if(Y==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+Y+".");var Pe=g({},Y.props),de=Y.key,ge=Y.ref,Re=Y._owner;if(re!=null){if(re.ref!==void 0&&(ge=re.ref,Re=L.current),re.key!==void 0&&(de=""+re.key),Y.type&&Y.type.defaultProps)var Oe=Y.type.defaultProps;for(Ve in re)E.call(re,Ve)&&!R.hasOwnProperty(Ve)&&(Pe[Ve]=re[Ve]===void 0&&Oe!==void 0?Oe[Ve]:re[Ve])}var Ve=arguments.length-2;if(Ve===1)Pe.children=Te;else if(1<Ve){Oe=Array(Ve);for(var We=0;We<Ve;We++)Oe[We]=arguments[We+2];Pe.children=Oe}return{$$typeof:t,type:Y.type,key:de,ref:ge,props:Pe,_owner:Re}},Wn.createContext=function(Y){return Y={$$typeof:o,_currentValue:Y,_currentValue2:Y,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},Y.Provider={$$typeof:i,_context:Y},Y.Consumer=Y},Wn.createElement=D,Wn.createFactory=function(Y){var re=D.bind(null,Y);return re.type=Y,re},Wn.createRef=function(){return{current:null}},Wn.forwardRef=function(Y){return{$$typeof:a,render:Y}},Wn.isValidElement=F,Wn.lazy=function(Y){return{$$typeof:c,_payload:{_status:-1,_result:Y},_init:me}},Wn.memo=function(Y,re){return{$$typeof:u,type:Y,compare:re===void 0?null:re}},Wn.startTransition=function(Y){var re=oe.transition;oe.transition={};try{Y()}finally{oe.transition=re}},Wn.unstable_act=_e,Wn.useCallback=function(Y,re){return ye.current.useCallback(Y,re)},Wn.useContext=function(Y){return ye.current.useContext(Y)},Wn.useDebugValue=function(){},Wn.useDeferredValue=function(Y){return ye.current.useDeferredValue(Y)},Wn.useEffect=function(Y,re){return ye.current.useEffect(Y,re)},Wn.useId=function(){return ye.current.useId()},Wn.useImperativeHandle=function(Y,re,Te){return ye.current.useImperativeHandle(Y,re,Te)},Wn.useInsertionEffect=function(Y,re){return ye.current.useInsertionEffect(Y,re)},Wn.useLayoutEffect=function(Y,re){return ye.current.useLayoutEffect(Y,re)},Wn.useMemo=function(Y,re){return ye.current.useMemo(Y,re)},Wn.useReducer=function(Y,re,Te){return ye.current.useReducer(Y,re,Te)},Wn.useRef=function(Y){return ye.current.useRef(Y)},Wn.useState=function(Y){return ye.current.useState(Y)},Wn.useSyncExternalStore=function(Y,re,Te){return ye.current.useSyncExternalStore(Y,re,Te)},Wn.useTransition=function(){return ye.current.useTransition()},Wn.version="18.3.1",Wn}var TD;function _C(){return TD||(TD=1,YI.exports=BY()),YI.exports}var SD;function UY(){if(SD)return _2;SD=1;var t=_C(),e=Symbol.for("react.element"),n=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i={key:!0,ref:!0,__self:!0,__source:!0};function o(a,l,u){var c,d={},f=null,m=null;u!==void 0&&(f=""+u),l.key!==void 0&&(f=""+l.key),l.ref!==void 0&&(m=l.ref);for(c in l)r.call(l,c)&&!i.hasOwnProperty(c)&&(d[c]=l[c]);if(a&&a.defaultProps)for(c in l=a.defaultProps,l)d[c]===void 0&&(d[c]=l[c]);return{$$typeof:e,type:a,key:f,ref:m,props:d,_owner:s.current}}return _2.Fragment=n,_2.jsx=o,_2.jsxs=o,_2}var $D;function WY(){return $D||($D=1,XI.exports=UY()),XI.exports}var et=WY(),lr=_C();const jY=bC(lr);var ev={},QI={exports:{}},Xo={},JI={exports:{}},ZI={};var CD;function GY(){return CD||(CD=1,(function(t){function e(oe,ue){var _e=oe.length;oe.push(ue);e:for(;0<_e;){var Y=_e-1>>>1,re=oe[Y];if(0<s(re,ue))oe[Y]=ue,oe[_e]=re,_e=Y;else break e}}function n(oe){return oe.length===0?null:oe[0]}function r(oe){if(oe.length===0)return null;var ue=oe[0],_e=oe.pop();if(_e!==ue){oe[0]=_e;e:for(var Y=0,re=oe.length,Te=re>>>1;Y<Te;){var Pe=2*(Y+1)-1,de=oe[Pe],ge=Pe+1,Re=oe[ge];if(0>s(de,_e))ge<re&&0>s(Re,de)?(oe[Y]=Re,oe[ge]=_e,Y=ge):(oe[Y]=de,oe[Pe]=_e,Y=Pe);else if(ge<re&&0>s(Re,_e))oe[Y]=Re,oe[ge]=_e,Y=ge;else break e}}return ue}function s(oe,ue){var _e=oe.sortIndex-ue.sortIndex;return _e!==0?_e:oe.id-ue.id}if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();t.unstable_now=function(){return o.now()-a}}var l=[],u=[],c=1,d=null,f=3,m=!1,g=!1,y=!1,v=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,x=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function $(oe){for(var ue=n(u);ue!==null;){if(ue.callback===null)r(u);else if(ue.startTime<=oe)r(u),ue.sortIndex=ue.expirationTime,e(l,ue);else break;ue=n(u)}}function S(oe){if(y=!1,$(oe),!g)if(n(l)!==null)g=!0,me(E);else{var ue=n(u);ue!==null&&ye(S,ue.startTime-oe)}}function E(oe,ue){g=!1,y&&(y=!1,b(D),D=-1),m=!0;var _e=f;try{for($(ue),d=n(l);d!==null&&(!(d.expirationTime>ue)||oe&&!P());){var Y=d.callback;if(typeof Y=="function"){d.callback=null,f=d.priorityLevel;var re=Y(d.expirationTime<=ue);ue=t.unstable_now(),typeof re=="function"?d.callback=re:d===n(l)&&r(l),$(ue)}else r(l);d=n(l)}if(d!==null)var Te=!0;else{var Pe=n(u);Pe!==null&&ye(S,Pe.startTime-ue),Te=!1}return Te}finally{d=null,f=_e,m=!1}}var L=!1,R=null,D=-1,A=5,F=-1;function P(){return!(t.unstable_now()-F<A)}function K(){if(R!==null){var oe=t.unstable_now();F=oe;var ue=!0;try{ue=R(!0,oe)}finally{ue?j():(L=!1,R=null)}}else L=!1}var j;if(typeof x=="function")j=function(){x(K)};else if(typeof MessageChannel<"u"){var se=new MessageChannel,fe=se.port2;se.port1.onmessage=K,j=function(){fe.postMessage(null)}}else j=function(){v(K,0)};function me(oe){R=oe,L||(L=!0,j())}function ye(oe,ue){D=v(function(){oe(t.unstable_now())},ue)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(oe){oe.callback=null},t.unstable_continueExecution=function(){g||m||(g=!0,me(E))},t.unstable_forceFrameRate=function(oe){0>oe||125<oe?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):A=0<oe?Math.floor(1e3/oe):5},t.unstable_getCurrentPriorityLevel=function(){return f},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(oe){switch(f){case 1:case 2:case 3:var ue=3;break;default:ue=f}var _e=f;f=ue;try{return oe()}finally{f=_e}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(oe,ue){switch(oe){case 1:case 2:case 3:case 4:case 5:break;default:oe=3}var _e=f;f=oe;try{return ue()}finally{f=_e}},t.unstable_scheduleCallback=function(oe,ue,_e){var Y=t.unstable_now();switch(typeof _e=="object"&&_e!==null?(_e=_e.delay,_e=typeof _e=="number"&&0<_e?Y+_e:Y):_e=Y,oe){case 1:var re=-1;break;case 2:re=250;break;case 5:re=1073741823;break;case 4:re=1e4;break;default:re=5e3}return re=_e+re,oe={id:c++,callback:ue,priorityLevel:oe,startTime:_e,expirationTime:re,sortIndex:-1},_e>Y?(oe.sortIndex=_e,e(u,oe),n(l)===null&&oe===n(u)&&(y?(b(D),D=-1):y=!0,ye(S,_e-Y))):(oe.sortIndex=re,e(l,oe),g||m||(g=!0,me(E))),oe},t.unstable_shouldYield=P,t.unstable_wrapCallback=function(oe){var ue=f;return function(){var _e=f;f=ue;try{return oe.apply(this,arguments)}finally{f=_e}}}})(ZI)),ZI}var ED;function HY(){return ED||(ED=1,JI.exports=GY()),JI.exports}var kD;function qY(){if(kD)return Xo;kD=1;var t=_C(),e=HY();function n(h){for(var p="https://reactjs.org/docs/error-decoder.html?invariant="+h,w=1;w<arguments.length;w++)p+="&args[]="+encodeURIComponent(arguments[w]);return"Minified React error #"+h+"; visit "+p+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,s={};function i(h,p){o(h,p),o(h+"Capture",p)}function o(h,p){for(s[h]=p,h=0;h<p.length;h++)r.add(p[h])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,u=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,c={},d={};function f(h){return l.call(d,h)?!0:l.call(c,h)?!1:u.test(h)?d[h]=!0:(c[h]=!0,!1)}function m(h,p,w,I){if(w!==null&&w.type===0)return!1;switch(typeof p){case"function":case"symbol":return!0;case"boolean":return I?!1:w!==null?!w.acceptsBooleans:(h=h.toLowerCase().slice(0,5),h!=="data-"&&h!=="aria-");default:return!1}}function g(h,p,w,I){if(p===null||typeof p>"u"||m(h,p,w,I))return!0;if(I)return!1;if(w!==null)switch(w.type){case 3:return!p;case 4:return p===!1;case 5:return isNaN(p);case 6:return isNaN(p)||1>p}return!1}function y(h,p,w,I,N,M,Z){this.acceptsBooleans=p===2||p===3||p===4,this.attributeName=I,this.attributeNamespace=N,this.mustUseProperty=w,this.propertyName=h,this.type=p,this.sanitizeURL=M,this.removeEmptyString=Z}var v={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(h){v[h]=new y(h,0,!1,h,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(h){var p=h[0];v[p]=new y(p,1,!1,h[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(h){v[h]=new y(h,2,!1,h.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(h){v[h]=new y(h,2,!1,h,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(h){v[h]=new y(h,3,!1,h.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(h){v[h]=new y(h,3,!0,h,null,!1,!1)}),["capture","download"].forEach(function(h){v[h]=new y(h,4,!1,h,null,!1,!1)}),["cols","rows","size","span"].forEach(function(h){v[h]=new y(h,6,!1,h,null,!1,!1)}),["rowSpan","start"].forEach(function(h){v[h]=new y(h,5,!1,h.toLowerCase(),null,!1,!1)});var b=/[\-:]([a-z])/g;function x(h){return h[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(h){var p=h.replace(b,x);v[p]=new y(p,1,!1,h,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(h){var p=h.replace(b,x);v[p]=new y(p,1,!1,h,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(h){var p=h.replace(b,x);v[p]=new y(p,1,!1,h,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(h){v[h]=new y(h,1,!1,h.toLowerCase(),null,!1,!1)}),v.xlinkHref=new y("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(h){v[h]=new y(h,1,!1,h.toLowerCase(),null,!0,!0)});function $(h,p,w,I){var N=v.hasOwnProperty(p)?v[p]:null;(N!==null?N.type!==0:I||!(2<p.length)||p[0]!=="o"&&p[0]!=="O"||p[1]!=="n"&&p[1]!=="N")&&(g(p,w,N,I)&&(w=null),I||N===null?f(p)&&(w===null?h.removeAttribute(p):h.setAttribute(p,""+w)):N.mustUseProperty?h[N.propertyName]=w===null?N.type===3?!1:"":w:(p=N.attributeName,I=N.attributeNamespace,w===null?h.removeAttribute(p):(N=N.type,w=N===3||N===4&&w===!0?"":""+w,I?h.setAttributeNS(I,p,w):h.setAttribute(p,w))))}var S=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,E=Symbol.for("react.element"),L=Symbol.for("react.portal"),R=Symbol.for("react.fragment"),D=Symbol.for("react.strict_mode"),A=Symbol.for("react.profiler"),F=Symbol.for("react.provider"),P=Symbol.for("react.context"),K=Symbol.for("react.forward_ref"),j=Symbol.for("react.suspense"),se=Symbol.for("react.suspense_list"),fe=Symbol.for("react.memo"),me=Symbol.for("react.lazy"),ye=Symbol.for("react.offscreen"),oe=Symbol.iterator;function ue(h){return h===null||typeof h!="object"?null:(h=oe&&h[oe]||h["@@iterator"],typeof h=="function"?h:null)}var _e=Object.assign,Y;function re(h){if(Y===void 0)try{throw Error()}catch(w){var p=w.stack.trim().match(/\n( *(at )?)/);Y=p&&p[1]||""}return`
`+Y+h}var Te=!1;function Pe(h,p){if(!h||Te)return"";Te=!0;var w=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(p)if(p=function(){throw Error()},Object.defineProperty(p.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(p,[])}catch(je){var I=je}Reflect.construct(h,[],p)}else{try{p.call()}catch(je){I=je}h.call(p.prototype)}else{try{throw Error()}catch(je){I=je}h()}}catch(je){if(je&&I&&typeof je.stack=="string"){for(var N=je.stack.split(`
`),M=I.stack.split(`
`),Z=N.length-1,pe=M.length-1;1<=Z&&0<=pe&&N[Z]!==M[pe];)pe--;for(;1<=Z&&0<=pe;Z--,pe--)if(N[Z]!==M[pe]){if(Z!==1||pe!==1)do if(Z--,pe--,0>pe||N[Z]!==M[pe]){var Se=`
`+N[Z].replace(" at new "," at ");return h.displayName&&Se.includes("<anonymous>")&&(Se=Se.replace("<anonymous>",h.displayName)),Se}while(1<=Z&&0<=pe);break}}}finally{Te=!1,Error.prepareStackTrace=w}return(h=h?h.displayName||h.name:"")?re(h):""}function de(h){switch(h.tag){case 5:return re(h.type);case 16:return re("Lazy");case 13:return re("Suspense");case 19:return re("SuspenseList");case 0:case 2:case 15:return h=Pe(h.type,!1),h;case 11:return h=Pe(h.type.render,!1),h;case 1:return h=Pe(h.type,!0),h;default:return""}}function ge(h){if(h==null)return null;if(typeof h=="function")return h.displayName||h.name||null;if(typeof h=="string")return h;switch(h){case R:return"Fragment";case L:return"Portal";case A:return"Profiler";case D:return"StrictMode";case j:return"Suspense";case se:return"SuspenseList"}if(typeof h=="object")switch(h.$$typeof){case P:return(h.displayName||"Context")+".Consumer";case F:return(h._context.displayName||"Context")+".Provider";case K:var p=h.render;return h=h.displayName,h||(h=p.displayName||p.name||"",h=h!==""?"ForwardRef("+h+")":"ForwardRef"),h;case fe:return p=h.displayName||null,p!==null?p:ge(h.type)||"Memo";case me:p=h._payload,h=h._init;try{return ge(h(p))}catch{}}return null}function Re(h){var p=h.type;switch(h.tag){case 24:return"Cache";case 9:return(p.displayName||"Context")+".Consumer";case 10:return(p._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return h=p.render,h=h.displayName||h.name||"",p.displayName||(h!==""?"ForwardRef("+h+")":"ForwardRef");case 7:return"Fragment";case 5:return p;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return ge(p);case 8:return p===D?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof p=="function")return p.displayName||p.name||null;if(typeof p=="string")return p}return null}function Oe(h){switch(typeof h){case"boolean":case"number":case"string":case"undefined":return h;case"object":return h;default:return""}}function Ve(h){var p=h.type;return(h=h.nodeName)&&h.toLowerCase()==="input"&&(p==="checkbox"||p==="radio")}function We(h){var p=Ve(h)?"checked":"value",w=Object.getOwnPropertyDescriptor(h.constructor.prototype,p),I=""+h[p];if(!h.hasOwnProperty(p)&&typeof w<"u"&&typeof w.get=="function"&&typeof w.set=="function"){var N=w.get,M=w.set;return Object.defineProperty(h,p,{configurable:!0,get:function(){return N.call(this)},set:function(Z){I=""+Z,M.call(this,Z)}}),Object.defineProperty(h,p,{enumerable:w.enumerable}),{getValue:function(){return I},setValue:function(Z){I=""+Z},stopTracking:function(){h._valueTracker=null,delete h[p]}}}}function nt(h){h._valueTracker||(h._valueTracker=We(h))}function ct(h){if(!h)return!1;var p=h._valueTracker;if(!p)return!0;var w=p.getValue(),I="";return h&&(I=Ve(h)?h.checked?"true":"false":h.value),h=I,h!==w?(p.setValue(h),!0):!1}function Ct(h){if(h=h||(typeof document<"u"?document:void 0),typeof h>"u")return null;try{return h.activeElement||h.body}catch{return h.body}}function Wt(h,p){var w=p.checked;return _e({},p,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:w??h._wrapperState.initialChecked})}function Et(h,p){var w=p.defaultValue==null?"":p.defaultValue,I=p.checked!=null?p.checked:p.defaultChecked;w=Oe(p.value!=null?p.value:w),h._wrapperState={initialChecked:I,initialValue:w,controlled:p.type==="checkbox"||p.type==="radio"?p.checked!=null:p.value!=null}}function vt(h,p){p=p.checked,p!=null&&$(h,"checked",p,!1)}function Ht(h,p){vt(h,p);var w=Oe(p.value),I=p.type;if(w!=null)I==="number"?(w===0&&h.value===""||h.value!=w)&&(h.value=""+w):h.value!==""+w&&(h.value=""+w);else if(I==="submit"||I==="reset"){h.removeAttribute("value");return}p.hasOwnProperty("value")?Pt(h,p.type,w):p.hasOwnProperty("defaultValue")&&Pt(h,p.type,Oe(p.defaultValue)),p.checked==null&&p.defaultChecked!=null&&(h.defaultChecked=!!p.defaultChecked)}function Tt(h,p,w){if(p.hasOwnProperty("value")||p.hasOwnProperty("defaultValue")){var I=p.type;if(!(I!=="submit"&&I!=="reset"||p.value!==void 0&&p.value!==null))return;p=""+h._wrapperState.initialValue,w||p===h.value||(h.value=p),h.defaultValue=p}w=h.name,w!==""&&(h.name=""),h.defaultChecked=!!h._wrapperState.initialChecked,w!==""&&(h.name=w)}function Pt(h,p,w){(p!=="number"||Ct(h.ownerDocument)!==h)&&(w==null?h.defaultValue=""+h._wrapperState.initialValue:h.defaultValue!==""+w&&(h.defaultValue=""+w))}var Rt=Array.isArray;function Yt(h,p,w,I){if(h=h.options,p){p={};for(var N=0;N<w.length;N++)p["$"+w[N]]=!0;for(w=0;w<h.length;w++)N=p.hasOwnProperty("$"+h[w].value),h[w].selected!==N&&(h[w].selected=N),N&&I&&(h[w].defaultSelected=!0)}else{for(w=""+Oe(w),p=null,N=0;N<h.length;N++){if(h[N].value===w){h[N].selected=!0,I&&(h[N].defaultSelected=!0);return}p!==null||h[N].disabled||(p=h[N])}p!==null&&(p.selected=!0)}}function mn(h,p){if(p.dangerouslySetInnerHTML!=null)throw Error(n(91));return _e({},p,{value:void 0,defaultValue:void 0,children:""+h._wrapperState.initialValue})}function jt(h,p){var w=p.value;if(w==null){if(w=p.children,p=p.defaultValue,w!=null){if(p!=null)throw Error(n(92));if(Rt(w)){if(1<w.length)throw Error(n(93));w=w[0]}p=w}p==null&&(p=""),w=p}h._wrapperState={initialValue:Oe(w)}}function Fn(h,p){var w=Oe(p.value),I=Oe(p.defaultValue);w!=null&&(w=""+w,w!==h.value&&(h.value=w),p.defaultValue==null&&h.defaultValue!==w&&(h.defaultValue=w)),I!=null&&(h.defaultValue=""+I)}function Vn(h){var p=h.textContent;p===h._wrapperState.initialValue&&p!==""&&p!==null&&(h.value=p)}function Bn(h){switch(h){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ln(h,p){return h==null||h==="http://www.w3.org/1999/xhtml"?Bn(p):h==="http://www.w3.org/2000/svg"&&p==="foreignObject"?"http://www.w3.org/1999/xhtml":h}var Tn,xr=(function(h){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(p,w,I,N){MSApp.execUnsafeLocalFunction(function(){return h(p,w,I,N)})}:h})(function(h,p){if(h.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in h)h.innerHTML=p;else{for(Tn=Tn||document.createElement("div"),Tn.innerHTML="<svg>"+p.valueOf().toString()+"</svg>",p=Tn.firstChild;h.firstChild;)h.removeChild(h.firstChild);for(;p.firstChild;)h.appendChild(p.firstChild)}});function fr(h,p){if(p){var w=h.firstChild;if(w&&w===h.lastChild&&w.nodeType===3){w.nodeValue=p;return}}h.textContent=p}var Ar={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Hs=["Webkit","ms","Moz","O"];Object.keys(Ar).forEach(function(h){Hs.forEach(function(p){p=p+h.charAt(0).toUpperCase()+h.substring(1),Ar[p]=Ar[h]})});function qr(h,p,w){return p==null||typeof p=="boolean"||p===""?"":w||typeof p!="number"||p===0||Ar.hasOwnProperty(h)&&Ar[h]?(""+p).trim():p+"px"}function gr(h,p){h=h.style;for(var w in p)if(p.hasOwnProperty(w)){var I=w.indexOf("--")===0,N=qr(w,p[w],I);w==="float"&&(w="cssFloat"),I?h.setProperty(w,N):h[w]=N}}var ir=_e({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Un(h,p){if(p){if(ir[h]&&(p.children!=null||p.dangerouslySetInnerHTML!=null))throw Error(n(137,h));if(p.dangerouslySetInnerHTML!=null){if(p.children!=null)throw Error(n(60));if(typeof p.dangerouslySetInnerHTML!="object"||!("__html"in p.dangerouslySetInnerHTML))throw Error(n(61))}if(p.style!=null&&typeof p.style!="object")throw Error(n(62))}}function Kr(h,p){if(h.indexOf("-")===-1)return typeof p.is=="string";switch(h){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ui=null;function Gn(h){return h=h.target||h.srcElement||window,h.correspondingUseElement&&(h=h.correspondingUseElement),h.nodeType===3?h.parentNode:h}var Cs=null,ci=null,Kn=null;function Dn(h){if(h=a2(h)){if(typeof Cs!="function")throw Error(n(280));var p=h.stateNode;p&&(p=m3(p),Cs(h.stateNode,h.type,p))}}function hn(h){ci?Kn?Kn.push(h):Kn=[h]:ci=h}function Qi(){if(ci){var h=ci,p=Kn;if(Kn=ci=null,Dn(h),p)for(h=0;h<p.length;h++)Dn(p[h])}}function Po(h,p){return h(p)}function bo(){}var bs=!1;function hi(h,p,w){if(bs)return h(p,w);bs=!0;try{return Po(h,p,w)}finally{bs=!1,(ci!==null||Kn!==null)&&(bo(),Qi())}}function Pi(h,p){var w=h.stateNode;if(w===null)return null;var I=m3(w);if(I===null)return null;w=I[p];e:switch(p){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(I=!I.disabled)||(h=h.type,I=!(h==="button"||h==="input"||h==="select"||h==="textarea")),h=!I;break e;default:h=!1}if(h)return null;if(w&&typeof w!="function")throw Error(n(231,p,typeof w));return w}var Or=!1;if(a)try{var cs={};Object.defineProperty(cs,"passive",{get:function(){Or=!0}}),window.addEventListener("test",cs,cs),window.removeEventListener("test",cs,cs)}catch{Or=!1}function Aa(h,p,w,I,N,M,Z,pe,Se){var je=Array.prototype.slice.call(arguments,3);try{p.apply(w,je)}catch(ut){this.onError(ut)}}var Ji=!1,cr=null,Es=!1,ks=null,ua={onError:function(h){Ji=!0,cr=h}};function Ns(h,p,w,I,N,M,Z,pe,Se){Ji=!1,cr=null,Aa.apply(ua,arguments)}function di(h,p,w,I,N,M,Z,pe,Se){if(Ns.apply(this,arguments),Ji){if(Ji){var je=cr;Ji=!1,cr=null}else throw Error(n(198));Es||(Es=!0,ks=je)}}function qs(h){var p=h,w=h;if(h.alternate)for(;p.return;)p=p.return;else{h=p;do p=h,(p.flags&4098)!==0&&(w=p.return),h=p.return;while(h)}return p.tag===3?w:null}function Fi(h){if(h.tag===13){var p=h.memoizedState;if(p===null&&(h=h.alternate,h!==null&&(p=h.memoizedState)),p!==null)return p.dehydrated}return null}function Ks(h){if(qs(h)!==h)throw Error(n(188))}function Ra(h){var p=h.alternate;if(!p){if(p=qs(h),p===null)throw Error(n(188));return p!==h?null:h}for(var w=h,I=p;;){var N=w.return;if(N===null)break;var M=N.alternate;if(M===null){if(I=N.return,I!==null){w=I;continue}break}if(N.child===M.child){for(M=N.child;M;){if(M===w)return Ks(N),h;if(M===I)return Ks(N),p;M=M.sibling}throw Error(n(188))}if(w.return!==I.return)w=N,I=M;else{for(var Z=!1,pe=N.child;pe;){if(pe===w){Z=!0,w=N,I=M;break}if(pe===I){Z=!0,I=N,w=M;break}pe=pe.sibling}if(!Z){for(pe=M.child;pe;){if(pe===w){Z=!0,w=M,I=N;break}if(pe===I){Z=!0,I=M,w=N;break}pe=pe.sibling}if(!Z)throw Error(n(189))}}if(w.alternate!==I)throw Error(n(190))}if(w.tag!==3)throw Error(n(188));return w.stateNode.current===w?h:p}function ca(h){return h=Ra(h),h!==null?Rr(h):null}function Rr(h){if(h.tag===5||h.tag===6)return h;for(h=h.child;h!==null;){var p=Rr(h);if(p!==null)return p;h=h.sibling}return null}var cl=e.unstable_scheduleCallback,Fo=e.unstable_cancelCallback,Xr=e.unstable_shouldYield,fi=e.unstable_requestPaint,gn=e.unstable_now,hs=e.unstable_getCurrentPriorityLevel,Zi=e.unstable_ImmediatePriority,xo=e.unstable_UserBlockingPriority,pi=e.unstable_NormalPriority,xs=e.unstable_LowPriority,Da=e.unstable_IdlePriority,ha=null,As=null;function mi(h){if(As&&typeof As.onCommitFiberRoot=="function")try{As.onCommitFiberRoot(ha,h,void 0,(h.current.flags&128)===128)}catch{}}var hr=Math.clz32?Math.clz32:Lo,Li=Math.log,Pr=Math.LN2;function Lo(h){return h>>>=0,h===0?32:31-(Li(h)/Pr|0)|0}var gi=64,Mo=4194304;function Hn(h){switch(h&-h){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return h&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return h}}function Rs(h,p){var w=h.pendingLanes;if(w===0)return 0;var I=0,N=h.suspendedLanes,M=h.pingedLanes,Z=w&268435455;if(Z!==0){var pe=Z&~N;pe!==0?I=Hn(pe):(M&=Z,M!==0&&(I=Hn(M)))}else Z=w&~N,Z!==0?I=Hn(Z):M!==0&&(I=Hn(M));if(I===0)return 0;if(p!==0&&p!==I&&(p&N)===0&&(N=I&-I,M=p&-p,N>=M||N===16&&(M&4194240)!==0))return p;if((I&4)!==0&&(I|=w&16),p=h.entangledLanes,p!==0)for(h=h.entanglements,p&=I;0<p;)w=31-hr(p),N=1<<w,I|=h[w],p&=~N;return I}function zo(h,p){switch(h){case 1:case 2:case 4:return p+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return p+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Vo(h,p){for(var w=h.suspendedLanes,I=h.pingedLanes,N=h.expirationTimes,M=h.pendingLanes;0<M;){var Z=31-hr(M),pe=1<<Z,Se=N[Z];Se===-1?((pe&w)===0||(pe&I)!==0)&&(N[Z]=zo(pe,p)):Se<=p&&(h.expiredLanes|=pe),M&=~pe}}function hl(h){return h=h.pendingLanes&-1073741825,h!==0?h:h&1073741824?1073741824:0}function dl(){var h=gi;return gi<<=1,(gi&4194240)===0&&(gi=64),h}function _o(h){for(var p=[],w=0;31>w;w++)p.push(h);return p}function Mi(h,p,w){h.pendingLanes|=p,p!==536870912&&(h.suspendedLanes=0,h.pingedLanes=0),h=h.eventTimes,p=31-hr(p),h[p]=w}function Bo(h,p){var w=h.pendingLanes&~p;h.pendingLanes=p,h.suspendedLanes=0,h.pingedLanes=0,h.expiredLanes&=p,h.mutableReadLanes&=p,h.entangledLanes&=p,p=h.entanglements;var I=h.eventTimes;for(h=h.expirationTimes;0<w;){var N=31-hr(w),M=1<<N;p[N]=0,I[N]=-1,h[N]=-1,w&=~M}}function da(h,p){var w=h.entangledLanes|=p;for(h=h.entanglements;w;){var I=31-hr(w),N=1<<I;N&p|h[I]&p&&(h[I]|=p),w&=~N}}var Sn=0;function yi(h){return h&=-h,1<h?4<h?(h&268435455)!==0?16:536870912:4:1}var fa,pa,Oa,O,U,G=!1,ce=[],Ne=null,qe=null,Ae=null,Ye=new Map,ot=new Map,bt=[],tn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function bn(h,p){switch(h){case"focusin":case"focusout":Ne=null;break;case"dragenter":case"dragleave":qe=null;break;case"mouseover":case"mouseout":Ae=null;break;case"pointerover":case"pointerout":Ye.delete(p.pointerId);break;case"gotpointercapture":case"lostpointercapture":ot.delete(p.pointerId)}}function Zt(h,p,w,I,N,M){return h===null||h.nativeEvent!==M?(h={blockedOn:p,domEventName:w,eventSystemFlags:I,nativeEvent:M,targetContainers:[N]},p!==null&&(p=a2(p),p!==null&&pa(p)),h):(h.eventSystemFlags|=I,p=h.targetContainers,N!==null&&p.indexOf(N)===-1&&p.push(N),h)}function an(h,p,w,I,N){switch(p){case"focusin":return Ne=Zt(Ne,h,p,w,I,N),!0;case"dragenter":return qe=Zt(qe,h,p,w,I,N),!0;case"mouseover":return Ae=Zt(Ae,h,p,w,I,N),!0;case"pointerover":var M=N.pointerId;return Ye.set(M,Zt(Ye.get(M)||null,h,p,w,I,N)),!0;case"gotpointercapture":return M=N.pointerId,ot.set(M,Zt(ot.get(M)||null,h,p,w,I,N)),!0}return!1}function kt(h){var p=td(h.target);if(p!==null){var w=qs(p);if(w!==null){if(p=w.tag,p===13){if(p=Fi(w),p!==null){h.blockedOn=p,U(h.priority,function(){Oa(w)});return}}else if(p===3&&w.stateNode.current.memoizedState.isDehydrated){h.blockedOn=w.tag===3?w.stateNode.containerInfo:null;return}}}h.blockedOn=null}function C(h){if(h.blockedOn!==null)return!1;for(var p=h.targetContainers;0<p.length;){var w=dt(h.domEventName,h.eventSystemFlags,p[0],h.nativeEvent);if(w===null){w=h.nativeEvent;var I=new w.constructor(w.type,w);ui=I,w.target.dispatchEvent(I),ui=null}else return p=a2(w),p!==null&&pa(p),h.blockedOn=w,!1;p.shift()}return!0}function W(h,p,w){C(h)&&w.delete(p)}function X(){G=!1,Ne!==null&&C(Ne)&&(Ne=null),qe!==null&&C(qe)&&(qe=null),Ae!==null&&C(Ae)&&(Ae=null),Ye.forEach(W),ot.forEach(W)}function te(h,p){h.blockedOn===p&&(h.blockedOn=null,G||(G=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,X)))}function ae(h){function p(N){return te(N,h)}if(0<ce.length){te(ce[0],h);for(var w=1;w<ce.length;w++){var I=ce[w];I.blockedOn===h&&(I.blockedOn=null)}}for(Ne!==null&&te(Ne,h),qe!==null&&te(qe,h),Ae!==null&&te(Ae,h),Ye.forEach(p),ot.forEach(p),w=0;w<bt.length;w++)I=bt[w],I.blockedOn===h&&(I.blockedOn=null);for(;0<bt.length&&(w=bt[0],w.blockedOn===null);)kt(w),w.blockedOn===null&&bt.shift()}var ie=S.ReactCurrentBatchConfig,he=!0;function xe(h,p,w,I){var N=Sn,M=ie.transition;ie.transition=null;try{Sn=1,Qe(h,p,w,I)}finally{Sn=N,ie.transition=M}}function Me(h,p,w,I){var N=Sn,M=ie.transition;ie.transition=null;try{Sn=4,Qe(h,p,w,I)}finally{Sn=N,ie.transition=M}}function Qe(h,p,w,I){if(he){var N=dt(h,p,w,I);if(N===null)z4(h,p,I,Ze,w),bn(h,I);else if(an(N,h,p,w,I))I.stopPropagation();else if(bn(h,I),p&4&&-1<tn.indexOf(h)){for(;N!==null;){var M=a2(N);if(M!==null&&fa(M),M=dt(h,p,w,I),M===null&&z4(h,p,I,Ze,w),M===N)break;N=M}N!==null&&I.stopPropagation()}else z4(h,p,I,null,w)}}var Ze=null;function dt(h,p,w,I){if(Ze=null,h=Gn(I),h=td(h),h!==null)if(p=qs(h),p===null)h=null;else if(w=p.tag,w===13){if(h=Fi(p),h!==null)return h;h=null}else if(w===3){if(p.stateNode.current.memoizedState.isDehydrated)return p.tag===3?p.stateNode.containerInfo:null;h=null}else p!==h&&(h=null);return Ze=h,null}function mt(h){switch(h){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(hs()){case Zi:return 1;case xo:return 4;case pi:case xs:return 16;case Da:return 536870912;default:return 16}default:return 16}}var yt=null,nn=null,sn=null;function er(){if(sn)return sn;var h,p=nn,w=p.length,I,N="value"in yt?yt.value:yt.textContent,M=N.length;for(h=0;h<w&&p[h]===N[h];h++);var Z=w-h;for(I=1;I<=Z&&p[w-I]===N[M-I];I++);return sn=N.slice(h,1<I?1-I:void 0)}function Xn(h){var p=h.keyCode;return"charCode"in h?(h=h.charCode,h===0&&p===13&&(h=13)):h=p,h===10&&(h=13),32<=h||h===13?h:0}function Ir(){return!0}function Ds(){return!1}function or(h){function p(w,I,N,M,Z){this._reactName=w,this._targetInst=N,this.type=I,this.nativeEvent=M,this.target=Z,this.currentTarget=null;for(var pe in h)h.hasOwnProperty(pe)&&(w=h[pe],this[pe]=w?w(M):M[pe]);return this.isDefaultPrevented=(M.defaultPrevented!=null?M.defaultPrevented:M.returnValue===!1)?Ir:Ds,this.isPropagationStopped=Ds,this}return _e(p.prototype,{preventDefault:function(){this.defaultPrevented=!0;var w=this.nativeEvent;w&&(w.preventDefault?w.preventDefault():typeof w.returnValue!="unknown"&&(w.returnValue=!1),this.isDefaultPrevented=Ir)},stopPropagation:function(){var w=this.nativeEvent;w&&(w.stopPropagation?w.stopPropagation():typeof w.cancelBubble!="unknown"&&(w.cancelBubble=!0),this.isPropagationStopped=Ir)},persist:function(){},isPersistent:Ir}),p}var Cn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(h){return h.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Cr=or(Cn),Os=_e({},Cn,{view:0,detail:0}),zi=or(Os),Pa,Io,Ps,Uo=_e({},Os,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:xn,button:0,buttons:0,relatedTarget:function(h){return h.relatedTarget===void 0?h.fromElement===h.srcElement?h.toElement:h.fromElement:h.relatedTarget},movementX:function(h){return"movementX"in h?h.movementX:(h!==Ps&&(Ps&&h.type==="mousemove"?(Pa=h.screenX-Ps.screenX,Io=h.screenY-Ps.screenY):Io=Pa=0,Ps=h),Pa)},movementY:function(h){return"movementY"in h?h.movementY:Io}}),Sc=or(Uo),Kl=_e({},Uo,{dataTransfer:0}),Fp=or(Kl),Nu=_e({},Os,{relatedTarget:0}),Xs=or(Nu),Lp=_e({},Cn,{animationName:0,elapsedTime:0,pseudoElement:0}),Mp=or(Lp),Fa=_e({},Cn,{clipboardData:function(h){return"clipboardData"in h?h.clipboardData:window.clipboardData}}),_=or(Fa),z=_e({},Cn,{data:0}),q=or(z),ne={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Fe={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Ge={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function xt(h){var p=this.nativeEvent;return p.getModifierState?p.getModifierState(h):(h=Ge[h])?!!p[h]:!1}function xn(){return xt}var rs=_e({},Os,{key:function(h){if(h.key){var p=ne[h.key]||h.key;if(p!=="Unidentified")return p}return h.type==="keypress"?(h=Xn(h),h===13?"Enter":String.fromCharCode(h)):h.type==="keydown"||h.type==="keyup"?Fe[h.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:xn,charCode:function(h){return h.type==="keypress"?Xn(h):0},keyCode:function(h){return h.type==="keydown"||h.type==="keyup"?h.keyCode:0},which:function(h){return h.type==="keypress"?Xn(h):h.type==="keydown"||h.type==="keyup"?h.keyCode:0}}),pr=or(rs),Fr=_e({},Uo,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Ys=or(Fr),La=_e({},Os,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:xn}),Ma=or(La),za=_e({},Cn,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xl=or(za),Au=_e({},Uo,{deltaX:function(h){return"deltaX"in h?h.deltaX:"wheelDeltaX"in h?-h.wheelDeltaX:0},deltaY:function(h){return"deltaY"in h?h.deltaY:"wheelDeltaY"in h?-h.wheelDeltaY:"wheelDelta"in h?-h.wheelDelta:0},deltaZ:0,deltaMode:0}),s3=or(Au),i3=[9,13,27,32],zp=a&&"CompositionEvent"in window,$c=null;a&&"documentMode"in document&&($c=document.documentMode);var o3=a&&"TextEvent"in window&&!$c,j1=a&&(!zp||$c&&8<$c&&11>=$c),a3=" ",G1=!1;function H1(h,p){switch(h){case"keyup":return i3.indexOf(p.keyCode)!==-1;case"keydown":return p.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function ed(h){return h=h.detail,typeof h=="object"&&"data"in h?h.data:null}var Cc=!1;function q1(h,p){switch(h){case"compositionend":return ed(p);case"keypress":return p.which!==32?null:(G1=!0,a3);case"textInput":return h=p.data,h===a3&&G1?null:h;default:return null}}function O4(h,p){if(Cc)return h==="compositionend"||!zp&&H1(h,p)?(h=er(),sn=nn=yt=null,Cc=!1,h):null;switch(h){case"paste":return null;case"keypress":if(!(p.ctrlKey||p.altKey||p.metaKey)||p.ctrlKey&&p.altKey){if(p.char&&1<p.char.length)return p.char;if(p.which)return String.fromCharCode(p.which)}return null;case"compositionend":return j1&&p.locale!=="ko"?null:p.data;default:return null}}var P4={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Xe(h){var p=h&&h.nodeName&&h.nodeName.toLowerCase();return p==="input"?!!P4[h.type]:p==="textarea"}function K1(h,p,w,I){hn(I),p=d3(p,"onChange"),0<p.length&&(w=new Cr("onChange","change",null,w,I),h.push({event:w,listeners:p}))}var Ec=null,Ru=null;function fl(h){MR(h,0)}function Du(h){var p=qp(h);if(ct(p))return h}function X1(h,p){if(h==="change")return p}var Y1=!1;if(a){var Vp;if(a){var Bp="oninput"in document;if(!Bp){var Up=document.createElement("div");Up.setAttribute("oninput","return;"),Bp=typeof Up.oninput=="function"}Vp=Bp}else Vp=!1;Y1=Vp&&(!document.documentMode||9<document.documentMode)}function Q1(){Ec&&(Ec.detachEvent("onpropertychange",J1),Ru=Ec=null)}function J1(h){if(h.propertyName==="value"&&Du(Ru)){var p=[];K1(p,Ru,h,Gn(h)),hi(fl,p)}}function l3(h,p,w){h==="focusin"?(Q1(),Ec=p,Ru=w,Ec.attachEvent("onpropertychange",J1)):h==="focusout"&&Q1()}function Wp(h){if(h==="selectionchange"||h==="keyup"||h==="keydown")return Du(Ru)}function Z1(h,p){if(h==="click")return Du(p)}function e2(h,p){if(h==="input"||h==="change")return Du(p)}function u3(h,p){return h===p&&(h!==0||1/h===1/p)||h!==h&&p!==p}var Wo=typeof Object.is=="function"?Object.is:u3;function kc(h,p){if(Wo(h,p))return!0;if(typeof h!="object"||h===null||typeof p!="object"||p===null)return!1;var w=Object.keys(h),I=Object.keys(p);if(w.length!==I.length)return!1;for(I=0;I<w.length;I++){var N=w[I];if(!l.call(p,N)||!Wo(h[N],p[N]))return!1}return!0}function t2(h){for(;h&&h.firstChild;)h=h.firstChild;return h}function n2(h,p){var w=t2(h);h=0;for(var I;w;){if(w.nodeType===3){if(I=h+w.textContent.length,h<=p&&I>=p)return{node:w,offset:p-h};h=I}e:{for(;w;){if(w.nextSibling){w=w.nextSibling;break e}w=w.parentNode}w=void 0}w=t2(w)}}function T(h,p){return h&&p?h===p?!0:h&&h.nodeType===3?!1:p&&p.nodeType===3?T(h,p.parentNode):"contains"in h?h.contains(p):h.compareDocumentPosition?!!(h.compareDocumentPosition(p)&16):!1:!1}function k(){for(var h=window,p=Ct();p instanceof h.HTMLIFrameElement;){try{var w=typeof p.contentWindow.location.href=="string"}catch{w=!1}if(w)h=p.contentWindow;else break;p=Ct(h.document)}return p}function V(h){var p=h&&h.nodeName&&h.nodeName.toLowerCase();return p&&(p==="input"&&(h.type==="text"||h.type==="search"||h.type==="tel"||h.type==="url"||h.type==="password")||p==="textarea"||h.contentEditable==="true")}function H(h){var p=k(),w=h.focusedElem,I=h.selectionRange;if(p!==w&&w&&w.ownerDocument&&T(w.ownerDocument.documentElement,w)){if(I!==null&&V(w)){if(p=I.start,h=I.end,h===void 0&&(h=p),"selectionStart"in w)w.selectionStart=p,w.selectionEnd=Math.min(h,w.value.length);else if(h=(p=w.ownerDocument||document)&&p.defaultView||window,h.getSelection){h=h.getSelection();var N=w.textContent.length,M=Math.min(I.start,N);I=I.end===void 0?M:Math.min(I.end,N),!h.extend&&M>I&&(N=I,I=M,M=N),N=n2(w,M);var Z=n2(w,I);N&&Z&&(h.rangeCount!==1||h.anchorNode!==N.node||h.anchorOffset!==N.offset||h.focusNode!==Z.node||h.focusOffset!==Z.offset)&&(p=p.createRange(),p.setStart(N.node,N.offset),h.removeAllRanges(),M>I?(h.addRange(p),h.extend(Z.node,Z.offset)):(p.setEnd(Z.node,Z.offset),h.addRange(p)))}}for(p=[],h=w;h=h.parentNode;)h.nodeType===1&&p.push({element:h,left:h.scrollLeft,top:h.scrollTop});for(typeof w.focus=="function"&&w.focus(),w=0;w<p.length;w++)h=p[w],h.element.scrollLeft=h.left,h.element.scrollTop=h.top}}var Q=a&&"documentMode"in document&&11>=document.documentMode,le=null,Ee=null,Be=null,rt=!1;function ft(h,p,w){var I=w.window===w?w.document:w.nodeType===9?w:w.ownerDocument;rt||le==null||le!==Ct(I)||(I=le,"selectionStart"in I&&V(I)?I={start:I.selectionStart,end:I.selectionEnd}:(I=(I.ownerDocument&&I.ownerDocument.defaultView||window).getSelection(),I={anchorNode:I.anchorNode,anchorOffset:I.anchorOffset,focusNode:I.focusNode,focusOffset:I.focusOffset}),Be&&kc(Be,I)||(Be=I,I=d3(Ee,"onSelect"),0<I.length&&(p=new Cr("onSelect","select",null,p,w),h.push({event:p,listeners:I}),p.target=le)))}function Nt(h,p){var w={};return w[h.toLowerCase()]=p.toLowerCase(),w["Webkit"+h]="webkit"+p,w["Moz"+h]="moz"+p,w}var qt={animationend:Nt("Animation","AnimationEnd"),animationiteration:Nt("Animation","AnimationIteration"),animationstart:Nt("Animation","AnimationStart"),transitionend:Nt("Transition","TransitionEnd")},yn={},Yn={};a&&(Yn=document.createElement("div").style,"AnimationEvent"in window||(delete qt.animationend.animation,delete qt.animationiteration.animation,delete qt.animationstart.animation),"TransitionEvent"in window||delete qt.transitionend.transition);function Lr(h){if(yn[h])return yn[h];if(!qt[h])return h;var p=qt[h],w;for(w in p)if(p.hasOwnProperty(w)&&w in Yn)return yn[h]=p[w];return h}var eo=Lr("animationend"),Va=Lr("animationiteration"),Yl=Lr("animationstart"),Nc=Lr("transitionend"),jp=new Map,c3="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ac(h,p){jp.set(h,p),i(p,[h])}for(var F4=0;F4<c3.length;F4++){var L4=c3[F4],YX=L4.toLowerCase(),QX=L4[0].toUpperCase()+L4.slice(1);Ac(YX,"on"+QX)}Ac(eo,"onAnimationEnd"),Ac(Va,"onAnimationIteration"),Ac(Yl,"onAnimationStart"),Ac("dblclick","onDoubleClick"),Ac("focusin","onFocus"),Ac("focusout","onBlur"),Ac(Nc,"onTransitionEnd"),o("onMouseEnter",["mouseout","mouseover"]),o("onMouseLeave",["mouseout","mouseover"]),o("onPointerEnter",["pointerout","pointerover"]),o("onPointerLeave",["pointerout","pointerover"]),i("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),i("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),i("onBeforeInput",["compositionend","keypress","textInput","paste"]),i("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var r2="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),JX=new Set("cancel close invalid load scroll toggle".split(" ").concat(r2));function LR(h,p,w){var I=h.type||"unknown-event";h.currentTarget=w,di(I,p,void 0,h),h.currentTarget=null}function MR(h,p){p=(p&4)!==0;for(var w=0;w<h.length;w++){var I=h[w],N=I.event;I=I.listeners;e:{var M=void 0;if(p)for(var Z=I.length-1;0<=Z;Z--){var pe=I[Z],Se=pe.instance,je=pe.currentTarget;if(pe=pe.listener,Se!==M&&N.isPropagationStopped())break e;LR(N,pe,je),M=Se}else for(Z=0;Z<I.length;Z++){if(pe=I[Z],Se=pe.instance,je=pe.currentTarget,pe=pe.listener,Se!==M&&N.isPropagationStopped())break e;LR(N,pe,je),M=Se}}}if(Es)throw h=ks,Es=!1,ks=null,h}function Mr(h,p){var w=p[G4];w===void 0&&(w=p[G4]=new Set);var I=h+"__bubble";w.has(I)||(zR(p,h,2,!1),w.add(I))}function M4(h,p,w){var I=0;p&&(I|=4),zR(w,h,I,p)}var h3="_reactListening"+Math.random().toString(36).slice(2);function s2(h){if(!h[h3]){h[h3]=!0,r.forEach(function(w){w!=="selectionchange"&&(JX.has(w)||M4(w,!1,h),M4(w,!0,h))});var p=h.nodeType===9?h:h.ownerDocument;p===null||p[h3]||(p[h3]=!0,M4("selectionchange",!1,p))}}function zR(h,p,w,I){switch(mt(p)){case 1:var N=xe;break;case 4:N=Me;break;default:N=Qe}w=N.bind(null,p,w,h),N=void 0,!Or||p!=="touchstart"&&p!=="touchmove"&&p!=="wheel"||(N=!0),I?N!==void 0?h.addEventListener(p,w,{capture:!0,passive:N}):h.addEventListener(p,w,!0):N!==void 0?h.addEventListener(p,w,{passive:N}):h.addEventListener(p,w,!1)}function z4(h,p,w,I,N){var M=I;if((p&1)===0&&(p&2)===0&&I!==null)e:for(;;){if(I===null)return;var Z=I.tag;if(Z===3||Z===4){var pe=I.stateNode.containerInfo;if(pe===N||pe.nodeType===8&&pe.parentNode===N)break;if(Z===4)for(Z=I.return;Z!==null;){var Se=Z.tag;if((Se===3||Se===4)&&(Se=Z.stateNode.containerInfo,Se===N||Se.nodeType===8&&Se.parentNode===N))return;Z=Z.return}for(;pe!==null;){if(Z=td(pe),Z===null)return;if(Se=Z.tag,Se===5||Se===6){I=M=Z;continue e}pe=pe.parentNode}}I=I.return}hi(function(){var je=M,ut=Gn(w),pt=[];e:{var at=jp.get(h);if(at!==void 0){var At=Cr,Vt=h;switch(h){case"keypress":if(Xn(w)===0)break e;case"keydown":case"keyup":At=pr;break;case"focusin":Vt="focus",At=Xs;break;case"focusout":Vt="blur",At=Xs;break;case"beforeblur":case"afterblur":At=Xs;break;case"click":if(w.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":At=Sc;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":At=Fp;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":At=Ma;break;case eo:case Va:case Yl:At=Mp;break;case Nc:At=Xl;break;case"scroll":At=zi;break;case"wheel":At=s3;break;case"copy":case"cut":case"paste":At=_;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":At=Ys}var Gt=(p&4)!==0,_s=!Gt&&h==="scroll",Le=Gt?at!==null?at+"Capture":null:at;Gt=[];for(var Ce=je,ze;Ce!==null;){ze=Ce;var wt=ze.stateNode;if(ze.tag===5&&wt!==null&&(ze=wt,Le!==null&&(wt=Pi(Ce,Le),wt!=null&&Gt.push(i2(Ce,wt,ze)))),_s)break;Ce=Ce.return}0<Gt.length&&(at=new At(at,Vt,null,w,ut),pt.push({event:at,listeners:Gt}))}}if((p&7)===0){e:{if(at=h==="mouseover"||h==="pointerover",At=h==="mouseout"||h==="pointerout",at&&w!==ui&&(Vt=w.relatedTarget||w.fromElement)&&(td(Vt)||Vt[Ou]))break e;if((At||at)&&(at=ut.window===ut?ut:(at=ut.ownerDocument)?at.defaultView||at.parentWindow:window,At?(Vt=w.relatedTarget||w.toElement,At=je,Vt=Vt?td(Vt):null,Vt!==null&&(_s=qs(Vt),Vt!==_s||Vt.tag!==5&&Vt.tag!==6)&&(Vt=null)):(At=null,Vt=je),At!==Vt)){if(Gt=Sc,wt="onMouseLeave",Le="onMouseEnter",Ce="mouse",(h==="pointerout"||h==="pointerover")&&(Gt=Ys,wt="onPointerLeave",Le="onPointerEnter",Ce="pointer"),_s=At==null?at:qp(At),ze=Vt==null?at:qp(Vt),at=new Gt(wt,Ce+"leave",At,w,ut),at.target=_s,at.relatedTarget=ze,wt=null,td(ut)===je&&(Gt=new Gt(Le,Ce+"enter",Vt,w,ut),Gt.target=ze,Gt.relatedTarget=_s,wt=Gt),_s=wt,At&&Vt)t:{for(Gt=At,Le=Vt,Ce=0,ze=Gt;ze;ze=Gp(ze))Ce++;for(ze=0,wt=Le;wt;wt=Gp(wt))ze++;for(;0<Ce-ze;)Gt=Gp(Gt),Ce--;for(;0<ze-Ce;)Le=Gp(Le),ze--;for(;Ce--;){if(Gt===Le||Le!==null&&Gt===Le.alternate)break t;Gt=Gp(Gt),Le=Gp(Le)}Gt=null}else Gt=null;At!==null&&VR(pt,at,At,Gt,!1),Vt!==null&&_s!==null&&VR(pt,_s,Vt,Gt,!0)}}e:{if(at=je?qp(je):window,At=at.nodeName&&at.nodeName.toLowerCase(),At==="select"||At==="input"&&at.type==="file")var Kt=X1;else if(Xe(at))if(Y1)Kt=e2;else{Kt=Wp;var ln=l3}else(At=at.nodeName)&&At.toLowerCase()==="input"&&(at.type==="checkbox"||at.type==="radio")&&(Kt=Z1);if(Kt&&(Kt=Kt(h,je))){K1(pt,Kt,w,ut);break e}ln&&ln(h,at,je),h==="focusout"&&(ln=at._wrapperState)&&ln.controlled&&at.type==="number"&&Pt(at,"number",at.value)}switch(ln=je?qp(je):window,h){case"focusin":(Xe(ln)||ln.contentEditable==="true")&&(le=ln,Ee=je,Be=null);break;case"focusout":Be=Ee=le=null;break;case"mousedown":rt=!0;break;case"contextmenu":case"mouseup":case"dragend":rt=!1,ft(pt,w,ut);break;case"selectionchange":if(Q)break;case"keydown":case"keyup":ft(pt,w,ut)}var un;if(zp)e:{switch(h){case"compositionstart":var wn="onCompositionStart";break e;case"compositionend":wn="onCompositionEnd";break e;case"compositionupdate":wn="onCompositionUpdate";break e}wn=void 0}else Cc?H1(h,w)&&(wn="onCompositionEnd"):h==="keydown"&&w.keyCode===229&&(wn="onCompositionStart");wn&&(j1&&w.locale!=="ko"&&(Cc||wn!=="onCompositionStart"?wn==="onCompositionEnd"&&Cc&&(un=er()):(yt=ut,nn="value"in yt?yt.value:yt.textContent,Cc=!0)),ln=d3(je,wn),0<ln.length&&(wn=new q(wn,h,null,w,ut),pt.push({event:wn,listeners:ln}),un?wn.data=un:(un=ed(w),un!==null&&(wn.data=un)))),(un=o3?q1(h,w):O4(h,w))&&(je=d3(je,"onBeforeInput"),0<je.length&&(ut=new q("onBeforeInput","beforeinput",null,w,ut),pt.push({event:ut,listeners:je}),ut.data=un))}MR(pt,p)})}function i2(h,p,w){return{instance:h,listener:p,currentTarget:w}}function d3(h,p){for(var w=p+"Capture",I=[];h!==null;){var N=h,M=N.stateNode;N.tag===5&&M!==null&&(N=M,M=Pi(h,w),M!=null&&I.unshift(i2(h,M,N)),M=Pi(h,p),M!=null&&I.push(i2(h,M,N))),h=h.return}return I}function Gp(h){if(h===null)return null;do h=h.return;while(h&&h.tag!==5);return h||null}function VR(h,p,w,I,N){for(var M=p._reactName,Z=[];w!==null&&w!==I;){var pe=w,Se=pe.alternate,je=pe.stateNode;if(Se!==null&&Se===I)break;pe.tag===5&&je!==null&&(pe=je,N?(Se=Pi(w,M),Se!=null&&Z.unshift(i2(w,Se,pe))):N||(Se=Pi(w,M),Se!=null&&Z.push(i2(w,Se,pe)))),w=w.return}Z.length!==0&&h.push({event:p,listeners:Z})}var ZX=/\r\n?/g,eY=/\u0000|\uFFFD/g;function BR(h){return(typeof h=="string"?h:""+h).replace(ZX,`
`).replace(eY,"")}function f3(h,p,w){if(p=BR(p),BR(h)!==p&&w)throw Error(n(425))}function p3(){}var V4=null,B4=null;function U4(h,p){return h==="textarea"||h==="noscript"||typeof p.children=="string"||typeof p.children=="number"||typeof p.dangerouslySetInnerHTML=="object"&&p.dangerouslySetInnerHTML!==null&&p.dangerouslySetInnerHTML.__html!=null}var W4=typeof setTimeout=="function"?setTimeout:void 0,tY=typeof clearTimeout=="function"?clearTimeout:void 0,UR=typeof Promise=="function"?Promise:void 0,nY=typeof queueMicrotask=="function"?queueMicrotask:typeof UR<"u"?function(h){return UR.resolve(null).then(h).catch(rY)}:W4;function rY(h){setTimeout(function(){throw h})}function j4(h,p){var w=p,I=0;do{var N=w.nextSibling;if(h.removeChild(w),N&&N.nodeType===8)if(w=N.data,w==="/$"){if(I===0){h.removeChild(N),ae(p);return}I--}else w!=="$"&&w!=="$?"&&w!=="$!"||I++;w=N}while(w);ae(p)}function Rc(h){for(;h!=null;h=h.nextSibling){var p=h.nodeType;if(p===1||p===3)break;if(p===8){if(p=h.data,p==="$"||p==="$!"||p==="$?")break;if(p==="/$")return null}}return h}function WR(h){h=h.previousSibling;for(var p=0;h;){if(h.nodeType===8){var w=h.data;if(w==="$"||w==="$!"||w==="$?"){if(p===0)return h;p--}else w==="/$"&&p++}h=h.previousSibling}return null}var Hp=Math.random().toString(36).slice(2),Ql="__reactFiber$"+Hp,o2="__reactProps$"+Hp,Ou="__reactContainer$"+Hp,G4="__reactEvents$"+Hp,sY="__reactListeners$"+Hp,iY="__reactHandles$"+Hp;function td(h){var p=h[Ql];if(p)return p;for(var w=h.parentNode;w;){if(p=w[Ou]||w[Ql]){if(w=p.alternate,p.child!==null||w!==null&&w.child!==null)for(h=WR(h);h!==null;){if(w=h[Ql])return w;h=WR(h)}return p}h=w,w=h.parentNode}return null}function a2(h){return h=h[Ql]||h[Ou],!h||h.tag!==5&&h.tag!==6&&h.tag!==13&&h.tag!==3?null:h}function qp(h){if(h.tag===5||h.tag===6)return h.stateNode;throw Error(n(33))}function m3(h){return h[o2]||null}var H4=[],Kp=-1;function Dc(h){return{current:h}}function zr(h){0>Kp||(h.current=H4[Kp],H4[Kp]=null,Kp--)}function Dr(h,p){Kp++,H4[Kp]=h.current,h.current=p}var Oc={},to=Dc(Oc),jo=Dc(!1),nd=Oc;function Xp(h,p){var w=h.type.contextTypes;if(!w)return Oc;var I=h.stateNode;if(I&&I.__reactInternalMemoizedUnmaskedChildContext===p)return I.__reactInternalMemoizedMaskedChildContext;var N={},M;for(M in w)N[M]=p[M];return I&&(h=h.stateNode,h.__reactInternalMemoizedUnmaskedChildContext=p,h.__reactInternalMemoizedMaskedChildContext=N),N}function Go(h){return h=h.childContextTypes,h!=null}function g3(){zr(jo),zr(to)}function jR(h,p,w){if(to.current!==Oc)throw Error(n(168));Dr(to,p),Dr(jo,w)}function GR(h,p,w){var I=h.stateNode;if(p=p.childContextTypes,typeof I.getChildContext!="function")return w;I=I.getChildContext();for(var N in I)if(!(N in p))throw Error(n(108,Re(h)||"Unknown",N));return _e({},w,I)}function y3(h){return h=(h=h.stateNode)&&h.__reactInternalMemoizedMergedChildContext||Oc,nd=to.current,Dr(to,h),Dr(jo,jo.current),!0}function HR(h,p,w){var I=h.stateNode;if(!I)throw Error(n(169));w?(h=GR(h,p,nd),I.__reactInternalMemoizedMergedChildContext=h,zr(jo),zr(to),Dr(to,h)):zr(jo),Dr(jo,w)}var Pu=null,w3=!1,q4=!1;function qR(h){Pu===null?Pu=[h]:Pu.push(h)}function oY(h){w3=!0,qR(h)}function Pc(){if(!q4&&Pu!==null){q4=!0;var h=0,p=Sn;try{var w=Pu;for(Sn=1;h<w.length;h++){var I=w[h];do I=I(!0);while(I!==null)}Pu=null,w3=!1}catch(N){throw Pu!==null&&(Pu=Pu.slice(h+1)),cl(Zi,Pc),N}finally{Sn=p,q4=!1}}return null}var Yp=[],Qp=0,v3=null,b3=0,Ba=[],Ua=0,rd=null,Fu=1,Lu="";function sd(h,p){Yp[Qp++]=b3,Yp[Qp++]=v3,v3=h,b3=p}function KR(h,p,w){Ba[Ua++]=Fu,Ba[Ua++]=Lu,Ba[Ua++]=rd,rd=h;var I=Fu;h=Lu;var N=32-hr(I)-1;I&=~(1<<N),w+=1;var M=32-hr(p)+N;if(30<M){var Z=N-N%5;M=(I&(1<<Z)-1).toString(32),I>>=Z,N-=Z,Fu=1<<32-hr(p)+N|w<<N|I,Lu=M+h}else Fu=1<<M|w<<N|I,Lu=h}function K4(h){h.return!==null&&(sd(h,1),KR(h,1,0))}function X4(h){for(;h===v3;)v3=Yp[--Qp],Yp[Qp]=null,b3=Yp[--Qp],Yp[Qp]=null;for(;h===rd;)rd=Ba[--Ua],Ba[Ua]=null,Lu=Ba[--Ua],Ba[Ua]=null,Fu=Ba[--Ua],Ba[Ua]=null}var ma=null,ga=null,Yr=!1,pl=null;function XR(h,p){var w=Ha(5,null,null,0);w.elementType="DELETED",w.stateNode=p,w.return=h,p=h.deletions,p===null?(h.deletions=[w],h.flags|=16):p.push(w)}function YR(h,p){switch(h.tag){case 5:var w=h.type;return p=p.nodeType!==1||w.toLowerCase()!==p.nodeName.toLowerCase()?null:p,p!==null?(h.stateNode=p,ma=h,ga=Rc(p.firstChild),!0):!1;case 6:return p=h.pendingProps===""||p.nodeType!==3?null:p,p!==null?(h.stateNode=p,ma=h,ga=null,!0):!1;case 13:return p=p.nodeType!==8?null:p,p!==null?(w=rd!==null?{id:Fu,overflow:Lu}:null,h.memoizedState={dehydrated:p,treeContext:w,retryLane:1073741824},w=Ha(18,null,null,0),w.stateNode=p,w.return=h,h.child=w,ma=h,ga=null,!0):!1;default:return!1}}function Y4(h){return(h.mode&1)!==0&&(h.flags&128)===0}function Q4(h){if(Yr){var p=ga;if(p){var w=p;if(!YR(h,p)){if(Y4(h))throw Error(n(418));p=Rc(w.nextSibling);var I=ma;p&&YR(h,p)?XR(I,w):(h.flags=h.flags&-4097|2,Yr=!1,ma=h)}}else{if(Y4(h))throw Error(n(418));h.flags=h.flags&-4097|2,Yr=!1,ma=h}}}function QR(h){for(h=h.return;h!==null&&h.tag!==5&&h.tag!==3&&h.tag!==13;)h=h.return;ma=h}function x3(h){if(h!==ma)return!1;if(!Yr)return QR(h),Yr=!0,!1;var p;if((p=h.tag!==3)&&!(p=h.tag!==5)&&(p=h.type,p=p!=="head"&&p!=="body"&&!U4(h.type,h.memoizedProps)),p&&(p=ga)){if(Y4(h))throw JR(),Error(n(418));for(;p;)XR(h,p),p=Rc(p.nextSibling)}if(QR(h),h.tag===13){if(h=h.memoizedState,h=h!==null?h.dehydrated:null,!h)throw Error(n(317));e:{for(h=h.nextSibling,p=0;h;){if(h.nodeType===8){var w=h.data;if(w==="/$"){if(p===0){ga=Rc(h.nextSibling);break e}p--}else w!=="$"&&w!=="$!"&&w!=="$?"||p++}h=h.nextSibling}ga=null}}else ga=ma?Rc(h.stateNode.nextSibling):null;return!0}function JR(){for(var h=ga;h;)h=Rc(h.nextSibling)}function Jp(){ga=ma=null,Yr=!1}function J4(h){pl===null?pl=[h]:pl.push(h)}var aY=S.ReactCurrentBatchConfig;function l2(h,p,w){if(h=w.ref,h!==null&&typeof h!="function"&&typeof h!="object"){if(w._owner){if(w=w._owner,w){if(w.tag!==1)throw Error(n(309));var I=w.stateNode}if(!I)throw Error(n(147,h));var N=I,M=""+h;return p!==null&&p.ref!==null&&typeof p.ref=="function"&&p.ref._stringRef===M?p.ref:(p=function(Z){var pe=N.refs;Z===null?delete pe[M]:pe[M]=Z},p._stringRef=M,p)}if(typeof h!="string")throw Error(n(284));if(!w._owner)throw Error(n(290,h))}return h}function _3(h,p){throw h=Object.prototype.toString.call(p),Error(n(31,h==="[object Object]"?"object with keys {"+Object.keys(p).join(", ")+"}":h))}function ZR(h){var p=h._init;return p(h._payload)}function e6(h){function p(Le,Ce){if(h){var ze=Le.deletions;ze===null?(Le.deletions=[Ce],Le.flags|=16):ze.push(Ce)}}function w(Le,Ce){if(!h)return null;for(;Ce!==null;)p(Le,Ce),Ce=Ce.sibling;return null}function I(Le,Ce){for(Le=new Map;Ce!==null;)Ce.key!==null?Le.set(Ce.key,Ce):Le.set(Ce.index,Ce),Ce=Ce.sibling;return Le}function N(Le,Ce){return Le=Wc(Le,Ce),Le.index=0,Le.sibling=null,Le}function M(Le,Ce,ze){return Le.index=ze,h?(ze=Le.alternate,ze!==null?(ze=ze.index,ze<Ce?(Le.flags|=2,Ce):ze):(Le.flags|=2,Ce)):(Le.flags|=1048576,Ce)}function Z(Le){return h&&Le.alternate===null&&(Le.flags|=2),Le}function pe(Le,Ce,ze,wt){return Ce===null||Ce.tag!==6?(Ce=WI(ze,Le.mode,wt),Ce.return=Le,Ce):(Ce=N(Ce,ze),Ce.return=Le,Ce)}function Se(Le,Ce,ze,wt){var Kt=ze.type;return Kt===R?ut(Le,Ce,ze.props.children,wt,ze.key):Ce!==null&&(Ce.elementType===Kt||typeof Kt=="object"&&Kt!==null&&Kt.$$typeof===me&&ZR(Kt)===Ce.type)?(wt=N(Ce,ze.props),wt.ref=l2(Le,Ce,ze),wt.return=Le,wt):(wt=H3(ze.type,ze.key,ze.props,null,Le.mode,wt),wt.ref=l2(Le,Ce,ze),wt.return=Le,wt)}function je(Le,Ce,ze,wt){return Ce===null||Ce.tag!==4||Ce.stateNode.containerInfo!==ze.containerInfo||Ce.stateNode.implementation!==ze.implementation?(Ce=jI(ze,Le.mode,wt),Ce.return=Le,Ce):(Ce=N(Ce,ze.children||[]),Ce.return=Le,Ce)}function ut(Le,Ce,ze,wt,Kt){return Ce===null||Ce.tag!==7?(Ce=dd(ze,Le.mode,wt,Kt),Ce.return=Le,Ce):(Ce=N(Ce,ze),Ce.return=Le,Ce)}function pt(Le,Ce,ze){if(typeof Ce=="string"&&Ce!==""||typeof Ce=="number")return Ce=WI(""+Ce,Le.mode,ze),Ce.return=Le,Ce;if(typeof Ce=="object"&&Ce!==null){switch(Ce.$$typeof){case E:return ze=H3(Ce.type,Ce.key,Ce.props,null,Le.mode,ze),ze.ref=l2(Le,null,Ce),ze.return=Le,ze;case L:return Ce=jI(Ce,Le.mode,ze),Ce.return=Le,Ce;case me:var wt=Ce._init;return pt(Le,wt(Ce._payload),ze)}if(Rt(Ce)||ue(Ce))return Ce=dd(Ce,Le.mode,ze,null),Ce.return=Le,Ce;_3(Le,Ce)}return null}function at(Le,Ce,ze,wt){var Kt=Ce!==null?Ce.key:null;if(typeof ze=="string"&&ze!==""||typeof ze=="number")return Kt!==null?null:pe(Le,Ce,""+ze,wt);if(typeof ze=="object"&&ze!==null){switch(ze.$$typeof){case E:return ze.key===Kt?Se(Le,Ce,ze,wt):null;case L:return ze.key===Kt?je(Le,Ce,ze,wt):null;case me:return Kt=ze._init,at(Le,Ce,Kt(ze._payload),wt)}if(Rt(ze)||ue(ze))return Kt!==null?null:ut(Le,Ce,ze,wt,null);_3(Le,ze)}return null}function At(Le,Ce,ze,wt,Kt){if(typeof wt=="string"&&wt!==""||typeof wt=="number")return Le=Le.get(ze)||null,pe(Ce,Le,""+wt,Kt);if(typeof wt=="object"&&wt!==null){switch(wt.$$typeof){case E:return Le=Le.get(wt.key===null?ze:wt.key)||null,Se(Ce,Le,wt,Kt);case L:return Le=Le.get(wt.key===null?ze:wt.key)||null,je(Ce,Le,wt,Kt);case me:var ln=wt._init;return At(Le,Ce,ze,ln(wt._payload),Kt)}if(Rt(wt)||ue(wt))return Le=Le.get(ze)||null,ut(Ce,Le,wt,Kt,null);_3(Ce,wt)}return null}function Vt(Le,Ce,ze,wt){for(var Kt=null,ln=null,un=Ce,wn=Ce=0,bi=null;un!==null&&wn<ze.length;wn++){un.index>wn?(bi=un,un=null):bi=un.sibling;var dr=at(Le,un,ze[wn],wt);if(dr===null){un===null&&(un=bi);break}h&&un&&dr.alternate===null&&p(Le,un),Ce=M(dr,Ce,wn),ln===null?Kt=dr:ln.sibling=dr,ln=dr,un=bi}if(wn===ze.length)return w(Le,un),Yr&&sd(Le,wn),Kt;if(un===null){for(;wn<ze.length;wn++)un=pt(Le,ze[wn],wt),un!==null&&(Ce=M(un,Ce,wn),ln===null?Kt=un:ln.sibling=un,ln=un);return Yr&&sd(Le,wn),Kt}for(un=I(Le,un);wn<ze.length;wn++)bi=At(un,Le,wn,ze[wn],wt),bi!==null&&(h&&bi.alternate!==null&&un.delete(bi.key===null?wn:bi.key),Ce=M(bi,Ce,wn),ln===null?Kt=bi:ln.sibling=bi,ln=bi);return h&&un.forEach(function(jc){return p(Le,jc)}),Yr&&sd(Le,wn),Kt}function Gt(Le,Ce,ze,wt){var Kt=ue(ze);if(typeof Kt!="function")throw Error(n(150));if(ze=Kt.call(ze),ze==null)throw Error(n(151));for(var ln=Kt=null,un=Ce,wn=Ce=0,bi=null,dr=ze.next();un!==null&&!dr.done;wn++,dr=ze.next()){un.index>wn?(bi=un,un=null):bi=un.sibling;var jc=at(Le,un,dr.value,wt);if(jc===null){un===null&&(un=bi);break}h&&un&&jc.alternate===null&&p(Le,un),Ce=M(jc,Ce,wn),ln===null?Kt=jc:ln.sibling=jc,ln=jc,un=bi}if(dr.done)return w(Le,un),Yr&&sd(Le,wn),Kt;if(un===null){for(;!dr.done;wn++,dr=ze.next())dr=pt(Le,dr.value,wt),dr!==null&&(Ce=M(dr,Ce,wn),ln===null?Kt=dr:ln.sibling=dr,ln=dr);return Yr&&sd(Le,wn),Kt}for(un=I(Le,un);!dr.done;wn++,dr=ze.next())dr=At(un,Le,wn,dr.value,wt),dr!==null&&(h&&dr.alternate!==null&&un.delete(dr.key===null?wn:dr.key),Ce=M(dr,Ce,wn),ln===null?Kt=dr:ln.sibling=dr,ln=dr);return h&&un.forEach(function(VY){return p(Le,VY)}),Yr&&sd(Le,wn),Kt}function _s(Le,Ce,ze,wt){if(typeof ze=="object"&&ze!==null&&ze.type===R&&ze.key===null&&(ze=ze.props.children),typeof ze=="object"&&ze!==null){switch(ze.$$typeof){case E:e:{for(var Kt=ze.key,ln=Ce;ln!==null;){if(ln.key===Kt){if(Kt=ze.type,Kt===R){if(ln.tag===7){w(Le,ln.sibling),Ce=N(ln,ze.props.children),Ce.return=Le,Le=Ce;break e}}else if(ln.elementType===Kt||typeof Kt=="object"&&Kt!==null&&Kt.$$typeof===me&&ZR(Kt)===ln.type){w(Le,ln.sibling),Ce=N(ln,ze.props),Ce.ref=l2(Le,ln,ze),Ce.return=Le,Le=Ce;break e}w(Le,ln);break}else p(Le,ln);ln=ln.sibling}ze.type===R?(Ce=dd(ze.props.children,Le.mode,wt,ze.key),Ce.return=Le,Le=Ce):(wt=H3(ze.type,ze.key,ze.props,null,Le.mode,wt),wt.ref=l2(Le,Ce,ze),wt.return=Le,Le=wt)}return Z(Le);case L:e:{for(ln=ze.key;Ce!==null;){if(Ce.key===ln)if(Ce.tag===4&&Ce.stateNode.containerInfo===ze.containerInfo&&Ce.stateNode.implementation===ze.implementation){w(Le,Ce.sibling),Ce=N(Ce,ze.children||[]),Ce.return=Le,Le=Ce;break e}else{w(Le,Ce);break}else p(Le,Ce);Ce=Ce.sibling}Ce=jI(ze,Le.mode,wt),Ce.return=Le,Le=Ce}return Z(Le);case me:return ln=ze._init,_s(Le,Ce,ln(ze._payload),wt)}if(Rt(ze))return Vt(Le,Ce,ze,wt);if(ue(ze))return Gt(Le,Ce,ze,wt);_3(Le,ze)}return typeof ze=="string"&&ze!==""||typeof ze=="number"?(ze=""+ze,Ce!==null&&Ce.tag===6?(w(Le,Ce.sibling),Ce=N(Ce,ze),Ce.return=Le,Le=Ce):(w(Le,Ce),Ce=WI(ze,Le.mode,wt),Ce.return=Le,Le=Ce),Z(Le)):w(Le,Ce)}return _s}var Zp=e6(!0),t6=e6(!1),I3=Dc(null),T3=null,em=null,Z4=null;function eI(){Z4=em=T3=null}function tI(h){var p=I3.current;zr(I3),h._currentValue=p}function nI(h,p,w){for(;h!==null;){var I=h.alternate;if((h.childLanes&p)!==p?(h.childLanes|=p,I!==null&&(I.childLanes|=p)):I!==null&&(I.childLanes&p)!==p&&(I.childLanes|=p),h===w)break;h=h.return}}function tm(h,p){T3=h,Z4=em=null,h=h.dependencies,h!==null&&h.firstContext!==null&&((h.lanes&p)!==0&&(Ho=!0),h.firstContext=null)}function Wa(h){var p=h._currentValue;if(Z4!==h)if(h={context:h,memoizedValue:p,next:null},em===null){if(T3===null)throw Error(n(308));em=h,T3.dependencies={lanes:0,firstContext:h}}else em=em.next=h;return p}var id=null;function rI(h){id===null?id=[h]:id.push(h)}function n6(h,p,w,I){var N=p.interleaved;return N===null?(w.next=w,rI(p)):(w.next=N.next,N.next=w),p.interleaved=w,Mu(h,I)}function Mu(h,p){h.lanes|=p;var w=h.alternate;for(w!==null&&(w.lanes|=p),w=h,h=h.return;h!==null;)h.childLanes|=p,w=h.alternate,w!==null&&(w.childLanes|=p),w=h,h=h.return;return w.tag===3?w.stateNode:null}var Fc=!1;function sI(h){h.updateQueue={baseState:h.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function r6(h,p){h=h.updateQueue,p.updateQueue===h&&(p.updateQueue={baseState:h.baseState,firstBaseUpdate:h.firstBaseUpdate,lastBaseUpdate:h.lastBaseUpdate,shared:h.shared,effects:h.effects})}function zu(h,p){return{eventTime:h,lane:p,tag:0,payload:null,callback:null,next:null}}function Lc(h,p,w){var I=h.updateQueue;if(I===null)return null;if(I=I.shared,(ar&2)!==0){var N=I.pending;return N===null?p.next=p:(p.next=N.next,N.next=p),I.pending=p,Mu(h,w)}return N=I.interleaved,N===null?(p.next=p,rI(I)):(p.next=N.next,N.next=p),I.interleaved=p,Mu(h,w)}function S3(h,p,w){if(p=p.updateQueue,p!==null&&(p=p.shared,(w&4194240)!==0)){var I=p.lanes;I&=h.pendingLanes,w|=I,p.lanes=w,da(h,w)}}function s6(h,p){var w=h.updateQueue,I=h.alternate;if(I!==null&&(I=I.updateQueue,w===I)){var N=null,M=null;if(w=w.firstBaseUpdate,w!==null){do{var Z={eventTime:w.eventTime,lane:w.lane,tag:w.tag,payload:w.payload,callback:w.callback,next:null};M===null?N=M=Z:M=M.next=Z,w=w.next}while(w!==null);M===null?N=M=p:M=M.next=p}else N=M=p;w={baseState:I.baseState,firstBaseUpdate:N,lastBaseUpdate:M,shared:I.shared,effects:I.effects},h.updateQueue=w;return}h=w.lastBaseUpdate,h===null?w.firstBaseUpdate=p:h.next=p,w.lastBaseUpdate=p}function $3(h,p,w,I){var N=h.updateQueue;Fc=!1;var M=N.firstBaseUpdate,Z=N.lastBaseUpdate,pe=N.shared.pending;if(pe!==null){N.shared.pending=null;var Se=pe,je=Se.next;Se.next=null,Z===null?M=je:Z.next=je,Z=Se;var ut=h.alternate;ut!==null&&(ut=ut.updateQueue,pe=ut.lastBaseUpdate,pe!==Z&&(pe===null?ut.firstBaseUpdate=je:pe.next=je,ut.lastBaseUpdate=Se))}if(M!==null){var pt=N.baseState;Z=0,ut=je=Se=null,pe=M;do{var at=pe.lane,At=pe.eventTime;if((I&at)===at){ut!==null&&(ut=ut.next={eventTime:At,lane:0,tag:pe.tag,payload:pe.payload,callback:pe.callback,next:null});e:{var Vt=h,Gt=pe;switch(at=p,At=w,Gt.tag){case 1:if(Vt=Gt.payload,typeof Vt=="function"){pt=Vt.call(At,pt,at);break e}pt=Vt;break e;case 3:Vt.flags=Vt.flags&-65537|128;case 0:if(Vt=Gt.payload,at=typeof Vt=="function"?Vt.call(At,pt,at):Vt,at==null)break e;pt=_e({},pt,at);break e;case 2:Fc=!0}}pe.callback!==null&&pe.lane!==0&&(h.flags|=64,at=N.effects,at===null?N.effects=[pe]:at.push(pe))}else At={eventTime:At,lane:at,tag:pe.tag,payload:pe.payload,callback:pe.callback,next:null},ut===null?(je=ut=At,Se=pt):ut=ut.next=At,Z|=at;if(pe=pe.next,pe===null){if(pe=N.shared.pending,pe===null)break;at=pe,pe=at.next,at.next=null,N.lastBaseUpdate=at,N.shared.pending=null}}while(!0);if(ut===null&&(Se=pt),N.baseState=Se,N.firstBaseUpdate=je,N.lastBaseUpdate=ut,p=N.shared.interleaved,p!==null){N=p;do Z|=N.lane,N=N.next;while(N!==p)}else M===null&&(N.shared.lanes=0);ld|=Z,h.lanes=Z,h.memoizedState=pt}}function i6(h,p,w){if(h=p.effects,p.effects=null,h!==null)for(p=0;p<h.length;p++){var I=h[p],N=I.callback;if(N!==null){if(I.callback=null,I=w,typeof N!="function")throw Error(n(191,N));N.call(I)}}}var u2={},Jl=Dc(u2),c2=Dc(u2),h2=Dc(u2);function od(h){if(h===u2)throw Error(n(174));return h}function iI(h,p){switch(Dr(h2,p),Dr(c2,h),Dr(Jl,u2),h=p.nodeType,h){case 9:case 11:p=(p=p.documentElement)?p.namespaceURI:Ln(null,"");break;default:h=h===8?p.parentNode:p,p=h.namespaceURI||null,h=h.tagName,p=Ln(p,h)}zr(Jl),Dr(Jl,p)}function nm(){zr(Jl),zr(c2),zr(h2)}function o6(h){od(h2.current);var p=od(Jl.current),w=Ln(p,h.type);p!==w&&(Dr(c2,h),Dr(Jl,w))}function oI(h){c2.current===h&&(zr(Jl),zr(c2))}var ss=Dc(0);function C3(h){for(var p=h;p!==null;){if(p.tag===13){var w=p.memoizedState;if(w!==null&&(w=w.dehydrated,w===null||w.data==="$?"||w.data==="$!"))return p}else if(p.tag===19&&p.memoizedProps.revealOrder!==void 0){if((p.flags&128)!==0)return p}else if(p.child!==null){p.child.return=p,p=p.child;continue}if(p===h)break;for(;p.sibling===null;){if(p.return===null||p.return===h)return null;p=p.return}p.sibling.return=p.return,p=p.sibling}return null}var aI=[];function lI(){for(var h=0;h<aI.length;h++)aI[h]._workInProgressVersionPrimary=null;aI.length=0}var E3=S.ReactCurrentDispatcher,uI=S.ReactCurrentBatchConfig,ad=0,is=null,Qs=null,wi=null,k3=!1,d2=!1,f2=0,lY=0;function no(){throw Error(n(321))}function cI(h,p){if(p===null)return!1;for(var w=0;w<p.length&&w<h.length;w++)if(!Wo(h[w],p[w]))return!1;return!0}function hI(h,p,w,I,N,M){if(ad=M,is=p,p.memoizedState=null,p.updateQueue=null,p.lanes=0,E3.current=h===null||h.memoizedState===null?dY:fY,h=w(I,N),d2){M=0;do{if(d2=!1,f2=0,25<=M)throw Error(n(301));M+=1,wi=Qs=null,p.updateQueue=null,E3.current=pY,h=w(I,N)}while(d2)}if(E3.current=R3,p=Qs!==null&&Qs.next!==null,ad=0,wi=Qs=is=null,k3=!1,p)throw Error(n(300));return h}function dI(){var h=f2!==0;return f2=0,h}function Zl(){var h={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return wi===null?is.memoizedState=wi=h:wi=wi.next=h,wi}function ja(){if(Qs===null){var h=is.alternate;h=h!==null?h.memoizedState:null}else h=Qs.next;var p=wi===null?is.memoizedState:wi.next;if(p!==null)wi=p,Qs=h;else{if(h===null)throw Error(n(310));Qs=h,h={memoizedState:Qs.memoizedState,baseState:Qs.baseState,baseQueue:Qs.baseQueue,queue:Qs.queue,next:null},wi===null?is.memoizedState=wi=h:wi=wi.next=h}return wi}function p2(h,p){return typeof p=="function"?p(h):p}function fI(h){var p=ja(),w=p.queue;if(w===null)throw Error(n(311));w.lastRenderedReducer=h;var I=Qs,N=I.baseQueue,M=w.pending;if(M!==null){if(N!==null){var Z=N.next;N.next=M.next,M.next=Z}I.baseQueue=N=M,w.pending=null}if(N!==null){M=N.next,I=I.baseState;var pe=Z=null,Se=null,je=M;do{var ut=je.lane;if((ad&ut)===ut)Se!==null&&(Se=Se.next={lane:0,action:je.action,hasEagerState:je.hasEagerState,eagerState:je.eagerState,next:null}),I=je.hasEagerState?je.eagerState:h(I,je.action);else{var pt={lane:ut,action:je.action,hasEagerState:je.hasEagerState,eagerState:je.eagerState,next:null};Se===null?(pe=Se=pt,Z=I):Se=Se.next=pt,is.lanes|=ut,ld|=ut}je=je.next}while(je!==null&&je!==M);Se===null?Z=I:Se.next=pe,Wo(I,p.memoizedState)||(Ho=!0),p.memoizedState=I,p.baseState=Z,p.baseQueue=Se,w.lastRenderedState=I}if(h=w.interleaved,h!==null){N=h;do M=N.lane,is.lanes|=M,ld|=M,N=N.next;while(N!==h)}else N===null&&(w.lanes=0);return[p.memoizedState,w.dispatch]}function pI(h){var p=ja(),w=p.queue;if(w===null)throw Error(n(311));w.lastRenderedReducer=h;var I=w.dispatch,N=w.pending,M=p.memoizedState;if(N!==null){w.pending=null;var Z=N=N.next;do M=h(M,Z.action),Z=Z.next;while(Z!==N);Wo(M,p.memoizedState)||(Ho=!0),p.memoizedState=M,p.baseQueue===null&&(p.baseState=M),w.lastRenderedState=M}return[M,I]}function a6(){}function l6(h,p){var w=is,I=ja(),N=p(),M=!Wo(I.memoizedState,N);if(M&&(I.memoizedState=N,Ho=!0),I=I.queue,mI(h6.bind(null,w,I,h),[h]),I.getSnapshot!==p||M||wi!==null&&wi.memoizedState.tag&1){if(w.flags|=2048,m2(9,c6.bind(null,w,I,N,p),void 0,null),vi===null)throw Error(n(349));(ad&30)!==0||u6(w,p,N)}return N}function u6(h,p,w){h.flags|=16384,h={getSnapshot:p,value:w},p=is.updateQueue,p===null?(p={lastEffect:null,stores:null},is.updateQueue=p,p.stores=[h]):(w=p.stores,w===null?p.stores=[h]:w.push(h))}function c6(h,p,w,I){p.value=w,p.getSnapshot=I,d6(p)&&f6(h)}function h6(h,p,w){return w(function(){d6(p)&&f6(h)})}function d6(h){var p=h.getSnapshot;h=h.value;try{var w=p();return!Wo(h,w)}catch{return!0}}function f6(h){var p=Mu(h,1);p!==null&&wl(p,h,1,-1)}function p6(h){var p=Zl();return typeof h=="function"&&(h=h()),p.memoizedState=p.baseState=h,h={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:p2,lastRenderedState:h},p.queue=h,h=h.dispatch=hY.bind(null,is,h),[p.memoizedState,h]}function m2(h,p,w,I){return h={tag:h,create:p,destroy:w,deps:I,next:null},p=is.updateQueue,p===null?(p={lastEffect:null,stores:null},is.updateQueue=p,p.lastEffect=h.next=h):(w=p.lastEffect,w===null?p.lastEffect=h.next=h:(I=w.next,w.next=h,h.next=I,p.lastEffect=h)),h}function m6(){return ja().memoizedState}function N3(h,p,w,I){var N=Zl();is.flags|=h,N.memoizedState=m2(1|p,w,void 0,I===void 0?null:I)}function A3(h,p,w,I){var N=ja();I=I===void 0?null:I;var M=void 0;if(Qs!==null){var Z=Qs.memoizedState;if(M=Z.destroy,I!==null&&cI(I,Z.deps)){N.memoizedState=m2(p,w,M,I);return}}is.flags|=h,N.memoizedState=m2(1|p,w,M,I)}function g6(h,p){return N3(8390656,8,h,p)}function mI(h,p){return A3(2048,8,h,p)}function y6(h,p){return A3(4,2,h,p)}function w6(h,p){return A3(4,4,h,p)}function v6(h,p){if(typeof p=="function")return h=h(),p(h),function(){p(null)};if(p!=null)return h=h(),p.current=h,function(){p.current=null}}function b6(h,p,w){return w=w!=null?w.concat([h]):null,A3(4,4,v6.bind(null,p,h),w)}function gI(){}function x6(h,p){var w=ja();p=p===void 0?null:p;var I=w.memoizedState;return I!==null&&p!==null&&cI(p,I[1])?I[0]:(w.memoizedState=[h,p],h)}function _6(h,p){var w=ja();p=p===void 0?null:p;var I=w.memoizedState;return I!==null&&p!==null&&cI(p,I[1])?I[0]:(h=h(),w.memoizedState=[h,p],h)}function I6(h,p,w){return(ad&21)===0?(h.baseState&&(h.baseState=!1,Ho=!0),h.memoizedState=w):(Wo(w,p)||(w=dl(),is.lanes|=w,ld|=w,h.baseState=!0),p)}function uY(h,p){var w=Sn;Sn=w!==0&&4>w?w:4,h(!0);var I=uI.transition;uI.transition={};try{h(!1),p()}finally{Sn=w,uI.transition=I}}function T6(){return ja().memoizedState}function cY(h,p,w){var I=Bc(h);if(w={lane:I,action:w,hasEagerState:!1,eagerState:null,next:null},S6(h))$6(p,w);else if(w=n6(h,p,w,I),w!==null){var N=So();wl(w,h,I,N),C6(w,p,I)}}function hY(h,p,w){var I=Bc(h),N={lane:I,action:w,hasEagerState:!1,eagerState:null,next:null};if(S6(h))$6(p,N);else{var M=h.alternate;if(h.lanes===0&&(M===null||M.lanes===0)&&(M=p.lastRenderedReducer,M!==null))try{var Z=p.lastRenderedState,pe=M(Z,w);if(N.hasEagerState=!0,N.eagerState=pe,Wo(pe,Z)){var Se=p.interleaved;Se===null?(N.next=N,rI(p)):(N.next=Se.next,Se.next=N),p.interleaved=N;return}}catch{}finally{}w=n6(h,p,N,I),w!==null&&(N=So(),wl(w,h,I,N),C6(w,p,I))}}function S6(h){var p=h.alternate;return h===is||p!==null&&p===is}function $6(h,p){d2=k3=!0;var w=h.pending;w===null?p.next=p:(p.next=w.next,w.next=p),h.pending=p}function C6(h,p,w){if((w&4194240)!==0){var I=p.lanes;I&=h.pendingLanes,w|=I,p.lanes=w,da(h,w)}}var R3={readContext:Wa,useCallback:no,useContext:no,useEffect:no,useImperativeHandle:no,useInsertionEffect:no,useLayoutEffect:no,useMemo:no,useReducer:no,useRef:no,useState:no,useDebugValue:no,useDeferredValue:no,useTransition:no,useMutableSource:no,useSyncExternalStore:no,useId:no,unstable_isNewReconciler:!1},dY={readContext:Wa,useCallback:function(h,p){return Zl().memoizedState=[h,p===void 0?null:p],h},useContext:Wa,useEffect:g6,useImperativeHandle:function(h,p,w){return w=w!=null?w.concat([h]):null,N3(4194308,4,v6.bind(null,p,h),w)},useLayoutEffect:function(h,p){return N3(4194308,4,h,p)},useInsertionEffect:function(h,p){return N3(4,2,h,p)},useMemo:function(h,p){var w=Zl();return p=p===void 0?null:p,h=h(),w.memoizedState=[h,p],h},useReducer:function(h,p,w){var I=Zl();return p=w!==void 0?w(p):p,I.memoizedState=I.baseState=p,h={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:h,lastRenderedState:p},I.queue=h,h=h.dispatch=cY.bind(null,is,h),[I.memoizedState,h]},useRef:function(h){var p=Zl();return h={current:h},p.memoizedState=h},useState:p6,useDebugValue:gI,useDeferredValue:function(h){return Zl().memoizedState=h},useTransition:function(){var h=p6(!1),p=h[0];return h=uY.bind(null,h[1]),Zl().memoizedState=h,[p,h]},useMutableSource:function(){},useSyncExternalStore:function(h,p,w){var I=is,N=Zl();if(Yr){if(w===void 0)throw Error(n(407));w=w()}else{if(w=p(),vi===null)throw Error(n(349));(ad&30)!==0||u6(I,p,w)}N.memoizedState=w;var M={value:w,getSnapshot:p};return N.queue=M,g6(h6.bind(null,I,M,h),[h]),I.flags|=2048,m2(9,c6.bind(null,I,M,w,p),void 0,null),w},useId:function(){var h=Zl(),p=vi.identifierPrefix;if(Yr){var w=Lu,I=Fu;w=(I&~(1<<32-hr(I)-1)).toString(32)+w,p=":"+p+"R"+w,w=f2++,0<w&&(p+="H"+w.toString(32)),p+=":"}else w=lY++,p=":"+p+"r"+w.toString(32)+":";return h.memoizedState=p},unstable_isNewReconciler:!1},fY={readContext:Wa,useCallback:x6,useContext:Wa,useEffect:mI,useImperativeHandle:b6,useInsertionEffect:y6,useLayoutEffect:w6,useMemo:_6,useReducer:fI,useRef:m6,useState:function(){return fI(p2)},useDebugValue:gI,useDeferredValue:function(h){var p=ja();return I6(p,Qs.memoizedState,h)},useTransition:function(){var h=fI(p2)[0],p=ja().memoizedState;return[h,p]},useMutableSource:a6,useSyncExternalStore:l6,useId:T6,unstable_isNewReconciler:!1},pY={readContext:Wa,useCallback:x6,useContext:Wa,useEffect:mI,useImperativeHandle:b6,useInsertionEffect:y6,useLayoutEffect:w6,useMemo:_6,useReducer:pI,useRef:m6,useState:function(){return pI(p2)},useDebugValue:gI,useDeferredValue:function(h){var p=ja();return Qs===null?p.memoizedState=h:I6(p,Qs.memoizedState,h)},useTransition:function(){var h=pI(p2)[0],p=ja().memoizedState;return[h,p]},useMutableSource:a6,useSyncExternalStore:l6,useId:T6,unstable_isNewReconciler:!1};function ml(h,p){if(h&&h.defaultProps){p=_e({},p),h=h.defaultProps;for(var w in h)p[w]===void 0&&(p[w]=h[w]);return p}return p}function yI(h,p,w,I){p=h.memoizedState,w=w(I,p),w=w==null?p:_e({},p,w),h.memoizedState=w,h.lanes===0&&(h.updateQueue.baseState=w)}var D3={isMounted:function(h){return(h=h._reactInternals)?qs(h)===h:!1},enqueueSetState:function(h,p,w){h=h._reactInternals;var I=So(),N=Bc(h),M=zu(I,N);M.payload=p,w!=null&&(M.callback=w),p=Lc(h,M,N),p!==null&&(wl(p,h,N,I),S3(p,h,N))},enqueueReplaceState:function(h,p,w){h=h._reactInternals;var I=So(),N=Bc(h),M=zu(I,N);M.tag=1,M.payload=p,w!=null&&(M.callback=w),p=Lc(h,M,N),p!==null&&(wl(p,h,N,I),S3(p,h,N))},enqueueForceUpdate:function(h,p){h=h._reactInternals;var w=So(),I=Bc(h),N=zu(w,I);N.tag=2,p!=null&&(N.callback=p),p=Lc(h,N,I),p!==null&&(wl(p,h,I,w),S3(p,h,I))}};function E6(h,p,w,I,N,M,Z){return h=h.stateNode,typeof h.shouldComponentUpdate=="function"?h.shouldComponentUpdate(I,M,Z):p.prototype&&p.prototype.isPureReactComponent?!kc(w,I)||!kc(N,M):!0}function k6(h,p,w){var I=!1,N=Oc,M=p.contextType;return typeof M=="object"&&M!==null?M=Wa(M):(N=Go(p)?nd:to.current,I=p.contextTypes,M=(I=I!=null)?Xp(h,N):Oc),p=new p(w,M),h.memoizedState=p.state!==null&&p.state!==void 0?p.state:null,p.updater=D3,h.stateNode=p,p._reactInternals=h,I&&(h=h.stateNode,h.__reactInternalMemoizedUnmaskedChildContext=N,h.__reactInternalMemoizedMaskedChildContext=M),p}function N6(h,p,w,I){h=p.state,typeof p.componentWillReceiveProps=="function"&&p.componentWillReceiveProps(w,I),typeof p.UNSAFE_componentWillReceiveProps=="function"&&p.UNSAFE_componentWillReceiveProps(w,I),p.state!==h&&D3.enqueueReplaceState(p,p.state,null)}function wI(h,p,w,I){var N=h.stateNode;N.props=w,N.state=h.memoizedState,N.refs={},sI(h);var M=p.contextType;typeof M=="object"&&M!==null?N.context=Wa(M):(M=Go(p)?nd:to.current,N.context=Xp(h,M)),N.state=h.memoizedState,M=p.getDerivedStateFromProps,typeof M=="function"&&(yI(h,p,M,w),N.state=h.memoizedState),typeof p.getDerivedStateFromProps=="function"||typeof N.getSnapshotBeforeUpdate=="function"||typeof N.UNSAFE_componentWillMount!="function"&&typeof N.componentWillMount!="function"||(p=N.state,typeof N.componentWillMount=="function"&&N.componentWillMount(),typeof N.UNSAFE_componentWillMount=="function"&&N.UNSAFE_componentWillMount(),p!==N.state&&D3.enqueueReplaceState(N,N.state,null),$3(h,w,N,I),N.state=h.memoizedState),typeof N.componentDidMount=="function"&&(h.flags|=4194308)}function rm(h,p){try{var w="",I=p;do w+=de(I),I=I.return;while(I);var N=w}catch(M){N=`
Error generating stack: `+M.message+`
`+M.stack}return{value:h,source:p,stack:N,digest:null}}function vI(h,p,w){return{value:h,source:null,stack:w??null,digest:p??null}}function bI(h,p){try{console.error(p.value)}catch(w){setTimeout(function(){throw w})}}var mY=typeof WeakMap=="function"?WeakMap:Map;function A6(h,p,w){w=zu(-1,w),w.tag=3,w.payload={element:null};var I=p.value;return w.callback=function(){V3||(V3=!0,PI=I),bI(h,p)},w}function R6(h,p,w){w=zu(-1,w),w.tag=3;var I=h.type.getDerivedStateFromError;if(typeof I=="function"){var N=p.value;w.payload=function(){return I(N)},w.callback=function(){bI(h,p)}}var M=h.stateNode;return M!==null&&typeof M.componentDidCatch=="function"&&(w.callback=function(){bI(h,p),typeof I!="function"&&(zc===null?zc=new Set([this]):zc.add(this));var Z=p.stack;this.componentDidCatch(p.value,{componentStack:Z!==null?Z:""})}),w}function D6(h,p,w){var I=h.pingCache;if(I===null){I=h.pingCache=new mY;var N=new Set;I.set(p,N)}else N=I.get(p),N===void 0&&(N=new Set,I.set(p,N));N.has(w)||(N.add(w),h=kY.bind(null,h,p,w),p.then(h,h))}function O6(h){do{var p;if((p=h.tag===13)&&(p=h.memoizedState,p=p!==null?p.dehydrated!==null:!0),p)return h;h=h.return}while(h!==null);return null}function P6(h,p,w,I,N){return(h.mode&1)===0?(h===p?h.flags|=65536:(h.flags|=128,w.flags|=131072,w.flags&=-52805,w.tag===1&&(w.alternate===null?w.tag=17:(p=zu(-1,1),p.tag=2,Lc(w,p,1))),w.lanes|=1),h):(h.flags|=65536,h.lanes=N,h)}var gY=S.ReactCurrentOwner,Ho=!1;function To(h,p,w,I){p.child=h===null?t6(p,null,w,I):Zp(p,h.child,w,I)}function F6(h,p,w,I,N){w=w.render;var M=p.ref;return tm(p,N),I=hI(h,p,w,I,M,N),w=dI(),h!==null&&!Ho?(p.updateQueue=h.updateQueue,p.flags&=-2053,h.lanes&=~N,Vu(h,p,N)):(Yr&&w&&K4(p),p.flags|=1,To(h,p,I,N),p.child)}function L6(h,p,w,I,N){if(h===null){var M=w.type;return typeof M=="function"&&!UI(M)&&M.defaultProps===void 0&&w.compare===null&&w.defaultProps===void 0?(p.tag=15,p.type=M,M6(h,p,M,I,N)):(h=H3(w.type,null,I,p,p.mode,N),h.ref=p.ref,h.return=p,p.child=h)}if(M=h.child,(h.lanes&N)===0){var Z=M.memoizedProps;if(w=w.compare,w=w!==null?w:kc,w(Z,I)&&h.ref===p.ref)return Vu(h,p,N)}return p.flags|=1,h=Wc(M,I),h.ref=p.ref,h.return=p,p.child=h}function M6(h,p,w,I,N){if(h!==null){var M=h.memoizedProps;if(kc(M,I)&&h.ref===p.ref)if(Ho=!1,p.pendingProps=I=M,(h.lanes&N)!==0)(h.flags&131072)!==0&&(Ho=!0);else return p.lanes=h.lanes,Vu(h,p,N)}return xI(h,p,w,I,N)}function z6(h,p,w){var I=p.pendingProps,N=I.children,M=h!==null?h.memoizedState:null;if(I.mode==="hidden")if((p.mode&1)===0)p.memoizedState={baseLanes:0,cachePool:null,transitions:null},Dr(im,ya),ya|=w;else{if((w&1073741824)===0)return h=M!==null?M.baseLanes|w:w,p.lanes=p.childLanes=1073741824,p.memoizedState={baseLanes:h,cachePool:null,transitions:null},p.updateQueue=null,Dr(im,ya),ya|=h,null;p.memoizedState={baseLanes:0,cachePool:null,transitions:null},I=M!==null?M.baseLanes:w,Dr(im,ya),ya|=I}else M!==null?(I=M.baseLanes|w,p.memoizedState=null):I=w,Dr(im,ya),ya|=I;return To(h,p,N,w),p.child}function V6(h,p){var w=p.ref;(h===null&&w!==null||h!==null&&h.ref!==w)&&(p.flags|=512,p.flags|=2097152)}function xI(h,p,w,I,N){var M=Go(w)?nd:to.current;return M=Xp(p,M),tm(p,N),w=hI(h,p,w,I,M,N),I=dI(),h!==null&&!Ho?(p.updateQueue=h.updateQueue,p.flags&=-2053,h.lanes&=~N,Vu(h,p,N)):(Yr&&I&&K4(p),p.flags|=1,To(h,p,w,N),p.child)}function B6(h,p,w,I,N){if(Go(w)){var M=!0;y3(p)}else M=!1;if(tm(p,N),p.stateNode===null)P3(h,p),k6(p,w,I),wI(p,w,I,N),I=!0;else if(h===null){var Z=p.stateNode,pe=p.memoizedProps;Z.props=pe;var Se=Z.context,je=w.contextType;typeof je=="object"&&je!==null?je=Wa(je):(je=Go(w)?nd:to.current,je=Xp(p,je));var ut=w.getDerivedStateFromProps,pt=typeof ut=="function"||typeof Z.getSnapshotBeforeUpdate=="function";pt||typeof Z.UNSAFE_componentWillReceiveProps!="function"&&typeof Z.componentWillReceiveProps!="function"||(pe!==I||Se!==je)&&N6(p,Z,I,je),Fc=!1;var at=p.memoizedState;Z.state=at,$3(p,I,Z,N),Se=p.memoizedState,pe!==I||at!==Se||jo.current||Fc?(typeof ut=="function"&&(yI(p,w,ut,I),Se=p.memoizedState),(pe=Fc||E6(p,w,pe,I,at,Se,je))?(pt||typeof Z.UNSAFE_componentWillMount!="function"&&typeof Z.componentWillMount!="function"||(typeof Z.componentWillMount=="function"&&Z.componentWillMount(),typeof Z.UNSAFE_componentWillMount=="function"&&Z.UNSAFE_componentWillMount()),typeof Z.componentDidMount=="function"&&(p.flags|=4194308)):(typeof Z.componentDidMount=="function"&&(p.flags|=4194308),p.memoizedProps=I,p.memoizedState=Se),Z.props=I,Z.state=Se,Z.context=je,I=pe):(typeof Z.componentDidMount=="function"&&(p.flags|=4194308),I=!1)}else{Z=p.stateNode,r6(h,p),pe=p.memoizedProps,je=p.type===p.elementType?pe:ml(p.type,pe),Z.props=je,pt=p.pendingProps,at=Z.context,Se=w.contextType,typeof Se=="object"&&Se!==null?Se=Wa(Se):(Se=Go(w)?nd:to.current,Se=Xp(p,Se));var At=w.getDerivedStateFromProps;(ut=typeof At=="function"||typeof Z.getSnapshotBeforeUpdate=="function")||typeof Z.UNSAFE_componentWillReceiveProps!="function"&&typeof Z.componentWillReceiveProps!="function"||(pe!==pt||at!==Se)&&N6(p,Z,I,Se),Fc=!1,at=p.memoizedState,Z.state=at,$3(p,I,Z,N);var Vt=p.memoizedState;pe!==pt||at!==Vt||jo.current||Fc?(typeof At=="function"&&(yI(p,w,At,I),Vt=p.memoizedState),(je=Fc||E6(p,w,je,I,at,Vt,Se)||!1)?(ut||typeof Z.UNSAFE_componentWillUpdate!="function"&&typeof Z.componentWillUpdate!="function"||(typeof Z.componentWillUpdate=="function"&&Z.componentWillUpdate(I,Vt,Se),typeof Z.UNSAFE_componentWillUpdate=="function"&&Z.UNSAFE_componentWillUpdate(I,Vt,Se)),typeof Z.componentDidUpdate=="function"&&(p.flags|=4),typeof Z.getSnapshotBeforeUpdate=="function"&&(p.flags|=1024)):(typeof Z.componentDidUpdate!="function"||pe===h.memoizedProps&&at===h.memoizedState||(p.flags|=4),typeof Z.getSnapshotBeforeUpdate!="function"||pe===h.memoizedProps&&at===h.memoizedState||(p.flags|=1024),p.memoizedProps=I,p.memoizedState=Vt),Z.props=I,Z.state=Vt,Z.context=Se,I=je):(typeof Z.componentDidUpdate!="function"||pe===h.memoizedProps&&at===h.memoizedState||(p.flags|=4),typeof Z.getSnapshotBeforeUpdate!="function"||pe===h.memoizedProps&&at===h.memoizedState||(p.flags|=1024),I=!1)}return _I(h,p,w,I,M,N)}function _I(h,p,w,I,N,M){V6(h,p);var Z=(p.flags&128)!==0;if(!I&&!Z)return N&&HR(p,w,!1),Vu(h,p,M);I=p.stateNode,gY.current=p;var pe=Z&&typeof w.getDerivedStateFromError!="function"?null:I.render();return p.flags|=1,h!==null&&Z?(p.child=Zp(p,h.child,null,M),p.child=Zp(p,null,pe,M)):To(h,p,pe,M),p.memoizedState=I.state,N&&HR(p,w,!0),p.child}function U6(h){var p=h.stateNode;p.pendingContext?jR(h,p.pendingContext,p.pendingContext!==p.context):p.context&&jR(h,p.context,!1),iI(h,p.containerInfo)}function W6(h,p,w,I,N){return Jp(),J4(N),p.flags|=256,To(h,p,w,I),p.child}var II={dehydrated:null,treeContext:null,retryLane:0};function TI(h){return{baseLanes:h,cachePool:null,transitions:null}}function j6(h,p,w){var I=p.pendingProps,N=ss.current,M=!1,Z=(p.flags&128)!==0,pe;if((pe=Z)||(pe=h!==null&&h.memoizedState===null?!1:(N&2)!==0),pe?(M=!0,p.flags&=-129):(h===null||h.memoizedState!==null)&&(N|=1),Dr(ss,N&1),h===null)return Q4(p),h=p.memoizedState,h!==null&&(h=h.dehydrated,h!==null)?((p.mode&1)===0?p.lanes=1:h.data==="$!"?p.lanes=8:p.lanes=1073741824,null):(Z=I.children,h=I.fallback,M?(I=p.mode,M=p.child,Z={mode:"hidden",children:Z},(I&1)===0&&M!==null?(M.childLanes=0,M.pendingProps=Z):M=q3(Z,I,0,null),h=dd(h,I,w,null),M.return=p,h.return=p,M.sibling=h,p.child=M,p.child.memoizedState=TI(w),p.memoizedState=II,h):SI(p,Z));if(N=h.memoizedState,N!==null&&(pe=N.dehydrated,pe!==null))return yY(h,p,Z,I,pe,N,w);if(M){M=I.fallback,Z=p.mode,N=h.child,pe=N.sibling;var Se={mode:"hidden",children:I.children};return(Z&1)===0&&p.child!==N?(I=p.child,I.childLanes=0,I.pendingProps=Se,p.deletions=null):(I=Wc(N,Se),I.subtreeFlags=N.subtreeFlags&14680064),pe!==null?M=Wc(pe,M):(M=dd(M,Z,w,null),M.flags|=2),M.return=p,I.return=p,I.sibling=M,p.child=I,I=M,M=p.child,Z=h.child.memoizedState,Z=Z===null?TI(w):{baseLanes:Z.baseLanes|w,cachePool:null,transitions:Z.transitions},M.memoizedState=Z,M.childLanes=h.childLanes&~w,p.memoizedState=II,I}return M=h.child,h=M.sibling,I=Wc(M,{mode:"visible",children:I.children}),(p.mode&1)===0&&(I.lanes=w),I.return=p,I.sibling=null,h!==null&&(w=p.deletions,w===null?(p.deletions=[h],p.flags|=16):w.push(h)),p.child=I,p.memoizedState=null,I}function SI(h,p){return p=q3({mode:"visible",children:p},h.mode,0,null),p.return=h,h.child=p}function O3(h,p,w,I){return I!==null&&J4(I),Zp(p,h.child,null,w),h=SI(p,p.pendingProps.children),h.flags|=2,p.memoizedState=null,h}function yY(h,p,w,I,N,M,Z){if(w)return p.flags&256?(p.flags&=-257,I=vI(Error(n(422))),O3(h,p,Z,I)):p.memoizedState!==null?(p.child=h.child,p.flags|=128,null):(M=I.fallback,N=p.mode,I=q3({mode:"visible",children:I.children},N,0,null),M=dd(M,N,Z,null),M.flags|=2,I.return=p,M.return=p,I.sibling=M,p.child=I,(p.mode&1)!==0&&Zp(p,h.child,null,Z),p.child.memoizedState=TI(Z),p.memoizedState=II,M);if((p.mode&1)===0)return O3(h,p,Z,null);if(N.data==="$!"){if(I=N.nextSibling&&N.nextSibling.dataset,I)var pe=I.dgst;return I=pe,M=Error(n(419)),I=vI(M,I,void 0),O3(h,p,Z,I)}if(pe=(Z&h.childLanes)!==0,Ho||pe){if(I=vi,I!==null){switch(Z&-Z){case 4:N=2;break;case 16:N=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:N=32;break;case 536870912:N=268435456;break;default:N=0}N=(N&(I.suspendedLanes|Z))!==0?0:N,N!==0&&N!==M.retryLane&&(M.retryLane=N,Mu(h,N),wl(I,h,N,-1))}return BI(),I=vI(Error(n(421))),O3(h,p,Z,I)}return N.data==="$?"?(p.flags|=128,p.child=h.child,p=NY.bind(null,h),N._reactRetry=p,null):(h=M.treeContext,ga=Rc(N.nextSibling),ma=p,Yr=!0,pl=null,h!==null&&(Ba[Ua++]=Fu,Ba[Ua++]=Lu,Ba[Ua++]=rd,Fu=h.id,Lu=h.overflow,rd=p),p=SI(p,I.children),p.flags|=4096,p)}function G6(h,p,w){h.lanes|=p;var I=h.alternate;I!==null&&(I.lanes|=p),nI(h.return,p,w)}function $I(h,p,w,I,N){var M=h.memoizedState;M===null?h.memoizedState={isBackwards:p,rendering:null,renderingStartTime:0,last:I,tail:w,tailMode:N}:(M.isBackwards=p,M.rendering=null,M.renderingStartTime=0,M.last=I,M.tail=w,M.tailMode=N)}function H6(h,p,w){var I=p.pendingProps,N=I.revealOrder,M=I.tail;if(To(h,p,I.children,w),I=ss.current,(I&2)!==0)I=I&1|2,p.flags|=128;else{if(h!==null&&(h.flags&128)!==0)e:for(h=p.child;h!==null;){if(h.tag===13)h.memoizedState!==null&&G6(h,w,p);else if(h.tag===19)G6(h,w,p);else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===p)break e;for(;h.sibling===null;){if(h.return===null||h.return===p)break e;h=h.return}h.sibling.return=h.return,h=h.sibling}I&=1}if(Dr(ss,I),(p.mode&1)===0)p.memoizedState=null;else switch(N){case"forwards":for(w=p.child,N=null;w!==null;)h=w.alternate,h!==null&&C3(h)===null&&(N=w),w=w.sibling;w=N,w===null?(N=p.child,p.child=null):(N=w.sibling,w.sibling=null),$I(p,!1,N,w,M);break;case"backwards":for(w=null,N=p.child,p.child=null;N!==null;){if(h=N.alternate,h!==null&&C3(h)===null){p.child=N;break}h=N.sibling,N.sibling=w,w=N,N=h}$I(p,!0,w,null,M);break;case"together":$I(p,!1,null,null,void 0);break;default:p.memoizedState=null}return p.child}function P3(h,p){(p.mode&1)===0&&h!==null&&(h.alternate=null,p.alternate=null,p.flags|=2)}function Vu(h,p,w){if(h!==null&&(p.dependencies=h.dependencies),ld|=p.lanes,(w&p.childLanes)===0)return null;if(h!==null&&p.child!==h.child)throw Error(n(153));if(p.child!==null){for(h=p.child,w=Wc(h,h.pendingProps),p.child=w,w.return=p;h.sibling!==null;)h=h.sibling,w=w.sibling=Wc(h,h.pendingProps),w.return=p;w.sibling=null}return p.child}function wY(h,p,w){switch(p.tag){case 3:U6(p),Jp();break;case 5:o6(p);break;case 1:Go(p.type)&&y3(p);break;case 4:iI(p,p.stateNode.containerInfo);break;case 10:var I=p.type._context,N=p.memoizedProps.value;Dr(I3,I._currentValue),I._currentValue=N;break;case 13:if(I=p.memoizedState,I!==null)return I.dehydrated!==null?(Dr(ss,ss.current&1),p.flags|=128,null):(w&p.child.childLanes)!==0?j6(h,p,w):(Dr(ss,ss.current&1),h=Vu(h,p,w),h!==null?h.sibling:null);Dr(ss,ss.current&1);break;case 19:if(I=(w&p.childLanes)!==0,(h.flags&128)!==0){if(I)return H6(h,p,w);p.flags|=128}if(N=p.memoizedState,N!==null&&(N.rendering=null,N.tail=null,N.lastEffect=null),Dr(ss,ss.current),I)break;return null;case 22:case 23:return p.lanes=0,z6(h,p,w)}return Vu(h,p,w)}var q6,CI,K6,X6;q6=function(h,p){for(var w=p.child;w!==null;){if(w.tag===5||w.tag===6)h.appendChild(w.stateNode);else if(w.tag!==4&&w.child!==null){w.child.return=w,w=w.child;continue}if(w===p)break;for(;w.sibling===null;){if(w.return===null||w.return===p)return;w=w.return}w.sibling.return=w.return,w=w.sibling}},CI=function(){},K6=function(h,p,w,I){var N=h.memoizedProps;if(N!==I){h=p.stateNode,od(Jl.current);var M=null;switch(w){case"input":N=Wt(h,N),I=Wt(h,I),M=[];break;case"select":N=_e({},N,{value:void 0}),I=_e({},I,{value:void 0}),M=[];break;case"textarea":N=mn(h,N),I=mn(h,I),M=[];break;default:typeof N.onClick!="function"&&typeof I.onClick=="function"&&(h.onclick=p3)}Un(w,I);var Z;w=null;for(je in N)if(!I.hasOwnProperty(je)&&N.hasOwnProperty(je)&&N[je]!=null)if(je==="style"){var pe=N[je];for(Z in pe)pe.hasOwnProperty(Z)&&(w||(w={}),w[Z]="")}else je!=="dangerouslySetInnerHTML"&&je!=="children"&&je!=="suppressContentEditableWarning"&&je!=="suppressHydrationWarning"&&je!=="autoFocus"&&(s.hasOwnProperty(je)?M||(M=[]):(M=M||[]).push(je,null));for(je in I){var Se=I[je];if(pe=N?.[je],I.hasOwnProperty(je)&&Se!==pe&&(Se!=null||pe!=null))if(je==="style")if(pe){for(Z in pe)!pe.hasOwnProperty(Z)||Se&&Se.hasOwnProperty(Z)||(w||(w={}),w[Z]="");for(Z in Se)Se.hasOwnProperty(Z)&&pe[Z]!==Se[Z]&&(w||(w={}),w[Z]=Se[Z])}else w||(M||(M=[]),M.push(je,w)),w=Se;else je==="dangerouslySetInnerHTML"?(Se=Se?Se.__html:void 0,pe=pe?pe.__html:void 0,Se!=null&&pe!==Se&&(M=M||[]).push(je,Se)):je==="children"?typeof Se!="string"&&typeof Se!="number"||(M=M||[]).push(je,""+Se):je!=="suppressContentEditableWarning"&&je!=="suppressHydrationWarning"&&(s.hasOwnProperty(je)?(Se!=null&&je==="onScroll"&&Mr("scroll",h),M||pe===Se||(M=[])):(M=M||[]).push(je,Se))}w&&(M=M||[]).push("style",w);var je=M;(p.updateQueue=je)&&(p.flags|=4)}},X6=function(h,p,w,I){w!==I&&(p.flags|=4)};function g2(h,p){if(!Yr)switch(h.tailMode){case"hidden":p=h.tail;for(var w=null;p!==null;)p.alternate!==null&&(w=p),p=p.sibling;w===null?h.tail=null:w.sibling=null;break;case"collapsed":w=h.tail;for(var I=null;w!==null;)w.alternate!==null&&(I=w),w=w.sibling;I===null?p||h.tail===null?h.tail=null:h.tail.sibling=null:I.sibling=null}}function ro(h){var p=h.alternate!==null&&h.alternate.child===h.child,w=0,I=0;if(p)for(var N=h.child;N!==null;)w|=N.lanes|N.childLanes,I|=N.subtreeFlags&14680064,I|=N.flags&14680064,N.return=h,N=N.sibling;else for(N=h.child;N!==null;)w|=N.lanes|N.childLanes,I|=N.subtreeFlags,I|=N.flags,N.return=h,N=N.sibling;return h.subtreeFlags|=I,h.childLanes=w,p}function vY(h,p,w){var I=p.pendingProps;switch(X4(p),p.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ro(p),null;case 1:return Go(p.type)&&g3(),ro(p),null;case 3:return I=p.stateNode,nm(),zr(jo),zr(to),lI(),I.pendingContext&&(I.context=I.pendingContext,I.pendingContext=null),(h===null||h.child===null)&&(x3(p)?p.flags|=4:h===null||h.memoizedState.isDehydrated&&(p.flags&256)===0||(p.flags|=1024,pl!==null&&(MI(pl),pl=null))),CI(h,p),ro(p),null;case 5:oI(p);var N=od(h2.current);if(w=p.type,h!==null&&p.stateNode!=null)K6(h,p,w,I,N),h.ref!==p.ref&&(p.flags|=512,p.flags|=2097152);else{if(!I){if(p.stateNode===null)throw Error(n(166));return ro(p),null}if(h=od(Jl.current),x3(p)){I=p.stateNode,w=p.type;var M=p.memoizedProps;switch(I[Ql]=p,I[o2]=M,h=(p.mode&1)!==0,w){case"dialog":Mr("cancel",I),Mr("close",I);break;case"iframe":case"object":case"embed":Mr("load",I);break;case"video":case"audio":for(N=0;N<r2.length;N++)Mr(r2[N],I);break;case"source":Mr("error",I);break;case"img":case"image":case"link":Mr("error",I),Mr("load",I);break;case"details":Mr("toggle",I);break;case"input":Et(I,M),Mr("invalid",I);break;case"select":I._wrapperState={wasMultiple:!!M.multiple},Mr("invalid",I);break;case"textarea":jt(I,M),Mr("invalid",I)}Un(w,M),N=null;for(var Z in M)if(M.hasOwnProperty(Z)){var pe=M[Z];Z==="children"?typeof pe=="string"?I.textContent!==pe&&(M.suppressHydrationWarning!==!0&&f3(I.textContent,pe,h),N=["children",pe]):typeof pe=="number"&&I.textContent!==""+pe&&(M.suppressHydrationWarning!==!0&&f3(I.textContent,pe,h),N=["children",""+pe]):s.hasOwnProperty(Z)&&pe!=null&&Z==="onScroll"&&Mr("scroll",I)}switch(w){case"input":nt(I),Tt(I,M,!0);break;case"textarea":nt(I),Vn(I);break;case"select":case"option":break;default:typeof M.onClick=="function"&&(I.onclick=p3)}I=N,p.updateQueue=I,I!==null&&(p.flags|=4)}else{Z=N.nodeType===9?N:N.ownerDocument,h==="http://www.w3.org/1999/xhtml"&&(h=Bn(w)),h==="http://www.w3.org/1999/xhtml"?w==="script"?(h=Z.createElement("div"),h.innerHTML="<script><\/script>",h=h.removeChild(h.firstChild)):typeof I.is=="string"?h=Z.createElement(w,{is:I.is}):(h=Z.createElement(w),w==="select"&&(Z=h,I.multiple?Z.multiple=!0:I.size&&(Z.size=I.size))):h=Z.createElementNS(h,w),h[Ql]=p,h[o2]=I,q6(h,p,!1,!1),p.stateNode=h;e:{switch(Z=Kr(w,I),w){case"dialog":Mr("cancel",h),Mr("close",h),N=I;break;case"iframe":case"object":case"embed":Mr("load",h),N=I;break;case"video":case"audio":for(N=0;N<r2.length;N++)Mr(r2[N],h);N=I;break;case"source":Mr("error",h),N=I;break;case"img":case"image":case"link":Mr("error",h),Mr("load",h),N=I;break;case"details":Mr("toggle",h),N=I;break;case"input":Et(h,I),N=Wt(h,I),Mr("invalid",h);break;case"option":N=I;break;case"select":h._wrapperState={wasMultiple:!!I.multiple},N=_e({},I,{value:void 0}),Mr("invalid",h);break;case"textarea":jt(h,I),N=mn(h,I),Mr("invalid",h);break;default:N=I}Un(w,N),pe=N;for(M in pe)if(pe.hasOwnProperty(M)){var Se=pe[M];M==="style"?gr(h,Se):M==="dangerouslySetInnerHTML"?(Se=Se?Se.__html:void 0,Se!=null&&xr(h,Se)):M==="children"?typeof Se=="string"?(w!=="textarea"||Se!=="")&&fr(h,Se):typeof Se=="number"&&fr(h,""+Se):M!=="suppressContentEditableWarning"&&M!=="suppressHydrationWarning"&&M!=="autoFocus"&&(s.hasOwnProperty(M)?Se!=null&&M==="onScroll"&&Mr("scroll",h):Se!=null&&$(h,M,Se,Z))}switch(w){case"input":nt(h),Tt(h,I,!1);break;case"textarea":nt(h),Vn(h);break;case"option":I.value!=null&&h.setAttribute("value",""+Oe(I.value));break;case"select":h.multiple=!!I.multiple,M=I.value,M!=null?Yt(h,!!I.multiple,M,!1):I.defaultValue!=null&&Yt(h,!!I.multiple,I.defaultValue,!0);break;default:typeof N.onClick=="function"&&(h.onclick=p3)}switch(w){case"button":case"input":case"select":case"textarea":I=!!I.autoFocus;break e;case"img":I=!0;break e;default:I=!1}}I&&(p.flags|=4)}p.ref!==null&&(p.flags|=512,p.flags|=2097152)}return ro(p),null;case 6:if(h&&p.stateNode!=null)X6(h,p,h.memoizedProps,I);else{if(typeof I!="string"&&p.stateNode===null)throw Error(n(166));if(w=od(h2.current),od(Jl.current),x3(p)){if(I=p.stateNode,w=p.memoizedProps,I[Ql]=p,(M=I.nodeValue!==w)&&(h=ma,h!==null))switch(h.tag){case 3:f3(I.nodeValue,w,(h.mode&1)!==0);break;case 5:h.memoizedProps.suppressHydrationWarning!==!0&&f3(I.nodeValue,w,(h.mode&1)!==0)}M&&(p.flags|=4)}else I=(w.nodeType===9?w:w.ownerDocument).createTextNode(I),I[Ql]=p,p.stateNode=I}return ro(p),null;case 13:if(zr(ss),I=p.memoizedState,h===null||h.memoizedState!==null&&h.memoizedState.dehydrated!==null){if(Yr&&ga!==null&&(p.mode&1)!==0&&(p.flags&128)===0)JR(),Jp(),p.flags|=98560,M=!1;else if(M=x3(p),I!==null&&I.dehydrated!==null){if(h===null){if(!M)throw Error(n(318));if(M=p.memoizedState,M=M!==null?M.dehydrated:null,!M)throw Error(n(317));M[Ql]=p}else Jp(),(p.flags&128)===0&&(p.memoizedState=null),p.flags|=4;ro(p),M=!1}else pl!==null&&(MI(pl),pl=null),M=!0;if(!M)return p.flags&65536?p:null}return(p.flags&128)!==0?(p.lanes=w,p):(I=I!==null,I!==(h!==null&&h.memoizedState!==null)&&I&&(p.child.flags|=8192,(p.mode&1)!==0&&(h===null||(ss.current&1)!==0?Js===0&&(Js=3):BI())),p.updateQueue!==null&&(p.flags|=4),ro(p),null);case 4:return nm(),CI(h,p),h===null&&s2(p.stateNode.containerInfo),ro(p),null;case 10:return tI(p.type._context),ro(p),null;case 17:return Go(p.type)&&g3(),ro(p),null;case 19:if(zr(ss),M=p.memoizedState,M===null)return ro(p),null;if(I=(p.flags&128)!==0,Z=M.rendering,Z===null)if(I)g2(M,!1);else{if(Js!==0||h!==null&&(h.flags&128)!==0)for(h=p.child;h!==null;){if(Z=C3(h),Z!==null){for(p.flags|=128,g2(M,!1),I=Z.updateQueue,I!==null&&(p.updateQueue=I,p.flags|=4),p.subtreeFlags=0,I=w,w=p.child;w!==null;)M=w,h=I,M.flags&=14680066,Z=M.alternate,Z===null?(M.childLanes=0,M.lanes=h,M.child=null,M.subtreeFlags=0,M.memoizedProps=null,M.memoizedState=null,M.updateQueue=null,M.dependencies=null,M.stateNode=null):(M.childLanes=Z.childLanes,M.lanes=Z.lanes,M.child=Z.child,M.subtreeFlags=0,M.deletions=null,M.memoizedProps=Z.memoizedProps,M.memoizedState=Z.memoizedState,M.updateQueue=Z.updateQueue,M.type=Z.type,h=Z.dependencies,M.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext}),w=w.sibling;return Dr(ss,ss.current&1|2),p.child}h=h.sibling}M.tail!==null&&gn()>om&&(p.flags|=128,I=!0,g2(M,!1),p.lanes=4194304)}else{if(!I)if(h=C3(Z),h!==null){if(p.flags|=128,I=!0,w=h.updateQueue,w!==null&&(p.updateQueue=w,p.flags|=4),g2(M,!0),M.tail===null&&M.tailMode==="hidden"&&!Z.alternate&&!Yr)return ro(p),null}else 2*gn()-M.renderingStartTime>om&&w!==1073741824&&(p.flags|=128,I=!0,g2(M,!1),p.lanes=4194304);M.isBackwards?(Z.sibling=p.child,p.child=Z):(w=M.last,w!==null?w.sibling=Z:p.child=Z,M.last=Z)}return M.tail!==null?(p=M.tail,M.rendering=p,M.tail=p.sibling,M.renderingStartTime=gn(),p.sibling=null,w=ss.current,Dr(ss,I?w&1|2:w&1),p):(ro(p),null);case 22:case 23:return VI(),I=p.memoizedState!==null,h!==null&&h.memoizedState!==null!==I&&(p.flags|=8192),I&&(p.mode&1)!==0?(ya&1073741824)!==0&&(ro(p),p.subtreeFlags&6&&(p.flags|=8192)):ro(p),null;case 24:return null;case 25:return null}throw Error(n(156,p.tag))}function bY(h,p){switch(X4(p),p.tag){case 1:return Go(p.type)&&g3(),h=p.flags,h&65536?(p.flags=h&-65537|128,p):null;case 3:return nm(),zr(jo),zr(to),lI(),h=p.flags,(h&65536)!==0&&(h&128)===0?(p.flags=h&-65537|128,p):null;case 5:return oI(p),null;case 13:if(zr(ss),h=p.memoizedState,h!==null&&h.dehydrated!==null){if(p.alternate===null)throw Error(n(340));Jp()}return h=p.flags,h&65536?(p.flags=h&-65537|128,p):null;case 19:return zr(ss),null;case 4:return nm(),null;case 10:return tI(p.type._context),null;case 22:case 23:return VI(),null;case 24:return null;default:return null}}var F3=!1,so=!1,xY=typeof WeakSet=="function"?WeakSet:Set,Lt=null;function sm(h,p){var w=h.ref;if(w!==null)if(typeof w=="function")try{w(null)}catch(I){ds(h,p,I)}else w.current=null}function EI(h,p,w){try{w()}catch(I){ds(h,p,I)}}var Y6=!1;function _Y(h,p){if(V4=he,h=k(),V(h)){if("selectionStart"in h)var w={start:h.selectionStart,end:h.selectionEnd};else e:{w=(w=h.ownerDocument)&&w.defaultView||window;var I=w.getSelection&&w.getSelection();if(I&&I.rangeCount!==0){w=I.anchorNode;var N=I.anchorOffset,M=I.focusNode;I=I.focusOffset;try{w.nodeType,M.nodeType}catch{w=null;break e}var Z=0,pe=-1,Se=-1,je=0,ut=0,pt=h,at=null;t:for(;;){for(var At;pt!==w||N!==0&&pt.nodeType!==3||(pe=Z+N),pt!==M||I!==0&&pt.nodeType!==3||(Se=Z+I),pt.nodeType===3&&(Z+=pt.nodeValue.length),(At=pt.firstChild)!==null;)at=pt,pt=At;for(;;){if(pt===h)break t;if(at===w&&++je===N&&(pe=Z),at===M&&++ut===I&&(Se=Z),(At=pt.nextSibling)!==null)break;pt=at,at=pt.parentNode}pt=At}w=pe===-1||Se===-1?null:{start:pe,end:Se}}else w=null}w=w||{start:0,end:0}}else w=null;for(B4={focusedElem:h,selectionRange:w},he=!1,Lt=p;Lt!==null;)if(p=Lt,h=p.child,(p.subtreeFlags&1028)!==0&&h!==null)h.return=p,Lt=h;else for(;Lt!==null;){p=Lt;try{var Vt=p.alternate;if((p.flags&1024)!==0)switch(p.tag){case 0:case 11:case 15:break;case 1:if(Vt!==null){var Gt=Vt.memoizedProps,_s=Vt.memoizedState,Le=p.stateNode,Ce=Le.getSnapshotBeforeUpdate(p.elementType===p.type?Gt:ml(p.type,Gt),_s);Le.__reactInternalSnapshotBeforeUpdate=Ce}break;case 3:var ze=p.stateNode.containerInfo;ze.nodeType===1?ze.textContent="":ze.nodeType===9&&ze.documentElement&&ze.removeChild(ze.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(n(163))}}catch(wt){ds(p,p.return,wt)}if(h=p.sibling,h!==null){h.return=p.return,Lt=h;break}Lt=p.return}return Vt=Y6,Y6=!1,Vt}function y2(h,p,w){var I=p.updateQueue;if(I=I!==null?I.lastEffect:null,I!==null){var N=I=I.next;do{if((N.tag&h)===h){var M=N.destroy;N.destroy=void 0,M!==void 0&&EI(p,w,M)}N=N.next}while(N!==I)}}function L3(h,p){if(p=p.updateQueue,p=p!==null?p.lastEffect:null,p!==null){var w=p=p.next;do{if((w.tag&h)===h){var I=w.create;w.destroy=I()}w=w.next}while(w!==p)}}function kI(h){var p=h.ref;if(p!==null){var w=h.stateNode;switch(h.tag){case 5:h=w;break;default:h=w}typeof p=="function"?p(h):p.current=h}}function Q6(h){var p=h.alternate;p!==null&&(h.alternate=null,Q6(p)),h.child=null,h.deletions=null,h.sibling=null,h.tag===5&&(p=h.stateNode,p!==null&&(delete p[Ql],delete p[o2],delete p[G4],delete p[sY],delete p[iY])),h.stateNode=null,h.return=null,h.dependencies=null,h.memoizedProps=null,h.memoizedState=null,h.pendingProps=null,h.stateNode=null,h.updateQueue=null}function J6(h){return h.tag===5||h.tag===3||h.tag===4}function Z6(h){e:for(;;){for(;h.sibling===null;){if(h.return===null||J6(h.return))return null;h=h.return}for(h.sibling.return=h.return,h=h.sibling;h.tag!==5&&h.tag!==6&&h.tag!==18;){if(h.flags&2||h.child===null||h.tag===4)continue e;h.child.return=h,h=h.child}if(!(h.flags&2))return h.stateNode}}function NI(h,p,w){var I=h.tag;if(I===5||I===6)h=h.stateNode,p?w.nodeType===8?w.parentNode.insertBefore(h,p):w.insertBefore(h,p):(w.nodeType===8?(p=w.parentNode,p.insertBefore(h,w)):(p=w,p.appendChild(h)),w=w._reactRootContainer,w!=null||p.onclick!==null||(p.onclick=p3));else if(I!==4&&(h=h.child,h!==null))for(NI(h,p,w),h=h.sibling;h!==null;)NI(h,p,w),h=h.sibling}function AI(h,p,w){var I=h.tag;if(I===5||I===6)h=h.stateNode,p?w.insertBefore(h,p):w.appendChild(h);else if(I!==4&&(h=h.child,h!==null))for(AI(h,p,w),h=h.sibling;h!==null;)AI(h,p,w),h=h.sibling}var Vi=null,gl=!1;function Mc(h,p,w){for(w=w.child;w!==null;)eD(h,p,w),w=w.sibling}function eD(h,p,w){if(As&&typeof As.onCommitFiberUnmount=="function")try{As.onCommitFiberUnmount(ha,w)}catch{}switch(w.tag){case 5:so||sm(w,p);case 6:var I=Vi,N=gl;Vi=null,Mc(h,p,w),Vi=I,gl=N,Vi!==null&&(gl?(h=Vi,w=w.stateNode,h.nodeType===8?h.parentNode.removeChild(w):h.removeChild(w)):Vi.removeChild(w.stateNode));break;case 18:Vi!==null&&(gl?(h=Vi,w=w.stateNode,h.nodeType===8?j4(h.parentNode,w):h.nodeType===1&&j4(h,w),ae(h)):j4(Vi,w.stateNode));break;case 4:I=Vi,N=gl,Vi=w.stateNode.containerInfo,gl=!0,Mc(h,p,w),Vi=I,gl=N;break;case 0:case 11:case 14:case 15:if(!so&&(I=w.updateQueue,I!==null&&(I=I.lastEffect,I!==null))){N=I=I.next;do{var M=N,Z=M.destroy;M=M.tag,Z!==void 0&&((M&2)!==0||(M&4)!==0)&&EI(w,p,Z),N=N.next}while(N!==I)}Mc(h,p,w);break;case 1:if(!so&&(sm(w,p),I=w.stateNode,typeof I.componentWillUnmount=="function"))try{I.props=w.memoizedProps,I.state=w.memoizedState,I.componentWillUnmount()}catch(pe){ds(w,p,pe)}Mc(h,p,w);break;case 21:Mc(h,p,w);break;case 22:w.mode&1?(so=(I=so)||w.memoizedState!==null,Mc(h,p,w),so=I):Mc(h,p,w);break;default:Mc(h,p,w)}}function tD(h){var p=h.updateQueue;if(p!==null){h.updateQueue=null;var w=h.stateNode;w===null&&(w=h.stateNode=new xY),p.forEach(function(I){var N=AY.bind(null,h,I);w.has(I)||(w.add(I),I.then(N,N))})}}function yl(h,p){var w=p.deletions;if(w!==null)for(var I=0;I<w.length;I++){var N=w[I];try{var M=h,Z=p,pe=Z;e:for(;pe!==null;){switch(pe.tag){case 5:Vi=pe.stateNode,gl=!1;break e;case 3:Vi=pe.stateNode.containerInfo,gl=!0;break e;case 4:Vi=pe.stateNode.containerInfo,gl=!0;break e}pe=pe.return}if(Vi===null)throw Error(n(160));eD(M,Z,N),Vi=null,gl=!1;var Se=N.alternate;Se!==null&&(Se.return=null),N.return=null}catch(je){ds(N,p,je)}}if(p.subtreeFlags&12854)for(p=p.child;p!==null;)nD(p,h),p=p.sibling}function nD(h,p){var w=h.alternate,I=h.flags;switch(h.tag){case 0:case 11:case 14:case 15:if(yl(p,h),eu(h),I&4){try{y2(3,h,h.return),L3(3,h)}catch(Gt){ds(h,h.return,Gt)}try{y2(5,h,h.return)}catch(Gt){ds(h,h.return,Gt)}}break;case 1:yl(p,h),eu(h),I&512&&w!==null&&sm(w,w.return);break;case 5:if(yl(p,h),eu(h),I&512&&w!==null&&sm(w,w.return),h.flags&32){var N=h.stateNode;try{fr(N,"")}catch(Gt){ds(h,h.return,Gt)}}if(I&4&&(N=h.stateNode,N!=null)){var M=h.memoizedProps,Z=w!==null?w.memoizedProps:M,pe=h.type,Se=h.updateQueue;if(h.updateQueue=null,Se!==null)try{pe==="input"&&M.type==="radio"&&M.name!=null&&vt(N,M),Kr(pe,Z);var je=Kr(pe,M);for(Z=0;Z<Se.length;Z+=2){var ut=Se[Z],pt=Se[Z+1];ut==="style"?gr(N,pt):ut==="dangerouslySetInnerHTML"?xr(N,pt):ut==="children"?fr(N,pt):$(N,ut,pt,je)}switch(pe){case"input":Ht(N,M);break;case"textarea":Fn(N,M);break;case"select":var at=N._wrapperState.wasMultiple;N._wrapperState.wasMultiple=!!M.multiple;var At=M.value;At!=null?Yt(N,!!M.multiple,At,!1):at!==!!M.multiple&&(M.defaultValue!=null?Yt(N,!!M.multiple,M.defaultValue,!0):Yt(N,!!M.multiple,M.multiple?[]:"",!1))}N[o2]=M}catch(Gt){ds(h,h.return,Gt)}}break;case 6:if(yl(p,h),eu(h),I&4){if(h.stateNode===null)throw Error(n(162));N=h.stateNode,M=h.memoizedProps;try{N.nodeValue=M}catch(Gt){ds(h,h.return,Gt)}}break;case 3:if(yl(p,h),eu(h),I&4&&w!==null&&w.memoizedState.isDehydrated)try{ae(p.containerInfo)}catch(Gt){ds(h,h.return,Gt)}break;case 4:yl(p,h),eu(h);break;case 13:yl(p,h),eu(h),N=h.child,N.flags&8192&&(M=N.memoizedState!==null,N.stateNode.isHidden=M,!M||N.alternate!==null&&N.alternate.memoizedState!==null||(OI=gn())),I&4&&tD(h);break;case 22:if(ut=w!==null&&w.memoizedState!==null,h.mode&1?(so=(je=so)||ut,yl(p,h),so=je):yl(p,h),eu(h),I&8192){if(je=h.memoizedState!==null,(h.stateNode.isHidden=je)&&!ut&&(h.mode&1)!==0)for(Lt=h,ut=h.child;ut!==null;){for(pt=Lt=ut;Lt!==null;){switch(at=Lt,At=at.child,at.tag){case 0:case 11:case 14:case 15:y2(4,at,at.return);break;case 1:sm(at,at.return);var Vt=at.stateNode;if(typeof Vt.componentWillUnmount=="function"){I=at,w=at.return;try{p=I,Vt.props=p.memoizedProps,Vt.state=p.memoizedState,Vt.componentWillUnmount()}catch(Gt){ds(I,w,Gt)}}break;case 5:sm(at,at.return);break;case 22:if(at.memoizedState!==null){iD(pt);continue}}At!==null?(At.return=at,Lt=At):iD(pt)}ut=ut.sibling}e:for(ut=null,pt=h;;){if(pt.tag===5){if(ut===null){ut=pt;try{N=pt.stateNode,je?(M=N.style,typeof M.setProperty=="function"?M.setProperty("display","none","important"):M.display="none"):(pe=pt.stateNode,Se=pt.memoizedProps.style,Z=Se!=null&&Se.hasOwnProperty("display")?Se.display:null,pe.style.display=qr("display",Z))}catch(Gt){ds(h,h.return,Gt)}}}else if(pt.tag===6){if(ut===null)try{pt.stateNode.nodeValue=je?"":pt.memoizedProps}catch(Gt){ds(h,h.return,Gt)}}else if((pt.tag!==22&&pt.tag!==23||pt.memoizedState===null||pt===h)&&pt.child!==null){pt.child.return=pt,pt=pt.child;continue}if(pt===h)break e;for(;pt.sibling===null;){if(pt.return===null||pt.return===h)break e;ut===pt&&(ut=null),pt=pt.return}ut===pt&&(ut=null),pt.sibling.return=pt.return,pt=pt.sibling}}break;case 19:yl(p,h),eu(h),I&4&&tD(h);break;case 21:break;default:yl(p,h),eu(h)}}function eu(h){var p=h.flags;if(p&2){try{e:{for(var w=h.return;w!==null;){if(J6(w)){var I=w;break e}w=w.return}throw Error(n(160))}switch(I.tag){case 5:var N=I.stateNode;I.flags&32&&(fr(N,""),I.flags&=-33);var M=Z6(h);AI(h,M,N);break;case 3:case 4:var Z=I.stateNode.containerInfo,pe=Z6(h);NI(h,pe,Z);break;default:throw Error(n(161))}}catch(Se){ds(h,h.return,Se)}h.flags&=-3}p&4096&&(h.flags&=-4097)}function IY(h,p,w){Lt=h,rD(h)}function rD(h,p,w){for(var I=(h.mode&1)!==0;Lt!==null;){var N=Lt,M=N.child;if(N.tag===22&&I){var Z=N.memoizedState!==null||F3;if(!Z){var pe=N.alternate,Se=pe!==null&&pe.memoizedState!==null||so;pe=F3;var je=so;if(F3=Z,(so=Se)&&!je)for(Lt=N;Lt!==null;)Z=Lt,Se=Z.child,Z.tag===22&&Z.memoizedState!==null?oD(N):Se!==null?(Se.return=Z,Lt=Se):oD(N);for(;M!==null;)Lt=M,rD(M),M=M.sibling;Lt=N,F3=pe,so=je}sD(h)}else(N.subtreeFlags&8772)!==0&&M!==null?(M.return=N,Lt=M):sD(h)}}function sD(h){for(;Lt!==null;){var p=Lt;if((p.flags&8772)!==0){var w=p.alternate;try{if((p.flags&8772)!==0)switch(p.tag){case 0:case 11:case 15:so||L3(5,p);break;case 1:var I=p.stateNode;if(p.flags&4&&!so)if(w===null)I.componentDidMount();else{var N=p.elementType===p.type?w.memoizedProps:ml(p.type,w.memoizedProps);I.componentDidUpdate(N,w.memoizedState,I.__reactInternalSnapshotBeforeUpdate)}var M=p.updateQueue;M!==null&&i6(p,M,I);break;case 3:var Z=p.updateQueue;if(Z!==null){if(w=null,p.child!==null)switch(p.child.tag){case 5:w=p.child.stateNode;break;case 1:w=p.child.stateNode}i6(p,Z,w)}break;case 5:var pe=p.stateNode;if(w===null&&p.flags&4){w=pe;var Se=p.memoizedProps;switch(p.type){case"button":case"input":case"select":case"textarea":Se.autoFocus&&w.focus();break;case"img":Se.src&&(w.src=Se.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(p.memoizedState===null){var je=p.alternate;if(je!==null){var ut=je.memoizedState;if(ut!==null){var pt=ut.dehydrated;pt!==null&&ae(pt)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(n(163))}so||p.flags&512&&kI(p)}catch(at){ds(p,p.return,at)}}if(p===h){Lt=null;break}if(w=p.sibling,w!==null){w.return=p.return,Lt=w;break}Lt=p.return}}function iD(h){for(;Lt!==null;){var p=Lt;if(p===h){Lt=null;break}var w=p.sibling;if(w!==null){w.return=p.return,Lt=w;break}Lt=p.return}}function oD(h){for(;Lt!==null;){var p=Lt;try{switch(p.tag){case 0:case 11:case 15:var w=p.return;try{L3(4,p)}catch(Se){ds(p,w,Se)}break;case 1:var I=p.stateNode;if(typeof I.componentDidMount=="function"){var N=p.return;try{I.componentDidMount()}catch(Se){ds(p,N,Se)}}var M=p.return;try{kI(p)}catch(Se){ds(p,M,Se)}break;case 5:var Z=p.return;try{kI(p)}catch(Se){ds(p,Z,Se)}}}catch(Se){ds(p,p.return,Se)}if(p===h){Lt=null;break}var pe=p.sibling;if(pe!==null){pe.return=p.return,Lt=pe;break}Lt=p.return}}var TY=Math.ceil,M3=S.ReactCurrentDispatcher,RI=S.ReactCurrentOwner,Ga=S.ReactCurrentBatchConfig,ar=0,vi=null,Fs=null,Bi=0,ya=0,im=Dc(0),Js=0,w2=null,ld=0,z3=0,DI=0,v2=null,qo=null,OI=0,om=1/0,Bu=null,V3=!1,PI=null,zc=null,B3=!1,Vc=null,U3=0,b2=0,FI=null,W3=-1,j3=0;function So(){return(ar&6)!==0?gn():W3!==-1?W3:W3=gn()}function Bc(h){return(h.mode&1)===0?1:(ar&2)!==0&&Bi!==0?Bi&-Bi:aY.transition!==null?(j3===0&&(j3=dl()),j3):(h=Sn,h!==0||(h=window.event,h=h===void 0?16:mt(h.type)),h)}function wl(h,p,w,I){if(50<b2)throw b2=0,FI=null,Error(n(185));Mi(h,w,I),((ar&2)===0||h!==vi)&&(h===vi&&((ar&2)===0&&(z3|=w),Js===4&&Uc(h,Bi)),Ko(h,I),w===1&&ar===0&&(p.mode&1)===0&&(om=gn()+500,w3&&Pc()))}function Ko(h,p){var w=h.callbackNode;Vo(h,p);var I=Rs(h,h===vi?Bi:0);if(I===0)w!==null&&Fo(w),h.callbackNode=null,h.callbackPriority=0;else if(p=I&-I,h.callbackPriority!==p){if(w!=null&&Fo(w),p===1)h.tag===0?oY(lD.bind(null,h)):qR(lD.bind(null,h)),nY(function(){(ar&6)===0&&Pc()}),w=null;else{switch(yi(I)){case 1:w=Zi;break;case 4:w=xo;break;case 16:w=pi;break;case 536870912:w=Da;break;default:w=pi}w=gD(w,aD.bind(null,h))}h.callbackPriority=p,h.callbackNode=w}}function aD(h,p){if(W3=-1,j3=0,(ar&6)!==0)throw Error(n(327));var w=h.callbackNode;if(am()&&h.callbackNode!==w)return null;var I=Rs(h,h===vi?Bi:0);if(I===0)return null;if((I&30)!==0||(I&h.expiredLanes)!==0||p)p=G3(h,I);else{p=I;var N=ar;ar|=2;var M=cD();(vi!==h||Bi!==p)&&(Bu=null,om=gn()+500,cd(h,p));do try{CY();break}catch(pe){uD(h,pe)}while(!0);eI(),M3.current=M,ar=N,Fs!==null?p=0:(vi=null,Bi=0,p=Js)}if(p!==0){if(p===2&&(N=hl(h),N!==0&&(I=N,p=LI(h,N))),p===1)throw w=w2,cd(h,0),Uc(h,I),Ko(h,gn()),w;if(p===6)Uc(h,I);else{if(N=h.current.alternate,(I&30)===0&&!SY(N)&&(p=G3(h,I),p===2&&(M=hl(h),M!==0&&(I=M,p=LI(h,M))),p===1))throw w=w2,cd(h,0),Uc(h,I),Ko(h,gn()),w;switch(h.finishedWork=N,h.finishedLanes=I,p){case 0:case 1:throw Error(n(345));case 2:hd(h,qo,Bu);break;case 3:if(Uc(h,I),(I&130023424)===I&&(p=OI+500-gn(),10<p)){if(Rs(h,0)!==0)break;if(N=h.suspendedLanes,(N&I)!==I){So(),h.pingedLanes|=h.suspendedLanes&N;break}h.timeoutHandle=W4(hd.bind(null,h,qo,Bu),p);break}hd(h,qo,Bu);break;case 4:if(Uc(h,I),(I&4194240)===I)break;for(p=h.eventTimes,N=-1;0<I;){var Z=31-hr(I);M=1<<Z,Z=p[Z],Z>N&&(N=Z),I&=~M}if(I=N,I=gn()-I,I=(120>I?120:480>I?480:1080>I?1080:1920>I?1920:3e3>I?3e3:4320>I?4320:1960*TY(I/1960))-I,10<I){h.timeoutHandle=W4(hd.bind(null,h,qo,Bu),I);break}hd(h,qo,Bu);break;case 5:hd(h,qo,Bu);break;default:throw Error(n(329))}}}return Ko(h,gn()),h.callbackNode===w?aD.bind(null,h):null}function LI(h,p){var w=v2;return h.current.memoizedState.isDehydrated&&(cd(h,p).flags|=256),h=G3(h,p),h!==2&&(p=qo,qo=w,p!==null&&MI(p)),h}function MI(h){qo===null?qo=h:qo.push.apply(qo,h)}function SY(h){for(var p=h;;){if(p.flags&16384){var w=p.updateQueue;if(w!==null&&(w=w.stores,w!==null))for(var I=0;I<w.length;I++){var N=w[I],M=N.getSnapshot;N=N.value;try{if(!Wo(M(),N))return!1}catch{return!1}}}if(w=p.child,p.subtreeFlags&16384&&w!==null)w.return=p,p=w;else{if(p===h)break;for(;p.sibling===null;){if(p.return===null||p.return===h)return!0;p=p.return}p.sibling.return=p.return,p=p.sibling}}return!0}function Uc(h,p){for(p&=~DI,p&=~z3,h.suspendedLanes|=p,h.pingedLanes&=~p,h=h.expirationTimes;0<p;){var w=31-hr(p),I=1<<w;h[w]=-1,p&=~I}}function lD(h){if((ar&6)!==0)throw Error(n(327));am();var p=Rs(h,0);if((p&1)===0)return Ko(h,gn()),null;var w=G3(h,p);if(h.tag!==0&&w===2){var I=hl(h);I!==0&&(p=I,w=LI(h,I))}if(w===1)throw w=w2,cd(h,0),Uc(h,p),Ko(h,gn()),w;if(w===6)throw Error(n(345));return h.finishedWork=h.current.alternate,h.finishedLanes=p,hd(h,qo,Bu),Ko(h,gn()),null}function zI(h,p){var w=ar;ar|=1;try{return h(p)}finally{ar=w,ar===0&&(om=gn()+500,w3&&Pc())}}function ud(h){Vc!==null&&Vc.tag===0&&(ar&6)===0&&am();var p=ar;ar|=1;var w=Ga.transition,I=Sn;try{if(Ga.transition=null,Sn=1,h)return h()}finally{Sn=I,Ga.transition=w,ar=p,(ar&6)===0&&Pc()}}function VI(){ya=im.current,zr(im)}function cd(h,p){h.finishedWork=null,h.finishedLanes=0;var w=h.timeoutHandle;if(w!==-1&&(h.timeoutHandle=-1,tY(w)),Fs!==null)for(w=Fs.return;w!==null;){var I=w;switch(X4(I),I.tag){case 1:I=I.type.childContextTypes,I!=null&&g3();break;case 3:nm(),zr(jo),zr(to),lI();break;case 5:oI(I);break;case 4:nm();break;case 13:zr(ss);break;case 19:zr(ss);break;case 10:tI(I.type._context);break;case 22:case 23:VI()}w=w.return}if(vi=h,Fs=h=Wc(h.current,null),Bi=ya=p,Js=0,w2=null,DI=z3=ld=0,qo=v2=null,id!==null){for(p=0;p<id.length;p++)if(w=id[p],I=w.interleaved,I!==null){w.interleaved=null;var N=I.next,M=w.pending;if(M!==null){var Z=M.next;M.next=N,I.next=Z}w.pending=I}id=null}return h}function uD(h,p){do{var w=Fs;try{if(eI(),E3.current=R3,k3){for(var I=is.memoizedState;I!==null;){var N=I.queue;N!==null&&(N.pending=null),I=I.next}k3=!1}if(ad=0,wi=Qs=is=null,d2=!1,f2=0,RI.current=null,w===null||w.return===null){Js=1,w2=p,Fs=null;break}e:{var M=h,Z=w.return,pe=w,Se=p;if(p=Bi,pe.flags|=32768,Se!==null&&typeof Se=="object"&&typeof Se.then=="function"){var je=Se,ut=pe,pt=ut.tag;if((ut.mode&1)===0&&(pt===0||pt===11||pt===15)){var at=ut.alternate;at?(ut.updateQueue=at.updateQueue,ut.memoizedState=at.memoizedState,ut.lanes=at.lanes):(ut.updateQueue=null,ut.memoizedState=null)}var At=O6(Z);if(At!==null){At.flags&=-257,P6(At,Z,pe,M,p),At.mode&1&&D6(M,je,p),p=At,Se=je;var Vt=p.updateQueue;if(Vt===null){var Gt=new Set;Gt.add(Se),p.updateQueue=Gt}else Vt.add(Se);break e}else{if((p&1)===0){D6(M,je,p),BI();break e}Se=Error(n(426))}}else if(Yr&&pe.mode&1){var _s=O6(Z);if(_s!==null){(_s.flags&65536)===0&&(_s.flags|=256),P6(_s,Z,pe,M,p),J4(rm(Se,pe));break e}}M=Se=rm(Se,pe),Js!==4&&(Js=2),v2===null?v2=[M]:v2.push(M),M=Z;do{switch(M.tag){case 3:M.flags|=65536,p&=-p,M.lanes|=p;var Le=A6(M,Se,p);s6(M,Le);break e;case 1:pe=Se;var Ce=M.type,ze=M.stateNode;if((M.flags&128)===0&&(typeof Ce.getDerivedStateFromError=="function"||ze!==null&&typeof ze.componentDidCatch=="function"&&(zc===null||!zc.has(ze)))){M.flags|=65536,p&=-p,M.lanes|=p;var wt=R6(M,pe,p);s6(M,wt);break e}}M=M.return}while(M!==null)}dD(w)}catch(Kt){p=Kt,Fs===w&&w!==null&&(Fs=w=w.return);continue}break}while(!0)}function cD(){var h=M3.current;return M3.current=R3,h===null?R3:h}function BI(){(Js===0||Js===3||Js===2)&&(Js=4),vi===null||(ld&268435455)===0&&(z3&268435455)===0||Uc(vi,Bi)}function G3(h,p){var w=ar;ar|=2;var I=cD();(vi!==h||Bi!==p)&&(Bu=null,cd(h,p));do try{$Y();break}catch(N){uD(h,N)}while(!0);if(eI(),ar=w,M3.current=I,Fs!==null)throw Error(n(261));return vi=null,Bi=0,Js}function $Y(){for(;Fs!==null;)hD(Fs)}function CY(){for(;Fs!==null&&!Xr();)hD(Fs)}function hD(h){var p=mD(h.alternate,h,ya);h.memoizedProps=h.pendingProps,p===null?dD(h):Fs=p,RI.current=null}function dD(h){var p=h;do{var w=p.alternate;if(h=p.return,(p.flags&32768)===0){if(w=vY(w,p,ya),w!==null){Fs=w;return}}else{if(w=bY(w,p),w!==null){w.flags&=32767,Fs=w;return}if(h!==null)h.flags|=32768,h.subtreeFlags=0,h.deletions=null;else{Js=6,Fs=null;return}}if(p=p.sibling,p!==null){Fs=p;return}Fs=p=h}while(p!==null);Js===0&&(Js=5)}function hd(h,p,w){var I=Sn,N=Ga.transition;try{Ga.transition=null,Sn=1,EY(h,p,w,I)}finally{Ga.transition=N,Sn=I}return null}function EY(h,p,w,I){do am();while(Vc!==null);if((ar&6)!==0)throw Error(n(327));w=h.finishedWork;var N=h.finishedLanes;if(w===null)return null;if(h.finishedWork=null,h.finishedLanes=0,w===h.current)throw Error(n(177));h.callbackNode=null,h.callbackPriority=0;var M=w.lanes|w.childLanes;if(Bo(h,M),h===vi&&(Fs=vi=null,Bi=0),(w.subtreeFlags&2064)===0&&(w.flags&2064)===0||B3||(B3=!0,gD(pi,function(){return am(),null})),M=(w.flags&15990)!==0,(w.subtreeFlags&15990)!==0||M){M=Ga.transition,Ga.transition=null;var Z=Sn;Sn=1;var pe=ar;ar|=4,RI.current=null,_Y(h,w),nD(w,h),H(B4),he=!!V4,B4=V4=null,h.current=w,IY(w),fi(),ar=pe,Sn=Z,Ga.transition=M}else h.current=w;if(B3&&(B3=!1,Vc=h,U3=N),M=h.pendingLanes,M===0&&(zc=null),mi(w.stateNode),Ko(h,gn()),p!==null)for(I=h.onRecoverableError,w=0;w<p.length;w++)N=p[w],I(N.value,{componentStack:N.stack,digest:N.digest});if(V3)throw V3=!1,h=PI,PI=null,h;return(U3&1)!==0&&h.tag!==0&&am(),M=h.pendingLanes,(M&1)!==0?h===FI?b2++:(b2=0,FI=h):b2=0,Pc(),null}function am(){if(Vc!==null){var h=yi(U3),p=Ga.transition,w=Sn;try{if(Ga.transition=null,Sn=16>h?16:h,Vc===null)var I=!1;else{if(h=Vc,Vc=null,U3=0,(ar&6)!==0)throw Error(n(331));var N=ar;for(ar|=4,Lt=h.current;Lt!==null;){var M=Lt,Z=M.child;if((Lt.flags&16)!==0){var pe=M.deletions;if(pe!==null){for(var Se=0;Se<pe.length;Se++){var je=pe[Se];for(Lt=je;Lt!==null;){var ut=Lt;switch(ut.tag){case 0:case 11:case 15:y2(8,ut,M)}var pt=ut.child;if(pt!==null)pt.return=ut,Lt=pt;else for(;Lt!==null;){ut=Lt;var at=ut.sibling,At=ut.return;if(Q6(ut),ut===je){Lt=null;break}if(at!==null){at.return=At,Lt=at;break}Lt=At}}}var Vt=M.alternate;if(Vt!==null){var Gt=Vt.child;if(Gt!==null){Vt.child=null;do{var _s=Gt.sibling;Gt.sibling=null,Gt=_s}while(Gt!==null)}}Lt=M}}if((M.subtreeFlags&2064)!==0&&Z!==null)Z.return=M,Lt=Z;else e:for(;Lt!==null;){if(M=Lt,(M.flags&2048)!==0)switch(M.tag){case 0:case 11:case 15:y2(9,M,M.return)}var Le=M.sibling;if(Le!==null){Le.return=M.return,Lt=Le;break e}Lt=M.return}}var Ce=h.current;for(Lt=Ce;Lt!==null;){Z=Lt;var ze=Z.child;if((Z.subtreeFlags&2064)!==0&&ze!==null)ze.return=Z,Lt=ze;else e:for(Z=Ce;Lt!==null;){if(pe=Lt,(pe.flags&2048)!==0)try{switch(pe.tag){case 0:case 11:case 15:L3(9,pe)}}catch(Kt){ds(pe,pe.return,Kt)}if(pe===Z){Lt=null;break e}var wt=pe.sibling;if(wt!==null){wt.return=pe.return,Lt=wt;break e}Lt=pe.return}}if(ar=N,Pc(),As&&typeof As.onPostCommitFiberRoot=="function")try{As.onPostCommitFiberRoot(ha,h)}catch{}I=!0}return I}finally{Sn=w,Ga.transition=p}}return!1}function fD(h,p,w){p=rm(w,p),p=A6(h,p,1),h=Lc(h,p,1),p=So(),h!==null&&(Mi(h,1,p),Ko(h,p))}function ds(h,p,w){if(h.tag===3)fD(h,h,w);else for(;p!==null;){if(p.tag===3){fD(p,h,w);break}else if(p.tag===1){var I=p.stateNode;if(typeof p.type.getDerivedStateFromError=="function"||typeof I.componentDidCatch=="function"&&(zc===null||!zc.has(I))){h=rm(w,h),h=R6(p,h,1),p=Lc(p,h,1),h=So(),p!==null&&(Mi(p,1,h),Ko(p,h));break}}p=p.return}}function kY(h,p,w){var I=h.pingCache;I!==null&&I.delete(p),p=So(),h.pingedLanes|=h.suspendedLanes&w,vi===h&&(Bi&w)===w&&(Js===4||Js===3&&(Bi&130023424)===Bi&&500>gn()-OI?cd(h,0):DI|=w),Ko(h,p)}function pD(h,p){p===0&&((h.mode&1)===0?p=1:(p=Mo,Mo<<=1,(Mo&130023424)===0&&(Mo=4194304)));var w=So();h=Mu(h,p),h!==null&&(Mi(h,p,w),Ko(h,w))}function NY(h){var p=h.memoizedState,w=0;p!==null&&(w=p.retryLane),pD(h,w)}function AY(h,p){var w=0;switch(h.tag){case 13:var I=h.stateNode,N=h.memoizedState;N!==null&&(w=N.retryLane);break;case 19:I=h.stateNode;break;default:throw Error(n(314))}I!==null&&I.delete(p),pD(h,w)}var mD;mD=function(h,p,w){if(h!==null)if(h.memoizedProps!==p.pendingProps||jo.current)Ho=!0;else{if((h.lanes&w)===0&&(p.flags&128)===0)return Ho=!1,wY(h,p,w);Ho=(h.flags&131072)!==0}else Ho=!1,Yr&&(p.flags&1048576)!==0&&KR(p,b3,p.index);switch(p.lanes=0,p.tag){case 2:var I=p.type;P3(h,p),h=p.pendingProps;var N=Xp(p,to.current);tm(p,w),N=hI(null,p,I,h,N,w);var M=dI();return p.flags|=1,typeof N=="object"&&N!==null&&typeof N.render=="function"&&N.$$typeof===void 0?(p.tag=1,p.memoizedState=null,p.updateQueue=null,Go(I)?(M=!0,y3(p)):M=!1,p.memoizedState=N.state!==null&&N.state!==void 0?N.state:null,sI(p),N.updater=D3,p.stateNode=N,N._reactInternals=p,wI(p,I,h,w),p=_I(null,p,I,!0,M,w)):(p.tag=0,Yr&&M&&K4(p),To(null,p,N,w),p=p.child),p;case 16:I=p.elementType;e:{switch(P3(h,p),h=p.pendingProps,N=I._init,I=N(I._payload),p.type=I,N=p.tag=DY(I),h=ml(I,h),N){case 0:p=xI(null,p,I,h,w);break e;case 1:p=B6(null,p,I,h,w);break e;case 11:p=F6(null,p,I,h,w);break e;case 14:p=L6(null,p,I,ml(I.type,h),w);break e}throw Error(n(306,I,""))}return p;case 0:return I=p.type,N=p.pendingProps,N=p.elementType===I?N:ml(I,N),xI(h,p,I,N,w);case 1:return I=p.type,N=p.pendingProps,N=p.elementType===I?N:ml(I,N),B6(h,p,I,N,w);case 3:e:{if(U6(p),h===null)throw Error(n(387));I=p.pendingProps,M=p.memoizedState,N=M.element,r6(h,p),$3(p,I,null,w);var Z=p.memoizedState;if(I=Z.element,M.isDehydrated)if(M={element:I,isDehydrated:!1,cache:Z.cache,pendingSuspenseBoundaries:Z.pendingSuspenseBoundaries,transitions:Z.transitions},p.updateQueue.baseState=M,p.memoizedState=M,p.flags&256){N=rm(Error(n(423)),p),p=W6(h,p,I,w,N);break e}else if(I!==N){N=rm(Error(n(424)),p),p=W6(h,p,I,w,N);break e}else for(ga=Rc(p.stateNode.containerInfo.firstChild),ma=p,Yr=!0,pl=null,w=t6(p,null,I,w),p.child=w;w;)w.flags=w.flags&-3|4096,w=w.sibling;else{if(Jp(),I===N){p=Vu(h,p,w);break e}To(h,p,I,w)}p=p.child}return p;case 5:return o6(p),h===null&&Q4(p),I=p.type,N=p.pendingProps,M=h!==null?h.memoizedProps:null,Z=N.children,U4(I,N)?Z=null:M!==null&&U4(I,M)&&(p.flags|=32),V6(h,p),To(h,p,Z,w),p.child;case 6:return h===null&&Q4(p),null;case 13:return j6(h,p,w);case 4:return iI(p,p.stateNode.containerInfo),I=p.pendingProps,h===null?p.child=Zp(p,null,I,w):To(h,p,I,w),p.child;case 11:return I=p.type,N=p.pendingProps,N=p.elementType===I?N:ml(I,N),F6(h,p,I,N,w);case 7:return To(h,p,p.pendingProps,w),p.child;case 8:return To(h,p,p.pendingProps.children,w),p.child;case 12:return To(h,p,p.pendingProps.children,w),p.child;case 10:e:{if(I=p.type._context,N=p.pendingProps,M=p.memoizedProps,Z=N.value,Dr(I3,I._currentValue),I._currentValue=Z,M!==null)if(Wo(M.value,Z)){if(M.children===N.children&&!jo.current){p=Vu(h,p,w);break e}}else for(M=p.child,M!==null&&(M.return=p);M!==null;){var pe=M.dependencies;if(pe!==null){Z=M.child;for(var Se=pe.firstContext;Se!==null;){if(Se.context===I){if(M.tag===1){Se=zu(-1,w&-w),Se.tag=2;var je=M.updateQueue;if(je!==null){je=je.shared;var ut=je.pending;ut===null?Se.next=Se:(Se.next=ut.next,ut.next=Se),je.pending=Se}}M.lanes|=w,Se=M.alternate,Se!==null&&(Se.lanes|=w),nI(M.return,w,p),pe.lanes|=w;break}Se=Se.next}}else if(M.tag===10)Z=M.type===p.type?null:M.child;else if(M.tag===18){if(Z=M.return,Z===null)throw Error(n(341));Z.lanes|=w,pe=Z.alternate,pe!==null&&(pe.lanes|=w),nI(Z,w,p),Z=M.sibling}else Z=M.child;if(Z!==null)Z.return=M;else for(Z=M;Z!==null;){if(Z===p){Z=null;break}if(M=Z.sibling,M!==null){M.return=Z.return,Z=M;break}Z=Z.return}M=Z}To(h,p,N.children,w),p=p.child}return p;case 9:return N=p.type,I=p.pendingProps.children,tm(p,w),N=Wa(N),I=I(N),p.flags|=1,To(h,p,I,w),p.child;case 14:return I=p.type,N=ml(I,p.pendingProps),N=ml(I.type,N),L6(h,p,I,N,w);case 15:return M6(h,p,p.type,p.pendingProps,w);case 17:return I=p.type,N=p.pendingProps,N=p.elementType===I?N:ml(I,N),P3(h,p),p.tag=1,Go(I)?(h=!0,y3(p)):h=!1,tm(p,w),k6(p,I,N),wI(p,I,N,w),_I(null,p,I,!0,h,w);case 19:return H6(h,p,w);case 22:return z6(h,p,w)}throw Error(n(156,p.tag))};function gD(h,p){return cl(h,p)}function RY(h,p,w,I){this.tag=h,this.key=w,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=p,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=I,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ha(h,p,w,I){return new RY(h,p,w,I)}function UI(h){return h=h.prototype,!(!h||!h.isReactComponent)}function DY(h){if(typeof h=="function")return UI(h)?1:0;if(h!=null){if(h=h.$$typeof,h===K)return 11;if(h===fe)return 14}return 2}function Wc(h,p){var w=h.alternate;return w===null?(w=Ha(h.tag,p,h.key,h.mode),w.elementType=h.elementType,w.type=h.type,w.stateNode=h.stateNode,w.alternate=h,h.alternate=w):(w.pendingProps=p,w.type=h.type,w.flags=0,w.subtreeFlags=0,w.deletions=null),w.flags=h.flags&14680064,w.childLanes=h.childLanes,w.lanes=h.lanes,w.child=h.child,w.memoizedProps=h.memoizedProps,w.memoizedState=h.memoizedState,w.updateQueue=h.updateQueue,p=h.dependencies,w.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext},w.sibling=h.sibling,w.index=h.index,w.ref=h.ref,w}function H3(h,p,w,I,N,M){var Z=2;if(I=h,typeof h=="function")UI(h)&&(Z=1);else if(typeof h=="string")Z=5;else e:switch(h){case R:return dd(w.children,N,M,p);case D:Z=8,N|=8;break;case A:return h=Ha(12,w,p,N|2),h.elementType=A,h.lanes=M,h;case j:return h=Ha(13,w,p,N),h.elementType=j,h.lanes=M,h;case se:return h=Ha(19,w,p,N),h.elementType=se,h.lanes=M,h;case ye:return q3(w,N,M,p);default:if(typeof h=="object"&&h!==null)switch(h.$$typeof){case F:Z=10;break e;case P:Z=9;break e;case K:Z=11;break e;case fe:Z=14;break e;case me:Z=16,I=null;break e}throw Error(n(130,h==null?h:typeof h,""))}return p=Ha(Z,w,p,N),p.elementType=h,p.type=I,p.lanes=M,p}function dd(h,p,w,I){return h=Ha(7,h,I,p),h.lanes=w,h}function q3(h,p,w,I){return h=Ha(22,h,I,p),h.elementType=ye,h.lanes=w,h.stateNode={isHidden:!1},h}function WI(h,p,w){return h=Ha(6,h,null,p),h.lanes=w,h}function jI(h,p,w){return p=Ha(4,h.children!==null?h.children:[],h.key,p),p.lanes=w,p.stateNode={containerInfo:h.containerInfo,pendingChildren:null,implementation:h.implementation},p}function OY(h,p,w,I,N){this.tag=p,this.containerInfo=h,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=_o(0),this.expirationTimes=_o(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=_o(0),this.identifierPrefix=I,this.onRecoverableError=N,this.mutableSourceEagerHydrationData=null}function GI(h,p,w,I,N,M,Z,pe,Se){return h=new OY(h,p,w,pe,Se),p===1?(p=1,M===!0&&(p|=8)):p=0,M=Ha(3,null,null,p),h.current=M,M.stateNode=h,M.memoizedState={element:I,isDehydrated:w,cache:null,transitions:null,pendingSuspenseBoundaries:null},sI(M),h}function PY(h,p,w){var I=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:L,key:I==null?null:""+I,children:h,containerInfo:p,implementation:w}}function yD(h){if(!h)return Oc;h=h._reactInternals;e:{if(qs(h)!==h||h.tag!==1)throw Error(n(170));var p=h;do{switch(p.tag){case 3:p=p.stateNode.context;break e;case 1:if(Go(p.type)){p=p.stateNode.__reactInternalMemoizedMergedChildContext;break e}}p=p.return}while(p!==null);throw Error(n(171))}if(h.tag===1){var w=h.type;if(Go(w))return GR(h,w,p)}return p}function wD(h,p,w,I,N,M,Z,pe,Se){return h=GI(w,I,!0,h,N,M,Z,pe,Se),h.context=yD(null),w=h.current,I=So(),N=Bc(w),M=zu(I,N),M.callback=p??null,Lc(w,M,N),h.current.lanes=N,Mi(h,N,I),Ko(h,I),h}function K3(h,p,w,I){var N=p.current,M=So(),Z=Bc(N);return w=yD(w),p.context===null?p.context=w:p.pendingContext=w,p=zu(M,Z),p.payload={element:h},I=I===void 0?null:I,I!==null&&(p.callback=I),h=Lc(N,p,Z),h!==null&&(wl(h,N,Z,M),S3(h,N,Z)),Z}function X3(h){if(h=h.current,!h.child)return null;switch(h.child.tag){case 5:return h.child.stateNode;default:return h.child.stateNode}}function vD(h,p){if(h=h.memoizedState,h!==null&&h.dehydrated!==null){var w=h.retryLane;h.retryLane=w!==0&&w<p?w:p}}function HI(h,p){vD(h,p),(h=h.alternate)&&vD(h,p)}function FY(){return null}var bD=typeof reportError=="function"?reportError:function(h){console.error(h)};function qI(h){this._internalRoot=h}Y3.prototype.render=qI.prototype.render=function(h){var p=this._internalRoot;if(p===null)throw Error(n(409));K3(h,p,null,null)},Y3.prototype.unmount=qI.prototype.unmount=function(){var h=this._internalRoot;if(h!==null){this._internalRoot=null;var p=h.containerInfo;ud(function(){K3(null,h,null,null)}),p[Ou]=null}};function Y3(h){this._internalRoot=h}Y3.prototype.unstable_scheduleHydration=function(h){if(h){var p=O();h={blockedOn:null,target:h,priority:p};for(var w=0;w<bt.length&&p!==0&&p<bt[w].priority;w++);bt.splice(w,0,h),w===0&&kt(h)}};function KI(h){return!(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)}function Q3(h){return!(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11&&(h.nodeType!==8||h.nodeValue!==" react-mount-point-unstable "))}function xD(){}function LY(h,p,w,I,N){if(N){if(typeof I=="function"){var M=I;I=function(){var je=X3(Z);M.call(je)}}var Z=wD(p,I,h,0,null,!1,!1,"",xD);return h._reactRootContainer=Z,h[Ou]=Z.current,s2(h.nodeType===8?h.parentNode:h),ud(),Z}for(;N=h.lastChild;)h.removeChild(N);if(typeof I=="function"){var pe=I;I=function(){var je=X3(Se);pe.call(je)}}var Se=GI(h,0,!1,null,null,!1,!1,"",xD);return h._reactRootContainer=Se,h[Ou]=Se.current,s2(h.nodeType===8?h.parentNode:h),ud(function(){K3(p,Se,w,I)}),Se}function J3(h,p,w,I,N){var M=w._reactRootContainer;if(M){var Z=M;if(typeof N=="function"){var pe=N;N=function(){var Se=X3(Z);pe.call(Se)}}K3(p,Z,h,N)}else Z=LY(w,p,h,N,I);return X3(Z)}fa=function(h){switch(h.tag){case 3:var p=h.stateNode;if(p.current.memoizedState.isDehydrated){var w=Hn(p.pendingLanes);w!==0&&(da(p,w|1),Ko(p,gn()),(ar&6)===0&&(om=gn()+500,Pc()))}break;case 13:ud(function(){var I=Mu(h,1);if(I!==null){var N=So();wl(I,h,1,N)}}),HI(h,1)}},pa=function(h){if(h.tag===13){var p=Mu(h,134217728);if(p!==null){var w=So();wl(p,h,134217728,w)}HI(h,134217728)}},Oa=function(h){if(h.tag===13){var p=Bc(h),w=Mu(h,p);if(w!==null){var I=So();wl(w,h,p,I)}HI(h,p)}},O=function(){return Sn},U=function(h,p){var w=Sn;try{return Sn=h,p()}finally{Sn=w}},Cs=function(h,p,w){switch(p){case"input":if(Ht(h,w),p=w.name,w.type==="radio"&&p!=null){for(w=h;w.parentNode;)w=w.parentNode;for(w=w.querySelectorAll("input[name="+JSON.stringify(""+p)+'][type="radio"]'),p=0;p<w.length;p++){var I=w[p];if(I!==h&&I.form===h.form){var N=m3(I);if(!N)throw Error(n(90));ct(I),Ht(I,N)}}}break;case"textarea":Fn(h,w);break;case"select":p=w.value,p!=null&&Yt(h,!!w.multiple,p,!1)}},Po=zI,bo=ud;var MY={usingClientEntryPoint:!1,Events:[a2,qp,m3,hn,Qi,zI]},x2={findFiberByHostInstance:td,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},zY={bundleType:x2.bundleType,version:x2.version,rendererPackageName:x2.rendererPackageName,rendererConfig:x2.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:S.ReactCurrentDispatcher,findHostInstanceByFiber:function(h){return h=ca(h),h===null?null:h.stateNode},findFiberByHostInstance:x2.findFiberByHostInstance||FY,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Z3=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Z3.isDisabled&&Z3.supportsFiber)try{ha=Z3.inject(zY),As=Z3}catch{}}return Xo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=MY,Xo.createPortal=function(h,p){var w=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!KI(p))throw Error(n(200));return PY(h,p,null,w)},Xo.createRoot=function(h,p){if(!KI(h))throw Error(n(299));var w=!1,I="",N=bD;return p!=null&&(p.unstable_strictMode===!0&&(w=!0),p.identifierPrefix!==void 0&&(I=p.identifierPrefix),p.onRecoverableError!==void 0&&(N=p.onRecoverableError)),p=GI(h,1,!1,null,null,w,!1,I,N),h[Ou]=p.current,s2(h.nodeType===8?h.parentNode:h),new qI(p)},Xo.findDOMNode=function(h){if(h==null)return null;if(h.nodeType===1)return h;var p=h._reactInternals;if(p===void 0)throw typeof h.render=="function"?Error(n(188)):(h=Object.keys(h).join(","),Error(n(268,h)));return h=ca(p),h=h===null?null:h.stateNode,h},Xo.flushSync=function(h){return ud(h)},Xo.hydrate=function(h,p,w){if(!Q3(p))throw Error(n(200));return J3(null,h,p,!0,w)},Xo.hydrateRoot=function(h,p,w){if(!KI(h))throw Error(n(405));var I=w!=null&&w.hydratedSources||null,N=!1,M="",Z=bD;if(w!=null&&(w.unstable_strictMode===!0&&(N=!0),w.identifierPrefix!==void 0&&(M=w.identifierPrefix),w.onRecoverableError!==void 0&&(Z=w.onRecoverableError)),p=wD(p,null,h,1,w??null,N,!1,M,Z),h[Ou]=p.current,s2(h),I)for(h=0;h<I.length;h++)w=I[h],N=w._getVersion,N=N(w._source),p.mutableSourceEagerHydrationData==null?p.mutableSourceEagerHydrationData=[w,N]:p.mutableSourceEagerHydrationData.push(w,N);return new Y3(p)},Xo.render=function(h,p,w){if(!Q3(p))throw Error(n(200));return J3(null,h,p,!1,w)},Xo.unmountComponentAtNode=function(h){if(!Q3(h))throw Error(n(40));return h._reactRootContainer?(ud(function(){J3(null,null,h,!1,function(){h._reactRootContainer=null,h[Ou]=null})}),!0):!1},Xo.unstable_batchedUpdates=zI,Xo.unstable_renderSubtreeIntoContainer=function(h,p,w,I){if(!Q3(w))throw Error(n(200));if(h==null||h._reactInternals===void 0)throw Error(n(38));return J3(h,p,w,!1,I)},Xo.version="18.3.1-next-f1338f8080-20240426",Xo}var ND;function KY(){if(ND)return QI.exports;ND=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}return t(),QI.exports=qY(),QI.exports}var AD;function XY(){if(AD)return ev;AD=1;var t=KY();return ev.createRoot=t.createRoot,ev.hydrateRoot=t.hydrateRoot,ev}var YY=XY();const QY=()=>{};var RD={};const jF=function(t){const e=[];let n=0;for(let r=0;r<t.length;r++){let s=t.charCodeAt(r);s<128?e[n++]=s:s<2048?(e[n++]=s>>6|192,e[n++]=s&63|128):(s&64512)===55296&&r+1<t.length&&(t.charCodeAt(r+1)&64512)===56320?(s=65536+((s&1023)<<10)+(t.charCodeAt(++r)&1023),e[n++]=s>>18|240,e[n++]=s>>12&63|128,e[n++]=s>>6&63|128,e[n++]=s&63|128):(e[n++]=s>>12|224,e[n++]=s>>6&63|128,e[n++]=s&63|128)}return e},JY=function(t){const e=[];let n=0,r=0;for(;n<t.length;){const s=t[n++];if(s<128)e[r++]=String.fromCharCode(s);else if(s>191&&s<224){const i=t[n++];e[r++]=String.fromCharCode((s&31)<<6|i&63)}else if(s>239&&s<365){const i=t[n++],o=t[n++],a=t[n++],l=((s&7)<<18|(i&63)<<12|(o&63)<<6|a&63)-65536;e[r++]=String.fromCharCode(55296+(l>>10)),e[r++]=String.fromCharCode(56320+(l&1023))}else{const i=t[n++],o=t[n++];e[r++]=String.fromCharCode((s&15)<<12|(i&63)<<6|o&63)}}return e.join("")},GF={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:typeof atob=="function",encodeByteArray(t,e){if(!Array.isArray(t))throw Error("encodeByteArray takes an array as a parameter");this.init_();const n=e?this.byteToCharMapWebSafe_:this.byteToCharMap_,r=[];for(let s=0;s<t.length;s+=3){const i=t[s],o=s+1<t.length,a=o?t[s+1]:0,l=s+2<t.length,u=l?t[s+2]:0,c=i>>2,d=(i&3)<<4|a>>4;let f=(a&15)<<2|u>>6,m=u&63;l||(m=64,o||(f=64)),r.push(n[c],n[d],n[f],n[m])}return r.join("")},encodeString(t,e){return this.HAS_NATIVE_SUPPORT&&!e?btoa(t):this.encodeByteArray(jF(t),e)},decodeString(t,e){return this.HAS_NATIVE_SUPPORT&&!e?atob(t):JY(this.decodeStringToByteArray(t,e))},decodeStringToByteArray(t,e){this.init_();const n=e?this.charToByteMapWebSafe_:this.charToByteMap_,r=[];for(let s=0;s<t.length;){const i=n[t.charAt(s++)],a=s<t.length?n[t.charAt(s)]:0;++s;const u=s<t.length?n[t.charAt(s)]:64;++s;const d=s<t.length?n[t.charAt(s)]:64;if(++s,i==null||a==null||u==null||d==null)throw new ZY;const f=i<<2|a>>4;if(r.push(f),u!==64){const m=a<<4&240|u>>2;if(r.push(m),d!==64){const g=u<<6&192|d;r.push(g)}}}return r},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let t=0;t<this.ENCODED_VALS.length;t++)this.byteToCharMap_[t]=this.ENCODED_VALS.charAt(t),this.charToByteMap_[this.byteToCharMap_[t]]=t,this.byteToCharMapWebSafe_[t]=this.ENCODED_VALS_WEBSAFE.charAt(t),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]]=t,t>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)]=t,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)]=t)}}};class ZY extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const eQ=function(t){const e=jF(t);return GF.encodeByteArray(e,!0)},cb=function(t){return eQ(t).replace(/\./g,"")},HF=function(t){try{return GF.decodeString(t,!0)}catch(e){console.error("base64Decode failed: ",e)}return null};function tQ(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("Unable to locate global object.")}const nQ=()=>tQ().__FIREBASE_DEFAULTS__,rQ=()=>{if(typeof process>"u"||typeof RD>"u")return;const t=RD.__FIREBASE_DEFAULTS__;if(t)return JSON.parse(t)},sQ=()=>{if(typeof document>"u")return;let t;try{t=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch{return}const e=t&&HF(t[1]);return e&&JSON.parse(e)},dx=()=>{try{return QY()||nQ()||rQ()||sQ()}catch(t){console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);return}},qF=t=>dx()?.emulatorHosts?.[t],iQ=t=>{const e=qF(t);if(!e)return;const n=e.lastIndexOf(":");if(n<=0||n+1===e.length)throw new Error(`Invalid host ${e} with no separate hostname and port!`);const r=parseInt(e.substring(n+1),10);return e[0]==="["?[e.substring(1,n-1),r]:[e.substring(0,n),r]},KF=()=>dx()?.config,XF=t=>dx()?.[`_${t}`];class oQ{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise((e,n)=>{this.resolve=e,this.reject=n})}wrapCallback(e){return(n,r)=>{n?this.reject(n):this.resolve(r),typeof e=="function"&&(this.promise.catch(()=>{}),e.length===1?e(n):e(n,r))}}}function Zm(t){try{return(t.startsWith("http://")||t.startsWith("https://")?new URL(t).hostname:t).endsWith(".cloudworkstations.dev")}catch{return!1}}async function YF(t){return(await fetch(t,{credentials:"include"})).ok}function aQ(t,e){if(t.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const n={alg:"none",type:"JWT"},r=e||"demo-project",s=t.iat||0,i=t.sub||t.user_id;if(!i)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const o={iss:`https://securetoken.google.com/${r}`,aud:r,iat:s,exp:s+3600,auth_time:s,sub:i,user_id:i,firebase:{sign_in_provider:"custom",identities:{}},...t};return[cb(JSON.stringify(n)),cb(JSON.stringify(o)),""].join(".")}const oy={};function lQ(){const t={prod:[],emulator:[]};for(const e of Object.keys(oy))oy[e]?t.emulator.push(e):t.prod.push(e);return t}function uQ(t){let e=document.getElementById(t),n=!1;return e||(e=document.createElement("div"),e.setAttribute("id",t),n=!0),{created:n,element:e}}let DD=!1;function QF(t,e){if(typeof window>"u"||typeof document>"u"||!Zm(window.location.host)||oy[t]===e||oy[t]||DD)return;oy[t]=e;function n(f){return`__firebase__banner__${f}`}const r="__firebase__banner",i=lQ().prod.length>0;function o(){const f=document.getElementById(r);f&&f.remove()}function a(f){f.style.display="flex",f.style.background="#7faaf0",f.style.position="fixed",f.style.bottom="5px",f.style.left="5px",f.style.padding=".5em",f.style.borderRadius="5px",f.style.alignItems="center"}function l(f,m){f.setAttribute("width","24"),f.setAttribute("id",m),f.setAttribute("height","24"),f.setAttribute("viewBox","0 0 24 24"),f.setAttribute("fill","none"),f.style.marginLeft="-6px"}function u(){const f=document.createElement("span");return f.style.cursor="pointer",f.style.marginLeft="16px",f.style.fontSize="24px",f.innerHTML=" &times;",f.onclick=()=>{DD=!0,o()},f}function c(f,m){f.setAttribute("id",m),f.innerText="Learn more",f.href="https://firebase.google.com/docs/studio/preview-apps#preview-backend",f.setAttribute("target","__blank"),f.style.paddingLeft="5px",f.style.textDecoration="underline"}function d(){const f=uQ(r),m=n("text"),g=document.getElementById(m)||document.createElement("span"),y=n("learnmore"),v=document.getElementById(y)||document.createElement("a"),b=n("preprendIcon"),x=document.getElementById(b)||document.createElementNS("http://www.w3.org/2000/svg","svg");if(f.created){const $=f.element;a($),c(v,y);const S=u();l(x,b),$.append(x,g,v,S),document.body.appendChild($)}i?(g.innerText="Preview backend disconnected.",x.innerHTML=`<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`):(x.innerHTML=`<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`,g.innerText="Preview backend running in this workspace."),g.setAttribute("id",m)}document.readyState==="loading"?window.addEventListener("DOMContentLoaded",d):d()}function mo(){return typeof navigator<"u"&&typeof navigator.userAgent=="string"?navigator.userAgent:""}function cQ(){return typeof window<"u"&&!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(mo())}function hQ(){const t=dx()?.forceEnvironment;if(t==="node")return!0;if(t==="browser")return!1;try{return Object.prototype.toString.call(global.process)==="[object process]"}catch{return!1}}function dQ(){return typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"}function fQ(){const t=typeof chrome=="object"?chrome.runtime:typeof browser=="object"?browser.runtime:void 0;return typeof t=="object"&&t.id!==void 0}function pQ(){return typeof navigator=="object"&&navigator.product==="ReactNative"}function mQ(){const t=mo();return t.indexOf("MSIE ")>=0||t.indexOf("Trident/")>=0}function gQ(){return!hQ()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function yQ(){try{return typeof indexedDB=="object"}catch{return!1}}function wQ(){return new Promise((t,e)=>{try{let n=!0;const r="validate-browser-context-for-indexeddb-analytics-module",s=self.indexedDB.open(r);s.onsuccess=()=>{s.result.close(),n||self.indexedDB.deleteDatabase(r),t(!0)},s.onupgradeneeded=()=>{n=!1},s.onerror=()=>{e(s.error?.message||"")}}catch(n){e(n)}})}const vQ="FirebaseError";class pc extends Error{constructor(e,n,r){super(n),this.code=e,this.customData=r,this.name=vQ,Object.setPrototypeOf(this,pc.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,Gy.prototype.create)}}class Gy{constructor(e,n,r){this.service=e,this.serviceName=n,this.errors=r}create(e,...n){const r=n[0]||{},s=`${this.service}/${e}`,i=this.errors[e],o=i?bQ(i,r):"Error",a=`${this.serviceName}: ${o} (${s}).`;return new pc(s,a,r)}}function bQ(t,e){return t.replace(xQ,(n,r)=>{const s=e[r];return s!=null?String(s):`<${r}?>`})}const xQ=/\{\$([^}]+)}/g;function _Q(t){for(const e in t)if(Object.prototype.hasOwnProperty.call(t,e))return!1;return!0}function zd(t,e){if(t===e)return!0;const n=Object.keys(t),r=Object.keys(e);for(const s of n){if(!r.includes(s))return!1;const i=t[s],o=e[s];if(OD(i)&&OD(o)){if(!zd(i,o))return!1}else if(i!==o)return!1}for(const s of r)if(!n.includes(s))return!1;return!0}function OD(t){return t!==null&&typeof t=="object"}function Hy(t){const e=[];for(const[n,r]of Object.entries(t))Array.isArray(r)?r.forEach(s=>{e.push(encodeURIComponent(n)+"="+encodeURIComponent(s))}):e.push(encodeURIComponent(n)+"="+encodeURIComponent(r));return e.length?"&"+e.join("&"):""}function V2(t){const e={};return t.replace(/^\?/,"").split("&").forEach(r=>{if(r){const[s,i]=r.split("=");e[decodeURIComponent(s)]=decodeURIComponent(i)}}),e}function B2(t){const e=t.indexOf("?");if(!e)return"";const n=t.indexOf("#",e);return t.substring(e,n>0?n:void 0)}function IQ(t,e){const n=new TQ(t,e);return n.subscribe.bind(n)}class TQ{constructor(e,n){this.observers=[],this.unsubscribes=[],this.observerCount=0,this.task=Promise.resolve(),this.finalized=!1,this.onNoObservers=n,this.task.then(()=>{e(this)}).catch(r=>{this.error(r)})}next(e){this.forEachObserver(n=>{n.next(e)})}error(e){this.forEachObserver(n=>{n.error(e)}),this.close(e)}complete(){this.forEachObserver(e=>{e.complete()}),this.close()}subscribe(e,n,r){let s;if(e===void 0&&n===void 0&&r===void 0)throw new Error("Missing Observer.");SQ(e,["next","error","complete"])?s=e:s={next:e,error:n,complete:r},s.next===void 0&&(s.next=eT),s.error===void 0&&(s.error=eT),s.complete===void 0&&(s.complete=eT);const i=this.unsubscribeOne.bind(this,this.observers.length);return this.finalized&&this.task.then(()=>{try{this.finalError?s.error(this.finalError):s.complete()}catch{}}),this.observers.push(s),i}unsubscribeOne(e){this.observers===void 0||this.observers[e]===void 0||(delete this.observers[e],this.observerCount-=1,this.observerCount===0&&this.onNoObservers!==void 0&&this.onNoObservers(this))}forEachObserver(e){if(!this.finalized)for(let n=0;n<this.observers.length;n++)this.sendOne(n,e)}sendOne(e,n){this.task.then(()=>{if(this.observers!==void 0&&this.observers[e]!==void 0)try{n(this.observers[e])}catch(r){typeof console<"u"&&console.error&&console.error(r)}})}close(e){this.finalized||(this.finalized=!0,e!==void 0&&(this.finalError=e),this.task.then(()=>{this.observers=void 0,this.onNoObservers=void 0}))}}function SQ(t,e){if(typeof t!="object"||t===null)return!1;for(const n of e)if(n in t&&typeof t[n]=="function")return!0;return!1}function eT(){}function sa(t){return t&&t._delegate?t._delegate:t}class Vd{constructor(e,n,r){this.name=e,this.instanceFactory=n,this.type=r,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(e){return this.instantiationMode=e,this}setMultipleInstances(e){return this.multipleInstances=e,this}setServiceProps(e){return this.serviceProps=e,this}setInstanceCreatedCallback(e){return this.onInstanceCreated=e,this}}const bd="[DEFAULT]";class $Q{constructor(e,n){this.name=e,this.container=n,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(e){const n=this.normalizeInstanceIdentifier(e);if(!this.instancesDeferred.has(n)){const r=new oQ;if(this.instancesDeferred.set(n,r),this.isInitialized(n)||this.shouldAutoInitialize())try{const s=this.getOrInitializeService({instanceIdentifier:n});s&&r.resolve(s)}catch{}}return this.instancesDeferred.get(n).promise}getImmediate(e){const n=this.normalizeInstanceIdentifier(e?.identifier),r=e?.optional??!1;if(this.isInitialized(n)||this.shouldAutoInitialize())try{return this.getOrInitializeService({instanceIdentifier:n})}catch(s){if(r)return null;throw s}else{if(r)return null;throw Error(`Service ${this.name} is not available`)}}getComponent(){return this.component}setComponent(e){if(e.name!==this.name)throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=e,!!this.shouldAutoInitialize()){if(EQ(e))try{this.getOrInitializeService({instanceIdentifier:bd})}catch{}for(const[n,r]of this.instancesDeferred.entries()){const s=this.normalizeInstanceIdentifier(n);try{const i=this.getOrInitializeService({instanceIdentifier:s});r.resolve(i)}catch{}}}}clearInstance(e=bd){this.instancesDeferred.delete(e),this.instancesOptions.delete(e),this.instances.delete(e)}async delete(){const e=Array.from(this.instances.values());await Promise.all([...e.filter(n=>"INTERNAL"in n).map(n=>n.INTERNAL.delete()),...e.filter(n=>"_delete"in n).map(n=>n._delete())])}isComponentSet(){return this.component!=null}isInitialized(e=bd){return this.instances.has(e)}getOptions(e=bd){return this.instancesOptions.get(e)||{}}initialize(e={}){const{options:n={}}=e,r=this.normalizeInstanceIdentifier(e.instanceIdentifier);if(this.isInitialized(r))throw Error(`${this.name}(${r}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const s=this.getOrInitializeService({instanceIdentifier:r,options:n});for(const[i,o]of this.instancesDeferred.entries()){const a=this.normalizeInstanceIdentifier(i);r===a&&o.resolve(s)}return s}onInit(e,n){const r=this.normalizeInstanceIdentifier(n),s=this.onInitCallbacks.get(r)??new Set;s.add(e),this.onInitCallbacks.set(r,s);const i=this.instances.get(r);return i&&e(i,r),()=>{s.delete(e)}}invokeOnInitCallbacks(e,n){const r=this.onInitCallbacks.get(n);if(r)for(const s of r)try{s(e,n)}catch{}}getOrInitializeService({instanceIdentifier:e,options:n={}}){let r=this.instances.get(e);if(!r&&this.component&&(r=this.component.instanceFactory(this.container,{instanceIdentifier:CQ(e),options:n}),this.instances.set(e,r),this.instancesOptions.set(e,n),this.invokeOnInitCallbacks(r,e),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,e,r)}catch{}return r||null}normalizeInstanceIdentifier(e=bd){return this.component?this.component.multipleInstances?e:bd:e}shouldAutoInitialize(){return!!this.component&&this.component.instantiationMode!=="EXPLICIT"}}function CQ(t){return t===bd?void 0:t}function EQ(t){return t.instantiationMode==="EAGER"}class kQ{constructor(e){this.name=e,this.providers=new Map}addComponent(e){const n=this.getProvider(e.name);if(n.isComponentSet())throw new Error(`Component ${e.name} has already been registered with ${this.name}`);n.setComponent(e)}addOrOverwriteComponent(e){this.getProvider(e.name).isComponentSet()&&this.providers.delete(e.name),this.addComponent(e)}getProvider(e){if(this.providers.has(e))return this.providers.get(e);const n=new $Q(e,this);return this.providers.set(e,n),n}getProviders(){return Array.from(this.providers.values())}}var Qn;(function(t){t[t.DEBUG=0]="DEBUG",t[t.VERBOSE=1]="VERBOSE",t[t.INFO=2]="INFO",t[t.WARN=3]="WARN",t[t.ERROR=4]="ERROR",t[t.SILENT=5]="SILENT"})(Qn||(Qn={}));const NQ={debug:Qn.DEBUG,verbose:Qn.VERBOSE,info:Qn.INFO,warn:Qn.WARN,error:Qn.ERROR,silent:Qn.SILENT},AQ=Qn.INFO,RQ={[Qn.DEBUG]:"log",[Qn.VERBOSE]:"log",[Qn.INFO]:"info",[Qn.WARN]:"warn",[Qn.ERROR]:"error"},DQ=(t,e,...n)=>{if(e<t.logLevel)return;const r=new Date().toISOString(),s=RQ[e];if(s)console[s](`[${r}]  ${t.name}:`,...n);else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)};let IC=class{constructor(e){this.name=e,this._logLevel=AQ,this._logHandler=DQ,this._userLogHandler=null}get logLevel(){return this._logLevel}set logLevel(e){if(!(e in Qn))throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);this._logLevel=e}setLogLevel(e){this._logLevel=typeof e=="string"?NQ[e]:e}get logHandler(){return this._logHandler}set logHandler(e){if(typeof e!="function")throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=e}get userLogHandler(){return this._userLogHandler}set userLogHandler(e){this._userLogHandler=e}debug(...e){this._userLogHandler&&this._userLogHandler(this,Qn.DEBUG,...e),this._logHandler(this,Qn.DEBUG,...e)}log(...e){this._userLogHandler&&this._userLogHandler(this,Qn.VERBOSE,...e),this._logHandler(this,Qn.VERBOSE,...e)}info(...e){this._userLogHandler&&this._userLogHandler(this,Qn.INFO,...e),this._logHandler(this,Qn.INFO,...e)}warn(...e){this._userLogHandler&&this._userLogHandler(this,Qn.WARN,...e),this._logHandler(this,Qn.WARN,...e)}error(...e){this._userLogHandler&&this._userLogHandler(this,Qn.ERROR,...e),this._logHandler(this,Qn.ERROR,...e)}};const OQ=(t,e)=>e.some(n=>t instanceof n);let PD,FD;function PQ(){return PD||(PD=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function FQ(){return FD||(FD=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const JF=new WeakMap,zS=new WeakMap,ZF=new WeakMap,tT=new WeakMap,TC=new WeakMap;function LQ(t){const e=new Promise((n,r)=>{const s=()=>{t.removeEventListener("success",i),t.removeEventListener("error",o)},i=()=>{n(uh(t.result)),s()},o=()=>{r(t.error),s()};t.addEventListener("success",i),t.addEventListener("error",o)});return e.then(n=>{n instanceof IDBCursor&&JF.set(n,t)}).catch(()=>{}),TC.set(e,t),e}function MQ(t){if(zS.has(t))return;const e=new Promise((n,r)=>{const s=()=>{t.removeEventListener("complete",i),t.removeEventListener("error",o),t.removeEventListener("abort",o)},i=()=>{n(),s()},o=()=>{r(t.error||new DOMException("AbortError","AbortError")),s()};t.addEventListener("complete",i),t.addEventListener("error",o),t.addEventListener("abort",o)});zS.set(t,e)}let VS={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return zS.get(t);if(e==="objectStoreNames")return t.objectStoreNames||ZF.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return uh(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function zQ(t){VS=t(VS)}function VQ(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...n){const r=t.call(nT(this),e,...n);return ZF.set(r,e.sort?e.sort():[e]),uh(r)}:FQ().includes(t)?function(...e){return t.apply(nT(this),e),uh(JF.get(this))}:function(...e){return uh(t.apply(nT(this),e))}}function BQ(t){return typeof t=="function"?VQ(t):(t instanceof IDBTransaction&&MQ(t),OQ(t,PQ())?new Proxy(t,VS):t)}function uh(t){if(t instanceof IDBRequest)return LQ(t);if(tT.has(t))return tT.get(t);const e=BQ(t);return e!==t&&(tT.set(t,e),TC.set(e,t)),e}const nT=t=>TC.get(t);function UQ(t,e,{blocked:n,upgrade:r,blocking:s,terminated:i}={}){const o=indexedDB.open(t,e),a=uh(o);return r&&o.addEventListener("upgradeneeded",l=>{r(uh(o.result),l.oldVersion,l.newVersion,uh(o.transaction),l)}),n&&o.addEventListener("blocked",l=>n(l.oldVersion,l.newVersion,l)),a.then(l=>{i&&l.addEventListener("close",()=>i()),s&&l.addEventListener("versionchange",u=>s(u.oldVersion,u.newVersion,u))}).catch(()=>{}),a}const WQ=["get","getKey","getAll","getAllKeys","count"],jQ=["put","add","delete","clear"],rT=new Map;function LD(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(rT.get(e))return rT.get(e);const n=e.replace(/FromIndex$/,""),r=e!==n,s=jQ.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(s||WQ.includes(n)))return;const i=async function(o,...a){const l=this.transaction(o,s?"readwrite":"readonly");let u=l.store;return r&&(u=u.index(a.shift())),(await Promise.all([u[n](...a),s&&l.done]))[0]};return rT.set(e,i),i}zQ(t=>({...t,get:(e,n,r)=>LD(e,n)||t.get(e,n,r),has:(e,n)=>!!LD(e,n)||t.has(e,n)}));class GQ{constructor(e){this.container=e}getPlatformInfoString(){return this.container.getProviders().map(n=>{if(HQ(n)){const r=n.getImmediate();return`${r.library}/${r.version}`}else return null}).filter(n=>n).join(" ")}}function HQ(t){return t.getComponent()?.type==="VERSION"}const BS="@firebase/app",MD="0.14.6";const tc=new IC("@firebase/app"),qQ="@firebase/app-compat",KQ="@firebase/analytics-compat",XQ="@firebase/analytics",YQ="@firebase/app-check-compat",QQ="@firebase/app-check",JQ="@firebase/auth",ZQ="@firebase/auth-compat",eJ="@firebase/database",tJ="@firebase/data-connect",nJ="@firebase/database-compat",rJ="@firebase/functions",sJ="@firebase/functions-compat",iJ="@firebase/installations",oJ="@firebase/installations-compat",aJ="@firebase/messaging",lJ="@firebase/messaging-compat",uJ="@firebase/performance",cJ="@firebase/performance-compat",hJ="@firebase/remote-config",dJ="@firebase/remote-config-compat",fJ="@firebase/storage",pJ="@firebase/storage-compat",mJ="@firebase/firestore",gJ="@firebase/ai",yJ="@firebase/firestore-compat",wJ="firebase",vJ="12.6.0";const US="[DEFAULT]",bJ={[BS]:"fire-core",[qQ]:"fire-core-compat",[XQ]:"fire-analytics",[KQ]:"fire-analytics-compat",[QQ]:"fire-app-check",[YQ]:"fire-app-check-compat",[JQ]:"fire-auth",[ZQ]:"fire-auth-compat",[eJ]:"fire-rtdb",[tJ]:"fire-data-connect",[nJ]:"fire-rtdb-compat",[rJ]:"fire-fn",[sJ]:"fire-fn-compat",[iJ]:"fire-iid",[oJ]:"fire-iid-compat",[aJ]:"fire-fcm",[lJ]:"fire-fcm-compat",[uJ]:"fire-perf",[cJ]:"fire-perf-compat",[hJ]:"fire-rc",[dJ]:"fire-rc-compat",[fJ]:"fire-gcs",[pJ]:"fire-gcs-compat",[mJ]:"fire-fst",[yJ]:"fire-fst-compat",[gJ]:"fire-vertex","fire-js":"fire-js",[wJ]:"fire-js-all"};const hb=new Map,xJ=new Map,WS=new Map;function zD(t,e){try{t.container.addComponent(e)}catch(n){tc.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`,n)}}function Cm(t){const e=t.name;if(WS.has(e))return tc.debug(`There were multiple attempts to register component ${e}.`),!1;WS.set(e,t);for(const n of hb.values())zD(n,t);for(const n of xJ.values())zD(n,t);return!0}function SC(t,e){const n=t.container.getProvider("heartbeat").getImmediate({optional:!0});return n&&n.triggerHeartbeat(),t.container.getProvider(e)}function Ja(t){return t==null?!1:t.settings!==void 0}const _J={"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."},ch=new Gy("app","Firebase",_J);class IJ{constructor(e,n,r){this._isDeleted=!1,this._options={...e},this._config={...n},this._name=n.name,this._automaticDataCollectionEnabled=n.automaticDataCollectionEnabled,this._container=r,this.container.addComponent(new Vd("app",()=>this,"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(e){this.checkDestroyed(),this._automaticDataCollectionEnabled=e}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(e){this._isDeleted=e}checkDestroyed(){if(this.isDeleted)throw ch.create("app-deleted",{appName:this._name})}}const eg=vJ;function eL(t,e={}){let n=t;typeof e!="object"&&(e={name:e});const r={name:US,automaticDataCollectionEnabled:!0,...e},s=r.name;if(typeof s!="string"||!s)throw ch.create("bad-app-name",{appName:String(s)});if(n||(n=KF()),!n)throw ch.create("no-options");const i=hb.get(s);if(i){if(zd(n,i.options)&&zd(r,i.config))return i;throw ch.create("duplicate-app",{appName:s})}const o=new kQ(s);for(const l of WS.values())o.addComponent(l);const a=new IJ(n,r,o);return hb.set(s,a),a}function tL(t=US){const e=hb.get(t);if(!e&&t===US&&KF())return eL();if(!e)throw ch.create("no-app",{appName:t});return e}function hh(t,e,n){let r=bJ[t]??t;n&&(r+=`-${n}`);const s=r.match(/\s|\//),i=e.match(/\s|\//);if(s||i){const o=[`Unable to register library "${r}" with version "${e}":`];s&&o.push(`library name "${r}" contains illegal characters (whitespace or "/")`),s&&i&&o.push("and"),i&&o.push(`version name "${e}" contains illegal characters (whitespace or "/")`),tc.warn(o.join(" "));return}Cm(new Vd(`${r}-version`,()=>({library:r,version:e}),"VERSION"))}const TJ="firebase-heartbeat-database",SJ=1,py="firebase-heartbeat-store";let sT=null;function nL(){return sT||(sT=UQ(TJ,SJ,{upgrade:(t,e)=>{switch(e){case 0:try{t.createObjectStore(py)}catch(n){console.warn(n)}}}}).catch(t=>{throw ch.create("idb-open",{originalErrorMessage:t.message})})),sT}async function $J(t){try{const n=(await nL()).transaction(py),r=await n.objectStore(py).get(rL(t));return await n.done,r}catch(e){if(e instanceof pc)tc.warn(e.message);else{const n=ch.create("idb-get",{originalErrorMessage:e?.message});tc.warn(n.message)}}}async function VD(t,e){try{const r=(await nL()).transaction(py,"readwrite");await r.objectStore(py).put(e,rL(t)),await r.done}catch(n){if(n instanceof pc)tc.warn(n.message);else{const r=ch.create("idb-set",{originalErrorMessage:n?.message});tc.warn(r.message)}}}function rL(t){return`${t.name}!${t.options.appId}`}const CJ=1024,EJ=30;class kJ{constructor(e){this.container=e,this._heartbeatsCache=null;const n=this.container.getProvider("app").getImmediate();this._storage=new AJ(n),this._heartbeatsCachePromise=this._storage.read().then(r=>(this._heartbeatsCache=r,r))}async triggerHeartbeat(){try{const n=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),r=BD();if(this._heartbeatsCache?.heartbeats==null&&(this._heartbeatsCache=await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null)||this._heartbeatsCache.lastSentHeartbeatDate===r||this._heartbeatsCache.heartbeats.some(s=>s.date===r))return;if(this._heartbeatsCache.heartbeats.push({date:r,agent:n}),this._heartbeatsCache.heartbeats.length>EJ){const s=RJ(this._heartbeatsCache.heartbeats);this._heartbeatsCache.heartbeats.splice(s,1)}return this._storage.overwrite(this._heartbeatsCache)}catch(e){tc.warn(e)}}async getHeartbeatsHeader(){try{if(this._heartbeatsCache===null&&await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null||this._heartbeatsCache.heartbeats.length===0)return"";const e=BD(),{heartbeatsToSend:n,unsentEntries:r}=NJ(this._heartbeatsCache.heartbeats),s=cb(JSON.stringify({version:2,heartbeats:n}));return this._heartbeatsCache.lastSentHeartbeatDate=e,r.length>0?(this._heartbeatsCache.heartbeats=r,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),s}catch(e){return tc.warn(e),""}}}function BD(){return new Date().toISOString().substring(0,10)}function NJ(t,e=CJ){const n=[];let r=t.slice();for(const s of t){const i=n.find(o=>o.agent===s.agent);if(i){if(i.dates.push(s.date),UD(n)>e){i.dates.pop();break}}else if(n.push({agent:s.agent,dates:[s.date]}),UD(n)>e){n.pop();break}r=r.slice(1)}return{heartbeatsToSend:n,unsentEntries:r}}class AJ{constructor(e){this.app=e,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return yQ()?wQ().then(()=>!0).catch(()=>!1):!1}async read(){if(await this._canUseIndexedDBPromise){const n=await $J(this.app);return n?.heartbeats?n:{heartbeats:[]}}else return{heartbeats:[]}}async overwrite(e){if(await this._canUseIndexedDBPromise){const r=await this.read();return VD(this.app,{lastSentHeartbeatDate:e.lastSentHeartbeatDate??r.lastSentHeartbeatDate,heartbeats:e.heartbeats})}else return}async add(e){if(await this._canUseIndexedDBPromise){const r=await this.read();return VD(this.app,{lastSentHeartbeatDate:e.lastSentHeartbeatDate??r.lastSentHeartbeatDate,heartbeats:[...r.heartbeats,...e.heartbeats]})}else return}}function UD(t){return cb(JSON.stringify({version:2,heartbeats:t})).length}function RJ(t){if(t.length===0)return-1;let e=0,n=t[0].date;for(let r=1;r<t.length;r++)t[r].date<n&&(n=t[r].date,e=r);return e}function DJ(t){Cm(new Vd("platform-logger",e=>new GQ(e),"PRIVATE")),Cm(new Vd("heartbeat",e=>new kJ(e),"PRIVATE")),hh(BS,MD,t),hh(BS,MD,"esm2020"),hh("fire-js","")}DJ("");var OJ="firebase",PJ="12.6.0";hh(OJ,PJ,"app");function sL(){return{"dependent-sdk-initialized-before-auth":"Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."}}const FJ=sL,iL=new Gy("auth","Firebase",sL());const db=new IC("@firebase/auth");function LJ(t,...e){db.logLevel<=Qn.WARN&&db.warn(`Auth (${eg}): ${t}`,...e)}function Fv(t,...e){db.logLevel<=Qn.ERROR&&db.error(`Auth (${eg}): ${t}`,...e)}function Fl(t,...e){throw $C(t,...e)}function lu(t,...e){return $C(t,...e)}function oL(t,e,n){const r={...FJ(),[e]:n};return new Gy("auth","Firebase",r).create(e,{appName:t.name})}function Zu(t){return oL(t,"operation-not-supported-in-this-environment","Operations that alter the current user are not supported in conjunction with FirebaseServerApp")}function $C(t,...e){if(typeof t!="string"){const n=e[0],r=[...e.slice(1)];return r[0]&&(r[0].appName=t.name),t._errorFactory.create(n,...r)}return iL.create(t,...e)}function fn(t,e,...n){if(!t)throw $C(e,...n)}function Xu(t){const e="INTERNAL ASSERTION FAILED: "+t;throw Fv(e),new Error(e)}function nc(t,e){t||Xu(e)}function jS(){return typeof self<"u"&&self.location?.href||""}function MJ(){return WD()==="http:"||WD()==="https:"}function WD(){return typeof self<"u"&&self.location?.protocol||null}function zJ(){return typeof navigator<"u"&&navigator&&"onLine"in navigator&&typeof navigator.onLine=="boolean"&&(MJ()||fQ()||"connection"in navigator)?navigator.onLine:!0}function VJ(){if(typeof navigator>"u")return null;const t=navigator;return t.languages&&t.languages[0]||t.language||null}class qy{constructor(e,n){this.shortDelay=e,this.longDelay=n,nc(n>e,"Short delay should be less than long delay!"),this.isMobile=cQ()||pQ()}get(){return zJ()?this.isMobile?this.longDelay:this.shortDelay:Math.min(5e3,this.shortDelay)}}function CC(t,e){nc(t.emulator,"Emulator should always be set here");const{url:n}=t.emulator;return e?`${n}${e.startsWith("/")?e.slice(1):e}`:n}class aL{static initialize(e,n,r){this.fetchImpl=e,n&&(this.headersImpl=n),r&&(this.responseImpl=r)}static fetch(){if(this.fetchImpl)return this.fetchImpl;if(typeof self<"u"&&"fetch"in self)return self.fetch;if(typeof globalThis<"u"&&globalThis.fetch)return globalThis.fetch;if(typeof fetch<"u")return fetch;Xu("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static headers(){if(this.headersImpl)return this.headersImpl;if(typeof self<"u"&&"Headers"in self)return self.Headers;if(typeof globalThis<"u"&&globalThis.Headers)return globalThis.Headers;if(typeof Headers<"u")return Headers;Xu("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static response(){if(this.responseImpl)return this.responseImpl;if(typeof self<"u"&&"Response"in self)return self.Response;if(typeof globalThis<"u"&&globalThis.Response)return globalThis.Response;if(typeof Response<"u")return Response;Xu("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}}const BJ={CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_PASSWORD:"wrong-password",MISSING_PASSWORD:"missing-password",INVALID_LOGIN_CREDENTIALS:"invalid-credential",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",INVALID_PENDING_TOKEN:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",MISSING_REQ_TYPE:"internal-error",EMAIL_NOT_FOUND:"user-not-found",RESET_PASSWORD_EXCEED_LIMIT:"too-many-requests",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",PASSWORD_DOES_NOT_MEET_REQUIREMENTS:"password-does-not-meet-requirements",INVALID_CODE:"invalid-verification-code",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_SESSION_INFO:"missing-verification-id",SESSION_EXPIRED:"code-expired",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id",ADMIN_ONLY_OPERATION:"admin-restricted-operation",INVALID_MFA_PENDING_CREDENTIAL:"invalid-multi-factor-session",MFA_ENROLLMENT_NOT_FOUND:"multi-factor-info-not-found",MISSING_MFA_ENROLLMENT_ID:"missing-multi-factor-info",MISSING_MFA_PENDING_CREDENTIAL:"missing-multi-factor-session",SECOND_FACTOR_EXISTS:"second-factor-already-in-use",SECOND_FACTOR_LIMIT_EXCEEDED:"maximum-second-factor-count-exceeded",BLOCKING_FUNCTION_ERROR_RESPONSE:"internal-error",RECAPTCHA_NOT_ENABLED:"recaptcha-not-enabled",MISSING_RECAPTCHA_TOKEN:"missing-recaptcha-token",INVALID_RECAPTCHA_TOKEN:"invalid-recaptcha-token",INVALID_RECAPTCHA_ACTION:"invalid-recaptcha-action",MISSING_CLIENT_TYPE:"missing-client-type",MISSING_RECAPTCHA_VERSION:"missing-recaptcha-version",INVALID_RECAPTCHA_VERSION:"invalid-recaptcha-version",INVALID_REQ_TYPE:"invalid-req-type"};const UJ=["/v1/accounts:signInWithCustomToken","/v1/accounts:signInWithEmailLink","/v1/accounts:signInWithIdp","/v1/accounts:signInWithPassword","/v1/accounts:signInWithPhoneNumber","/v1/token"],WJ=new qy(3e4,6e4);function Bh(t,e){return t.tenantId&&!e.tenantId?{...e,tenantId:t.tenantId}:e}async function mc(t,e,n,r,s={}){return lL(t,s,async()=>{let i={},o={};r&&(e==="GET"?o=r:i={body:JSON.stringify(r)});const a=Hy({key:t.config.apiKey,...o}).slice(1),l=await t._getAdditionalHeaders();l["Content-Type"]="application/json",t.languageCode&&(l["X-Firebase-Locale"]=t.languageCode);const u={method:e,headers:l,...i};return dQ()||(u.referrerPolicy="no-referrer"),t.emulatorConfig&&Zm(t.emulatorConfig.host)&&(u.credentials="include"),aL.fetch()(await uL(t,t.config.apiHost,n,a),u)})}async function lL(t,e,n){t._canInitEmulator=!1;const r={...BJ,...e};try{const s=new GJ(t),i=await Promise.race([n(),s.promise]);s.clearNetworkTimeout();const o=await i.json();if("needConfirmation"in o)throw tv(t,"account-exists-with-different-credential",o);if(i.ok&&!("errorMessage"in o))return o;{const a=i.ok?o.errorMessage:o.error.message,[l,u]=a.split(" : ");if(l==="FEDERATED_USER_ID_ALREADY_LINKED")throw tv(t,"credential-already-in-use",o);if(l==="EMAIL_EXISTS")throw tv(t,"email-already-in-use",o);if(l==="USER_DISABLED")throw tv(t,"user-disabled",o);const c=r[l]||l.toLowerCase().replace(/[_\s]+/g,"-");if(u)throw oL(t,c,u);Fl(t,c)}}catch(s){if(s instanceof pc)throw s;Fl(t,"network-request-failed",{message:String(s)})}}async function Ky(t,e,n,r,s={}){const i=await mc(t,e,n,r,s);return"mfaPendingCredential"in i&&Fl(t,"multi-factor-auth-required",{_serverResponse:i}),i}async function uL(t,e,n,r){const s=`${e}${n}?${r}`,i=t,o=i.config.emulator?CC(t.config,s):`${t.config.apiScheme}://${s}`;return UJ.includes(n)&&(await i._persistenceManagerAvailable,i._getPersistenceType()==="COOKIE")?i._getPersistence()._getFinalTarget(o).toString():o}function jJ(t){switch(t){case"ENFORCE":return"ENFORCE";case"AUDIT":return"AUDIT";case"OFF":return"OFF";default:return"ENFORCEMENT_STATE_UNSPECIFIED"}}class GJ{clearNetworkTimeout(){clearTimeout(this.timer)}constructor(e){this.auth=e,this.timer=null,this.promise=new Promise((n,r)=>{this.timer=setTimeout(()=>r(lu(this.auth,"network-request-failed")),WJ.get())})}}function tv(t,e,n){const r={appName:t.name};n.email&&(r.email=n.email),n.phoneNumber&&(r.phoneNumber=n.phoneNumber);const s=lu(t,e,r);return s.customData._tokenResponse=n,s}function jD(t){return t!==void 0&&t.enterprise!==void 0}class HJ{constructor(e){if(this.siteKey="",this.recaptchaEnforcementState=[],e.recaptchaKey===void 0)throw new Error("recaptchaKey undefined");this.siteKey=e.recaptchaKey.split("/")[3],this.recaptchaEnforcementState=e.recaptchaEnforcementState}getProviderEnforcementState(e){if(!this.recaptchaEnforcementState||this.recaptchaEnforcementState.length===0)return null;for(const n of this.recaptchaEnforcementState)if(n.provider&&n.provider===e)return jJ(n.enforcementState);return null}isProviderEnabled(e){return this.getProviderEnforcementState(e)==="ENFORCE"||this.getProviderEnforcementState(e)==="AUDIT"}isAnyProviderEnabled(){return this.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")||this.isProviderEnabled("PHONE_PROVIDER")}}async function qJ(t,e){return mc(t,"GET","/v2/recaptchaConfig",Bh(t,e))}async function KJ(t,e){return mc(t,"POST","/v1/accounts:delete",e)}async function fb(t,e){return mc(t,"POST","/v1/accounts:lookup",e)}function ay(t){if(t)try{const e=new Date(Number(t));if(!isNaN(e.getTime()))return e.toUTCString()}catch{}}async function XJ(t,e=!1){const n=sa(t),r=await n.getIdToken(e),s=EC(r);fn(s&&s.exp&&s.auth_time&&s.iat,n.auth,"internal-error");const i=typeof s.firebase=="object"?s.firebase:void 0,o=i?.sign_in_provider;return{claims:s,token:r,authTime:ay(iT(s.auth_time)),issuedAtTime:ay(iT(s.iat)),expirationTime:ay(iT(s.exp)),signInProvider:o||null,signInSecondFactor:i?.sign_in_second_factor||null}}function iT(t){return Number(t)*1e3}function EC(t){const[e,n,r]=t.split(".");if(e===void 0||n===void 0||r===void 0)return Fv("JWT malformed, contained fewer than 3 sections"),null;try{const s=HF(n);return s?JSON.parse(s):(Fv("Failed to decode base64 JWT payload"),null)}catch(s){return Fv("Caught error parsing JWT payload as JSON",s?.toString()),null}}function GD(t){const e=EC(t);return fn(e,"internal-error"),fn(typeof e.exp<"u","internal-error"),fn(typeof e.iat<"u","internal-error"),Number(e.exp)-Number(e.iat)}async function Em(t,e,n=!1){if(n)return e;try{return await e}catch(r){throw r instanceof pc&&YJ(r)&&t.auth.currentUser===t&&await t.auth.signOut(),r}}function YJ({code:t}){return t==="auth/user-disabled"||t==="auth/user-token-expired"}class QJ{constructor(e){this.user=e,this.isRunning=!1,this.timerId=null,this.errorBackoff=3e4}_start(){this.isRunning||(this.isRunning=!0,this.schedule())}_stop(){this.isRunning&&(this.isRunning=!1,this.timerId!==null&&clearTimeout(this.timerId))}getInterval(e){if(e){const n=this.errorBackoff;return this.errorBackoff=Math.min(this.errorBackoff*2,96e4),n}else{this.errorBackoff=3e4;const r=(this.user.stsTokenManager.expirationTime??0)-Date.now()-3e5;return Math.max(0,r)}}schedule(e=!1){if(!this.isRunning)return;const n=this.getInterval(e);this.timerId=setTimeout(async()=>{await this.iteration()},n)}async iteration(){try{await this.user.getIdToken(!0)}catch(e){e?.code==="auth/network-request-failed"&&this.schedule(!0);return}this.schedule()}}class GS{constructor(e,n){this.createdAt=e,this.lastLoginAt=n,this._initializeTime()}_initializeTime(){this.lastSignInTime=ay(this.lastLoginAt),this.creationTime=ay(this.createdAt)}_copy(e){this.createdAt=e.createdAt,this.lastLoginAt=e.lastLoginAt,this._initializeTime()}toJSON(){return{createdAt:this.createdAt,lastLoginAt:this.lastLoginAt}}}async function pb(t){const e=t.auth,n=await t.getIdToken(),r=await Em(t,fb(e,{idToken:n}));fn(r?.users.length,e,"internal-error");const s=r.users[0];t._notifyReloadListener(s);const i=s.providerUserInfo?.length?cL(s.providerUserInfo):[],o=ZJ(t.providerData,i),a=t.isAnonymous,l=!(t.email&&s.passwordHash)&&!o?.length,u=a?l:!1,c={uid:s.localId,displayName:s.displayName||null,photoURL:s.photoUrl||null,email:s.email||null,emailVerified:s.emailVerified||!1,phoneNumber:s.phoneNumber||null,tenantId:s.tenantId||null,providerData:o,metadata:new GS(s.createdAt,s.lastLoginAt),isAnonymous:u};Object.assign(t,c)}async function JJ(t){const e=sa(t);await pb(e),await e.auth._persistUserIfCurrent(e),e.auth._notifyListenersIfCurrent(e)}function ZJ(t,e){return[...t.filter(r=>!e.some(s=>s.providerId===r.providerId)),...e]}function cL(t){return t.map(({providerId:e,...n})=>({providerId:e,uid:n.rawId||"",displayName:n.displayName||null,email:n.email||null,phoneNumber:n.phoneNumber||null,photoURL:n.photoUrl||null}))}async function eZ(t,e){const n=await lL(t,{},async()=>{const r=Hy({grant_type:"refresh_token",refresh_token:e}).slice(1),{tokenApiHost:s,apiKey:i}=t.config,o=await uL(t,s,"/v1/token",`key=${i}`),a=await t._getAdditionalHeaders();a["Content-Type"]="application/x-www-form-urlencoded";const l={method:"POST",headers:a,body:r};return t.emulatorConfig&&Zm(t.emulatorConfig.host)&&(l.credentials="include"),aL.fetch()(o,l)});return{accessToken:n.access_token,expiresIn:n.expires_in,refreshToken:n.refresh_token}}async function tZ(t,e){return mc(t,"POST","/v2/accounts:revokeToken",Bh(t,e))}class vm{constructor(){this.refreshToken=null,this.accessToken=null,this.expirationTime=null}get isExpired(){return!this.expirationTime||Date.now()>this.expirationTime-3e4}updateFromServerResponse(e){fn(e.idToken,"internal-error"),fn(typeof e.idToken<"u","internal-error"),fn(typeof e.refreshToken<"u","internal-error");const n="expiresIn"in e&&typeof e.expiresIn<"u"?Number(e.expiresIn):GD(e.idToken);this.updateTokensAndExpiration(e.idToken,e.refreshToken,n)}updateFromIdToken(e){fn(e.length!==0,"internal-error");const n=GD(e);this.updateTokensAndExpiration(e,null,n)}async getToken(e,n=!1){return!n&&this.accessToken&&!this.isExpired?this.accessToken:(fn(this.refreshToken,e,"user-token-expired"),this.refreshToken?(await this.refresh(e,this.refreshToken),this.accessToken):null)}clearRefreshToken(){this.refreshToken=null}async refresh(e,n){const{accessToken:r,refreshToken:s,expiresIn:i}=await eZ(e,n);this.updateTokensAndExpiration(r,s,Number(i))}updateTokensAndExpiration(e,n,r){this.refreshToken=n||null,this.accessToken=e||null,this.expirationTime=Date.now()+r*1e3}static fromJSON(e,n){const{refreshToken:r,accessToken:s,expirationTime:i}=n,o=new vm;return r&&(fn(typeof r=="string","internal-error",{appName:e}),o.refreshToken=r),s&&(fn(typeof s=="string","internal-error",{appName:e}),o.accessToken=s),i&&(fn(typeof i=="number","internal-error",{appName:e}),o.expirationTime=i),o}toJSON(){return{refreshToken:this.refreshToken,accessToken:this.accessToken,expirationTime:this.expirationTime}}_assign(e){this.accessToken=e.accessToken,this.refreshToken=e.refreshToken,this.expirationTime=e.expirationTime}_clone(){return Object.assign(new vm,this.toJSON())}_performRefresh(){return Xu("not implemented")}}function Gc(t,e){fn(typeof t=="string"||typeof t>"u","internal-error",{appName:e})}class kl{constructor({uid:e,auth:n,stsTokenManager:r,...s}){this.providerId="firebase",this.proactiveRefresh=new QJ(this),this.reloadUserInfo=null,this.reloadListener=null,this.uid=e,this.auth=n,this.stsTokenManager=r,this.accessToken=r.accessToken,this.displayName=s.displayName||null,this.email=s.email||null,this.emailVerified=s.emailVerified||!1,this.phoneNumber=s.phoneNumber||null,this.photoURL=s.photoURL||null,this.isAnonymous=s.isAnonymous||!1,this.tenantId=s.tenantId||null,this.providerData=s.providerData?[...s.providerData]:[],this.metadata=new GS(s.createdAt||void 0,s.lastLoginAt||void 0)}async getIdToken(e){const n=await Em(this,this.stsTokenManager.getToken(this.auth,e));return fn(n,this.auth,"internal-error"),this.accessToken!==n&&(this.accessToken=n,await this.auth._persistUserIfCurrent(this),this.auth._notifyListenersIfCurrent(this)),n}getIdTokenResult(e){return XJ(this,e)}reload(){return JJ(this)}_assign(e){this!==e&&(fn(this.uid===e.uid,this.auth,"internal-error"),this.displayName=e.displayName,this.photoURL=e.photoURL,this.email=e.email,this.emailVerified=e.emailVerified,this.phoneNumber=e.phoneNumber,this.isAnonymous=e.isAnonymous,this.tenantId=e.tenantId,this.providerData=e.providerData.map(n=>({...n})),this.metadata._copy(e.metadata),this.stsTokenManager._assign(e.stsTokenManager))}_clone(e){const n=new kl({...this,auth:e,stsTokenManager:this.stsTokenManager._clone()});return n.metadata._copy(this.metadata),n}_onReload(e){fn(!this.reloadListener,this.auth,"internal-error"),this.reloadListener=e,this.reloadUserInfo&&(this._notifyReloadListener(this.reloadUserInfo),this.reloadUserInfo=null)}_notifyReloadListener(e){this.reloadListener?this.reloadListener(e):this.reloadUserInfo=e}_startProactiveRefresh(){this.proactiveRefresh._start()}_stopProactiveRefresh(){this.proactiveRefresh._stop()}async _updateTokensIfNecessary(e,n=!1){let r=!1;e.idToken&&e.idToken!==this.stsTokenManager.accessToken&&(this.stsTokenManager.updateFromServerResponse(e),r=!0),n&&await pb(this),await this.auth._persistUserIfCurrent(this),r&&this.auth._notifyListenersIfCurrent(this)}async delete(){if(Ja(this.auth.app))return Promise.reject(Zu(this.auth));const e=await this.getIdToken();return await Em(this,KJ(this.auth,{idToken:e})),this.stsTokenManager.clearRefreshToken(),this.auth.signOut()}toJSON(){return{uid:this.uid,email:this.email||void 0,emailVerified:this.emailVerified,displayName:this.displayName||void 0,isAnonymous:this.isAnonymous,photoURL:this.photoURL||void 0,phoneNumber:this.phoneNumber||void 0,tenantId:this.tenantId||void 0,providerData:this.providerData.map(e=>({...e})),stsTokenManager:this.stsTokenManager.toJSON(),_redirectEventId:this._redirectEventId,...this.metadata.toJSON(),apiKey:this.auth.config.apiKey,appName:this.auth.name}}get refreshToken(){return this.stsTokenManager.refreshToken||""}static _fromJSON(e,n){const r=n.displayName??void 0,s=n.email??void 0,i=n.phoneNumber??void 0,o=n.photoURL??void 0,a=n.tenantId??void 0,l=n._redirectEventId??void 0,u=n.createdAt??void 0,c=n.lastLoginAt??void 0,{uid:d,emailVerified:f,isAnonymous:m,providerData:g,stsTokenManager:y}=n;fn(d&&y,e,"internal-error");const v=vm.fromJSON(this.name,y);fn(typeof d=="string",e,"internal-error"),Gc(r,e.name),Gc(s,e.name),fn(typeof f=="boolean",e,"internal-error"),fn(typeof m=="boolean",e,"internal-error"),Gc(i,e.name),Gc(o,e.name),Gc(a,e.name),Gc(l,e.name),Gc(u,e.name),Gc(c,e.name);const b=new kl({uid:d,auth:e,email:s,emailVerified:f,displayName:r,isAnonymous:m,photoURL:o,phoneNumber:i,tenantId:a,stsTokenManager:v,createdAt:u,lastLoginAt:c});return g&&Array.isArray(g)&&(b.providerData=g.map(x=>({...x}))),l&&(b._redirectEventId=l),b}static async _fromIdTokenResponse(e,n,r=!1){const s=new vm;s.updateFromServerResponse(n);const i=new kl({uid:n.localId,auth:e,stsTokenManager:s,isAnonymous:r});return await pb(i),i}static async _fromGetAccountInfoResponse(e,n,r){const s=n.users[0];fn(s.localId!==void 0,"internal-error");const i=s.providerUserInfo!==void 0?cL(s.providerUserInfo):[],o=!(s.email&&s.passwordHash)&&!i?.length,a=new vm;a.updateFromIdToken(r);const l=new kl({uid:s.localId,auth:e,stsTokenManager:a,isAnonymous:o}),u={uid:s.localId,displayName:s.displayName||null,photoURL:s.photoUrl||null,email:s.email||null,emailVerified:s.emailVerified||!1,phoneNumber:s.phoneNumber||null,tenantId:s.tenantId||null,providerData:i,metadata:new GS(s.createdAt,s.lastLoginAt),isAnonymous:!(s.email&&s.passwordHash)&&!i?.length};return Object.assign(l,u),l}}const HD=new Map;function Yu(t){nc(t instanceof Function,"Expected a class definition");let e=HD.get(t);return e?(nc(e instanceof t,"Instance stored in cache mismatched with class"),e):(e=new t,HD.set(t,e),e)}class hL{constructor(){this.type="NONE",this.storage={}}async _isAvailable(){return!0}async _set(e,n){this.storage[e]=n}async _get(e){const n=this.storage[e];return n===void 0?null:n}async _remove(e){delete this.storage[e]}_addListener(e,n){}_removeListener(e,n){}}hL.type="NONE";const qD=hL;function Lv(t,e,n){return`firebase:${t}:${e}:${n}`}class bm{constructor(e,n,r){this.persistence=e,this.auth=n,this.userKey=r;const{config:s,name:i}=this.auth;this.fullUserKey=Lv(this.userKey,s.apiKey,i),this.fullPersistenceKey=Lv("persistence",s.apiKey,i),this.boundEventHandler=n._onStorageEvent.bind(n),this.persistence._addListener(this.fullUserKey,this.boundEventHandler)}setCurrentUser(e){return this.persistence._set(this.fullUserKey,e.toJSON())}async getCurrentUser(){const e=await this.persistence._get(this.fullUserKey);if(!e)return null;if(typeof e=="string"){const n=await fb(this.auth,{idToken:e}).catch(()=>{});return n?kl._fromGetAccountInfoResponse(this.auth,n,e):null}return kl._fromJSON(this.auth,e)}removeCurrentUser(){return this.persistence._remove(this.fullUserKey)}savePersistenceForRedirect(){return this.persistence._set(this.fullPersistenceKey,this.persistence.type)}async setPersistence(e){if(this.persistence===e)return;const n=await this.getCurrentUser();if(await this.removeCurrentUser(),this.persistence=e,n)return this.setCurrentUser(n)}delete(){this.persistence._removeListener(this.fullUserKey,this.boundEventHandler)}static async create(e,n,r="authUser"){if(!n.length)return new bm(Yu(qD),e,r);const s=(await Promise.all(n.map(async u=>{if(await u._isAvailable())return u}))).filter(u=>u);let i=s[0]||Yu(qD);const o=Lv(r,e.config.apiKey,e.name);let a=null;for(const u of n)try{const c=await u._get(o);if(c){let d;if(typeof c=="string"){const f=await fb(e,{idToken:c}).catch(()=>{});if(!f)break;d=await kl._fromGetAccountInfoResponse(e,f,c)}else d=kl._fromJSON(e,c);u!==i&&(a=d),i=u;break}}catch{}const l=s.filter(u=>u._shouldAllowMigration);return!i._shouldAllowMigration||!l.length?new bm(i,e,r):(i=l[0],a&&await i._set(o,a.toJSON()),await Promise.all(n.map(async u=>{if(u!==i)try{await u._remove(o)}catch{}})),new bm(i,e,r))}}function KD(t){const e=t.toLowerCase();if(e.includes("opera/")||e.includes("opr/")||e.includes("opios/"))return"Opera";if(mL(e))return"IEMobile";if(e.includes("msie")||e.includes("trident/"))return"IE";if(e.includes("edge/"))return"Edge";if(dL(e))return"Firefox";if(e.includes("silk/"))return"Silk";if(yL(e))return"Blackberry";if(wL(e))return"Webos";if(fL(e))return"Safari";if((e.includes("chrome/")||pL(e))&&!e.includes("edge/"))return"Chrome";if(gL(e))return"Android";{const n=/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,r=t.match(n);if(r?.length===2)return r[1]}return"Other"}function dL(t=mo()){return/firefox\//i.test(t)}function fL(t=mo()){const e=t.toLowerCase();return e.includes("safari/")&&!e.includes("chrome/")&&!e.includes("crios/")&&!e.includes("android")}function pL(t=mo()){return/crios\//i.test(t)}function mL(t=mo()){return/iemobile/i.test(t)}function gL(t=mo()){return/android/i.test(t)}function yL(t=mo()){return/blackberry/i.test(t)}function wL(t=mo()){return/webos/i.test(t)}function kC(t=mo()){return/iphone|ipad|ipod/i.test(t)||/macintosh/i.test(t)&&/mobile/i.test(t)}function nZ(t=mo()){return kC(t)&&!!window.navigator?.standalone}function rZ(){return mQ()&&document.documentMode===10}function vL(t=mo()){return kC(t)||gL(t)||wL(t)||yL(t)||/windows phone/i.test(t)||mL(t)}function bL(t,e=[]){let n;switch(t){case"Browser":n=KD(mo());break;case"Worker":n=`${KD(mo())}-${t}`;break;default:n=t}const r=e.length?e.join(","):"FirebaseCore-web";return`${n}/JsCore/${eg}/${r}`}class sZ{constructor(e){this.auth=e,this.queue=[]}pushCallback(e,n){const r=i=>new Promise((o,a)=>{try{const l=e(i);o(l)}catch(l){a(l)}});r.onAbort=n,this.queue.push(r);const s=this.queue.length-1;return()=>{this.queue[s]=()=>Promise.resolve()}}async runMiddleware(e){if(this.auth.currentUser===e)return;const n=[];try{for(const r of this.queue)await r(e),r.onAbort&&n.push(r.onAbort)}catch(r){n.reverse();for(const s of n)try{s()}catch{}throw this.auth._errorFactory.create("login-blocked",{originalMessage:r?.message})}}}async function iZ(t,e={}){return mc(t,"GET","/v2/passwordPolicy",Bh(t,e))}const oZ=6;class aZ{constructor(e){const n=e.customStrengthOptions;this.customStrengthOptions={},this.customStrengthOptions.minPasswordLength=n.minPasswordLength??oZ,n.maxPasswordLength&&(this.customStrengthOptions.maxPasswordLength=n.maxPasswordLength),n.containsLowercaseCharacter!==void 0&&(this.customStrengthOptions.containsLowercaseLetter=n.containsLowercaseCharacter),n.containsUppercaseCharacter!==void 0&&(this.customStrengthOptions.containsUppercaseLetter=n.containsUppercaseCharacter),n.containsNumericCharacter!==void 0&&(this.customStrengthOptions.containsNumericCharacter=n.containsNumericCharacter),n.containsNonAlphanumericCharacter!==void 0&&(this.customStrengthOptions.containsNonAlphanumericCharacter=n.containsNonAlphanumericCharacter),this.enforcementState=e.enforcementState,this.enforcementState==="ENFORCEMENT_STATE_UNSPECIFIED"&&(this.enforcementState="OFF"),this.allowedNonAlphanumericCharacters=e.allowedNonAlphanumericCharacters?.join("")??"",this.forceUpgradeOnSignin=e.forceUpgradeOnSignin??!1,this.schemaVersion=e.schemaVersion}validatePassword(e){const n={isValid:!0,passwordPolicy:this};return this.validatePasswordLengthOptions(e,n),this.validatePasswordCharacterOptions(e,n),n.isValid&&(n.isValid=n.meetsMinPasswordLength??!0),n.isValid&&(n.isValid=n.meetsMaxPasswordLength??!0),n.isValid&&(n.isValid=n.containsLowercaseLetter??!0),n.isValid&&(n.isValid=n.containsUppercaseLetter??!0),n.isValid&&(n.isValid=n.containsNumericCharacter??!0),n.isValid&&(n.isValid=n.containsNonAlphanumericCharacter??!0),n}validatePasswordLengthOptions(e,n){const r=this.customStrengthOptions.minPasswordLength,s=this.customStrengthOptions.maxPasswordLength;r&&(n.meetsMinPasswordLength=e.length>=r),s&&(n.meetsMaxPasswordLength=e.length<=s)}validatePasswordCharacterOptions(e,n){this.updatePasswordCharacterOptionsStatuses(n,!1,!1,!1,!1);let r;for(let s=0;s<e.length;s++)r=e.charAt(s),this.updatePasswordCharacterOptionsStatuses(n,r>="a"&&r<="z",r>="A"&&r<="Z",r>="0"&&r<="9",this.allowedNonAlphanumericCharacters.includes(r))}updatePasswordCharacterOptionsStatuses(e,n,r,s,i){this.customStrengthOptions.containsLowercaseLetter&&(e.containsLowercaseLetter||(e.containsLowercaseLetter=n)),this.customStrengthOptions.containsUppercaseLetter&&(e.containsUppercaseLetter||(e.containsUppercaseLetter=r)),this.customStrengthOptions.containsNumericCharacter&&(e.containsNumericCharacter||(e.containsNumericCharacter=s)),this.customStrengthOptions.containsNonAlphanumericCharacter&&(e.containsNonAlphanumericCharacter||(e.containsNonAlphanumericCharacter=i))}}class lZ{constructor(e,n,r,s){this.app=e,this.heartbeatServiceProvider=n,this.appCheckServiceProvider=r,this.config=s,this.currentUser=null,this.emulatorConfig=null,this.operations=Promise.resolve(),this.authStateSubscription=new XD(this),this.idTokenSubscription=new XD(this),this.beforeStateQueue=new sZ(this),this.redirectUser=null,this.isProactiveRefreshEnabled=!1,this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION=1,this._canInitEmulator=!0,this._isInitialized=!1,this._deleted=!1,this._initializationPromise=null,this._popupRedirectResolver=null,this._errorFactory=iL,this._agentRecaptchaConfig=null,this._tenantRecaptchaConfigs={},this._projectPasswordPolicy=null,this._tenantPasswordPolicies={},this._resolvePersistenceManagerAvailable=void 0,this.lastNotifiedUid=void 0,this.languageCode=null,this.tenantId=null,this.settings={appVerificationDisabledForTesting:!1},this.frameworks=[],this.name=e.name,this.clientVersion=s.sdkClientVersion,this._persistenceManagerAvailable=new Promise(i=>this._resolvePersistenceManagerAvailable=i)}_initializeWithPersistence(e,n){return n&&(this._popupRedirectResolver=Yu(n)),this._initializationPromise=this.queue(async()=>{if(!this._deleted&&(this.persistenceManager=await bm.create(this,e),this._resolvePersistenceManagerAvailable?.(),!this._deleted)){if(this._popupRedirectResolver?._shouldInitProactively)try{await this._popupRedirectResolver._initialize(this)}catch{}await this.initializeCurrentUser(n),this.lastNotifiedUid=this.currentUser?.uid||null,!this._deleted&&(this._isInitialized=!0)}}),this._initializationPromise}async _onStorageEvent(){if(this._deleted)return;const e=await this.assertedPersistence.getCurrentUser();if(!(!this.currentUser&&!e)){if(this.currentUser&&e&&this.currentUser.uid===e.uid){this._currentUser._assign(e),await this.currentUser.getIdToken();return}await this._updateCurrentUser(e,!0)}}async initializeCurrentUserFromIdToken(e){try{const n=await fb(this,{idToken:e}),r=await kl._fromGetAccountInfoResponse(this,n,e);await this.directlySetCurrentUser(r)}catch(n){console.warn("FirebaseServerApp could not login user with provided authIdToken: ",n),await this.directlySetCurrentUser(null)}}async initializeCurrentUser(e){if(Ja(this.app)){const i=this.app.settings.authIdToken;return i?new Promise(o=>{setTimeout(()=>this.initializeCurrentUserFromIdToken(i).then(o,o))}):this.directlySetCurrentUser(null)}const n=await this.assertedPersistence.getCurrentUser();let r=n,s=!1;if(e&&this.config.authDomain){await this.getOrInitRedirectPersistenceManager();const i=this.redirectUser?._redirectEventId,o=r?._redirectEventId,a=await this.tryRedirectSignIn(e);(!i||i===o)&&a?.user&&(r=a.user,s=!0)}if(!r)return this.directlySetCurrentUser(null);if(!r._redirectEventId){if(s)try{await this.beforeStateQueue.runMiddleware(r)}catch(i){r=n,this._popupRedirectResolver._overrideRedirectResult(this,()=>Promise.reject(i))}return r?this.reloadAndSetCurrentUserOrClear(r):this.directlySetCurrentUser(null)}return fn(this._popupRedirectResolver,this,"argument-error"),await this.getOrInitRedirectPersistenceManager(),this.redirectUser&&this.redirectUser._redirectEventId===r._redirectEventId?this.directlySetCurrentUser(r):this.reloadAndSetCurrentUserOrClear(r)}async tryRedirectSignIn(e){let n=null;try{n=await this._popupRedirectResolver._completeRedirectFn(this,e,!0)}catch{await this._setRedirectUser(null)}return n}async reloadAndSetCurrentUserOrClear(e){try{await pb(e)}catch(n){if(n?.code!=="auth/network-request-failed")return this.directlySetCurrentUser(null)}return this.directlySetCurrentUser(e)}useDeviceLanguage(){this.languageCode=VJ()}async _delete(){this._deleted=!0}async updateCurrentUser(e){if(Ja(this.app))return Promise.reject(Zu(this));const n=e?sa(e):null;return n&&fn(n.auth.config.apiKey===this.config.apiKey,this,"invalid-user-token"),this._updateCurrentUser(n&&n._clone(this))}async _updateCurrentUser(e,n=!1){if(!this._deleted)return e&&fn(this.tenantId===e.tenantId,this,"tenant-id-mismatch"),n||await this.beforeStateQueue.runMiddleware(e),this.queue(async()=>{await this.directlySetCurrentUser(e),this.notifyAuthListeners()})}async signOut(){return Ja(this.app)?Promise.reject(Zu(this)):(await this.beforeStateQueue.runMiddleware(null),(this.redirectPersistenceManager||this._popupRedirectResolver)&&await this._setRedirectUser(null),this._updateCurrentUser(null,!0))}setPersistence(e){return Ja(this.app)?Promise.reject(Zu(this)):this.queue(async()=>{await this.assertedPersistence.setPersistence(Yu(e))})}_getRecaptchaConfig(){return this.tenantId==null?this._agentRecaptchaConfig:this._tenantRecaptchaConfigs[this.tenantId]}async validatePassword(e){this._getPasswordPolicyInternal()||await this._updatePasswordPolicy();const n=this._getPasswordPolicyInternal();return n.schemaVersion!==this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION?Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version",{})):n.validatePassword(e)}_getPasswordPolicyInternal(){return this.tenantId===null?this._projectPasswordPolicy:this._tenantPasswordPolicies[this.tenantId]}async _updatePasswordPolicy(){const e=await iZ(this),n=new aZ(e);this.tenantId===null?this._projectPasswordPolicy=n:this._tenantPasswordPolicies[this.tenantId]=n}_getPersistenceType(){return this.assertedPersistence.persistence.type}_getPersistence(){return this.assertedPersistence.persistence}_updateErrorMap(e){this._errorFactory=new Gy("auth","Firebase",e())}onAuthStateChanged(e,n,r){return this.registerStateListener(this.authStateSubscription,e,n,r)}beforeAuthStateChanged(e,n){return this.beforeStateQueue.pushCallback(e,n)}onIdTokenChanged(e,n,r){return this.registerStateListener(this.idTokenSubscription,e,n,r)}authStateReady(){return new Promise((e,n)=>{if(this.currentUser)e();else{const r=this.onAuthStateChanged(()=>{r(),e()},n)}})}async revokeAccessToken(e){if(this.currentUser){const n=await this.currentUser.getIdToken(),r={providerId:"apple.com",tokenType:"ACCESS_TOKEN",token:e,idToken:n};this.tenantId!=null&&(r.tenantId=this.tenantId),await tZ(this,r)}}toJSON(){return{apiKey:this.config.apiKey,authDomain:this.config.authDomain,appName:this.name,currentUser:this._currentUser?.toJSON()}}async _setRedirectUser(e,n){const r=await this.getOrInitRedirectPersistenceManager(n);return e===null?r.removeCurrentUser():r.setCurrentUser(e)}async getOrInitRedirectPersistenceManager(e){if(!this.redirectPersistenceManager){const n=e&&Yu(e)||this._popupRedirectResolver;fn(n,this,"argument-error"),this.redirectPersistenceManager=await bm.create(this,[Yu(n._redirectPersistence)],"redirectUser"),this.redirectUser=await this.redirectPersistenceManager.getCurrentUser()}return this.redirectPersistenceManager}async _redirectUserForId(e){return this._isInitialized&&await this.queue(async()=>{}),this._currentUser?._redirectEventId===e?this._currentUser:this.redirectUser?._redirectEventId===e?this.redirectUser:null}async _persistUserIfCurrent(e){if(e===this.currentUser)return this.queue(async()=>this.directlySetCurrentUser(e))}_notifyListenersIfCurrent(e){e===this.currentUser&&this.notifyAuthListeners()}_key(){return`${this.config.authDomain}:${this.config.apiKey}:${this.name}`}_startProactiveRefresh(){this.isProactiveRefreshEnabled=!0,this.currentUser&&this._currentUser._startProactiveRefresh()}_stopProactiveRefresh(){this.isProactiveRefreshEnabled=!1,this.currentUser&&this._currentUser._stopProactiveRefresh()}get _currentUser(){return this.currentUser}notifyAuthListeners(){if(!this._isInitialized)return;this.idTokenSubscription.next(this.currentUser);const e=this.currentUser?.uid??null;this.lastNotifiedUid!==e&&(this.lastNotifiedUid=e,this.authStateSubscription.next(this.currentUser))}registerStateListener(e,n,r,s){if(this._deleted)return()=>{};const i=typeof n=="function"?n:n.next.bind(n);let o=!1;const a=this._isInitialized?Promise.resolve():this._initializationPromise;if(fn(a,this,"internal-error"),a.then(()=>{o||i(this.currentUser)}),typeof n=="function"){const l=e.addObserver(n,r,s);return()=>{o=!0,l()}}else{const l=e.addObserver(n);return()=>{o=!0,l()}}}async directlySetCurrentUser(e){this.currentUser&&this.currentUser!==e&&this._currentUser._stopProactiveRefresh(),e&&this.isProactiveRefreshEnabled&&e._startProactiveRefresh(),this.currentUser=e,e?await this.assertedPersistence.setCurrentUser(e):await this.assertedPersistence.removeCurrentUser()}queue(e){return this.operations=this.operations.then(e,e),this.operations}get assertedPersistence(){return fn(this.persistenceManager,this,"internal-error"),this.persistenceManager}_logFramework(e){!e||this.frameworks.includes(e)||(this.frameworks.push(e),this.frameworks.sort(),this.clientVersion=bL(this.config.clientPlatform,this._getFrameworks()))}_getFrameworks(){return this.frameworks}async _getAdditionalHeaders(){const e={"X-Client-Version":this.clientVersion};this.app.options.appId&&(e["X-Firebase-gmpid"]=this.app.options.appId);const n=await this.heartbeatServiceProvider.getImmediate({optional:!0})?.getHeartbeatsHeader();n&&(e["X-Firebase-Client"]=n);const r=await this._getAppCheckToken();return r&&(e["X-Firebase-AppCheck"]=r),e}async _getAppCheckToken(){if(Ja(this.app)&&this.app.settings.appCheckToken)return this.app.settings.appCheckToken;const e=await this.appCheckServiceProvider.getImmediate({optional:!0})?.getToken();return e?.error&&LJ(`Error while retrieving App Check token: ${e.error}`),e?.token}}function yf(t){return sa(t)}class XD{constructor(e){this.auth=e,this.observer=null,this.addObserver=IQ(n=>this.observer=n)}get next(){return fn(this.observer,this.auth,"internal-error"),this.observer.next.bind(this.observer)}}let fx={async loadJS(){throw new Error("Unable to load external scripts")},recaptchaV2Script:"",recaptchaEnterpriseScript:"",gapiScript:""};function uZ(t){fx=t}function xL(t){return fx.loadJS(t)}function cZ(){return fx.recaptchaEnterpriseScript}function hZ(){return fx.gapiScript}function dZ(t){return`__${t}${Math.floor(Math.random()*1e6)}`}class fZ{constructor(){this.enterprise=new pZ}ready(e){e()}execute(e,n){return Promise.resolve("token")}render(e,n){return""}}class pZ{ready(e){e()}execute(e,n){return Promise.resolve("token")}render(e,n){return""}}const mZ="recaptcha-enterprise",_L="NO_RECAPTCHA";class gZ{constructor(e){this.type=mZ,this.auth=yf(e)}async verify(e="verify",n=!1){async function r(i){if(!n){if(i.tenantId==null&&i._agentRecaptchaConfig!=null)return i._agentRecaptchaConfig.siteKey;if(i.tenantId!=null&&i._tenantRecaptchaConfigs[i.tenantId]!==void 0)return i._tenantRecaptchaConfigs[i.tenantId].siteKey}return new Promise(async(o,a)=>{qJ(i,{clientType:"CLIENT_TYPE_WEB",version:"RECAPTCHA_ENTERPRISE"}).then(l=>{if(l.recaptchaKey===void 0)a(new Error("recaptcha Enterprise site key undefined"));else{const u=new HJ(l);return i.tenantId==null?i._agentRecaptchaConfig=u:i._tenantRecaptchaConfigs[i.tenantId]=u,o(u.siteKey)}}).catch(l=>{a(l)})})}function s(i,o,a){const l=window.grecaptcha;jD(l)?l.enterprise.ready(()=>{l.enterprise.execute(i,{action:e}).then(u=>{o(u)}).catch(()=>{o(_L)})}):a(Error("No reCAPTCHA enterprise script loaded."))}return this.auth.settings.appVerificationDisabledForTesting?new fZ().execute("siteKey",{action:"verify"}):new Promise((i,o)=>{r(this.auth).then(a=>{if(!n&&jD(window.grecaptcha))s(a,i,o);else{if(typeof window>"u"){o(new Error("RecaptchaVerifier is only supported in browser"));return}let l=cZ();l.length!==0&&(l+=a),xL(l).then(()=>{s(a,i,o)}).catch(u=>{o(u)})}}).catch(a=>{o(a)})})}}async function YD(t,e,n,r=!1,s=!1){const i=new gZ(t);let o;if(s)o=_L;else try{o=await i.verify(n)}catch{o=await i.verify(n,!0)}const a={...e};if(n==="mfaSmsEnrollment"||n==="mfaSmsSignIn"){if("phoneEnrollmentInfo"in a){const l=a.phoneEnrollmentInfo.phoneNumber,u=a.phoneEnrollmentInfo.recaptchaToken;Object.assign(a,{phoneEnrollmentInfo:{phoneNumber:l,recaptchaToken:u,captchaResponse:o,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}else if("phoneSignInInfo"in a){const l=a.phoneSignInInfo.recaptchaToken;Object.assign(a,{phoneSignInInfo:{recaptchaToken:l,captchaResponse:o,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}return a}return r?Object.assign(a,{captchaResp:o}):Object.assign(a,{captchaResponse:o}),Object.assign(a,{clientType:"CLIENT_TYPE_WEB"}),Object.assign(a,{recaptchaVersion:"RECAPTCHA_ENTERPRISE"}),a}async function HS(t,e,n,r,s){if(t._getRecaptchaConfig()?.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")){const i=await YD(t,e,n,n==="getOobCode");return r(t,i)}else return r(t,e).catch(async i=>{if(i.code==="auth/missing-recaptcha-token"){console.log(`${n} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);const o=await YD(t,e,n,n==="getOobCode");return r(t,o)}else return Promise.reject(i)})}function yZ(t,e){const n=SC(t,"auth");if(n.isInitialized()){const s=n.getImmediate(),i=n.getOptions();if(zd(i,e??{}))return s;Fl(s,"already-initialized")}return n.initialize({options:e})}function wZ(t,e){const n=e?.persistence||[],r=(Array.isArray(n)?n:[n]).map(Yu);e?.errorMap&&t._updateErrorMap(e.errorMap),t._initializeWithPersistence(r,e?.popupRedirectResolver)}function vZ(t,e,n){const r=yf(t);fn(/^https?:\/\//.test(e),r,"invalid-emulator-scheme");const s=!1,i=IL(e),{host:o,port:a}=bZ(e),l=a===null?"":`:${a}`,u={url:`${i}//${o}${l}/`},c=Object.freeze({host:o,port:a,protocol:i.replace(":",""),options:Object.freeze({disableWarnings:s})});if(!r._canInitEmulator){fn(r.config.emulator&&r.emulatorConfig,r,"emulator-config-failed"),fn(zd(u,r.config.emulator)&&zd(c,r.emulatorConfig),r,"emulator-config-failed");return}r.config.emulator=u,r.emulatorConfig=c,r.settings.appVerificationDisabledForTesting=!0,Zm(o)?(YF(`${i}//${o}${l}`),QF("Auth",!0)):xZ()}function IL(t){const e=t.indexOf(":");return e<0?"":t.substr(0,e+1)}function bZ(t){const e=IL(t),n=/(\/\/)?([^?#/]+)/.exec(t.substr(e.length));if(!n)return{host:"",port:null};const r=n[2].split("@").pop()||"",s=/^(\[[^\]]+\])(:|$)/.exec(r);if(s){const i=s[1];return{host:i,port:QD(r.substr(i.length+1))}}else{const[i,o]=r.split(":");return{host:i,port:QD(o)}}}function QD(t){if(!t)return null;const e=Number(t);return isNaN(e)?null:e}function xZ(){function t(){const e=document.createElement("p"),n=e.style;e.innerText="Running in emulator mode. Do not use with production credentials.",n.position="fixed",n.width="100%",n.backgroundColor="#ffffff",n.border=".1em solid #000000",n.color="#b50000",n.bottom="0px",n.left="0px",n.margin="0px",n.zIndex="10000",n.textAlign="center",e.classList.add("firebase-emulator-warning"),document.body.appendChild(e)}typeof console<"u"&&typeof console.info=="function"&&console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."),typeof window<"u"&&typeof document<"u"&&(document.readyState==="loading"?window.addEventListener("DOMContentLoaded",t):t())}class NC{constructor(e,n){this.providerId=e,this.signInMethod=n}toJSON(){return Xu("not implemented")}_getIdTokenResponse(e){return Xu("not implemented")}_linkToIdToken(e,n){return Xu("not implemented")}_getReauthenticationResolver(e){return Xu("not implemented")}}async function _Z(t,e){return mc(t,"POST","/v1/accounts:signUp",e)}async function IZ(t,e){return Ky(t,"POST","/v1/accounts:signInWithPassword",Bh(t,e))}async function TZ(t,e){return Ky(t,"POST","/v1/accounts:signInWithEmailLink",Bh(t,e))}async function SZ(t,e){return Ky(t,"POST","/v1/accounts:signInWithEmailLink",Bh(t,e))}class my extends NC{constructor(e,n,r,s=null){super("password",r),this._email=e,this._password=n,this._tenantId=s}static _fromEmailAndPassword(e,n){return new my(e,n,"password")}static _fromEmailAndCode(e,n,r=null){return new my(e,n,"emailLink",r)}toJSON(){return{email:this._email,password:this._password,signInMethod:this.signInMethod,tenantId:this._tenantId}}static fromJSON(e){const n=typeof e=="string"?JSON.parse(e):e;if(n?.email&&n?.password){if(n.signInMethod==="password")return this._fromEmailAndPassword(n.email,n.password);if(n.signInMethod==="emailLink")return this._fromEmailAndCode(n.email,n.password,n.tenantId)}return null}async _getIdTokenResponse(e){switch(this.signInMethod){case"password":const n={returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return HS(e,n,"signInWithPassword",IZ);case"emailLink":return TZ(e,{email:this._email,oobCode:this._password});default:Fl(e,"internal-error")}}async _linkToIdToken(e,n){switch(this.signInMethod){case"password":const r={idToken:n,returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return HS(e,r,"signUpPassword",_Z);case"emailLink":return SZ(e,{idToken:n,email:this._email,oobCode:this._password});default:Fl(e,"internal-error")}}_getReauthenticationResolver(e){return this._getIdTokenResponse(e)}}async function xm(t,e){return Ky(t,"POST","/v1/accounts:signInWithIdp",Bh(t,e))}const $Z="http://localhost";class Bd extends NC{constructor(){super(...arguments),this.pendingToken=null}static _fromParams(e){const n=new Bd(e.providerId,e.signInMethod);return e.idToken||e.accessToken?(e.idToken&&(n.idToken=e.idToken),e.accessToken&&(n.accessToken=e.accessToken),e.nonce&&!e.pendingToken&&(n.nonce=e.nonce),e.pendingToken&&(n.pendingToken=e.pendingToken)):e.oauthToken&&e.oauthTokenSecret?(n.accessToken=e.oauthToken,n.secret=e.oauthTokenSecret):Fl("argument-error"),n}toJSON(){return{idToken:this.idToken,accessToken:this.accessToken,secret:this.secret,nonce:this.nonce,pendingToken:this.pendingToken,providerId:this.providerId,signInMethod:this.signInMethod}}static fromJSON(e){const n=typeof e=="string"?JSON.parse(e):e,{providerId:r,signInMethod:s,...i}=n;if(!r||!s)return null;const o=new Bd(r,s);return o.idToken=i.idToken||void 0,o.accessToken=i.accessToken||void 0,o.secret=i.secret,o.nonce=i.nonce,o.pendingToken=i.pendingToken||null,o}_getIdTokenResponse(e){const n=this.buildRequest();return xm(e,n)}_linkToIdToken(e,n){const r=this.buildRequest();return r.idToken=n,xm(e,r)}_getReauthenticationResolver(e){const n=this.buildRequest();return n.autoCreate=!1,xm(e,n)}buildRequest(){const e={requestUri:$Z,returnSecureToken:!0};if(this.pendingToken)e.pendingToken=this.pendingToken;else{const n={};this.idToken&&(n.id_token=this.idToken),this.accessToken&&(n.access_token=this.accessToken),this.secret&&(n.oauth_token_secret=this.secret),n.providerId=this.providerId,this.nonce&&!this.pendingToken&&(n.nonce=this.nonce),e.postBody=Hy(n)}return e}}function CZ(t){switch(t){case"recoverEmail":return"RECOVER_EMAIL";case"resetPassword":return"PASSWORD_RESET";case"signIn":return"EMAIL_SIGNIN";case"verifyEmail":return"VERIFY_EMAIL";case"verifyAndChangeEmail":return"VERIFY_AND_CHANGE_EMAIL";case"revertSecondFactorAddition":return"REVERT_SECOND_FACTOR_ADDITION";default:return null}}function EZ(t){const e=V2(B2(t)).link,n=e?V2(B2(e)).deep_link_id:null,r=V2(B2(t)).deep_link_id;return(r?V2(B2(r)).link:null)||r||n||e||t}class AC{constructor(e){const n=V2(B2(e)),r=n.apiKey??null,s=n.oobCode??null,i=CZ(n.mode??null);fn(r&&s&&i,"argument-error"),this.apiKey=r,this.operation=i,this.code=s,this.continueUrl=n.continueUrl??null,this.languageCode=n.lang??null,this.tenantId=n.tenantId??null}static parseLink(e){const n=EZ(e);try{return new AC(n)}catch{return null}}}class tg{constructor(){this.providerId=tg.PROVIDER_ID}static credential(e,n){return my._fromEmailAndPassword(e,n)}static credentialWithLink(e,n){const r=AC.parseLink(n);return fn(r,"argument-error"),my._fromEmailAndCode(e,r.code,r.tenantId)}}tg.PROVIDER_ID="password";tg.EMAIL_PASSWORD_SIGN_IN_METHOD="password";tg.EMAIL_LINK_SIGN_IN_METHOD="emailLink";class TL{constructor(e){this.providerId=e,this.defaultLanguageCode=null,this.customParameters={}}setDefaultLanguage(e){this.defaultLanguageCode=e}setCustomParameters(e){return this.customParameters=e,this}getCustomParameters(){return this.customParameters}}class Xy extends TL{constructor(){super(...arguments),this.scopes=[]}addScope(e){return this.scopes.includes(e)||this.scopes.push(e),this}getScopes(){return[...this.scopes]}}class Zc extends Xy{constructor(){super("facebook.com")}static credential(e){return Bd._fromParams({providerId:Zc.PROVIDER_ID,signInMethod:Zc.FACEBOOK_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return Zc.credentialFromTaggedObject(e)}static credentialFromError(e){return Zc.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e||!("oauthAccessToken"in e)||!e.oauthAccessToken)return null;try{return Zc.credential(e.oauthAccessToken)}catch{return null}}}Zc.FACEBOOK_SIGN_IN_METHOD="facebook.com";Zc.PROVIDER_ID="facebook.com";class eh extends Xy{constructor(){super("google.com"),this.addScope("profile")}static credential(e,n){return Bd._fromParams({providerId:eh.PROVIDER_ID,signInMethod:eh.GOOGLE_SIGN_IN_METHOD,idToken:e,accessToken:n})}static credentialFromResult(e){return eh.credentialFromTaggedObject(e)}static credentialFromError(e){return eh.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e)return null;const{oauthIdToken:n,oauthAccessToken:r}=e;if(!n&&!r)return null;try{return eh.credential(n,r)}catch{return null}}}eh.GOOGLE_SIGN_IN_METHOD="google.com";eh.PROVIDER_ID="google.com";class th extends Xy{constructor(){super("github.com")}static credential(e){return Bd._fromParams({providerId:th.PROVIDER_ID,signInMethod:th.GITHUB_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return th.credentialFromTaggedObject(e)}static credentialFromError(e){return th.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e||!("oauthAccessToken"in e)||!e.oauthAccessToken)return null;try{return th.credential(e.oauthAccessToken)}catch{return null}}}th.GITHUB_SIGN_IN_METHOD="github.com";th.PROVIDER_ID="github.com";class nh extends Xy{constructor(){super("twitter.com")}static credential(e,n){return Bd._fromParams({providerId:nh.PROVIDER_ID,signInMethod:nh.TWITTER_SIGN_IN_METHOD,oauthToken:e,oauthTokenSecret:n})}static credentialFromResult(e){return nh.credentialFromTaggedObject(e)}static credentialFromError(e){return nh.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e)return null;const{oauthAccessToken:n,oauthTokenSecret:r}=e;if(!n||!r)return null;try{return nh.credential(n,r)}catch{return null}}}nh.TWITTER_SIGN_IN_METHOD="twitter.com";nh.PROVIDER_ID="twitter.com";async function kZ(t,e){return Ky(t,"POST","/v1/accounts:signUp",Bh(t,e))}class Ud{constructor(e){this.user=e.user,this.providerId=e.providerId,this._tokenResponse=e._tokenResponse,this.operationType=e.operationType}static async _fromIdTokenResponse(e,n,r,s=!1){const i=await kl._fromIdTokenResponse(e,r,s),o=JD(r);return new Ud({user:i,providerId:o,_tokenResponse:r,operationType:n})}static async _forOperation(e,n,r){await e._updateTokensIfNecessary(r,!0);const s=JD(r);return new Ud({user:e,providerId:s,_tokenResponse:r,operationType:n})}}function JD(t){return t.providerId?t.providerId:"phoneNumber"in t?"phone":null}class mb extends pc{constructor(e,n,r,s){super(n.code,n.message),this.operationType=r,this.user=s,Object.setPrototypeOf(this,mb.prototype),this.customData={appName:e.name,tenantId:e.tenantId??void 0,_serverResponse:n.customData._serverResponse,operationType:r}}static _fromErrorAndOperation(e,n,r,s){return new mb(e,n,r,s)}}function SL(t,e,n,r){return(e==="reauthenticate"?n._getReauthenticationResolver(t):n._getIdTokenResponse(t)).catch(i=>{throw i.code==="auth/multi-factor-auth-required"?mb._fromErrorAndOperation(t,i,e,r):i})}async function NZ(t,e,n=!1){const r=await Em(t,e._linkToIdToken(t.auth,await t.getIdToken()),n);return Ud._forOperation(t,"link",r)}async function AZ(t,e,n=!1){const{auth:r}=t;if(Ja(r.app))return Promise.reject(Zu(r));const s="reauthenticate";try{const i=await Em(t,SL(r,s,e,t),n);fn(i.idToken,r,"internal-error");const o=EC(i.idToken);fn(o,r,"internal-error");const{sub:a}=o;return fn(t.uid===a,r,"user-mismatch"),Ud._forOperation(t,s,i)}catch(i){throw i?.code==="auth/user-not-found"&&Fl(r,"user-mismatch"),i}}async function $L(t,e,n=!1){if(Ja(t.app))return Promise.reject(Zu(t));const r="signIn",s=await SL(t,r,e),i=await Ud._fromIdTokenResponse(t,r,s);return n||await t._updateCurrentUser(i.user),i}async function RZ(t,e){return $L(yf(t),e)}async function CL(t){const e=yf(t);e._getPasswordPolicyInternal()&&await e._updatePasswordPolicy()}async function DZ(t,e,n){if(Ja(t.app))return Promise.reject(Zu(t));const r=yf(t),o=await HS(r,{returnSecureToken:!0,email:e,password:n,clientType:"CLIENT_TYPE_WEB"},"signUpPassword",kZ).catch(l=>{throw l.code==="auth/password-does-not-meet-requirements"&&CL(t),l}),a=await Ud._fromIdTokenResponse(r,"signIn",o);return await r._updateCurrentUser(a.user),a}function OZ(t,e,n){return Ja(t.app)?Promise.reject(Zu(t)):RZ(sa(t),tg.credential(e,n)).catch(async r=>{throw r.code==="auth/password-does-not-meet-requirements"&&CL(t),r})}async function PZ(t,e){return mc(t,"POST","/v1/accounts:update",e)}async function FZ(t,{displayName:e,photoURL:n}){if(e===void 0&&n===void 0)return;const r=sa(t),i={idToken:await r.getIdToken(),displayName:e,photoUrl:n,returnSecureToken:!0},o=await Em(r,PZ(r.auth,i));r.displayName=o.displayName||null,r.photoURL=o.photoUrl||null;const a=r.providerData.find(({providerId:l})=>l==="password");a&&(a.displayName=r.displayName,a.photoURL=r.photoURL),await r._updateTokensIfNecessary(o)}function LZ(t,e,n,r){return sa(t).onIdTokenChanged(e,n,r)}function MZ(t,e,n){return sa(t).beforeAuthStateChanged(e,n)}const gb="__sak";class EL{constructor(e,n){this.storageRetriever=e,this.type=n}_isAvailable(){try{return this.storage?(this.storage.setItem(gb,"1"),this.storage.removeItem(gb),Promise.resolve(!0)):Promise.resolve(!1)}catch{return Promise.resolve(!1)}}_set(e,n){return this.storage.setItem(e,JSON.stringify(n)),Promise.resolve()}_get(e){const n=this.storage.getItem(e);return Promise.resolve(n?JSON.parse(n):null)}_remove(e){return this.storage.removeItem(e),Promise.resolve()}get storage(){return this.storageRetriever()}}const zZ=1e3,VZ=10;class kL extends EL{constructor(){super(()=>window.localStorage,"LOCAL"),this.boundEventHandler=(e,n)=>this.onStorageEvent(e,n),this.listeners={},this.localCache={},this.pollTimer=null,this.fallbackToPolling=vL(),this._shouldAllowMigration=!0}forAllChangedKeys(e){for(const n of Object.keys(this.listeners)){const r=this.storage.getItem(n),s=this.localCache[n];r!==s&&e(n,s,r)}}onStorageEvent(e,n=!1){if(!e.key){this.forAllChangedKeys((o,a,l)=>{this.notifyListeners(o,l)});return}const r=e.key;n?this.detachListener():this.stopPolling();const s=()=>{const o=this.storage.getItem(r);!n&&this.localCache[r]===o||this.notifyListeners(r,o)},i=this.storage.getItem(r);rZ()&&i!==e.newValue&&e.newValue!==e.oldValue?setTimeout(s,VZ):s()}notifyListeners(e,n){this.localCache[e]=n;const r=this.listeners[e];if(r)for(const s of Array.from(r))s(n&&JSON.parse(n))}startPolling(){this.stopPolling(),this.pollTimer=setInterval(()=>{this.forAllChangedKeys((e,n,r)=>{this.onStorageEvent(new StorageEvent("storage",{key:e,oldValue:n,newValue:r}),!0)})},zZ)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}attachListener(){window.addEventListener("storage",this.boundEventHandler)}detachListener(){window.removeEventListener("storage",this.boundEventHandler)}_addListener(e,n){Object.keys(this.listeners).length===0&&(this.fallbackToPolling?this.startPolling():this.attachListener()),this.listeners[e]||(this.listeners[e]=new Set,this.localCache[e]=this.storage.getItem(e)),this.listeners[e].add(n)}_removeListener(e,n){this.listeners[e]&&(this.listeners[e].delete(n),this.listeners[e].size===0&&delete this.listeners[e]),Object.keys(this.listeners).length===0&&(this.detachListener(),this.stopPolling())}async _set(e,n){await super._set(e,n),this.localCache[e]=JSON.stringify(n)}async _get(e){const n=await super._get(e);return this.localCache[e]=JSON.stringify(n),n}async _remove(e){await super._remove(e),delete this.localCache[e]}}kL.type="LOCAL";const BZ=kL;class NL extends EL{constructor(){super(()=>window.sessionStorage,"SESSION")}_addListener(e,n){}_removeListener(e,n){}}NL.type="SESSION";const AL=NL;function UZ(t){return Promise.all(t.map(async e=>{try{return{fulfilled:!0,value:await e}}catch(n){return{fulfilled:!1,reason:n}}}))}class px{constructor(e){this.eventTarget=e,this.handlersMap={},this.boundEventHandler=this.handleEvent.bind(this)}static _getInstance(e){const n=this.receivers.find(s=>s.isListeningto(e));if(n)return n;const r=new px(e);return this.receivers.push(r),r}isListeningto(e){return this.eventTarget===e}async handleEvent(e){const n=e,{eventId:r,eventType:s,data:i}=n.data,o=this.handlersMap[s];if(!o?.size)return;n.ports[0].postMessage({status:"ack",eventId:r,eventType:s});const a=Array.from(o).map(async u=>u(n.origin,i)),l=await UZ(a);n.ports[0].postMessage({status:"done",eventId:r,eventType:s,response:l})}_subscribe(e,n){Object.keys(this.handlersMap).length===0&&this.eventTarget.addEventListener("message",this.boundEventHandler),this.handlersMap[e]||(this.handlersMap[e]=new Set),this.handlersMap[e].add(n)}_unsubscribe(e,n){this.handlersMap[e]&&n&&this.handlersMap[e].delete(n),(!n||this.handlersMap[e].size===0)&&delete this.handlersMap[e],Object.keys(this.handlersMap).length===0&&this.eventTarget.removeEventListener("message",this.boundEventHandler)}}px.receivers=[];function RC(t="",e=10){let n="";for(let r=0;r<e;r++)n+=Math.floor(Math.random()*10);return t+n}class WZ{constructor(e){this.target=e,this.handlers=new Set}removeMessageHandler(e){e.messageChannel&&(e.messageChannel.port1.removeEventListener("message",e.onMessage),e.messageChannel.port1.close()),this.handlers.delete(e)}async _send(e,n,r=50){const s=typeof MessageChannel<"u"?new MessageChannel:null;if(!s)throw new Error("connection_unavailable");let i,o;return new Promise((a,l)=>{const u=RC("",20);s.port1.start();const c=setTimeout(()=>{l(new Error("unsupported_event"))},r);o={messageChannel:s,onMessage(d){const f=d;if(f.data.eventId===u)switch(f.data.status){case"ack":clearTimeout(c),i=setTimeout(()=>{l(new Error("timeout"))},3e3);break;case"done":clearTimeout(i),a(f.data.response);break;default:clearTimeout(c),clearTimeout(i),l(new Error("invalid_response"));break}}},this.handlers.add(o),s.port1.addEventListener("message",o.onMessage),this.target.postMessage({eventType:e,eventId:u,data:n},[s.port2])}).finally(()=>{o&&this.removeMessageHandler(o)})}}function uu(){return window}function jZ(t){uu().location.href=t}function RL(){return typeof uu().WorkerGlobalScope<"u"&&typeof uu().importScripts=="function"}async function GZ(){if(!navigator?.serviceWorker)return null;try{return(await navigator.serviceWorker.ready).active}catch{return null}}function HZ(){return navigator?.serviceWorker?.controller||null}function qZ(){return RL()?self:null}const DL="firebaseLocalStorageDb",KZ=1,yb="firebaseLocalStorage",OL="fbase_key";class Yy{constructor(e){this.request=e}toPromise(){return new Promise((e,n)=>{this.request.addEventListener("success",()=>{e(this.request.result)}),this.request.addEventListener("error",()=>{n(this.request.error)})})}}function mx(t,e){return t.transaction([yb],e?"readwrite":"readonly").objectStore(yb)}function XZ(){const t=indexedDB.deleteDatabase(DL);return new Yy(t).toPromise()}function qS(){const t=indexedDB.open(DL,KZ);return new Promise((e,n)=>{t.addEventListener("error",()=>{n(t.error)}),t.addEventListener("upgradeneeded",()=>{const r=t.result;try{r.createObjectStore(yb,{keyPath:OL})}catch(s){n(s)}}),t.addEventListener("success",async()=>{const r=t.result;r.objectStoreNames.contains(yb)?e(r):(r.close(),await XZ(),e(await qS()))})})}async function ZD(t,e,n){const r=mx(t,!0).put({[OL]:e,value:n});return new Yy(r).toPromise()}async function YZ(t,e){const n=mx(t,!1).get(e),r=await new Yy(n).toPromise();return r===void 0?null:r.value}function e5(t,e){const n=mx(t,!0).delete(e);return new Yy(n).toPromise()}const QZ=800,JZ=3;class PL{constructor(){this.type="LOCAL",this._shouldAllowMigration=!0,this.listeners={},this.localCache={},this.pollTimer=null,this.pendingWrites=0,this.receiver=null,this.sender=null,this.serviceWorkerReceiverAvailable=!1,this.activeServiceWorker=null,this._workerInitializationPromise=this.initializeServiceWorkerMessaging().then(()=>{},()=>{})}async _openDb(){return this.db?this.db:(this.db=await qS(),this.db)}async _withRetries(e){let n=0;for(;;)try{const r=await this._openDb();return await e(r)}catch(r){if(n++>JZ)throw r;this.db&&(this.db.close(),this.db=void 0)}}async initializeServiceWorkerMessaging(){return RL()?this.initializeReceiver():this.initializeSender()}async initializeReceiver(){this.receiver=px._getInstance(qZ()),this.receiver._subscribe("keyChanged",async(e,n)=>({keyProcessed:(await this._poll()).includes(n.key)})),this.receiver._subscribe("ping",async(e,n)=>["keyChanged"])}async initializeSender(){if(this.activeServiceWorker=await GZ(),!this.activeServiceWorker)return;this.sender=new WZ(this.activeServiceWorker);const e=await this.sender._send("ping",{},800);e&&e[0]?.fulfilled&&e[0]?.value.includes("keyChanged")&&(this.serviceWorkerReceiverAvailable=!0)}async notifyServiceWorker(e){if(!(!this.sender||!this.activeServiceWorker||HZ()!==this.activeServiceWorker))try{await this.sender._send("keyChanged",{key:e},this.serviceWorkerReceiverAvailable?800:50)}catch{}}async _isAvailable(){try{if(!indexedDB)return!1;const e=await qS();return await ZD(e,gb,"1"),await e5(e,gb),!0}catch{}return!1}async _withPendingWrite(e){this.pendingWrites++;try{await e()}finally{this.pendingWrites--}}async _set(e,n){return this._withPendingWrite(async()=>(await this._withRetries(r=>ZD(r,e,n)),this.localCache[e]=n,this.notifyServiceWorker(e)))}async _get(e){const n=await this._withRetries(r=>YZ(r,e));return this.localCache[e]=n,n}async _remove(e){return this._withPendingWrite(async()=>(await this._withRetries(n=>e5(n,e)),delete this.localCache[e],this.notifyServiceWorker(e)))}async _poll(){const e=await this._withRetries(s=>{const i=mx(s,!1).getAll();return new Yy(i).toPromise()});if(!e)return[];if(this.pendingWrites!==0)return[];const n=[],r=new Set;if(e.length!==0)for(const{fbase_key:s,value:i}of e)r.add(s),JSON.stringify(this.localCache[s])!==JSON.stringify(i)&&(this.notifyListeners(s,i),n.push(s));for(const s of Object.keys(this.localCache))this.localCache[s]&&!r.has(s)&&(this.notifyListeners(s,null),n.push(s));return n}notifyListeners(e,n){this.localCache[e]=n;const r=this.listeners[e];if(r)for(const s of Array.from(r))s(n)}startPolling(){this.stopPolling(),this.pollTimer=setInterval(async()=>this._poll(),QZ)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}_addListener(e,n){Object.keys(this.listeners).length===0&&this.startPolling(),this.listeners[e]||(this.listeners[e]=new Set,this._get(e)),this.listeners[e].add(n)}_removeListener(e,n){this.listeners[e]&&(this.listeners[e].delete(n),this.listeners[e].size===0&&delete this.listeners[e]),Object.keys(this.listeners).length===0&&this.stopPolling()}}PL.type="LOCAL";const ZZ=PL;new qy(3e4,6e4);function eee(t,e){return e?Yu(e):(fn(t._popupRedirectResolver,t,"argument-error"),t._popupRedirectResolver)}class DC extends NC{constructor(e){super("custom","custom"),this.params=e}_getIdTokenResponse(e){return xm(e,this._buildIdpRequest())}_linkToIdToken(e,n){return xm(e,this._buildIdpRequest(n))}_getReauthenticationResolver(e){return xm(e,this._buildIdpRequest())}_buildIdpRequest(e){const n={requestUri:this.params.requestUri,sessionId:this.params.sessionId,postBody:this.params.postBody,tenantId:this.params.tenantId,pendingToken:this.params.pendingToken,returnSecureToken:!0,returnIdpCredential:!0};return e&&(n.idToken=e),n}}function tee(t){return $L(t.auth,new DC(t),t.bypassAuthState)}function nee(t){const{auth:e,user:n}=t;return fn(n,e,"internal-error"),AZ(n,new DC(t),t.bypassAuthState)}async function ree(t){const{auth:e,user:n}=t;return fn(n,e,"internal-error"),NZ(n,new DC(t),t.bypassAuthState)}class FL{constructor(e,n,r,s,i=!1){this.auth=e,this.resolver=r,this.user=s,this.bypassAuthState=i,this.pendingPromise=null,this.eventManager=null,this.filter=Array.isArray(n)?n:[n]}execute(){return new Promise(async(e,n)=>{this.pendingPromise={resolve:e,reject:n};try{this.eventManager=await this.resolver._initialize(this.auth),await this.onExecution(),this.eventManager.registerConsumer(this)}catch(r){this.reject(r)}})}async onAuthEvent(e){const{urlResponse:n,sessionId:r,postBody:s,tenantId:i,error:o,type:a}=e;if(o){this.reject(o);return}const l={auth:this.auth,requestUri:n,sessionId:r,tenantId:i||void 0,postBody:s||void 0,user:this.user,bypassAuthState:this.bypassAuthState};try{this.resolve(await this.getIdpTask(a)(l))}catch(u){this.reject(u)}}onError(e){this.reject(e)}getIdpTask(e){switch(e){case"signInViaPopup":case"signInViaRedirect":return tee;case"linkViaPopup":case"linkViaRedirect":return ree;case"reauthViaPopup":case"reauthViaRedirect":return nee;default:Fl(this.auth,"internal-error")}}resolve(e){nc(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.resolve(e),this.unregisterAndCleanUp()}reject(e){nc(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.reject(e),this.unregisterAndCleanUp()}unregisterAndCleanUp(){this.eventManager&&this.eventManager.unregisterConsumer(this),this.pendingPromise=null,this.cleanUp()}}const see=new qy(2e3,1e4);class ym extends FL{constructor(e,n,r,s,i){super(e,n,s,i),this.provider=r,this.authWindow=null,this.pollId=null,ym.currentPopupAction&&ym.currentPopupAction.cancel(),ym.currentPopupAction=this}async executeNotNull(){const e=await this.execute();return fn(e,this.auth,"internal-error"),e}async onExecution(){nc(this.filter.length===1,"Popup operations only handle one event");const e=RC();this.authWindow=await this.resolver._openPopup(this.auth,this.provider,this.filter[0],e),this.authWindow.associatedEvent=e,this.resolver._originValidation(this.auth).catch(n=>{this.reject(n)}),this.resolver._isIframeWebStorageSupported(this.auth,n=>{n||this.reject(lu(this.auth,"web-storage-unsupported"))}),this.pollUserCancellation()}get eventId(){return this.authWindow?.associatedEvent||null}cancel(){this.reject(lu(this.auth,"cancelled-popup-request"))}cleanUp(){this.authWindow&&this.authWindow.close(),this.pollId&&window.clearTimeout(this.pollId),this.authWindow=null,this.pollId=null,ym.currentPopupAction=null}pollUserCancellation(){const e=()=>{if(this.authWindow?.window?.closed){this.pollId=window.setTimeout(()=>{this.pollId=null,this.reject(lu(this.auth,"popup-closed-by-user"))},8e3);return}this.pollId=window.setTimeout(e,see.get())};e()}}ym.currentPopupAction=null;const iee="pendingRedirect",Mv=new Map;class oee extends FL{constructor(e,n,r=!1){super(e,["signInViaRedirect","linkViaRedirect","reauthViaRedirect","unknown"],n,void 0,r),this.eventId=null}async execute(){let e=Mv.get(this.auth._key());if(!e){try{const r=await aee(this.resolver,this.auth)?await super.execute():null;e=()=>Promise.resolve(r)}catch(n){e=()=>Promise.reject(n)}Mv.set(this.auth._key(),e)}return this.bypassAuthState||Mv.set(this.auth._key(),()=>Promise.resolve(null)),e()}async onAuthEvent(e){if(e.type==="signInViaRedirect")return super.onAuthEvent(e);if(e.type==="unknown"){this.resolve(null);return}if(e.eventId){const n=await this.auth._redirectUserForId(e.eventId);if(n)return this.user=n,super.onAuthEvent(e);this.resolve(null)}}async onExecution(){}cleanUp(){}}async function aee(t,e){const n=cee(e),r=uee(t);if(!await r._isAvailable())return!1;const s=await r._get(n)==="true";return await r._remove(n),s}function lee(t,e){Mv.set(t._key(),e)}function uee(t){return Yu(t._redirectPersistence)}function cee(t){return Lv(iee,t.config.apiKey,t.name)}async function hee(t,e,n=!1){if(Ja(t.app))return Promise.reject(Zu(t));const r=yf(t),s=eee(r,e),o=await new oee(r,s,n).execute();return o&&!n&&(delete o.user._redirectEventId,await r._persistUserIfCurrent(o.user),await r._setRedirectUser(null,e)),o}const dee=600*1e3;class fee{constructor(e){this.auth=e,this.cachedEventUids=new Set,this.consumers=new Set,this.queuedRedirectEvent=null,this.hasHandledPotentialRedirect=!1,this.lastProcessedEventTime=Date.now()}registerConsumer(e){this.consumers.add(e),this.queuedRedirectEvent&&this.isEventForConsumer(this.queuedRedirectEvent,e)&&(this.sendToConsumer(this.queuedRedirectEvent,e),this.saveEventToCache(this.queuedRedirectEvent),this.queuedRedirectEvent=null)}unregisterConsumer(e){this.consumers.delete(e)}onEvent(e){if(this.hasEventBeenHandled(e))return!1;let n=!1;return this.consumers.forEach(r=>{this.isEventForConsumer(e,r)&&(n=!0,this.sendToConsumer(e,r),this.saveEventToCache(e))}),this.hasHandledPotentialRedirect||!pee(e)||(this.hasHandledPotentialRedirect=!0,n||(this.queuedRedirectEvent=e,n=!0)),n}sendToConsumer(e,n){if(e.error&&!LL(e)){const r=e.error.code?.split("auth/")[1]||"internal-error";n.onError(lu(this.auth,r))}else n.onAuthEvent(e)}isEventForConsumer(e,n){const r=n.eventId===null||!!e.eventId&&e.eventId===n.eventId;return n.filter.includes(e.type)&&r}hasEventBeenHandled(e){return Date.now()-this.lastProcessedEventTime>=dee&&this.cachedEventUids.clear(),this.cachedEventUids.has(t5(e))}saveEventToCache(e){this.cachedEventUids.add(t5(e)),this.lastProcessedEventTime=Date.now()}}function t5(t){return[t.type,t.eventId,t.sessionId,t.tenantId].filter(e=>e).join("-")}function LL({type:t,error:e}){return t==="unknown"&&e?.code==="auth/no-auth-event"}function pee(t){switch(t.type){case"signInViaRedirect":case"linkViaRedirect":case"reauthViaRedirect":return!0;case"unknown":return LL(t);default:return!1}}async function mee(t,e={}){return mc(t,"GET","/v1/projects",e)}const gee=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,yee=/^https?/;async function wee(t){if(t.config.emulator)return;const{authorizedDomains:e}=await mee(t);for(const n of e)try{if(vee(n))return}catch{}Fl(t,"unauthorized-domain")}function vee(t){const e=jS(),{protocol:n,hostname:r}=new URL(e);if(t.startsWith("chrome-extension://")){const o=new URL(t);return o.hostname===""&&r===""?n==="chrome-extension:"&&t.replace("chrome-extension://","")===e.replace("chrome-extension://",""):n==="chrome-extension:"&&o.hostname===r}if(!yee.test(n))return!1;if(gee.test(t))return r===t;const s=t.replace(/\./g,"\\.");return new RegExp("^(.+\\."+s+"|"+s+")$","i").test(r)}const bee=new qy(3e4,6e4);function n5(){const t=uu().___jsl;if(t?.H){for(const e of Object.keys(t.H))if(t.H[e].r=t.H[e].r||[],t.H[e].L=t.H[e].L||[],t.H[e].r=[...t.H[e].L],t.CP)for(let n=0;n<t.CP.length;n++)t.CP[n]=null}}function xee(t){return new Promise((e,n)=>{function r(){n5(),gapi.load("gapi.iframes",{callback:()=>{e(gapi.iframes.getContext())},ontimeout:()=>{n5(),n(lu(t,"network-request-failed"))},timeout:bee.get()})}if(uu().gapi?.iframes?.Iframe)e(gapi.iframes.getContext());else if(uu().gapi?.load)r();else{const s=dZ("iframefcb");return uu()[s]=()=>{gapi.load?r():n(lu(t,"network-request-failed"))},xL(`${hZ()}?onload=${s}`).catch(i=>n(i))}}).catch(e=>{throw zv=null,e})}let zv=null;function _ee(t){return zv=zv||xee(t),zv}const Iee=new qy(5e3,15e3),Tee="__/auth/iframe",See="emulator/auth/iframe",$ee={style:{position:"absolute",top:"-100px",width:"1px",height:"1px"},"aria-hidden":"true",tabindex:"-1"},Cee=new Map([["identitytoolkit.googleapis.com","p"],["staging-identitytoolkit.sandbox.googleapis.com","s"],["test-identitytoolkit.sandbox.googleapis.com","t"]]);function Eee(t){const e=t.config;fn(e.authDomain,t,"auth-domain-config-required");const n=e.emulator?CC(e,See):`https://${t.config.authDomain}/${Tee}`,r={apiKey:e.apiKey,appName:t.name,v:eg},s=Cee.get(t.config.apiHost);s&&(r.eid=s);const i=t._getFrameworks();return i.length&&(r.fw=i.join(",")),`${n}?${Hy(r).slice(1)}`}async function kee(t){const e=await _ee(t),n=uu().gapi;return fn(n,t,"internal-error"),e.open({where:document.body,url:Eee(t),messageHandlersFilter:n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,attributes:$ee,dontclear:!0},r=>new Promise(async(s,i)=>{await r.restyle({setHideOnLeave:!1});const o=lu(t,"network-request-failed"),a=uu().setTimeout(()=>{i(o)},Iee.get());function l(){uu().clearTimeout(a),s(r)}r.ping(l).then(l,()=>{i(o)})}))}const Nee={location:"yes",resizable:"yes",statusbar:"yes",toolbar:"no"},Aee=500,Ree=600,Dee="_blank",Oee="http://localhost";class r5{constructor(e){this.window=e,this.associatedEvent=null}close(){if(this.window)try{this.window.close()}catch{}}}function Pee(t,e,n,r=Aee,s=Ree){const i=Math.max((window.screen.availHeight-s)/2,0).toString(),o=Math.max((window.screen.availWidth-r)/2,0).toString();let a="";const l={...Nee,width:r.toString(),height:s.toString(),top:i,left:o},u=mo().toLowerCase();n&&(a=pL(u)?Dee:n),dL(u)&&(e=e||Oee,l.scrollbars="yes");const c=Object.entries(l).reduce((f,[m,g])=>`${f}${m}=${g},`,"");if(nZ(u)&&a!=="_self")return Fee(e||"",a),new r5(null);const d=window.open(e||"",a,c);fn(d,t,"popup-blocked");try{d.focus()}catch{}return new r5(d)}function Fee(t,e){const n=document.createElement("a");n.href=t,n.target=e;const r=document.createEvent("MouseEvent");r.initMouseEvent("click",!0,!0,window,1,0,0,0,0,!1,!1,!1,!1,1,null),n.dispatchEvent(r)}const Lee="__/auth/handler",Mee="emulator/auth/handler",zee=encodeURIComponent("fac");async function s5(t,e,n,r,s,i){fn(t.config.authDomain,t,"auth-domain-config-required"),fn(t.config.apiKey,t,"invalid-api-key");const o={apiKey:t.config.apiKey,appName:t.name,authType:n,redirectUrl:r,v:eg,eventId:s};if(e instanceof TL){e.setDefaultLanguage(t.languageCode),o.providerId=e.providerId||"",_Q(e.getCustomParameters())||(o.customParameters=JSON.stringify(e.getCustomParameters()));for(const[c,d]of Object.entries({}))o[c]=d}if(e instanceof Xy){const c=e.getScopes().filter(d=>d!=="");c.length>0&&(o.scopes=c.join(","))}t.tenantId&&(o.tid=t.tenantId);const a=o;for(const c of Object.keys(a))a[c]===void 0&&delete a[c];const l=await t._getAppCheckToken(),u=l?`#${zee}=${encodeURIComponent(l)}`:"";return`${Vee(t)}?${Hy(a).slice(1)}${u}`}function Vee({config:t}){return t.emulator?CC(t,Mee):`https://${t.authDomain}/${Lee}`}const oT="webStorageSupport";class Bee{constructor(){this.eventManagers={},this.iframes={},this.originValidationPromises={},this._redirectPersistence=AL,this._completeRedirectFn=hee,this._overrideRedirectResult=lee}async _openPopup(e,n,r,s){nc(this.eventManagers[e._key()]?.manager,"_initialize() not called before _openPopup()");const i=await s5(e,n,r,jS(),s);return Pee(e,i,RC())}async _openRedirect(e,n,r,s){await this._originValidation(e);const i=await s5(e,n,r,jS(),s);return jZ(i),new Promise(()=>{})}_initialize(e){const n=e._key();if(this.eventManagers[n]){const{manager:s,promise:i}=this.eventManagers[n];return s?Promise.resolve(s):(nc(i,"If manager is not set, promise should be"),i)}const r=this.initAndGetManager(e);return this.eventManagers[n]={promise:r},r.catch(()=>{delete this.eventManagers[n]}),r}async initAndGetManager(e){const n=await kee(e),r=new fee(e);return n.register("authEvent",s=>(fn(s?.authEvent,e,"invalid-auth-event"),{status:r.onEvent(s.authEvent)?"ACK":"ERROR"}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),this.eventManagers[e._key()]={manager:r},this.iframes[e._key()]=n,r}_isIframeWebStorageSupported(e,n){this.iframes[e._key()].send(oT,{type:oT},s=>{const i=s?.[0]?.[oT];i!==void 0&&n(!!i),Fl(e,"internal-error")},gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)}_originValidation(e){const n=e._key();return this.originValidationPromises[n]||(this.originValidationPromises[n]=wee(e)),this.originValidationPromises[n]}get _shouldInitProactively(){return vL()||fL()||kC()}}const Uee=Bee;var i5="@firebase/auth",o5="1.11.1";class Wee{constructor(e){this.auth=e,this.internalListeners=new Map}getUid(){return this.assertAuthConfigured(),this.auth.currentUser?.uid||null}async getToken(e){return this.assertAuthConfigured(),await this.auth._initializationPromise,this.auth.currentUser?{accessToken:await this.auth.currentUser.getIdToken(e)}:null}addAuthTokenListener(e){if(this.assertAuthConfigured(),this.internalListeners.has(e))return;const n=this.auth.onIdTokenChanged(r=>{e(r?.stsTokenManager.accessToken||null)});this.internalListeners.set(e,n),this.updateProactiveRefresh()}removeAuthTokenListener(e){this.assertAuthConfigured();const n=this.internalListeners.get(e);n&&(this.internalListeners.delete(e),n(),this.updateProactiveRefresh())}assertAuthConfigured(){fn(this.auth._initializationPromise,"dependent-sdk-initialized-before-auth")}updateProactiveRefresh(){this.internalListeners.size>0?this.auth._startProactiveRefresh():this.auth._stopProactiveRefresh()}}function jee(t){switch(t){case"Node":return"node";case"ReactNative":return"rn";case"Worker":return"webworker";case"Cordova":return"cordova";case"WebExtension":return"web-extension";default:return}}function Gee(t){Cm(new Vd("auth",(e,{options:n})=>{const r=e.getProvider("app").getImmediate(),s=e.getProvider("heartbeat"),i=e.getProvider("app-check-internal"),{apiKey:o,authDomain:a}=r.options;fn(o&&!o.includes(":"),"invalid-api-key",{appName:r.name});const l={apiKey:o,authDomain:a,clientPlatform:t,apiHost:"identitytoolkit.googleapis.com",tokenApiHost:"securetoken.googleapis.com",apiScheme:"https",sdkClientVersion:bL(t)},u=new lZ(r,s,i,l);return wZ(u,n),u},"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e,n,r)=>{e.getProvider("auth-internal").initialize()})),Cm(new Vd("auth-internal",e=>{const n=yf(e.getProvider("auth").getImmediate());return(r=>new Wee(r))(n)},"PRIVATE").setInstantiationMode("EXPLICIT")),hh(i5,o5,jee(t)),hh(i5,o5,"esm2020")}const Hee=300,qee=XF("authIdTokenMaxAge")||Hee;let a5=null;const Kee=t=>async e=>{const n=e&&await e.getIdTokenResult(),r=n&&(new Date().getTime()-Date.parse(n.issuedAtTime))/1e3;if(r&&r>qee)return;const s=n?.token;a5!==s&&(a5=s,await fetch(t,{method:s?"POST":"DELETE",headers:s?{Authorization:`Bearer ${s}`}:{}}))};function Xee(t=tL()){const e=SC(t,"auth");if(e.isInitialized())return e.getImmediate();const n=yZ(t,{popupRedirectResolver:Uee,persistence:[ZZ,BZ,AL]}),r=XF("authTokenSyncURL");if(r&&typeof isSecureContext=="boolean"&&isSecureContext){const i=new URL(r,location.origin);if(location.origin===i.origin){const o=Kee(i.toString());MZ(n,o,()=>o(n.currentUser)),LZ(n,a=>o(a))}}const s=qF("auth");return s&&vZ(n,`http://${s}`),n}function Yee(){return document.getElementsByTagName("head")?.[0]??document}uZ({loadJS(t){return new Promise((e,n)=>{const r=document.createElement("script");r.setAttribute("src",t),r.onload=e,r.onerror=s=>{const i=lu("internal-error");i.customData=s,n(i)},r.type="text/javascript",r.charset="UTF-8",Yee().appendChild(r)})},gapiScript:"https://apis.google.com/js/api.js",recaptchaV2Script:"https://www.google.com/recaptcha/api.js",recaptchaEnterpriseScript:"https://www.google.com/recaptcha/enterprise.js?render="});Gee("Browser");var l5=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};var dh,ML;(function(){var t;function e(R,D){function A(){}A.prototype=D.prototype,R.F=D.prototype,R.prototype=new A,R.prototype.constructor=R,R.D=function(F,P,K){for(var j=Array(arguments.length-2),se=2;se<arguments.length;se++)j[se-2]=arguments[se];return D.prototype[P].apply(F,j)}}function n(){this.blockSize=-1}function r(){this.blockSize=-1,this.blockSize=64,this.g=Array(4),this.C=Array(this.blockSize),this.o=this.h=0,this.u()}e(r,n),r.prototype.u=function(){this.g[0]=1732584193,this.g[1]=4023233417,this.g[2]=2562383102,this.g[3]=271733878,this.o=this.h=0};function s(R,D,A){A||(A=0);const F=Array(16);if(typeof D=="string")for(var P=0;P<16;++P)F[P]=D.charCodeAt(A++)|D.charCodeAt(A++)<<8|D.charCodeAt(A++)<<16|D.charCodeAt(A++)<<24;else for(P=0;P<16;++P)F[P]=D[A++]|D[A++]<<8|D[A++]<<16|D[A++]<<24;D=R.g[0],A=R.g[1],P=R.g[2];let K=R.g[3],j;j=D+(K^A&(P^K))+F[0]+3614090360&4294967295,D=A+(j<<7&4294967295|j>>>25),j=K+(P^D&(A^P))+F[1]+3905402710&4294967295,K=D+(j<<12&4294967295|j>>>20),j=P+(A^K&(D^A))+F[2]+606105819&4294967295,P=K+(j<<17&4294967295|j>>>15),j=A+(D^P&(K^D))+F[3]+3250441966&4294967295,A=P+(j<<22&4294967295|j>>>10),j=D+(K^A&(P^K))+F[4]+4118548399&4294967295,D=A+(j<<7&4294967295|j>>>25),j=K+(P^D&(A^P))+F[5]+1200080426&4294967295,K=D+(j<<12&4294967295|j>>>20),j=P+(A^K&(D^A))+F[6]+2821735955&4294967295,P=K+(j<<17&4294967295|j>>>15),j=A+(D^P&(K^D))+F[7]+4249261313&4294967295,A=P+(j<<22&4294967295|j>>>10),j=D+(K^A&(P^K))+F[8]+1770035416&4294967295,D=A+(j<<7&4294967295|j>>>25),j=K+(P^D&(A^P))+F[9]+2336552879&4294967295,K=D+(j<<12&4294967295|j>>>20),j=P+(A^K&(D^A))+F[10]+4294925233&4294967295,P=K+(j<<17&4294967295|j>>>15),j=A+(D^P&(K^D))+F[11]+2304563134&4294967295,A=P+(j<<22&4294967295|j>>>10),j=D+(K^A&(P^K))+F[12]+1804603682&4294967295,D=A+(j<<7&4294967295|j>>>25),j=K+(P^D&(A^P))+F[13]+4254626195&4294967295,K=D+(j<<12&4294967295|j>>>20),j=P+(A^K&(D^A))+F[14]+2792965006&4294967295,P=K+(j<<17&4294967295|j>>>15),j=A+(D^P&(K^D))+F[15]+1236535329&4294967295,A=P+(j<<22&4294967295|j>>>10),j=D+(P^K&(A^P))+F[1]+4129170786&4294967295,D=A+(j<<5&4294967295|j>>>27),j=K+(A^P&(D^A))+F[6]+3225465664&4294967295,K=D+(j<<9&4294967295|j>>>23),j=P+(D^A&(K^D))+F[11]+643717713&4294967295,P=K+(j<<14&4294967295|j>>>18),j=A+(K^D&(P^K))+F[0]+3921069994&4294967295,A=P+(j<<20&4294967295|j>>>12),j=D+(P^K&(A^P))+F[5]+3593408605&4294967295,D=A+(j<<5&4294967295|j>>>27),j=K+(A^P&(D^A))+F[10]+38016083&4294967295,K=D+(j<<9&4294967295|j>>>23),j=P+(D^A&(K^D))+F[15]+3634488961&4294967295,P=K+(j<<14&4294967295|j>>>18),j=A+(K^D&(P^K))+F[4]+3889429448&4294967295,A=P+(j<<20&4294967295|j>>>12),j=D+(P^K&(A^P))+F[9]+568446438&4294967295,D=A+(j<<5&4294967295|j>>>27),j=K+(A^P&(D^A))+F[14]+3275163606&4294967295,K=D+(j<<9&4294967295|j>>>23),j=P+(D^A&(K^D))+F[3]+4107603335&4294967295,P=K+(j<<14&4294967295|j>>>18),j=A+(K^D&(P^K))+F[8]+1163531501&4294967295,A=P+(j<<20&4294967295|j>>>12),j=D+(P^K&(A^P))+F[13]+2850285829&4294967295,D=A+(j<<5&4294967295|j>>>27),j=K+(A^P&(D^A))+F[2]+4243563512&4294967295,K=D+(j<<9&4294967295|j>>>23),j=P+(D^A&(K^D))+F[7]+1735328473&4294967295,P=K+(j<<14&4294967295|j>>>18),j=A+(K^D&(P^K))+F[12]+2368359562&4294967295,A=P+(j<<20&4294967295|j>>>12),j=D+(A^P^K)+F[5]+4294588738&4294967295,D=A+(j<<4&4294967295|j>>>28),j=K+(D^A^P)+F[8]+2272392833&4294967295,K=D+(j<<11&4294967295|j>>>21),j=P+(K^D^A)+F[11]+1839030562&4294967295,P=K+(j<<16&4294967295|j>>>16),j=A+(P^K^D)+F[14]+4259657740&4294967295,A=P+(j<<23&4294967295|j>>>9),j=D+(A^P^K)+F[1]+2763975236&4294967295,D=A+(j<<4&4294967295|j>>>28),j=K+(D^A^P)+F[4]+1272893353&4294967295,K=D+(j<<11&4294967295|j>>>21),j=P+(K^D^A)+F[7]+4139469664&4294967295,P=K+(j<<16&4294967295|j>>>16),j=A+(P^K^D)+F[10]+3200236656&4294967295,A=P+(j<<23&4294967295|j>>>9),j=D+(A^P^K)+F[13]+681279174&4294967295,D=A+(j<<4&4294967295|j>>>28),j=K+(D^A^P)+F[0]+3936430074&4294967295,K=D+(j<<11&4294967295|j>>>21),j=P+(K^D^A)+F[3]+3572445317&4294967295,P=K+(j<<16&4294967295|j>>>16),j=A+(P^K^D)+F[6]+76029189&4294967295,A=P+(j<<23&4294967295|j>>>9),j=D+(A^P^K)+F[9]+3654602809&4294967295,D=A+(j<<4&4294967295|j>>>28),j=K+(D^A^P)+F[12]+3873151461&4294967295,K=D+(j<<11&4294967295|j>>>21),j=P+(K^D^A)+F[15]+530742520&4294967295,P=K+(j<<16&4294967295|j>>>16),j=A+(P^K^D)+F[2]+3299628645&4294967295,A=P+(j<<23&4294967295|j>>>9),j=D+(P^(A|~K))+F[0]+4096336452&4294967295,D=A+(j<<6&4294967295|j>>>26),j=K+(A^(D|~P))+F[7]+1126891415&4294967295,K=D+(j<<10&4294967295|j>>>22),j=P+(D^(K|~A))+F[14]+2878612391&4294967295,P=K+(j<<15&4294967295|j>>>17),j=A+(K^(P|~D))+F[5]+4237533241&4294967295,A=P+(j<<21&4294967295|j>>>11),j=D+(P^(A|~K))+F[12]+1700485571&4294967295,D=A+(j<<6&4294967295|j>>>26),j=K+(A^(D|~P))+F[3]+2399980690&4294967295,K=D+(j<<10&4294967295|j>>>22),j=P+(D^(K|~A))+F[10]+4293915773&4294967295,P=K+(j<<15&4294967295|j>>>17),j=A+(K^(P|~D))+F[1]+2240044497&4294967295,A=P+(j<<21&4294967295|j>>>11),j=D+(P^(A|~K))+F[8]+1873313359&4294967295,D=A+(j<<6&4294967295|j>>>26),j=K+(A^(D|~P))+F[15]+4264355552&4294967295,K=D+(j<<10&4294967295|j>>>22),j=P+(D^(K|~A))+F[6]+2734768916&4294967295,P=K+(j<<15&4294967295|j>>>17),j=A+(K^(P|~D))+F[13]+1309151649&4294967295,A=P+(j<<21&4294967295|j>>>11),j=D+(P^(A|~K))+F[4]+4149444226&4294967295,D=A+(j<<6&4294967295|j>>>26),j=K+(A^(D|~P))+F[11]+3174756917&4294967295,K=D+(j<<10&4294967295|j>>>22),j=P+(D^(K|~A))+F[2]+718787259&4294967295,P=K+(j<<15&4294967295|j>>>17),j=A+(K^(P|~D))+F[9]+3951481745&4294967295,R.g[0]=R.g[0]+D&4294967295,R.g[1]=R.g[1]+(P+(j<<21&4294967295|j>>>11))&4294967295,R.g[2]=R.g[2]+P&4294967295,R.g[3]=R.g[3]+K&4294967295}r.prototype.v=function(R,D){D===void 0&&(D=R.length);const A=D-this.blockSize,F=this.C;let P=this.h,K=0;for(;K<D;){if(P==0)for(;K<=A;)s(this,R,K),K+=this.blockSize;if(typeof R=="string"){for(;K<D;)if(F[P++]=R.charCodeAt(K++),P==this.blockSize){s(this,F),P=0;break}}else for(;K<D;)if(F[P++]=R[K++],P==this.blockSize){s(this,F),P=0;break}}this.h=P,this.o+=D},r.prototype.A=function(){var R=Array((this.h<56?this.blockSize:this.blockSize*2)-this.h);R[0]=128;for(var D=1;D<R.length-8;++D)R[D]=0;D=this.o*8;for(var A=R.length-8;A<R.length;++A)R[A]=D&255,D/=256;for(this.v(R),R=Array(16),D=0,A=0;A<4;++A)for(let F=0;F<32;F+=8)R[D++]=this.g[A]>>>F&255;return R};function i(R,D){var A=a;return Object.prototype.hasOwnProperty.call(A,R)?A[R]:A[R]=D(R)}function o(R,D){this.h=D;const A=[];let F=!0;for(let P=R.length-1;P>=0;P--){const K=R[P]|0;F&&K==D||(A[P]=K,F=!1)}this.g=A}var a={};function l(R){return-128<=R&&R<128?i(R,function(D){return new o([D|0],D<0?-1:0)}):new o([R|0],R<0?-1:0)}function u(R){if(isNaN(R)||!isFinite(R))return d;if(R<0)return v(u(-R));const D=[];let A=1;for(let F=0;R>=A;F++)D[F]=R/A|0,A*=4294967296;return new o(D,0)}function c(R,D){if(R.length==0)throw Error("number format error: empty string");if(D=D||10,D<2||36<D)throw Error("radix out of range: "+D);if(R.charAt(0)=="-")return v(c(R.substring(1),D));if(R.indexOf("-")>=0)throw Error('number format error: interior "-" character');const A=u(Math.pow(D,8));let F=d;for(let K=0;K<R.length;K+=8){var P=Math.min(8,R.length-K);const j=parseInt(R.substring(K,K+P),D);P<8?(P=u(Math.pow(D,P)),F=F.j(P).add(u(j))):(F=F.j(A),F=F.add(u(j)))}return F}var d=l(0),f=l(1),m=l(16777216);t=o.prototype,t.m=function(){if(y(this))return-v(this).m();let R=0,D=1;for(let A=0;A<this.g.length;A++){const F=this.i(A);R+=(F>=0?F:4294967296+F)*D,D*=4294967296}return R},t.toString=function(R){if(R=R||10,R<2||36<R)throw Error("radix out of range: "+R);if(g(this))return"0";if(y(this))return"-"+v(this).toString(R);const D=u(Math.pow(R,6));var A=this;let F="";for(;;){const P=S(A,D).g;A=b(A,P.j(D));let K=((A.g.length>0?A.g[0]:A.h)>>>0).toString(R);if(A=P,g(A))return K+F;for(;K.length<6;)K="0"+K;F=K+F}},t.i=function(R){return R<0?0:R<this.g.length?this.g[R]:this.h};function g(R){if(R.h!=0)return!1;for(let D=0;D<R.g.length;D++)if(R.g[D]!=0)return!1;return!0}function y(R){return R.h==-1}t.l=function(R){return R=b(this,R),y(R)?-1:g(R)?0:1};function v(R){const D=R.g.length,A=[];for(let F=0;F<D;F++)A[F]=~R.g[F];return new o(A,~R.h).add(f)}t.abs=function(){return y(this)?v(this):this},t.add=function(R){const D=Math.max(this.g.length,R.g.length),A=[];let F=0;for(let P=0;P<=D;P++){let K=F+(this.i(P)&65535)+(R.i(P)&65535),j=(K>>>16)+(this.i(P)>>>16)+(R.i(P)>>>16);F=j>>>16,K&=65535,j&=65535,A[P]=j<<16|K}return new o(A,A[A.length-1]&-2147483648?-1:0)};function b(R,D){return R.add(v(D))}t.j=function(R){if(g(this)||g(R))return d;if(y(this))return y(R)?v(this).j(v(R)):v(v(this).j(R));if(y(R))return v(this.j(v(R)));if(this.l(m)<0&&R.l(m)<0)return u(this.m()*R.m());const D=this.g.length+R.g.length,A=[];for(var F=0;F<2*D;F++)A[F]=0;for(F=0;F<this.g.length;F++)for(let P=0;P<R.g.length;P++){const K=this.i(F)>>>16,j=this.i(F)&65535,se=R.i(P)>>>16,fe=R.i(P)&65535;A[2*F+2*P]+=j*fe,x(A,2*F+2*P),A[2*F+2*P+1]+=K*fe,x(A,2*F+2*P+1),A[2*F+2*P+1]+=j*se,x(A,2*F+2*P+1),A[2*F+2*P+2]+=K*se,x(A,2*F+2*P+2)}for(R=0;R<D;R++)A[R]=A[2*R+1]<<16|A[2*R];for(R=D;R<2*D;R++)A[R]=0;return new o(A,0)};function x(R,D){for(;(R[D]&65535)!=R[D];)R[D+1]+=R[D]>>>16,R[D]&=65535,D++}function $(R,D){this.g=R,this.h=D}function S(R,D){if(g(D))throw Error("division by zero");if(g(R))return new $(d,d);if(y(R))return D=S(v(R),D),new $(v(D.g),v(D.h));if(y(D))return D=S(R,v(D)),new $(v(D.g),D.h);if(R.g.length>30){if(y(R)||y(D))throw Error("slowDivide_ only works with positive integers.");for(var A=f,F=D;F.l(R)<=0;)A=E(A),F=E(F);var P=L(A,1),K=L(F,1);for(F=L(F,2),A=L(A,2);!g(F);){var j=K.add(F);j.l(R)<=0&&(P=P.add(A),K=j),F=L(F,1),A=L(A,1)}return D=b(R,P.j(D)),new $(P,D)}for(P=d;R.l(D)>=0;){for(A=Math.max(1,Math.floor(R.m()/D.m())),F=Math.ceil(Math.log(A)/Math.LN2),F=F<=48?1:Math.pow(2,F-48),K=u(A),j=K.j(D);y(j)||j.l(R)>0;)A-=F,K=u(A),j=K.j(D);g(K)&&(K=f),P=P.add(K),R=b(R,j)}return new $(P,R)}t.B=function(R){return S(this,R).h},t.and=function(R){const D=Math.max(this.g.length,R.g.length),A=[];for(let F=0;F<D;F++)A[F]=this.i(F)&R.i(F);return new o(A,this.h&R.h)},t.or=function(R){const D=Math.max(this.g.length,R.g.length),A=[];for(let F=0;F<D;F++)A[F]=this.i(F)|R.i(F);return new o(A,this.h|R.h)},t.xor=function(R){const D=Math.max(this.g.length,R.g.length),A=[];for(let F=0;F<D;F++)A[F]=this.i(F)^R.i(F);return new o(A,this.h^R.h)};function E(R){const D=R.g.length+1,A=[];for(let F=0;F<D;F++)A[F]=R.i(F)<<1|R.i(F-1)>>>31;return new o(A,R.h)}function L(R,D){const A=D>>5;D%=32;const F=R.g.length-A,P=[];for(let K=0;K<F;K++)P[K]=D>0?R.i(K+A)>>>D|R.i(K+A+1)<<32-D:R.i(K+A);return new o(P,R.h)}r.prototype.digest=r.prototype.A,r.prototype.reset=r.prototype.u,r.prototype.update=r.prototype.v,ML=r,o.prototype.add=o.prototype.add,o.prototype.multiply=o.prototype.j,o.prototype.modulo=o.prototype.B,o.prototype.compare=o.prototype.l,o.prototype.toNumber=o.prototype.m,o.prototype.toString=o.prototype.toString,o.prototype.getBits=o.prototype.i,o.fromNumber=u,o.fromString=c,dh=o}).apply(typeof l5<"u"?l5:typeof self<"u"?self:typeof window<"u"?window:{});var nv=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};var zL,U2,VL,Vv,KS,BL,UL,WL;(function(){var t,e=Object.defineProperty;function n(_){_=[typeof globalThis=="object"&&globalThis,_,typeof window=="object"&&window,typeof self=="object"&&self,typeof nv=="object"&&nv];for(var z=0;z<_.length;++z){var q=_[z];if(q&&q.Math==Math)return q}throw Error("Cannot find global object")}var r=n(this);function s(_,z){if(z)e:{var q=r;_=_.split(".");for(var ne=0;ne<_.length-1;ne++){var Fe=_[ne];if(!(Fe in q))break e;q=q[Fe]}_=_[_.length-1],ne=q[_],z=z(ne),z!=ne&&z!=null&&e(q,_,{configurable:!0,writable:!0,value:z})}}s("Symbol.dispose",function(_){return _||Symbol("Symbol.dispose")}),s("Array.prototype.values",function(_){return _||function(){return this[Symbol.iterator]()}}),s("Object.entries",function(_){return _||function(z){var q=[],ne;for(ne in z)Object.prototype.hasOwnProperty.call(z,ne)&&q.push([ne,z[ne]]);return q}});var i=i||{},o=this||self;function a(_){var z=typeof _;return z=="object"&&_!=null||z=="function"}function l(_,z,q){return _.call.apply(_.bind,arguments)}function u(_,z,q){return u=l,u.apply(null,arguments)}function c(_,z){var q=Array.prototype.slice.call(arguments,1);return function(){var ne=q.slice();return ne.push.apply(ne,arguments),_.apply(this,ne)}}function d(_,z){function q(){}q.prototype=z.prototype,_.Z=z.prototype,_.prototype=new q,_.prototype.constructor=_,_.Ob=function(ne,Fe,Ge){for(var xt=Array(arguments.length-2),xn=2;xn<arguments.length;xn++)xt[xn-2]=arguments[xn];return z.prototype[Fe].apply(ne,xt)}}var f=typeof AsyncContext<"u"&&typeof AsyncContext.Snapshot=="function"?_=>_&&AsyncContext.Snapshot.wrap(_):_=>_;function m(_){const z=_.length;if(z>0){const q=Array(z);for(let ne=0;ne<z;ne++)q[ne]=_[ne];return q}return[]}function g(_,z){for(let ne=1;ne<arguments.length;ne++){const Fe=arguments[ne];var q=typeof Fe;if(q=q!="object"?q:Fe?Array.isArray(Fe)?"array":q:"null",q=="array"||q=="object"&&typeof Fe.length=="number"){q=_.length||0;const Ge=Fe.length||0;_.length=q+Ge;for(let xt=0;xt<Ge;xt++)_[q+xt]=Fe[xt]}else _.push(Fe)}}class y{constructor(z,q){this.i=z,this.j=q,this.h=0,this.g=null}get(){let z;return this.h>0?(this.h--,z=this.g,this.g=z.next,z.next=null):z=this.i(),z}}function v(_){o.setTimeout(()=>{throw _},0)}function b(){var _=R;let z=null;return _.g&&(z=_.g,_.g=_.g.next,_.g||(_.h=null),z.next=null),z}class x{constructor(){this.h=this.g=null}add(z,q){const ne=$.get();ne.set(z,q),this.h?this.h.next=ne:this.g=ne,this.h=ne}}var $=new y(()=>new S,_=>_.reset());class S{constructor(){this.next=this.g=this.h=null}set(z,q){this.h=z,this.g=q,this.next=null}reset(){this.next=this.g=this.h=null}}let E,L=!1,R=new x,D=()=>{const _=Promise.resolve(void 0);E=()=>{_.then(A)}};function A(){for(var _;_=b();){try{_.h.call(_.g)}catch(q){v(q)}var z=$;z.j(_),z.h<100&&(z.h++,_.next=z.g,z.g=_)}L=!1}function F(){this.u=this.u,this.C=this.C}F.prototype.u=!1,F.prototype.dispose=function(){this.u||(this.u=!0,this.N())},F.prototype[Symbol.dispose]=function(){this.dispose()},F.prototype.N=function(){if(this.C)for(;this.C.length;)this.C.shift()()};function P(_,z){this.type=_,this.g=this.target=z,this.defaultPrevented=!1}P.prototype.h=function(){this.defaultPrevented=!0};var K=(function(){if(!o.addEventListener||!Object.defineProperty)return!1;var _=!1,z=Object.defineProperty({},"passive",{get:function(){_=!0}});try{const q=()=>{};o.addEventListener("test",q,z),o.removeEventListener("test",q,z)}catch{}return _})();function j(_){return/^[\s\xa0]*$/.test(_)}function se(_,z){P.call(this,_?_.type:""),this.relatedTarget=this.g=this.target=null,this.button=this.screenY=this.screenX=this.clientY=this.clientX=0,this.key="",this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1,this.state=null,this.pointerId=0,this.pointerType="",this.i=null,_&&this.init(_,z)}d(se,P),se.prototype.init=function(_,z){const q=this.type=_.type,ne=_.changedTouches&&_.changedTouches.length?_.changedTouches[0]:null;this.target=_.target||_.srcElement,this.g=z,z=_.relatedTarget,z||(q=="mouseover"?z=_.fromElement:q=="mouseout"&&(z=_.toElement)),this.relatedTarget=z,ne?(this.clientX=ne.clientX!==void 0?ne.clientX:ne.pageX,this.clientY=ne.clientY!==void 0?ne.clientY:ne.pageY,this.screenX=ne.screenX||0,this.screenY=ne.screenY||0):(this.clientX=_.clientX!==void 0?_.clientX:_.pageX,this.clientY=_.clientY!==void 0?_.clientY:_.pageY,this.screenX=_.screenX||0,this.screenY=_.screenY||0),this.button=_.button,this.key=_.key||"",this.ctrlKey=_.ctrlKey,this.altKey=_.altKey,this.shiftKey=_.shiftKey,this.metaKey=_.metaKey,this.pointerId=_.pointerId||0,this.pointerType=_.pointerType,this.state=_.state,this.i=_,_.defaultPrevented&&se.Z.h.call(this)},se.prototype.h=function(){se.Z.h.call(this);const _=this.i;_.preventDefault?_.preventDefault():_.returnValue=!1};var fe="closure_listenable_"+(Math.random()*1e6|0),me=0;function ye(_,z,q,ne,Fe){this.listener=_,this.proxy=null,this.src=z,this.type=q,this.capture=!!ne,this.ha=Fe,this.key=++me,this.da=this.fa=!1}function oe(_){_.da=!0,_.listener=null,_.proxy=null,_.src=null,_.ha=null}function ue(_,z,q){for(const ne in _)z.call(q,_[ne],ne,_)}function _e(_,z){for(const q in _)z.call(void 0,_[q],q,_)}function Y(_){const z={};for(const q in _)z[q]=_[q];return z}const re="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function Te(_,z){let q,ne;for(let Fe=1;Fe<arguments.length;Fe++){ne=arguments[Fe];for(q in ne)_[q]=ne[q];for(let Ge=0;Ge<re.length;Ge++)q=re[Ge],Object.prototype.hasOwnProperty.call(ne,q)&&(_[q]=ne[q])}}function Pe(_){this.src=_,this.g={},this.h=0}Pe.prototype.add=function(_,z,q,ne,Fe){const Ge=_.toString();_=this.g[Ge],_||(_=this.g[Ge]=[],this.h++);const xt=ge(_,z,ne,Fe);return xt>-1?(z=_[xt],q||(z.fa=!1)):(z=new ye(z,this.src,Ge,!!ne,Fe),z.fa=q,_.push(z)),z};function de(_,z){const q=z.type;if(q in _.g){var ne=_.g[q],Fe=Array.prototype.indexOf.call(ne,z,void 0),Ge;(Ge=Fe>=0)&&Array.prototype.splice.call(ne,Fe,1),Ge&&(oe(z),_.g[q].length==0&&(delete _.g[q],_.h--))}}function ge(_,z,q,ne){for(let Fe=0;Fe<_.length;++Fe){const Ge=_[Fe];if(!Ge.da&&Ge.listener==z&&Ge.capture==!!q&&Ge.ha==ne)return Fe}return-1}var Re="closure_lm_"+(Math.random()*1e6|0),Oe={};function Ve(_,z,q,ne,Fe){if(Array.isArray(z)){for(let Ge=0;Ge<z.length;Ge++)Ve(_,z[Ge],q,ne,Fe);return null}return q=Tt(q),_&&_[fe]?_.J(z,q,a(ne)?!!ne.capture:!1,Fe):We(_,z,q,!1,ne,Fe)}function We(_,z,q,ne,Fe,Ge){if(!z)throw Error("Invalid event type");const xt=a(Fe)?!!Fe.capture:!!Fe;let xn=vt(_);if(xn||(_[Re]=xn=new Pe(_)),q=xn.add(z,q,ne,xt,Ge),q.proxy)return q;if(ne=nt(),q.proxy=ne,ne.src=_,ne.listener=q,_.addEventListener)K||(Fe=xt),Fe===void 0&&(Fe=!1),_.addEventListener(z.toString(),ne,Fe);else if(_.attachEvent)_.attachEvent(Wt(z.toString()),ne);else if(_.addListener&&_.removeListener)_.addListener(ne);else throw Error("addEventListener and attachEvent are unavailable.");return q}function nt(){function _(q){return z.call(_.src,_.listener,q)}const z=Et;return _}function ct(_,z,q,ne,Fe){if(Array.isArray(z))for(var Ge=0;Ge<z.length;Ge++)ct(_,z[Ge],q,ne,Fe);else ne=a(ne)?!!ne.capture:!!ne,q=Tt(q),_&&_[fe]?(_=_.i,Ge=String(z).toString(),Ge in _.g&&(z=_.g[Ge],q=ge(z,q,ne,Fe),q>-1&&(oe(z[q]),Array.prototype.splice.call(z,q,1),z.length==0&&(delete _.g[Ge],_.h--)))):_&&(_=vt(_))&&(z=_.g[z.toString()],_=-1,z&&(_=ge(z,q,ne,Fe)),(q=_>-1?z[_]:null)&&Ct(q))}function Ct(_){if(typeof _!="number"&&_&&!_.da){var z=_.src;if(z&&z[fe])de(z.i,_);else{var q=_.type,ne=_.proxy;z.removeEventListener?z.removeEventListener(q,ne,_.capture):z.detachEvent?z.detachEvent(Wt(q),ne):z.addListener&&z.removeListener&&z.removeListener(ne),(q=vt(z))?(de(q,_),q.h==0&&(q.src=null,z[Re]=null)):oe(_)}}}function Wt(_){return _ in Oe?Oe[_]:Oe[_]="on"+_}function Et(_,z){if(_.da)_=!0;else{z=new se(z,this);const q=_.listener,ne=_.ha||_.src;_.fa&&Ct(_),_=q.call(ne,z)}return _}function vt(_){return _=_[Re],_ instanceof Pe?_:null}var Ht="__closure_events_fn_"+(Math.random()*1e9>>>0);function Tt(_){return typeof _=="function"?_:(_[Ht]||(_[Ht]=function(z){return _.handleEvent(z)}),_[Ht])}function Pt(){F.call(this),this.i=new Pe(this),this.M=this,this.G=null}d(Pt,F),Pt.prototype[fe]=!0,Pt.prototype.removeEventListener=function(_,z,q,ne){ct(this,_,z,q,ne)};function Rt(_,z){var q,ne=_.G;if(ne)for(q=[];ne;ne=ne.G)q.push(ne);if(_=_.M,ne=z.type||z,typeof z=="string")z=new P(z,_);else if(z instanceof P)z.target=z.target||_;else{var Fe=z;z=new P(ne,_),Te(z,Fe)}Fe=!0;let Ge,xt;if(q)for(xt=q.length-1;xt>=0;xt--)Ge=z.g=q[xt],Fe=Yt(Ge,ne,!0,z)&&Fe;if(Ge=z.g=_,Fe=Yt(Ge,ne,!0,z)&&Fe,Fe=Yt(Ge,ne,!1,z)&&Fe,q)for(xt=0;xt<q.length;xt++)Ge=z.g=q[xt],Fe=Yt(Ge,ne,!1,z)&&Fe}Pt.prototype.N=function(){if(Pt.Z.N.call(this),this.i){var _=this.i;for(const z in _.g){const q=_.g[z];for(let ne=0;ne<q.length;ne++)oe(q[ne]);delete _.g[z],_.h--}}this.G=null},Pt.prototype.J=function(_,z,q,ne){return this.i.add(String(_),z,!1,q,ne)},Pt.prototype.K=function(_,z,q,ne){return this.i.add(String(_),z,!0,q,ne)};function Yt(_,z,q,ne){if(z=_.i.g[String(z)],!z)return!0;z=z.concat();let Fe=!0;for(let Ge=0;Ge<z.length;++Ge){const xt=z[Ge];if(xt&&!xt.da&&xt.capture==q){const xn=xt.listener,rs=xt.ha||xt.src;xt.fa&&de(_.i,xt),Fe=xn.call(rs,ne)!==!1&&Fe}}return Fe&&!ne.defaultPrevented}function mn(_,z){if(typeof _!="function")if(_&&typeof _.handleEvent=="function")_=u(_.handleEvent,_);else throw Error("Invalid listener argument");return Number(z)>2147483647?-1:o.setTimeout(_,z||0)}function jt(_){_.g=mn(()=>{_.g=null,_.i&&(_.i=!1,jt(_))},_.l);const z=_.h;_.h=null,_.m.apply(null,z)}class Fn extends F{constructor(z,q){super(),this.m=z,this.l=q,this.h=null,this.i=!1,this.g=null}j(z){this.h=arguments,this.g?this.i=!0:jt(this)}N(){super.N(),this.g&&(o.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null)}}function Vn(_){F.call(this),this.h=_,this.g={}}d(Vn,F);var Bn=[];function Ln(_){ue(_.g,function(z,q){this.g.hasOwnProperty(q)&&Ct(z)},_),_.g={}}Vn.prototype.N=function(){Vn.Z.N.call(this),Ln(this)},Vn.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented")};var Tn=o.JSON.stringify,xr=o.JSON.parse,fr=class{stringify(_){return o.JSON.stringify(_,void 0)}parse(_){return o.JSON.parse(_,void 0)}};function Ar(){}function Hs(){}var qr={OPEN:"a",hb:"b",ERROR:"c",tb:"d"};function gr(){P.call(this,"d")}d(gr,P);function ir(){P.call(this,"c")}d(ir,P);var Un={},Kr=null;function ui(){return Kr=Kr||new Pt}Un.Ia="serverreachability";function Gn(_){P.call(this,Un.Ia,_)}d(Gn,P);function Cs(_){const z=ui();Rt(z,new Gn(z))}Un.STAT_EVENT="statevent";function ci(_,z){P.call(this,Un.STAT_EVENT,_),this.stat=z}d(ci,P);function Kn(_){const z=ui();Rt(z,new ci(z,_))}Un.Ja="timingevent";function Dn(_,z){P.call(this,Un.Ja,_),this.size=z}d(Dn,P);function hn(_,z){if(typeof _!="function")throw Error("Fn must not be null and must be a function");return o.setTimeout(function(){_()},z)}function Qi(){this.g=!0}Qi.prototype.ua=function(){this.g=!1};function Po(_,z,q,ne,Fe,Ge){_.info(function(){if(_.g)if(Ge){var xt="",xn=Ge.split("&");for(let pr=0;pr<xn.length;pr++){var rs=xn[pr].split("=");if(rs.length>1){const Fr=rs[0];rs=rs[1];const Ys=Fr.split("_");xt=Ys.length>=2&&Ys[1]=="type"?xt+(Fr+"="+rs+"&"):xt+(Fr+"=redacted&")}}}else xt=null;else xt=Ge;return"XMLHTTP REQ ("+ne+") [attempt "+Fe+"]: "+z+`
`+q+`
`+xt})}function bo(_,z,q,ne,Fe,Ge,xt){_.info(function(){return"XMLHTTP RESP ("+ne+") [ attempt "+Fe+"]: "+z+`
`+q+`
`+Ge+" "+xt})}function bs(_,z,q,ne){_.info(function(){return"XMLHTTP TEXT ("+z+"): "+Pi(_,q)+(ne?" "+ne:"")})}function hi(_,z){_.info(function(){return"TIMEOUT: "+z})}Qi.prototype.info=function(){};function Pi(_,z){if(!_.g)return z;if(!z)return null;try{const Ge=JSON.parse(z);if(Ge){for(_=0;_<Ge.length;_++)if(Array.isArray(Ge[_])){var q=Ge[_];if(!(q.length<2)){var ne=q[1];if(Array.isArray(ne)&&!(ne.length<1)){var Fe=ne[0];if(Fe!="noop"&&Fe!="stop"&&Fe!="close")for(let xt=1;xt<ne.length;xt++)ne[xt]=""}}}}return Tn(Ge)}catch{return z}}var Or={NO_ERROR:0,cb:1,qb:2,pb:3,kb:4,ob:5,rb:6,Ga:7,TIMEOUT:8,ub:9},cs={ib:"complete",Fb:"success",ERROR:"error",Ga:"abort",xb:"ready",yb:"readystatechange",TIMEOUT:"timeout",sb:"incrementaldata",wb:"progress",lb:"downloadprogress",Nb:"uploadprogress"},Aa;function Ji(){}d(Ji,Ar),Ji.prototype.g=function(){return new XMLHttpRequest},Aa=new Ji;function cr(_){return encodeURIComponent(String(_))}function Es(_){var z=1;_=_.split(":");const q=[];for(;z>0&&_.length;)q.push(_.shift()),z--;return _.length&&q.push(_.join(":")),q}function ks(_,z,q,ne){this.j=_,this.i=z,this.l=q,this.S=ne||1,this.V=new Vn(this),this.H=45e3,this.J=null,this.o=!1,this.u=this.B=this.A=this.M=this.F=this.T=this.D=null,this.G=[],this.g=null,this.C=0,this.m=this.v=null,this.X=-1,this.K=!1,this.P=0,this.O=null,this.W=this.L=this.U=this.R=!1,this.h=new ua}function ua(){this.i=null,this.g="",this.h=!1}var Ns={},di={};function qs(_,z,q){_.M=1,_.A=Rs(Pr(z)),_.u=q,_.R=!0,Fi(_,null)}function Fi(_,z){_.F=Date.now(),Rr(_),_.B=Pr(_.A);var q=_.B,ne=_.S;Array.isArray(ne)||(ne=[String(ne)]),O(q.i,"t",ne),_.C=0,q=_.j.L,_.h=new ua,_.g=Kl(_.j,q?z:null,!_.u),_.P>0&&(_.O=new Fn(u(_.Y,_,_.g),_.P)),z=_.V,q=_.g,ne=_.ba;var Fe="readystatechange";Array.isArray(Fe)||(Fe&&(Bn[0]=Fe.toString()),Fe=Bn);for(let Ge=0;Ge<Fe.length;Ge++){const xt=Ve(q,Fe[Ge],ne||z.handleEvent,!1,z.h||z);if(!xt)break;z.g[xt.key]=xt}z=_.J?Y(_.J):{},_.u?(_.v||(_.v="POST"),z["Content-Type"]="application/x-www-form-urlencoded",_.g.ea(_.B,_.v,_.u,z)):(_.v="GET",_.g.ea(_.B,_.v,null,z)),Cs(),Po(_.i,_.v,_.B,_.l,_.S,_.u)}ks.prototype.ba=function(_){_=_.target;const z=this.O;z&&xe(_)==3?z.j():this.Y(_)},ks.prototype.Y=function(_){try{if(_==this.g)e:{const xn=xe(this.g),rs=this.g.ya(),pr=this.g.ca();if(!(xn<3)&&(xn!=3||this.g&&(this.h.h||this.g.la()||Me(this.g)))){this.K||xn!=4||rs==7||(rs==8||pr<=0?Cs(3):Cs(2)),Fo(this);var z=this.g.ca();this.X=z;var q=Ks(this);if(this.o=z==200,bo(this.i,this.v,this.B,this.l,this.S,xn,z),this.o){if(this.U&&!this.L){t:{if(this.g){var ne,Fe=this.g;if((ne=Fe.g?Fe.g.getResponseHeader("X-HTTP-Initial-Response"):null)&&!j(ne)){var Ge=ne;break t}}Ge=null}if(_=Ge)bs(this.i,this.l,_,"Initial handshake response via X-HTTP-Initial-Response"),this.L=!0,gn(this,_);else{this.o=!1,this.m=3,Kn(12),fi(this),Xr(this);break e}}if(this.R){_=!0;let Fr;for(;!this.K&&this.C<q.length;)if(Fr=ca(this,q),Fr==di){xn==4&&(this.m=4,Kn(14),_=!1),bs(this.i,this.l,null,"[Incomplete Response]");break}else if(Fr==Ns){this.m=4,Kn(15),bs(this.i,this.l,q,"[Invalid Chunk]"),_=!1;break}else bs(this.i,this.l,Fr,null),gn(this,Fr);if(Ra(this)&&this.C!=0&&(this.h.g=this.h.g.slice(this.C),this.C=0),xn!=4||q.length!=0||this.h.h||(this.m=1,Kn(16),_=!1),this.o=this.o&&_,!_)bs(this.i,this.l,q,"[Invalid Chunked Response]"),fi(this),Xr(this);else if(q.length>0&&!this.W){this.W=!0;var xt=this.j;xt.g==this&&xt.aa&&!xt.P&&(xt.j.info("Great, no buffering proxy detected. Bytes received: "+q.length),Cr(xt),xt.P=!0,Kn(11))}}else bs(this.i,this.l,q,null),gn(this,q);xn==4&&fi(this),this.o&&!this.K&&(xn==4?Pa(this.j,this):(this.o=!1,Rr(this)))}else Qe(this.g),z==400&&q.indexOf("Unknown SID")>0?(this.m=3,Kn(12)):(this.m=0,Kn(13)),fi(this),Xr(this)}}}catch{}finally{}};function Ks(_){if(!Ra(_))return _.g.la();const z=Me(_.g);if(z==="")return"";let q="";const ne=z.length,Fe=xe(_.g)==4;if(!_.h.i){if(typeof TextDecoder>"u")return fi(_),Xr(_),"";_.h.i=new o.TextDecoder}for(let Ge=0;Ge<ne;Ge++)_.h.h=!0,q+=_.h.i.decode(z[Ge],{stream:!(Fe&&Ge==ne-1)});return z.length=0,_.h.g+=q,_.C=0,_.h.g}function Ra(_){return _.g?_.v=="GET"&&_.M!=2&&_.j.Aa:!1}function ca(_,z){var q=_.C,ne=z.indexOf(`
`,q);return ne==-1?di:(q=Number(z.substring(q,ne)),isNaN(q)?Ns:(ne+=1,ne+q>z.length?di:(z=z.slice(ne,ne+q),_.C=ne+q,z)))}ks.prototype.cancel=function(){this.K=!0,fi(this)};function Rr(_){_.T=Date.now()+_.H,cl(_,_.H)}function cl(_,z){if(_.D!=null)throw Error("WatchDog timer not null");_.D=hn(u(_.aa,_),z)}function Fo(_){_.D&&(o.clearTimeout(_.D),_.D=null)}ks.prototype.aa=function(){this.D=null;const _=Date.now();_-this.T>=0?(hi(this.i,this.B),this.M!=2&&(Cs(),Kn(17)),fi(this),this.m=2,Xr(this)):cl(this,this.T-_)};function Xr(_){_.j.I==0||_.K||Pa(_.j,_)}function fi(_){Fo(_);var z=_.O;z&&typeof z.dispose=="function"&&z.dispose(),_.O=null,Ln(_.V),_.g&&(z=_.g,_.g=null,z.abort(),z.dispose())}function gn(_,z){try{var q=_.j;if(q.I!=0&&(q.g==_||xs(q.h,_))){if(!_.L&&xs(q.h,_)&&q.I==3){try{var ne=q.Ba.g.parse(z)}catch{ne=null}if(Array.isArray(ne)&&ne.length==3){var Fe=ne;if(Fe[0]==0){e:if(!q.v){if(q.g)if(q.g.F+3e3<_.F)zi(q),yt(q);else break e;Cn(q),Kn(18)}}else q.xa=Fe[1],0<q.xa-q.K&&Fe[2]<37500&&q.F&&q.A==0&&!q.C&&(q.C=hn(u(q.Va,q),6e3));pi(q.h)<=1&&q.ta&&(q.ta=void 0)}else Ps(q,11)}else if((_.L||q.g==_)&&zi(q),!j(z))for(Fe=q.Ba.g.parse(z),z=0;z<Fe.length;z++){let pr=Fe[z];const Fr=pr[0];if(!(Fr<=q.K))if(q.K=Fr,pr=pr[1],q.I==2)if(pr[0]=="c"){q.M=pr[1],q.ba=pr[2];const Ys=pr[3];Ys!=null&&(q.ka=Ys,q.j.info("VER="+q.ka));const La=pr[4];La!=null&&(q.za=La,q.j.info("SVER="+q.za));const Ma=pr[5];Ma!=null&&typeof Ma=="number"&&Ma>0&&(ne=1.5*Ma,q.O=ne,q.j.info("backChannelRequestTimeoutMs_="+ne)),ne=q;const za=_.g;if(za){const Xl=za.g?za.g.getResponseHeader("X-Client-Wire-Protocol"):null;if(Xl){var Ge=ne.h;Ge.g||Xl.indexOf("spdy")==-1&&Xl.indexOf("quic")==-1&&Xl.indexOf("h2")==-1||(Ge.j=Ge.l,Ge.g=new Set,Ge.h&&(Da(Ge,Ge.h),Ge.h=null))}if(ne.G){const Au=za.g?za.g.getResponseHeader("X-HTTP-Session-Id"):null;Au&&(ne.wa=Au,Hn(ne.J,ne.G,Au))}}q.I=3,q.l&&q.l.ra(),q.aa&&(q.T=Date.now()-_.F,q.j.info("Handshake RTT: "+q.T+"ms")),ne=q;var xt=_;if(ne.na=Sc(ne,ne.L?ne.ba:null,ne.W),xt.L){ha(ne.h,xt);var xn=xt,rs=ne.O;rs&&(xn.H=rs),xn.D&&(Fo(xn),Rr(xn)),ne.g=xt}else or(ne);q.i.length>0&&sn(q)}else pr[0]!="stop"&&pr[0]!="close"||Ps(q,7);else q.I==3&&(pr[0]=="stop"||pr[0]=="close"?pr[0]=="stop"?Ps(q,7):mt(q):pr[0]!="noop"&&q.l&&q.l.qa(pr),q.A=0)}}Cs(4)}catch{}}var hs=class{constructor(_,z){this.g=_,this.map=z}};function Zi(_){this.l=_||10,o.PerformanceNavigationTiming?(_=o.performance.getEntriesByType("navigation"),_=_.length>0&&(_[0].nextHopProtocol=="hq"||_[0].nextHopProtocol=="h2")):_=!!(o.chrome&&o.chrome.loadTimes&&o.chrome.loadTimes()&&o.chrome.loadTimes().wasFetchedViaSpdy),this.j=_?this.l:1,this.g=null,this.j>1&&(this.g=new Set),this.h=null,this.i=[]}function xo(_){return _.h?!0:_.g?_.g.size>=_.j:!1}function pi(_){return _.h?1:_.g?_.g.size:0}function xs(_,z){return _.h?_.h==z:_.g?_.g.has(z):!1}function Da(_,z){_.g?_.g.add(z):_.h=z}function ha(_,z){_.h&&_.h==z?_.h=null:_.g&&_.g.has(z)&&_.g.delete(z)}Zi.prototype.cancel=function(){if(this.i=As(this),this.h)this.h.cancel(),this.h=null;else if(this.g&&this.g.size!==0){for(const _ of this.g.values())_.cancel();this.g.clear()}};function As(_){if(_.h!=null)return _.i.concat(_.h.G);if(_.g!=null&&_.g.size!==0){let z=_.i;for(const q of _.g.values())z=z.concat(q.G);return z}return m(_.i)}var mi=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");function hr(_,z){if(_){_=_.split("&");for(let q=0;q<_.length;q++){const ne=_[q].indexOf("=");let Fe,Ge=null;ne>=0?(Fe=_[q].substring(0,ne),Ge=_[q].substring(ne+1)):Fe=_[q],z(Fe,Ge?decodeURIComponent(Ge.replace(/\+/g," ")):"")}}}function Li(_){this.g=this.o=this.j="",this.u=null,this.m=this.h="",this.l=!1;let z;_ instanceof Li?(this.l=_.l,Lo(this,_.j),this.o=_.o,this.g=_.g,gi(this,_.u),this.h=_.h,Mo(this,U(_.i)),this.m=_.m):_&&(z=String(_).match(mi))?(this.l=!1,Lo(this,z[1]||"",!0),this.o=zo(z[2]||""),this.g=zo(z[3]||"",!0),gi(this,z[4]),this.h=zo(z[5]||"",!0),Mo(this,z[6]||"",!0),this.m=zo(z[7]||"")):(this.l=!1,this.i=new Sn(null,this.l))}Li.prototype.toString=function(){const _=[];var z=this.j;z&&_.push(Vo(z,dl,!0),":");var q=this.g;return(q||z=="file")&&(_.push("//"),(z=this.o)&&_.push(Vo(z,dl,!0),"@"),_.push(cr(q).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),q=this.u,q!=null&&_.push(":",String(q))),(q=this.h)&&(this.g&&q.charAt(0)!="/"&&_.push("/"),_.push(Vo(q,q.charAt(0)=="/"?Mi:_o,!0))),(q=this.i.toString())&&_.push("?",q),(q=this.m)&&_.push("#",Vo(q,da)),_.join("")},Li.prototype.resolve=function(_){const z=Pr(this);let q=!!_.j;q?Lo(z,_.j):q=!!_.o,q?z.o=_.o:q=!!_.g,q?z.g=_.g:q=_.u!=null;var ne=_.h;if(q)gi(z,_.u);else if(q=!!_.h){if(ne.charAt(0)!="/")if(this.g&&!this.h)ne="/"+ne;else{var Fe=z.h.lastIndexOf("/");Fe!=-1&&(ne=z.h.slice(0,Fe+1)+ne)}if(Fe=ne,Fe==".."||Fe==".")ne="";else if(Fe.indexOf("./")!=-1||Fe.indexOf("/.")!=-1){ne=Fe.lastIndexOf("/",0)==0,Fe=Fe.split("/");const Ge=[];for(let xt=0;xt<Fe.length;){const xn=Fe[xt++];xn=="."?ne&&xt==Fe.length&&Ge.push(""):xn==".."?((Ge.length>1||Ge.length==1&&Ge[0]!="")&&Ge.pop(),ne&&xt==Fe.length&&Ge.push("")):(Ge.push(xn),ne=!0)}ne=Ge.join("/")}else ne=Fe}return q?z.h=ne:q=_.i.toString()!=="",q?Mo(z,U(_.i)):q=!!_.m,q&&(z.m=_.m),z};function Pr(_){return new Li(_)}function Lo(_,z,q){_.j=q?zo(z,!0):z,_.j&&(_.j=_.j.replace(/:$/,""))}function gi(_,z){if(z){if(z=Number(z),isNaN(z)||z<0)throw Error("Bad port number "+z);_.u=z}else _.u=null}function Mo(_,z,q){z instanceof Sn?(_.i=z,ce(_.i,_.l)):(q||(z=Vo(z,Bo)),_.i=new Sn(z,_.l))}function Hn(_,z,q){_.i.set(z,q)}function Rs(_){return Hn(_,"zx",Math.floor(Math.random()*2147483648).toString(36)+Math.abs(Math.floor(Math.random()*2147483648)^Date.now()).toString(36)),_}function zo(_,z){return _?z?decodeURI(_.replace(/%25/g,"%2525")):decodeURIComponent(_):""}function Vo(_,z,q){return typeof _=="string"?(_=encodeURI(_).replace(z,hl),q&&(_=_.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),_):null}function hl(_){return _=_.charCodeAt(0),"%"+(_>>4&15).toString(16)+(_&15).toString(16)}var dl=/[#\/\?@]/g,_o=/[#\?:]/g,Mi=/[#\?]/g,Bo=/[#\?@]/g,da=/#/g;function Sn(_,z){this.h=this.g=null,this.i=_||null,this.j=!!z}function yi(_){_.g||(_.g=new Map,_.h=0,_.i&&hr(_.i,function(z,q){_.add(decodeURIComponent(z.replace(/\+/g," ")),q)}))}t=Sn.prototype,t.add=function(_,z){yi(this),this.i=null,_=G(this,_);let q=this.g.get(_);return q||this.g.set(_,q=[]),q.push(z),this.h+=1,this};function fa(_,z){yi(_),z=G(_,z),_.g.has(z)&&(_.i=null,_.h-=_.g.get(z).length,_.g.delete(z))}function pa(_,z){return yi(_),z=G(_,z),_.g.has(z)}t.forEach=function(_,z){yi(this),this.g.forEach(function(q,ne){q.forEach(function(Fe){_.call(z,Fe,ne,this)},this)},this)};function Oa(_,z){yi(_);let q=[];if(typeof z=="string")pa(_,z)&&(q=q.concat(_.g.get(G(_,z))));else for(_=Array.from(_.g.values()),z=0;z<_.length;z++)q=q.concat(_[z]);return q}t.set=function(_,z){return yi(this),this.i=null,_=G(this,_),pa(this,_)&&(this.h-=this.g.get(_).length),this.g.set(_,[z]),this.h+=1,this},t.get=function(_,z){return _?(_=Oa(this,_),_.length>0?String(_[0]):z):z};function O(_,z,q){fa(_,z),q.length>0&&(_.i=null,_.g.set(G(_,z),m(q)),_.h+=q.length)}t.toString=function(){if(this.i)return this.i;if(!this.g)return"";const _=[],z=Array.from(this.g.keys());for(let ne=0;ne<z.length;ne++){var q=z[ne];const Fe=cr(q);q=Oa(this,q);for(let Ge=0;Ge<q.length;Ge++){let xt=Fe;q[Ge]!==""&&(xt+="="+cr(q[Ge])),_.push(xt)}}return this.i=_.join("&")};function U(_){const z=new Sn;return z.i=_.i,_.g&&(z.g=new Map(_.g),z.h=_.h),z}function G(_,z){return z=String(z),_.j&&(z=z.toLowerCase()),z}function ce(_,z){z&&!_.j&&(yi(_),_.i=null,_.g.forEach(function(q,ne){const Fe=ne.toLowerCase();ne!=Fe&&(fa(this,ne),O(this,Fe,q))},_)),_.j=z}function Ne(_,z){const q=new Qi;if(o.Image){const ne=new Image;ne.onload=c(Ae,q,"TestLoadImage: loaded",!0,z,ne),ne.onerror=c(Ae,q,"TestLoadImage: error",!1,z,ne),ne.onabort=c(Ae,q,"TestLoadImage: abort",!1,z,ne),ne.ontimeout=c(Ae,q,"TestLoadImage: timeout",!1,z,ne),o.setTimeout(function(){ne.ontimeout&&ne.ontimeout()},1e4),ne.src=_}else z(!1)}function qe(_,z){const q=new Qi,ne=new AbortController,Fe=setTimeout(()=>{ne.abort(),Ae(q,"TestPingServer: timeout",!1,z)},1e4);fetch(_,{signal:ne.signal}).then(Ge=>{clearTimeout(Fe),Ge.ok?Ae(q,"TestPingServer: ok",!0,z):Ae(q,"TestPingServer: server error",!1,z)}).catch(()=>{clearTimeout(Fe),Ae(q,"TestPingServer: error",!1,z)})}function Ae(_,z,q,ne,Fe){try{Fe&&(Fe.onload=null,Fe.onerror=null,Fe.onabort=null,Fe.ontimeout=null),ne(q)}catch{}}function Ye(){this.g=new fr}function ot(_){this.i=_.Sb||null,this.h=_.ab||!1}d(ot,Ar),ot.prototype.g=function(){return new bt(this.i,this.h)};function bt(_,z){Pt.call(this),this.H=_,this.o=z,this.m=void 0,this.status=this.readyState=0,this.responseType=this.responseText=this.response=this.statusText="",this.onreadystatechange=null,this.A=new Headers,this.h=null,this.F="GET",this.D="",this.g=!1,this.B=this.j=this.l=null,this.v=new AbortController}d(bt,Pt),t=bt.prototype,t.open=function(_,z){if(this.readyState!=0)throw this.abort(),Error("Error reopening a connection");this.F=_,this.D=z,this.readyState=1,Zt(this)},t.send=function(_){if(this.readyState!=1)throw this.abort(),Error("need to call open() first. ");if(this.v.signal.aborted)throw this.abort(),Error("Request was aborted.");this.g=!0;const z={headers:this.A,method:this.F,credentials:this.m,cache:void 0,signal:this.v.signal};_&&(z.body=_),(this.H||o).fetch(new Request(this.D,z)).then(this.Pa.bind(this),this.ga.bind(this))},t.abort=function(){this.response=this.responseText="",this.A=new Headers,this.status=0,this.v.abort(),this.j&&this.j.cancel("Request was aborted.").catch(()=>{}),this.readyState>=1&&this.g&&this.readyState!=4&&(this.g=!1,bn(this)),this.readyState=0},t.Pa=function(_){if(this.g&&(this.l=_,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=_.headers,this.readyState=2,Zt(this)),this.g&&(this.readyState=3,Zt(this),this.g)))if(this.responseType==="arraybuffer")_.arrayBuffer().then(this.Na.bind(this),this.ga.bind(this));else if(typeof o.ReadableStream<"u"&&"body"in _){if(this.j=_.body.getReader(),this.o){if(this.responseType)throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');this.response=[]}else this.response=this.responseText="",this.B=new TextDecoder;tn(this)}else _.text().then(this.Oa.bind(this),this.ga.bind(this))};function tn(_){_.j.read().then(_.Ma.bind(_)).catch(_.ga.bind(_))}t.Ma=function(_){if(this.g){if(this.o&&_.value)this.response.push(_.value);else if(!this.o){var z=_.value?_.value:new Uint8Array(0);(z=this.B.decode(z,{stream:!_.done}))&&(this.response=this.responseText+=z)}_.done?bn(this):Zt(this),this.readyState==3&&tn(this)}},t.Oa=function(_){this.g&&(this.response=this.responseText=_,bn(this))},t.Na=function(_){this.g&&(this.response=_,bn(this))},t.ga=function(){this.g&&bn(this)};function bn(_){_.readyState=4,_.l=null,_.j=null,_.B=null,Zt(_)}t.setRequestHeader=function(_,z){this.A.append(_,z)},t.getResponseHeader=function(_){return this.h&&this.h.get(_.toLowerCase())||""},t.getAllResponseHeaders=function(){if(!this.h)return"";const _=[],z=this.h.entries();for(var q=z.next();!q.done;)q=q.value,_.push(q[0]+": "+q[1]),q=z.next();return _.join(`\r
`)};function Zt(_){_.onreadystatechange&&_.onreadystatechange.call(_)}Object.defineProperty(bt.prototype,"withCredentials",{get:function(){return this.m==="include"},set:function(_){this.m=_?"include":"same-origin"}});function an(_){let z="";return ue(_,function(q,ne){z+=ne,z+=":",z+=q,z+=`\r
`}),z}function kt(_,z,q){e:{for(ne in q){var ne=!1;break e}ne=!0}ne||(q=an(q),typeof _=="string"?q!=null&&cr(q):Hn(_,z,q))}function C(_){Pt.call(this),this.headers=new Map,this.L=_||null,this.h=!1,this.g=null,this.D="",this.o=0,this.l="",this.j=this.B=this.v=this.A=!1,this.m=null,this.F="",this.H=!1}d(C,Pt);var W=/^https?$/i,X=["POST","PUT"];t=C.prototype,t.Fa=function(_){this.H=_},t.ea=function(_,z,q,ne){if(this.g)throw Error("[goog.net.XhrIo] Object is active with another request="+this.D+"; newUri="+_);z=z?z.toUpperCase():"GET",this.D=_,this.l="",this.o=0,this.A=!1,this.h=!0,this.g=this.L?this.L.g():Aa.g(),this.g.onreadystatechange=f(u(this.Ca,this));try{this.B=!0,this.g.open(z,String(_),!0),this.B=!1}catch(Ge){te(this,Ge);return}if(_=q||"",q=new Map(this.headers),ne)if(Object.getPrototypeOf(ne)===Object.prototype)for(var Fe in ne)q.set(Fe,ne[Fe]);else if(typeof ne.keys=="function"&&typeof ne.get=="function")for(const Ge of ne.keys())q.set(Ge,ne.get(Ge));else throw Error("Unknown input type for opt_headers: "+String(ne));ne=Array.from(q.keys()).find(Ge=>Ge.toLowerCase()=="content-type"),Fe=o.FormData&&_ instanceof o.FormData,!(Array.prototype.indexOf.call(X,z,void 0)>=0)||ne||Fe||q.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");for(const[Ge,xt]of q)this.g.setRequestHeader(Ge,xt);this.F&&(this.g.responseType=this.F),"withCredentials"in this.g&&this.g.withCredentials!==this.H&&(this.g.withCredentials=this.H);try{this.m&&(clearTimeout(this.m),this.m=null),this.v=!0,this.g.send(_),this.v=!1}catch(Ge){te(this,Ge)}};function te(_,z){_.h=!1,_.g&&(_.j=!0,_.g.abort(),_.j=!1),_.l=z,_.o=5,ae(_),he(_)}function ae(_){_.A||(_.A=!0,Rt(_,"complete"),Rt(_,"error"))}t.abort=function(_){this.g&&this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1,this.o=_||7,Rt(this,"complete"),Rt(this,"abort"),he(this))},t.N=function(){this.g&&(this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1),he(this,!0)),C.Z.N.call(this)},t.Ca=function(){this.u||(this.B||this.v||this.j?ie(this):this.Xa())},t.Xa=function(){ie(this)};function ie(_){if(_.h&&typeof i<"u"){if(_.v&&xe(_)==4)setTimeout(_.Ca.bind(_),0);else if(Rt(_,"readystatechange"),xe(_)==4){_.h=!1;try{const Ge=_.ca();e:switch(Ge){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var z=!0;break e;default:z=!1}var q;if(!(q=z)){var ne;if(ne=Ge===0){let xt=String(_.D).match(mi)[1]||null;!xt&&o.self&&o.self.location&&(xt=o.self.location.protocol.slice(0,-1)),ne=!W.test(xt?xt.toLowerCase():"")}q=ne}if(q)Rt(_,"complete"),Rt(_,"success");else{_.o=6;try{var Fe=xe(_)>2?_.g.statusText:""}catch{Fe=""}_.l=Fe+" ["+_.ca()+"]",ae(_)}}finally{he(_)}}}}function he(_,z){if(_.g){_.m&&(clearTimeout(_.m),_.m=null);const q=_.g;_.g=null,z||Rt(_,"ready");try{q.onreadystatechange=null}catch{}}}t.isActive=function(){return!!this.g};function xe(_){return _.g?_.g.readyState:0}t.ca=function(){try{return xe(this)>2?this.g.status:-1}catch{return-1}},t.la=function(){try{return this.g?this.g.responseText:""}catch{return""}},t.La=function(_){if(this.g){var z=this.g.responseText;return _&&z.indexOf(_)==0&&(z=z.substring(_.length)),xr(z)}};function Me(_){try{if(!_.g)return null;if("response"in _.g)return _.g.response;switch(_.F){case"":case"text":return _.g.responseText;case"arraybuffer":if("mozResponseArrayBuffer"in _.g)return _.g.mozResponseArrayBuffer}return null}catch{return null}}function Qe(_){const z={};_=(_.g&&xe(_)>=2&&_.g.getAllResponseHeaders()||"").split(`\r
`);for(let ne=0;ne<_.length;ne++){if(j(_[ne]))continue;var q=Es(_[ne]);const Fe=q[0];if(q=q[1],typeof q!="string")continue;q=q.trim();const Ge=z[Fe]||[];z[Fe]=Ge,Ge.push(q)}_e(z,function(ne){return ne.join(", ")})}t.ya=function(){return this.o},t.Ha=function(){return typeof this.l=="string"?this.l:String(this.l)};function Ze(_,z,q){return q&&q.internalChannelParams&&q.internalChannelParams[_]||z}function dt(_){this.za=0,this.i=[],this.j=new Qi,this.ba=this.na=this.J=this.W=this.g=this.wa=this.G=this.H=this.u=this.U=this.o=null,this.Ya=this.V=0,this.Sa=Ze("failFast",!1,_),this.F=this.C=this.v=this.m=this.l=null,this.X=!0,this.xa=this.K=-1,this.Y=this.A=this.D=0,this.Qa=Ze("baseRetryDelayMs",5e3,_),this.Za=Ze("retryDelaySeedMs",1e4,_),this.Ta=Ze("forwardChannelMaxRetries",2,_),this.va=Ze("forwardChannelRequestTimeoutMs",2e4,_),this.ma=_&&_.xmlHttpFactory||void 0,this.Ua=_&&_.Rb||void 0,this.Aa=_&&_.useFetchStreams||!1,this.O=void 0,this.L=_&&_.supportsCrossDomainXhr||!1,this.M="",this.h=new Zi(_&&_.concurrentRequestLimit),this.Ba=new Ye,this.S=_&&_.fastHandshake||!1,this.R=_&&_.encodeInitMessageHeaders||!1,this.S&&this.R&&(this.R=!1),this.Ra=_&&_.Pb||!1,_&&_.ua&&this.j.ua(),_&&_.forceLongPolling&&(this.X=!1),this.aa=!this.S&&this.X&&_&&_.detectBufferingProxy||!1,this.ia=void 0,_&&_.longPollingTimeout&&_.longPollingTimeout>0&&(this.ia=_.longPollingTimeout),this.ta=void 0,this.T=0,this.P=!1,this.ja=this.B=null}t=dt.prototype,t.ka=8,t.I=1,t.connect=function(_,z,q,ne){Kn(0),this.W=_,this.H=z||{},q&&ne!==void 0&&(this.H.OSID=q,this.H.OAID=ne),this.F=this.X,this.J=Sc(this,null,this.W),sn(this)};function mt(_){if(nn(_),_.I==3){var z=_.V++,q=Pr(_.J);if(Hn(q,"SID",_.M),Hn(q,"RID",z),Hn(q,"TYPE","terminate"),Ir(_,q),z=new ks(_,_.j,z),z.M=2,z.A=Rs(Pr(q)),q=!1,o.navigator&&o.navigator.sendBeacon)try{q=o.navigator.sendBeacon(z.A.toString(),"")}catch{}!q&&o.Image&&(new Image().src=z.A,q=!0),q||(z.g=Kl(z.j,null),z.g.ea(z.A)),z.F=Date.now(),Rr(z)}Uo(_)}function yt(_){_.g&&(Cr(_),_.g.cancel(),_.g=null)}function nn(_){yt(_),_.v&&(o.clearTimeout(_.v),_.v=null),zi(_),_.h.cancel(),_.m&&(typeof _.m=="number"&&o.clearTimeout(_.m),_.m=null)}function sn(_){if(!xo(_.h)&&!_.m){_.m=!0;var z=_.Ea;E||D(),L||(E(),L=!0),R.add(z,_),_.D=0}}function er(_,z){return pi(_.h)>=_.h.j-(_.m?1:0)?!1:_.m?(_.i=z.G.concat(_.i),!0):_.I==1||_.I==2||_.D>=(_.Sa?0:_.Ta)?!1:(_.m=hn(u(_.Ea,_,z),Io(_,_.D)),_.D++,!0)}t.Ea=function(_){if(this.m)if(this.m=null,this.I==1){if(!_){this.V=Math.floor(Math.random()*1e5),_=this.V++;const Fe=new ks(this,this.j,_);let Ge=this.o;if(this.U&&(Ge?(Ge=Y(Ge),Te(Ge,this.U)):Ge=this.U),this.u!==null||this.R||(Fe.J=Ge,Ge=null),this.S)e:{for(var z=0,q=0;q<this.i.length;q++){t:{var ne=this.i[q];if("__data__"in ne.map&&(ne=ne.map.__data__,typeof ne=="string")){ne=ne.length;break t}ne=void 0}if(ne===void 0)break;if(z+=ne,z>4096){z=q;break e}if(z===4096||q===this.i.length-1){z=q+1;break e}}z=1e3}else z=1e3;z=Ds(this,Fe,z),q=Pr(this.J),Hn(q,"RID",_),Hn(q,"CVER",22),this.G&&Hn(q,"X-HTTP-Session-Id",this.G),Ir(this,q),Ge&&(this.R?z="headers="+cr(an(Ge))+"&"+z:this.u&&kt(q,this.u,Ge)),Da(this.h,Fe),this.Ra&&Hn(q,"TYPE","init"),this.S?(Hn(q,"$req",z),Hn(q,"SID","null"),Fe.U=!0,qs(Fe,q,null)):qs(Fe,q,z),this.I=2}}else this.I==3&&(_?Xn(this,_):this.i.length==0||xo(this.h)||Xn(this))};function Xn(_,z){var q;z?q=z.l:q=_.V++;const ne=Pr(_.J);Hn(ne,"SID",_.M),Hn(ne,"RID",q),Hn(ne,"AID",_.K),Ir(_,ne),_.u&&_.o&&kt(ne,_.u,_.o),q=new ks(_,_.j,q,_.D+1),_.u===null&&(q.J=_.o),z&&(_.i=z.G.concat(_.i)),z=Ds(_,q,1e3),q.H=Math.round(_.va*.5)+Math.round(_.va*.5*Math.random()),Da(_.h,q),qs(q,ne,z)}function Ir(_,z){_.H&&ue(_.H,function(q,ne){Hn(z,ne,q)}),_.l&&ue({},function(q,ne){Hn(z,ne,q)})}function Ds(_,z,q){q=Math.min(_.i.length,q);const ne=_.l?u(_.l.Ka,_.l,_):null;e:{var Fe=_.i;let xn=-1;for(;;){const rs=["count="+q];xn==-1?q>0?(xn=Fe[0].g,rs.push("ofs="+xn)):xn=0:rs.push("ofs="+xn);let pr=!0;for(let Fr=0;Fr<q;Fr++){var Ge=Fe[Fr].g;const Ys=Fe[Fr].map;if(Ge-=xn,Ge<0)xn=Math.max(0,Fe[Fr].g-100),pr=!1;else try{Ge="req"+Ge+"_"||"";try{var xt=Ys instanceof Map?Ys:Object.entries(Ys);for(const[La,Ma]of xt){let za=Ma;a(Ma)&&(za=Tn(Ma)),rs.push(Ge+La+"="+encodeURIComponent(za))}}catch(La){throw rs.push(Ge+"type="+encodeURIComponent("_badmap")),La}}catch{ne&&ne(Ys)}}if(pr){xt=rs.join("&");break e}}xt=void 0}return _=_.i.splice(0,q),z.G=_,xt}function or(_){if(!_.g&&!_.v){_.Y=1;var z=_.Da;E||D(),L||(E(),L=!0),R.add(z,_),_.A=0}}function Cn(_){return _.g||_.v||_.A>=3?!1:(_.Y++,_.v=hn(u(_.Da,_),Io(_,_.A)),_.A++,!0)}t.Da=function(){if(this.v=null,Os(this),this.aa&&!(this.P||this.g==null||this.T<=0)){var _=4*this.T;this.j.info("BP detection timer enabled: "+_),this.B=hn(u(this.Wa,this),_)}},t.Wa=function(){this.B&&(this.B=null,this.j.info("BP detection timeout reached."),this.j.info("Buffering proxy detected and switch to long-polling!"),this.F=!1,this.P=!0,Kn(10),yt(this),Os(this))};function Cr(_){_.B!=null&&(o.clearTimeout(_.B),_.B=null)}function Os(_){_.g=new ks(_,_.j,"rpc",_.Y),_.u===null&&(_.g.J=_.o),_.g.P=0;var z=Pr(_.na);Hn(z,"RID","rpc"),Hn(z,"SID",_.M),Hn(z,"AID",_.K),Hn(z,"CI",_.F?"0":"1"),!_.F&&_.ia&&Hn(z,"TO",_.ia),Hn(z,"TYPE","xmlhttp"),Ir(_,z),_.u&&_.o&&kt(z,_.u,_.o),_.O&&(_.g.H=_.O);var q=_.g;_=_.ba,q.M=1,q.A=Rs(Pr(z)),q.u=null,q.R=!0,Fi(q,_)}t.Va=function(){this.C!=null&&(this.C=null,yt(this),Cn(this),Kn(19))};function zi(_){_.C!=null&&(o.clearTimeout(_.C),_.C=null)}function Pa(_,z){var q=null;if(_.g==z){zi(_),Cr(_),_.g=null;var ne=2}else if(xs(_.h,z))q=z.G,ha(_.h,z),ne=1;else return;if(_.I!=0){if(z.o)if(ne==1){q=z.u?z.u.length:0,z=Date.now()-z.F;var Fe=_.D;ne=ui(),Rt(ne,new Dn(ne,q)),sn(_)}else or(_);else if(Fe=z.m,Fe==3||Fe==0&&z.X>0||!(ne==1&&er(_,z)||ne==2&&Cn(_)))switch(q&&q.length>0&&(z=_.h,z.i=z.i.concat(q)),Fe){case 1:Ps(_,5);break;case 4:Ps(_,10);break;case 3:Ps(_,6);break;default:Ps(_,2)}}}function Io(_,z){let q=_.Qa+Math.floor(Math.random()*_.Za);return _.isActive()||(q*=2),q*z}function Ps(_,z){if(_.j.info("Error code "+z),z==2){var q=u(_.bb,_),ne=_.Ua;const Fe=!ne;ne=new Li(ne||"//www.google.com/images/cleardot.gif"),o.location&&o.location.protocol=="http"||Lo(ne,"https"),Rs(ne),Fe?Ne(ne.toString(),q):qe(ne.toString(),q)}else Kn(2);_.I=0,_.l&&_.l.pa(z),Uo(_),nn(_)}t.bb=function(_){_?(this.j.info("Successfully pinged google.com"),Kn(2)):(this.j.info("Failed to ping google.com"),Kn(1))};function Uo(_){if(_.I=0,_.ja=[],_.l){const z=As(_.h);(z.length!=0||_.i.length!=0)&&(g(_.ja,z),g(_.ja,_.i),_.h.i.length=0,m(_.i),_.i.length=0),_.l.oa()}}function Sc(_,z,q){var ne=q instanceof Li?Pr(q):new Li(q);if(ne.g!="")z&&(ne.g=z+"."+ne.g),gi(ne,ne.u);else{var Fe=o.location;ne=Fe.protocol,z=z?z+"."+Fe.hostname:Fe.hostname,Fe=+Fe.port;const Ge=new Li(null);ne&&Lo(Ge,ne),z&&(Ge.g=z),Fe&&gi(Ge,Fe),q&&(Ge.h=q),ne=Ge}return q=_.G,z=_.wa,q&&z&&Hn(ne,q,z),Hn(ne,"VER",_.ka),Ir(_,ne),ne}function Kl(_,z,q){if(z&&!_.L)throw Error("Can't create secondary domain capable XhrIo object.");return z=_.Aa&&!_.ma?new C(new ot({ab:q})):new C(_.ma),z.Fa(_.L),z}t.isActive=function(){return!!this.l&&this.l.isActive(this)};function Fp(){}t=Fp.prototype,t.ra=function(){},t.qa=function(){},t.pa=function(){},t.oa=function(){},t.isActive=function(){return!0},t.Ka=function(){};function Nu(){}Nu.prototype.g=function(_,z){return new Xs(_,z)};function Xs(_,z){Pt.call(this),this.g=new dt(z),this.l=_,this.h=z&&z.messageUrlParams||null,_=z&&z.messageHeaders||null,z&&z.clientProtocolHeaderRequired&&(_?_["X-Client-Protocol"]="webchannel":_={"X-Client-Protocol":"webchannel"}),this.g.o=_,_=z&&z.initMessageHeaders||null,z&&z.messageContentType&&(_?_["X-WebChannel-Content-Type"]=z.messageContentType:_={"X-WebChannel-Content-Type":z.messageContentType}),z&&z.sa&&(_?_["X-WebChannel-Client-Profile"]=z.sa:_={"X-WebChannel-Client-Profile":z.sa}),this.g.U=_,(_=z&&z.Qb)&&!j(_)&&(this.g.u=_),this.A=z&&z.supportsCrossDomainXhr||!1,this.v=z&&z.sendRawJson||!1,(z=z&&z.httpSessionIdParam)&&!j(z)&&(this.g.G=z,_=this.h,_!==null&&z in _&&(_=this.h,z in _&&delete _[z])),this.j=new Fa(this)}d(Xs,Pt),Xs.prototype.m=function(){this.g.l=this.j,this.A&&(this.g.L=!0),this.g.connect(this.l,this.h||void 0)},Xs.prototype.close=function(){mt(this.g)},Xs.prototype.o=function(_){var z=this.g;if(typeof _=="string"){var q={};q.__data__=_,_=q}else this.v&&(q={},q.__data__=Tn(_),_=q);z.i.push(new hs(z.Ya++,_)),z.I==3&&sn(z)},Xs.prototype.N=function(){this.g.l=null,delete this.j,mt(this.g),delete this.g,Xs.Z.N.call(this)};function Lp(_){gr.call(this),_.__headers__&&(this.headers=_.__headers__,this.statusCode=_.__status__,delete _.__headers__,delete _.__status__);var z=_.__sm__;if(z){e:{for(const q in z){_=q;break e}_=void 0}(this.i=_)&&(_=this.i,z=z!==null&&_ in z?z[_]:void 0),this.data=z}else this.data=_}d(Lp,gr);function Mp(){ir.call(this),this.status=1}d(Mp,ir);function Fa(_){this.g=_}d(Fa,Fp),Fa.prototype.ra=function(){Rt(this.g,"a")},Fa.prototype.qa=function(_){Rt(this.g,new Lp(_))},Fa.prototype.pa=function(_){Rt(this.g,new Mp)},Fa.prototype.oa=function(){Rt(this.g,"b")},Nu.prototype.createWebChannel=Nu.prototype.g,Xs.prototype.send=Xs.prototype.o,Xs.prototype.open=Xs.prototype.m,Xs.prototype.close=Xs.prototype.close,WL=function(){return new Nu},UL=function(){return ui()},BL=Un,KS={jb:0,mb:1,nb:2,Hb:3,Mb:4,Jb:5,Kb:6,Ib:7,Gb:8,Lb:9,PROXY:10,NOPROXY:11,Eb:12,Ab:13,Bb:14,zb:15,Cb:16,Db:17,fb:18,eb:19,gb:20},Or.NO_ERROR=0,Or.TIMEOUT=8,Or.HTTP_ERROR=6,Vv=Or,cs.COMPLETE="complete",VL=cs,Hs.EventType=qr,qr.OPEN="a",qr.CLOSE="b",qr.ERROR="c",qr.MESSAGE="d",Pt.prototype.listen=Pt.prototype.J,U2=Hs,C.prototype.listenOnce=C.prototype.K,C.prototype.getLastError=C.prototype.Ha,C.prototype.getLastErrorCode=C.prototype.ya,C.prototype.getStatus=C.prototype.ca,C.prototype.getResponseJson=C.prototype.La,C.prototype.getResponseText=C.prototype.la,C.prototype.send=C.prototype.ea,C.prototype.setWithCredentials=C.prototype.Fa,zL=C}).apply(typeof nv<"u"?nv:typeof self<"u"?self:typeof window<"u"?window:{});const u5="@firebase/firestore",c5="4.9.2";class ao{constructor(e){this.uid=e}isAuthenticated(){return this.uid!=null}toKey(){return this.isAuthenticated()?"uid:"+this.uid:"anonymous-user"}isEqual(e){return e.uid===this.uid}}ao.UNAUTHENTICATED=new ao(null),ao.GOOGLE_CREDENTIALS=new ao("google-credentials-uid"),ao.FIRST_PARTY=new ao("first-party-uid"),ao.MOCK_USER=new ao("mock-user");let ng="12.3.0";const Wd=new IC("@firebase/firestore");function hm(){return Wd.logLevel}function Dt(t,...e){if(Wd.logLevel<=Qn.DEBUG){const n=e.map(OC);Wd.debug(`Firestore (${ng}): ${t}`,...n)}}function rc(t,...e){if(Wd.logLevel<=Qn.ERROR){const n=e.map(OC);Wd.error(`Firestore (${ng}): ${t}`,...n)}}function km(t,...e){if(Wd.logLevel<=Qn.WARN){const n=e.map(OC);Wd.warn(`Firestore (${ng}): ${t}`,...n)}}function OC(t){if(typeof t=="string")return t;try{return(function(n){return JSON.stringify(n)})(t)}catch{return t}}function pn(t,e,n){let r="Unexpected state";typeof e=="string"?r=e:n=e,jL(t,r,n)}function jL(t,e,n){let r=`FIRESTORE (${ng}) INTERNAL ASSERTION FAILED: ${e} (ID: ${t.toString(16)})`;if(n!==void 0)try{r+=" CONTEXT: "+JSON.stringify(n)}catch{r+=" CONTEXT: "+n}throw rc(r),new Error(r)}function vr(t,e,n,r){let s="Unexpected state";typeof n=="string"?s=n:r=n,t||jL(e,s,r)}function kn(t,e){return t}const lt={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class Jt extends pc{constructor(e,n){super(e,n),this.code=e,this.message=n,this.toString=()=>`${this.name}: [code=${this.code}]: ${this.message}`}}class Dd{constructor(){this.promise=new Promise(((e,n)=>{this.resolve=e,this.reject=n}))}}class GL{constructor(e,n){this.user=n,this.type="OAuth",this.headers=new Map,this.headers.set("Authorization",`Bearer ${e}`)}}class Qee{getToken(){return Promise.resolve(null)}invalidateToken(){}start(e,n){e.enqueueRetryable((()=>n(ao.UNAUTHENTICATED)))}shutdown(){}}class Jee{constructor(e){this.token=e,this.changeListener=null}getToken(){return Promise.resolve(this.token)}invalidateToken(){}start(e,n){this.changeListener=n,e.enqueueRetryable((()=>n(this.token.user)))}shutdown(){this.changeListener=null}}class Zee{constructor(e){this.t=e,this.currentUser=ao.UNAUTHENTICATED,this.i=0,this.forceRefresh=!1,this.auth=null}start(e,n){vr(this.o===void 0,42304);let r=this.i;const s=l=>this.i!==r?(r=this.i,n(l)):Promise.resolve();let i=new Dd;this.o=()=>{this.i++,this.currentUser=this.u(),i.resolve(),i=new Dd,e.enqueueRetryable((()=>s(this.currentUser)))};const o=()=>{const l=i;e.enqueueRetryable((async()=>{await l.promise,await s(this.currentUser)}))},a=l=>{Dt("FirebaseAuthCredentialsProvider","Auth detected"),this.auth=l,this.o&&(this.auth.addAuthTokenListener(this.o),o())};this.t.onInit((l=>a(l))),setTimeout((()=>{if(!this.auth){const l=this.t.getImmediate({optional:!0});l?a(l):(Dt("FirebaseAuthCredentialsProvider","Auth not yet detected"),i.resolve(),i=new Dd)}}),0),o()}getToken(){const e=this.i,n=this.forceRefresh;return this.forceRefresh=!1,this.auth?this.auth.getToken(n).then((r=>this.i!==e?(Dt("FirebaseAuthCredentialsProvider","getToken aborted due to token change."),this.getToken()):r?(vr(typeof r.accessToken=="string",31837,{l:r}),new GL(r.accessToken,this.currentUser)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.auth&&this.o&&this.auth.removeAuthTokenListener(this.o),this.o=void 0}u(){const e=this.auth&&this.auth.getUid();return vr(e===null||typeof e=="string",2055,{h:e}),new ao(e)}}class ete{constructor(e,n,r){this.P=e,this.T=n,this.I=r,this.type="FirstParty",this.user=ao.FIRST_PARTY,this.A=new Map}R(){return this.I?this.I():null}get headers(){this.A.set("X-Goog-AuthUser",this.P);const e=this.R();return e&&this.A.set("Authorization",e),this.T&&this.A.set("X-Goog-Iam-Authorization-Token",this.T),this.A}}class tte{constructor(e,n,r){this.P=e,this.T=n,this.I=r}getToken(){return Promise.resolve(new ete(this.P,this.T,this.I))}start(e,n){e.enqueueRetryable((()=>n(ao.FIRST_PARTY)))}shutdown(){}invalidateToken(){}}class h5{constructor(e){this.value=e,this.type="AppCheck",this.headers=new Map,e&&e.length>0&&this.headers.set("x-firebase-appcheck",this.value)}}class nte{constructor(e,n){this.V=n,this.forceRefresh=!1,this.appCheck=null,this.m=null,this.p=null,Ja(e)&&e.settings.appCheckToken&&(this.p=e.settings.appCheckToken)}start(e,n){vr(this.o===void 0,3512);const r=i=>{i.error!=null&&Dt("FirebaseAppCheckTokenProvider",`Error getting App Check token; using placeholder token instead. Error: ${i.error.message}`);const o=i.token!==this.m;return this.m=i.token,Dt("FirebaseAppCheckTokenProvider",`Received ${o?"new":"existing"} token.`),o?n(i.token):Promise.resolve()};this.o=i=>{e.enqueueRetryable((()=>r(i)))};const s=i=>{Dt("FirebaseAppCheckTokenProvider","AppCheck detected"),this.appCheck=i,this.o&&this.appCheck.addTokenListener(this.o)};this.V.onInit((i=>s(i))),setTimeout((()=>{if(!this.appCheck){const i=this.V.getImmediate({optional:!0});i?s(i):Dt("FirebaseAppCheckTokenProvider","AppCheck not yet detected")}}),0)}getToken(){if(this.p)return Promise.resolve(new h5(this.p));const e=this.forceRefresh;return this.forceRefresh=!1,this.appCheck?this.appCheck.getToken(e).then((n=>n?(vr(typeof n.token=="string",44558,{tokenResult:n}),this.m=n.token,new h5(n.token)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.appCheck&&this.o&&this.appCheck.removeTokenListener(this.o),this.o=void 0}}function rte(t){const e=typeof self<"u"&&(self.crypto||self.msCrypto),n=new Uint8Array(t);if(e&&typeof e.getRandomValues=="function")e.getRandomValues(n);else for(let r=0;r<t;r++)n[r]=Math.floor(256*Math.random());return n}class PC{static newId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",n=62*Math.floor(4.129032258064516);let r="";for(;r.length<20;){const s=rte(40);for(let i=0;i<s.length;++i)r.length<20&&s[i]<n&&(r+=e.charAt(s[i]%62))}return r}}function Jn(t,e){return t<e?-1:t>e?1:0}function XS(t,e){const n=Math.min(t.length,e.length);for(let r=0;r<n;r++){const s=t.charAt(r),i=e.charAt(r);if(s!==i)return aT(s)===aT(i)?Jn(s,i):aT(s)?1:-1}return Jn(t.length,e.length)}const ste=55296,ite=57343;function aT(t){const e=t.charCodeAt(0);return e>=ste&&e<=ite}function Nm(t,e,n){return t.length===e.length&&t.every(((r,s)=>n(r,e[s])))}const d5="__name__";class nu{constructor(e,n,r){n===void 0?n=0:n>e.length&&pn(637,{offset:n,range:e.length}),r===void 0?r=e.length-n:r>e.length-n&&pn(1746,{length:r,range:e.length-n}),this.segments=e,this.offset=n,this.len=r}get length(){return this.len}isEqual(e){return nu.comparator(this,e)===0}child(e){const n=this.segments.slice(this.offset,this.limit());return e instanceof nu?e.forEach((r=>{n.push(r)})):n.push(e),this.construct(n)}limit(){return this.offset+this.length}popFirst(e){return e=e===void 0?1:e,this.construct(this.segments,this.offset+e,this.length-e)}popLast(){return this.construct(this.segments,this.offset,this.length-1)}firstSegment(){return this.segments[this.offset]}lastSegment(){return this.get(this.length-1)}get(e){return this.segments[this.offset+e]}isEmpty(){return this.length===0}isPrefixOf(e){if(e.length<this.length)return!1;for(let n=0;n<this.length;n++)if(this.get(n)!==e.get(n))return!1;return!0}isImmediateParentOf(e){if(this.length+1!==e.length)return!1;for(let n=0;n<this.length;n++)if(this.get(n)!==e.get(n))return!1;return!0}forEach(e){for(let n=this.offset,r=this.limit();n<r;n++)e(this.segments[n])}toArray(){return this.segments.slice(this.offset,this.limit())}static comparator(e,n){const r=Math.min(e.length,n.length);for(let s=0;s<r;s++){const i=nu.compareSegments(e.get(s),n.get(s));if(i!==0)return i}return Jn(e.length,n.length)}static compareSegments(e,n){const r=nu.isNumericId(e),s=nu.isNumericId(n);return r&&!s?-1:!r&&s?1:r&&s?nu.extractNumericId(e).compare(nu.extractNumericId(n)):XS(e,n)}static isNumericId(e){return e.startsWith("__id")&&e.endsWith("__")}static extractNumericId(e){return dh.fromString(e.substring(4,e.length-2))}}class Br extends nu{construct(e,n,r){return new Br(e,n,r)}canonicalString(){return this.toArray().join("/")}toString(){return this.canonicalString()}toUriEncodedString(){return this.toArray().map(encodeURIComponent).join("/")}static fromString(...e){const n=[];for(const r of e){if(r.indexOf("//")>=0)throw new Jt(lt.INVALID_ARGUMENT,`Invalid segment (${r}). Paths must not contain // in them.`);n.push(...r.split("/").filter((s=>s.length>0)))}return new Br(n)}static emptyPath(){return new Br([])}}const ote=/^[_a-zA-Z][_a-zA-Z0-9]*$/;class Wi extends nu{construct(e,n,r){return new Wi(e,n,r)}static isValidIdentifier(e){return ote.test(e)}canonicalString(){return this.toArray().map((e=>(e=e.replace(/\\/g,"\\\\").replace(/`/g,"\\`"),Wi.isValidIdentifier(e)||(e="`"+e+"`"),e))).join(".")}toString(){return this.canonicalString()}isKeyField(){return this.length===1&&this.get(0)===d5}static keyField(){return new Wi([d5])}static fromServerFormat(e){const n=[];let r="",s=0;const i=()=>{if(r.length===0)throw new Jt(lt.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);n.push(r),r=""};let o=!1;for(;s<e.length;){const a=e[s];if(a==="\\"){if(s+1===e.length)throw new Jt(lt.INVALID_ARGUMENT,"Path has trailing escape character: "+e);const l=e[s+1];if(l!=="\\"&&l!=="."&&l!=="`")throw new Jt(lt.INVALID_ARGUMENT,"Path has invalid escape sequence: "+e);r+=l,s+=2}else a==="`"?(o=!o,s++):a!=="."||o?(r+=a,s++):(i(),s++)}if(i(),o)throw new Jt(lt.INVALID_ARGUMENT,"Unterminated ` in path: "+e);return new Wi(n)}static emptyPath(){return new Wi([])}}class on{constructor(e){this.path=e}static fromPath(e){return new on(Br.fromString(e))}static fromName(e){return new on(Br.fromString(e).popFirst(5))}static empty(){return new on(Br.emptyPath())}get collectionGroup(){return this.path.popLast().lastSegment()}hasCollectionId(e){return this.path.length>=2&&this.path.get(this.path.length-2)===e}getCollectionGroup(){return this.path.get(this.path.length-2)}getCollectionPath(){return this.path.popLast()}isEqual(e){return e!==null&&Br.comparator(this.path,e.path)===0}toString(){return this.path.toString()}static comparator(e,n){return Br.comparator(e.path,n.path)}static isDocumentKey(e){return e.length%2==0}static fromSegments(e){return new on(new Br(e.slice()))}}function HL(t,e,n){if(!n)throw new Jt(lt.INVALID_ARGUMENT,`Function ${t}() cannot be called with an empty ${e}.`)}function ate(t,e,n,r){if(e===!0&&r===!0)throw new Jt(lt.INVALID_ARGUMENT,`${t} and ${n} cannot be used together.`)}function f5(t){if(!on.isDocumentKey(t))throw new Jt(lt.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`)}function p5(t){if(on.isDocumentKey(t))throw new Jt(lt.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`)}function qL(t){return typeof t=="object"&&t!==null&&(Object.getPrototypeOf(t)===Object.prototype||Object.getPrototypeOf(t)===null)}function FC(t){if(t===void 0)return"undefined";if(t===null)return"null";if(typeof t=="string")return t.length>20&&(t=`${t.substring(0,20)}...`),JSON.stringify(t);if(typeof t=="number"||typeof t=="boolean")return""+t;if(typeof t=="object"){if(t instanceof Array)return"an array";{const e=(function(r){return r.constructor?r.constructor.name:null})(t);return e?`a custom ${e} object`:"an object"}}return typeof t=="function"?"a function":pn(12329,{type:typeof t})}function Od(t,e){if("_delegate"in t&&(t=t._delegate),!(t instanceof e)){if(e.name===t.constructor.name)throw new Jt(lt.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");{const n=FC(t);throw new Jt(lt.INVALID_ARGUMENT,`Expected type '${e.name}', but it was: ${n}`)}}return t}function zs(t,e){const n={typeString:t};return e&&(n.value=e),n}function Qy(t,e){if(!qL(t))throw new Jt(lt.INVALID_ARGUMENT,"JSON must be an object");let n;for(const r in e)if(e[r]){const s=e[r].typeString,i="value"in e[r]?{value:e[r].value}:void 0;if(!(r in t)){n=`JSON missing required field: '${r}'`;break}const o=t[r];if(s&&typeof o!==s){n=`JSON field '${r}' must be a ${s}.`;break}if(i!==void 0&&o!==i.value){n=`Expected '${r}' field to equal '${i.value}'`;break}}if(n)throw new Jt(lt.INVALID_ARGUMENT,n);return!0}const m5=-62135596800,g5=1e6;class Ur{static now(){return Ur.fromMillis(Date.now())}static fromDate(e){return Ur.fromMillis(e.getTime())}static fromMillis(e){const n=Math.floor(e/1e3),r=Math.floor((e-1e3*n)*g5);return new Ur(n,r)}constructor(e,n){if(this.seconds=e,this.nanoseconds=n,n<0)throw new Jt(lt.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+n);if(n>=1e9)throw new Jt(lt.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+n);if(e<m5)throw new Jt(lt.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e);if(e>=253402300800)throw new Jt(lt.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e)}toDate(){return new Date(this.toMillis())}toMillis(){return 1e3*this.seconds+this.nanoseconds/g5}_compareTo(e){return this.seconds===e.seconds?Jn(this.nanoseconds,e.nanoseconds):Jn(this.seconds,e.seconds)}isEqual(e){return e.seconds===this.seconds&&e.nanoseconds===this.nanoseconds}toString(){return"Timestamp(seconds="+this.seconds+", nanoseconds="+this.nanoseconds+")"}toJSON(){return{type:Ur._jsonSchemaVersion,seconds:this.seconds,nanoseconds:this.nanoseconds}}static fromJSON(e){if(Qy(e,Ur._jsonSchema))return new Ur(e.seconds,e.nanoseconds)}valueOf(){const e=this.seconds-m5;return String(e).padStart(12,"0")+"."+String(this.nanoseconds).padStart(9,"0")}}Ur._jsonSchemaVersion="firestore/timestamp/1.0",Ur._jsonSchema={type:zs("string",Ur._jsonSchemaVersion),seconds:zs("number"),nanoseconds:zs("number")};class $n{static fromTimestamp(e){return new $n(e)}static min(){return new $n(new Ur(0,0))}static max(){return new $n(new Ur(253402300799,999999999))}constructor(e){this.timestamp=e}compareTo(e){return this.timestamp._compareTo(e.timestamp)}isEqual(e){return this.timestamp.isEqual(e.timestamp)}toMicroseconds(){return 1e6*this.timestamp.seconds+this.timestamp.nanoseconds/1e3}toString(){return"SnapshotVersion("+this.timestamp.toString()+")"}toTimestamp(){return this.timestamp}}const gy=-1;function lte(t,e){const n=t.toTimestamp().seconds,r=t.toTimestamp().nanoseconds+1,s=$n.fromTimestamp(r===1e9?new Ur(n+1,0):new Ur(n,r));return new xh(s,on.empty(),e)}function ute(t){return new xh(t.readTime,t.key,gy)}class xh{constructor(e,n,r){this.readTime=e,this.documentKey=n,this.largestBatchId=r}static min(){return new xh($n.min(),on.empty(),gy)}static max(){return new xh($n.max(),on.empty(),gy)}}function cte(t,e){let n=t.readTime.compareTo(e.readTime);return n!==0?n:(n=on.comparator(t.documentKey,e.documentKey),n!==0?n:Jn(t.largestBatchId,e.largestBatchId))}const hte="The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";class dte{constructor(){this.onCommittedListeners=[]}addOnCommittedListener(e){this.onCommittedListeners.push(e)}raiseOnCommittedEvent(){this.onCommittedListeners.forEach((e=>e()))}}async function rg(t){if(t.code!==lt.FAILED_PRECONDITION||t.message!==hte)throw t;Dt("LocalStore","Unexpectedly lost primary lease")}class st{constructor(e){this.nextCallback=null,this.catchCallback=null,this.result=void 0,this.error=void 0,this.isDone=!1,this.callbackAttached=!1,e((n=>{this.isDone=!0,this.result=n,this.nextCallback&&this.nextCallback(n)}),(n=>{this.isDone=!0,this.error=n,this.catchCallback&&this.catchCallback(n)}))}catch(e){return this.next(void 0,e)}next(e,n){return this.callbackAttached&&pn(59440),this.callbackAttached=!0,this.isDone?this.error?this.wrapFailure(n,this.error):this.wrapSuccess(e,this.result):new st(((r,s)=>{this.nextCallback=i=>{this.wrapSuccess(e,i).next(r,s)},this.catchCallback=i=>{this.wrapFailure(n,i).next(r,s)}}))}toPromise(){return new Promise(((e,n)=>{this.next(e,n)}))}wrapUserFunction(e){try{const n=e();return n instanceof st?n:st.resolve(n)}catch(n){return st.reject(n)}}wrapSuccess(e,n){return e?this.wrapUserFunction((()=>e(n))):st.resolve(n)}wrapFailure(e,n){return e?this.wrapUserFunction((()=>e(n))):st.reject(n)}static resolve(e){return new st(((n,r)=>{n(e)}))}static reject(e){return new st(((n,r)=>{r(e)}))}static waitFor(e){return new st(((n,r)=>{let s=0,i=0,o=!1;e.forEach((a=>{++s,a.next((()=>{++i,o&&i===s&&n()}),(l=>r(l)))})),o=!0,i===s&&n()}))}static or(e){let n=st.resolve(!1);for(const r of e)n=n.next((s=>s?st.resolve(s):r()));return n}static forEach(e,n){const r=[];return e.forEach(((s,i)=>{r.push(n.call(this,s,i))})),this.waitFor(r)}static mapArray(e,n){return new st(((r,s)=>{const i=e.length,o=new Array(i);let a=0;for(let l=0;l<i;l++){const u=l;n(e[u]).next((c=>{o[u]=c,++a,a===i&&r(o)}),(c=>s(c)))}}))}static doWhile(e,n){return new st(((r,s)=>{const i=()=>{e()===!0?n().next((()=>{i()}),s):r()};i()}))}}function fte(t){const e=t.match(/Android ([\d.]+)/i),n=e?e[1].split(".").slice(0,2).join("."):"-1";return Number(n)}function sg(t){return t.name==="IndexedDbTransactionError"}class gx{constructor(e,n){this.previousValue=e,n&&(n.sequenceNumberHandler=r=>this.ae(r),this.ue=r=>n.writeSequenceNumber(r))}ae(e){return this.previousValue=Math.max(e,this.previousValue),this.previousValue}next(){const e=++this.previousValue;return this.ue&&this.ue(e),e}}gx.ce=-1;const LC=-1;function yx(t){return t==null}function wb(t){return t===0&&1/t==-1/0}function pte(t){return typeof t=="number"&&Number.isInteger(t)&&!wb(t)&&t<=Number.MAX_SAFE_INTEGER&&t>=Number.MIN_SAFE_INTEGER}const KL="";function mte(t){let e="";for(let n=0;n<t.length;n++)e.length>0&&(e=y5(e)),e=gte(t.get(n),e);return y5(e)}function gte(t,e){let n=e;const r=t.length;for(let s=0;s<r;s++){const i=t.charAt(s);switch(i){case"\0":n+="";break;case KL:n+="";break;default:n+=i}}return n}function y5(t){return t+KL+""}function w5(t){let e=0;for(const n in t)Object.prototype.hasOwnProperty.call(t,n)&&e++;return e}function wf(t,e){for(const n in t)Object.prototype.hasOwnProperty.call(t,n)&&e(n,t[n])}function XL(t){for(const e in t)if(Object.prototype.hasOwnProperty.call(t,e))return!1;return!0}class ls{constructor(e,n){this.comparator=e,this.root=n||Ui.EMPTY}insert(e,n){return new ls(this.comparator,this.root.insert(e,n,this.comparator).copy(null,null,Ui.BLACK,null,null))}remove(e){return new ls(this.comparator,this.root.remove(e,this.comparator).copy(null,null,Ui.BLACK,null,null))}get(e){let n=this.root;for(;!n.isEmpty();){const r=this.comparator(e,n.key);if(r===0)return n.value;r<0?n=n.left:r>0&&(n=n.right)}return null}indexOf(e){let n=0,r=this.root;for(;!r.isEmpty();){const s=this.comparator(e,r.key);if(s===0)return n+r.left.size;s<0?r=r.left:(n+=r.left.size+1,r=r.right)}return-1}isEmpty(){return this.root.isEmpty()}get size(){return this.root.size}minKey(){return this.root.minKey()}maxKey(){return this.root.maxKey()}inorderTraversal(e){return this.root.inorderTraversal(e)}forEach(e){this.inorderTraversal(((n,r)=>(e(n,r),!1)))}toString(){const e=[];return this.inorderTraversal(((n,r)=>(e.push(`${n}:${r}`),!1))),`{${e.join(", ")}}`}reverseTraversal(e){return this.root.reverseTraversal(e)}getIterator(){return new rv(this.root,null,this.comparator,!1)}getIteratorFrom(e){return new rv(this.root,e,this.comparator,!1)}getReverseIterator(){return new rv(this.root,null,this.comparator,!0)}getReverseIteratorFrom(e){return new rv(this.root,e,this.comparator,!0)}}class rv{constructor(e,n,r,s){this.isReverse=s,this.nodeStack=[];let i=1;for(;!e.isEmpty();)if(i=n?r(e.key,n):1,n&&s&&(i*=-1),i<0)e=this.isReverse?e.left:e.right;else{if(i===0){this.nodeStack.push(e);break}this.nodeStack.push(e),e=this.isReverse?e.right:e.left}}getNext(){let e=this.nodeStack.pop();const n={key:e.key,value:e.value};if(this.isReverse)for(e=e.left;!e.isEmpty();)this.nodeStack.push(e),e=e.right;else for(e=e.right;!e.isEmpty();)this.nodeStack.push(e),e=e.left;return n}hasNext(){return this.nodeStack.length>0}peek(){if(this.nodeStack.length===0)return null;const e=this.nodeStack[this.nodeStack.length-1];return{key:e.key,value:e.value}}}class Ui{constructor(e,n,r,s,i){this.key=e,this.value=n,this.color=r??Ui.RED,this.left=s??Ui.EMPTY,this.right=i??Ui.EMPTY,this.size=this.left.size+1+this.right.size}copy(e,n,r,s,i){return new Ui(e??this.key,n??this.value,r??this.color,s??this.left,i??this.right)}isEmpty(){return!1}inorderTraversal(e){return this.left.inorderTraversal(e)||e(this.key,this.value)||this.right.inorderTraversal(e)}reverseTraversal(e){return this.right.reverseTraversal(e)||e(this.key,this.value)||this.left.reverseTraversal(e)}min(){return this.left.isEmpty()?this:this.left.min()}minKey(){return this.min().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(e,n,r){let s=this;const i=r(e,s.key);return s=i<0?s.copy(null,null,null,s.left.insert(e,n,r),null):i===0?s.copy(null,n,null,null,null):s.copy(null,null,null,null,s.right.insert(e,n,r)),s.fixUp()}removeMin(){if(this.left.isEmpty())return Ui.EMPTY;let e=this;return e.left.isRed()||e.left.left.isRed()||(e=e.moveRedLeft()),e=e.copy(null,null,null,e.left.removeMin(),null),e.fixUp()}remove(e,n){let r,s=this;if(n(e,s.key)<0)s.left.isEmpty()||s.left.isRed()||s.left.left.isRed()||(s=s.moveRedLeft()),s=s.copy(null,null,null,s.left.remove(e,n),null);else{if(s.left.isRed()&&(s=s.rotateRight()),s.right.isEmpty()||s.right.isRed()||s.right.left.isRed()||(s=s.moveRedRight()),n(e,s.key)===0){if(s.right.isEmpty())return Ui.EMPTY;r=s.right.min(),s=s.copy(r.key,r.value,null,null,s.right.removeMin())}s=s.copy(null,null,null,null,s.right.remove(e,n))}return s.fixUp()}isRed(){return this.color}fixUp(){let e=this;return e.right.isRed()&&!e.left.isRed()&&(e=e.rotateLeft()),e.left.isRed()&&e.left.left.isRed()&&(e=e.rotateRight()),e.left.isRed()&&e.right.isRed()&&(e=e.colorFlip()),e}moveRedLeft(){let e=this.colorFlip();return e.right.left.isRed()&&(e=e.copy(null,null,null,null,e.right.rotateRight()),e=e.rotateLeft(),e=e.colorFlip()),e}moveRedRight(){let e=this.colorFlip();return e.left.left.isRed()&&(e=e.rotateRight(),e=e.colorFlip()),e}rotateLeft(){const e=this.copy(null,null,Ui.RED,null,this.right.left);return this.right.copy(null,null,this.color,e,null)}rotateRight(){const e=this.copy(null,null,Ui.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,e)}colorFlip(){const e=this.left.copy(null,null,!this.left.color,null,null),n=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,e,n)}checkMaxDepth(){const e=this.check();return Math.pow(2,e)<=this.size+1}check(){if(this.isRed()&&this.left.isRed())throw pn(43730,{key:this.key,value:this.value});if(this.right.isRed())throw pn(14113,{key:this.key,value:this.value});const e=this.left.check();if(e!==this.right.check())throw pn(27949);return e+(this.isRed()?0:1)}}Ui.EMPTY=null,Ui.RED=!0,Ui.BLACK=!1;Ui.EMPTY=new class{constructor(){this.size=0}get key(){throw pn(57766)}get value(){throw pn(16141)}get color(){throw pn(16727)}get left(){throw pn(29726)}get right(){throw pn(36894)}copy(e,n,r,s,i){return this}insert(e,n,r){return new Ui(e,n)}remove(e,n){return this}isEmpty(){return!0}inorderTraversal(e){return!1}reverseTraversal(e){return!1}minKey(){return null}maxKey(){return null}isRed(){return!1}checkMaxDepth(){return!0}check(){return 0}};class ri{constructor(e){this.comparator=e,this.data=new ls(this.comparator)}has(e){return this.data.get(e)!==null}first(){return this.data.minKey()}last(){return this.data.maxKey()}get size(){return this.data.size}indexOf(e){return this.data.indexOf(e)}forEach(e){this.data.inorderTraversal(((n,r)=>(e(n),!1)))}forEachInRange(e,n){const r=this.data.getIteratorFrom(e[0]);for(;r.hasNext();){const s=r.getNext();if(this.comparator(s.key,e[1])>=0)return;n(s.key)}}forEachWhile(e,n){let r;for(r=n!==void 0?this.data.getIteratorFrom(n):this.data.getIterator();r.hasNext();)if(!e(r.getNext().key))return}firstAfterOrEqual(e){const n=this.data.getIteratorFrom(e);return n.hasNext()?n.getNext().key:null}getIterator(){return new v5(this.data.getIterator())}getIteratorFrom(e){return new v5(this.data.getIteratorFrom(e))}add(e){return this.copy(this.data.remove(e).insert(e,!0))}delete(e){return this.has(e)?this.copy(this.data.remove(e)):this}isEmpty(){return this.data.isEmpty()}unionWith(e){let n=this;return n.size<e.size&&(n=e,e=this),e.forEach((r=>{n=n.add(r)})),n}isEqual(e){if(!(e instanceof ri)||this.size!==e.size)return!1;const n=this.data.getIterator(),r=e.data.getIterator();for(;n.hasNext();){const s=n.getNext().key,i=r.getNext().key;if(this.comparator(s,i)!==0)return!1}return!0}toArray(){const e=[];return this.forEach((n=>{e.push(n)})),e}toString(){const e=[];return this.forEach((n=>e.push(n))),"SortedSet("+e.toString()+")"}copy(e){const n=new ri(this.comparator);return n.data=e,n}}class v5{constructor(e){this.iter=e}getNext(){return this.iter.getNext().key}hasNext(){return this.iter.hasNext()}}class Nl{constructor(e){this.fields=e,e.sort(Wi.comparator)}static empty(){return new Nl([])}unionWith(e){let n=new ri(Wi.comparator);for(const r of this.fields)n=n.add(r);for(const r of e)n=n.add(r);return new Nl(n.toArray())}covers(e){for(const n of this.fields)if(n.isPrefixOf(e))return!0;return!1}isEqual(e){return Nm(this.fields,e.fields,((n,r)=>n.isEqual(r)))}}class YL extends Error{constructor(){super(...arguments),this.name="Base64DecodeError"}}class Gi{constructor(e){this.binaryString=e}static fromBase64String(e){const n=(function(s){try{return atob(s)}catch(i){throw typeof DOMException<"u"&&i instanceof DOMException?new YL("Invalid base64 string: "+i):i}})(e);return new Gi(n)}static fromUint8Array(e){const n=(function(s){let i="";for(let o=0;o<s.length;++o)i+=String.fromCharCode(s[o]);return i})(e);return new Gi(n)}[Symbol.iterator](){let e=0;return{next:()=>e<this.binaryString.length?{value:this.binaryString.charCodeAt(e++),done:!1}:{value:void 0,done:!0}}}toBase64(){return(function(n){return btoa(n)})(this.binaryString)}toUint8Array(){return(function(n){const r=new Uint8Array(n.length);for(let s=0;s<n.length;s++)r[s]=n.charCodeAt(s);return r})(this.binaryString)}approximateByteSize(){return 2*this.binaryString.length}compareTo(e){return Jn(this.binaryString,e.binaryString)}isEqual(e){return this.binaryString===e.binaryString}}Gi.EMPTY_BYTE_STRING=new Gi("");const yte=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function _h(t){if(vr(!!t,39018),typeof t=="string"){let e=0;const n=yte.exec(t);if(vr(!!n,46558,{timestamp:t}),n[1]){let s=n[1];s=(s+"000000000").substr(0,9),e=Number(s)}const r=new Date(t);return{seconds:Math.floor(r.getTime()/1e3),nanos:e}}return{seconds:Is(t.seconds),nanos:Is(t.nanos)}}function Is(t){return typeof t=="number"?t:typeof t=="string"?Number(t):0}function Ih(t){return typeof t=="string"?Gi.fromBase64String(t):Gi.fromUint8Array(t)}const QL="server_timestamp",JL="__type__",ZL="__previous_value__",eM="__local_write_time__";function MC(t){return(t?.mapValue?.fields||{})[JL]?.stringValue===QL}function wx(t){const e=t.mapValue.fields[ZL];return MC(e)?wx(e):e}function yy(t){const e=_h(t.mapValue.fields[eM].timestampValue);return new Ur(e.seconds,e.nanos)}class wte{constructor(e,n,r,s,i,o,a,l,u,c){this.databaseId=e,this.appId=n,this.persistenceKey=r,this.host=s,this.ssl=i,this.forceLongPolling=o,this.autoDetectLongPolling=a,this.longPollingOptions=l,this.useFetchStreams=u,this.isUsingEmulator=c}}const vb="(default)";class wy{constructor(e,n){this.projectId=e,this.database=n||vb}static empty(){return new wy("","")}get isDefaultDatabase(){return this.database===vb}isEqual(e){return e instanceof wy&&e.projectId===this.projectId&&e.database===this.database}}const tM="__type__",vte="__max__",sv={mapValue:{}},nM="__vector__",bb="value";function Th(t){return"nullValue"in t?0:"booleanValue"in t?1:"integerValue"in t||"doubleValue"in t?2:"timestampValue"in t?3:"stringValue"in t?5:"bytesValue"in t?6:"referenceValue"in t?7:"geoPointValue"in t?8:"arrayValue"in t?9:"mapValue"in t?MC(t)?4:xte(t)?9007199254740991:bte(t)?10:11:pn(28295,{value:t})}function vu(t,e){if(t===e)return!0;const n=Th(t);if(n!==Th(e))return!1;switch(n){case 0:case 9007199254740991:return!0;case 1:return t.booleanValue===e.booleanValue;case 4:return yy(t).isEqual(yy(e));case 3:return(function(s,i){if(typeof s.timestampValue=="string"&&typeof i.timestampValue=="string"&&s.timestampValue.length===i.timestampValue.length)return s.timestampValue===i.timestampValue;const o=_h(s.timestampValue),a=_h(i.timestampValue);return o.seconds===a.seconds&&o.nanos===a.nanos})(t,e);case 5:return t.stringValue===e.stringValue;case 6:return(function(s,i){return Ih(s.bytesValue).isEqual(Ih(i.bytesValue))})(t,e);case 7:return t.referenceValue===e.referenceValue;case 8:return(function(s,i){return Is(s.geoPointValue.latitude)===Is(i.geoPointValue.latitude)&&Is(s.geoPointValue.longitude)===Is(i.geoPointValue.longitude)})(t,e);case 2:return(function(s,i){if("integerValue"in s&&"integerValue"in i)return Is(s.integerValue)===Is(i.integerValue);if("doubleValue"in s&&"doubleValue"in i){const o=Is(s.doubleValue),a=Is(i.doubleValue);return o===a?wb(o)===wb(a):isNaN(o)&&isNaN(a)}return!1})(t,e);case 9:return Nm(t.arrayValue.values||[],e.arrayValue.values||[],vu);case 10:case 11:return(function(s,i){const o=s.mapValue.fields||{},a=i.mapValue.fields||{};if(w5(o)!==w5(a))return!1;for(const l in o)if(o.hasOwnProperty(l)&&(a[l]===void 0||!vu(o[l],a[l])))return!1;return!0})(t,e);default:return pn(52216,{left:t})}}function vy(t,e){return(t.values||[]).find((n=>vu(n,e)))!==void 0}function Am(t,e){if(t===e)return 0;const n=Th(t),r=Th(e);if(n!==r)return Jn(n,r);switch(n){case 0:case 9007199254740991:return 0;case 1:return Jn(t.booleanValue,e.booleanValue);case 2:return(function(i,o){const a=Is(i.integerValue||i.doubleValue),l=Is(o.integerValue||o.doubleValue);return a<l?-1:a>l?1:a===l?0:isNaN(a)?isNaN(l)?0:-1:1})(t,e);case 3:return b5(t.timestampValue,e.timestampValue);case 4:return b5(yy(t),yy(e));case 5:return XS(t.stringValue,e.stringValue);case 6:return(function(i,o){const a=Ih(i),l=Ih(o);return a.compareTo(l)})(t.bytesValue,e.bytesValue);case 7:return(function(i,o){const a=i.split("/"),l=o.split("/");for(let u=0;u<a.length&&u<l.length;u++){const c=Jn(a[u],l[u]);if(c!==0)return c}return Jn(a.length,l.length)})(t.referenceValue,e.referenceValue);case 8:return(function(i,o){const a=Jn(Is(i.latitude),Is(o.latitude));return a!==0?a:Jn(Is(i.longitude),Is(o.longitude))})(t.geoPointValue,e.geoPointValue);case 9:return x5(t.arrayValue,e.arrayValue);case 10:return(function(i,o){const a=i.fields||{},l=o.fields||{},u=a[bb]?.arrayValue,c=l[bb]?.arrayValue,d=Jn(u?.values?.length||0,c?.values?.length||0);return d!==0?d:x5(u,c)})(t.mapValue,e.mapValue);case 11:return(function(i,o){if(i===sv.mapValue&&o===sv.mapValue)return 0;if(i===sv.mapValue)return 1;if(o===sv.mapValue)return-1;const a=i.fields||{},l=Object.keys(a),u=o.fields||{},c=Object.keys(u);l.sort(),c.sort();for(let d=0;d<l.length&&d<c.length;++d){const f=XS(l[d],c[d]);if(f!==0)return f;const m=Am(a[l[d]],u[c[d]]);if(m!==0)return m}return Jn(l.length,c.length)})(t.mapValue,e.mapValue);default:throw pn(23264,{he:n})}}function b5(t,e){if(typeof t=="string"&&typeof e=="string"&&t.length===e.length)return Jn(t,e);const n=_h(t),r=_h(e),s=Jn(n.seconds,r.seconds);return s!==0?s:Jn(n.nanos,r.nanos)}function x5(t,e){const n=t.values||[],r=e.values||[];for(let s=0;s<n.length&&s<r.length;++s){const i=Am(n[s],r[s]);if(i)return i}return Jn(n.length,r.length)}function Rm(t){return YS(t)}function YS(t){return"nullValue"in t?"null":"booleanValue"in t?""+t.booleanValue:"integerValue"in t?""+t.integerValue:"doubleValue"in t?""+t.doubleValue:"timestampValue"in t?(function(n){const r=_h(n);return`time(${r.seconds},${r.nanos})`})(t.timestampValue):"stringValue"in t?t.stringValue:"bytesValue"in t?(function(n){return Ih(n).toBase64()})(t.bytesValue):"referenceValue"in t?(function(n){return on.fromName(n).toString()})(t.referenceValue):"geoPointValue"in t?(function(n){return`geo(${n.latitude},${n.longitude})`})(t.geoPointValue):"arrayValue"in t?(function(n){let r="[",s=!0;for(const i of n.values||[])s?s=!1:r+=",",r+=YS(i);return r+"]"})(t.arrayValue):"mapValue"in t?(function(n){const r=Object.keys(n.fields||{}).sort();let s="{",i=!0;for(const o of r)i?i=!1:s+=",",s+=`${o}:${YS(n.fields[o])}`;return s+"}"})(t.mapValue):pn(61005,{value:t})}function Bv(t){switch(Th(t)){case 0:case 1:return 4;case 2:return 8;case 3:case 8:return 16;case 4:const e=wx(t);return e?16+Bv(e):16;case 5:return 2*t.stringValue.length;case 6:return Ih(t.bytesValue).approximateByteSize();case 7:return t.referenceValue.length;case 9:return(function(r){return(r.values||[]).reduce(((s,i)=>s+Bv(i)),0)})(t.arrayValue);case 10:case 11:return(function(r){let s=0;return wf(r.fields,((i,o)=>{s+=i.length+Bv(o)})),s})(t.mapValue);default:throw pn(13486,{value:t})}}function QS(t){return!!t&&"integerValue"in t}function zC(t){return!!t&&"arrayValue"in t}function _5(t){return!!t&&"nullValue"in t}function I5(t){return!!t&&"doubleValue"in t&&isNaN(Number(t.doubleValue))}function Uv(t){return!!t&&"mapValue"in t}function bte(t){return(t?.mapValue?.fields||{})[tM]?.stringValue===nM}function ly(t){if(t.geoPointValue)return{geoPointValue:{...t.geoPointValue}};if(t.timestampValue&&typeof t.timestampValue=="object")return{timestampValue:{...t.timestampValue}};if(t.mapValue){const e={mapValue:{fields:{}}};return wf(t.mapValue.fields,((n,r)=>e.mapValue.fields[n]=ly(r))),e}if(t.arrayValue){const e={arrayValue:{values:[]}};for(let n=0;n<(t.arrayValue.values||[]).length;++n)e.arrayValue.values[n]=ly(t.arrayValue.values[n]);return e}return{...t}}function xte(t){return(((t.mapValue||{}).fields||{}).__type__||{}).stringValue===vte}class Za{constructor(e){this.value=e}static empty(){return new Za({mapValue:{}})}field(e){if(e.isEmpty())return this.value;{let n=this.value;for(let r=0;r<e.length-1;++r)if(n=(n.mapValue.fields||{})[e.get(r)],!Uv(n))return null;return n=(n.mapValue.fields||{})[e.lastSegment()],n||null}}set(e,n){this.getFieldsMap(e.popLast())[e.lastSegment()]=ly(n)}setAll(e){let n=Wi.emptyPath(),r={},s=[];e.forEach(((o,a)=>{if(!n.isImmediateParentOf(a)){const l=this.getFieldsMap(n);this.applyChanges(l,r,s),r={},s=[],n=a.popLast()}o?r[a.lastSegment()]=ly(o):s.push(a.lastSegment())}));const i=this.getFieldsMap(n);this.applyChanges(i,r,s)}delete(e){const n=this.field(e.popLast());Uv(n)&&n.mapValue.fields&&delete n.mapValue.fields[e.lastSegment()]}isEqual(e){return vu(this.value,e.value)}getFieldsMap(e){let n=this.value;n.mapValue.fields||(n.mapValue={fields:{}});for(let r=0;r<e.length;++r){let s=n.mapValue.fields[e.get(r)];Uv(s)&&s.mapValue.fields||(s={mapValue:{fields:{}}},n.mapValue.fields[e.get(r)]=s),n=s}return n.mapValue.fields}applyChanges(e,n,r){wf(n,((s,i)=>e[s]=i));for(const s of r)delete e[s]}clone(){return new Za(ly(this.value))}}function rM(t){const e=[];return wf(t.fields,((n,r)=>{const s=new Wi([n]);if(Uv(r)){const i=rM(r.mapValue).fields;if(i.length===0)e.push(s);else for(const o of i)e.push(s.child(o))}else e.push(s)})),new Nl(e)}class uo{constructor(e,n,r,s,i,o,a){this.key=e,this.documentType=n,this.version=r,this.readTime=s,this.createTime=i,this.data=o,this.documentState=a}static newInvalidDocument(e){return new uo(e,0,$n.min(),$n.min(),$n.min(),Za.empty(),0)}static newFoundDocument(e,n,r,s){return new uo(e,1,n,$n.min(),r,s,0)}static newNoDocument(e,n){return new uo(e,2,n,$n.min(),$n.min(),Za.empty(),0)}static newUnknownDocument(e,n){return new uo(e,3,n,$n.min(),$n.min(),Za.empty(),2)}convertToFoundDocument(e,n){return!this.createTime.isEqual($n.min())||this.documentType!==2&&this.documentType!==0||(this.createTime=e),this.version=e,this.documentType=1,this.data=n,this.documentState=0,this}convertToNoDocument(e){return this.version=e,this.documentType=2,this.data=Za.empty(),this.documentState=0,this}convertToUnknownDocument(e){return this.version=e,this.documentType=3,this.data=Za.empty(),this.documentState=2,this}setHasCommittedMutations(){return this.documentState=2,this}setHasLocalMutations(){return this.documentState=1,this.version=$n.min(),this}setReadTime(e){return this.readTime=e,this}get hasLocalMutations(){return this.documentState===1}get hasCommittedMutations(){return this.documentState===2}get hasPendingWrites(){return this.hasLocalMutations||this.hasCommittedMutations}isValidDocument(){return this.documentType!==0}isFoundDocument(){return this.documentType===1}isNoDocument(){return this.documentType===2}isUnknownDocument(){return this.documentType===3}isEqual(e){return e instanceof uo&&this.key.isEqual(e.key)&&this.version.isEqual(e.version)&&this.documentType===e.documentType&&this.documentState===e.documentState&&this.data.isEqual(e.data)}mutableCopy(){return new uo(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)}toString(){return`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`}}class xb{constructor(e,n){this.position=e,this.inclusive=n}}function T5(t,e,n){let r=0;for(let s=0;s<t.position.length;s++){const i=e[s],o=t.position[s];if(i.field.isKeyField()?r=on.comparator(on.fromName(o.referenceValue),n.key):r=Am(o,n.data.field(i.field)),i.dir==="desc"&&(r*=-1),r!==0)break}return r}function S5(t,e){if(t===null)return e===null;if(e===null||t.inclusive!==e.inclusive||t.position.length!==e.position.length)return!1;for(let n=0;n<t.position.length;n++)if(!vu(t.position[n],e.position[n]))return!1;return!0}class _b{constructor(e,n="asc"){this.field=e,this.dir=n}}function _te(t,e){return t.dir===e.dir&&t.field.isEqual(e.field)}class sM{}class ei extends sM{constructor(e,n,r){super(),this.field=e,this.op=n,this.value=r}static create(e,n,r){return e.isKeyField()?n==="in"||n==="not-in"?this.createKeyFieldInFilter(e,n,r):new Tte(e,n,r):n==="array-contains"?new Cte(e,r):n==="in"?new Ete(e,r):n==="not-in"?new kte(e,r):n==="array-contains-any"?new Nte(e,r):new ei(e,n,r)}static createKeyFieldInFilter(e,n,r){return n==="in"?new Ste(e,r):new $te(e,r)}matches(e){const n=e.data.field(this.field);return this.op==="!="?n!==null&&n.nullValue===void 0&&this.matchesComparison(Am(n,this.value)):n!==null&&Th(this.value)===Th(n)&&this.matchesComparison(Am(n,this.value))}matchesComparison(e){switch(this.op){case"<":return e<0;case"<=":return e<=0;case"==":return e===0;case"!=":return e!==0;case">":return e>0;case">=":return e>=0;default:return pn(47266,{operator:this.op})}}isInequality(){return["<","<=",">",">=","!=","not-in"].indexOf(this.op)>=0}getFlattenedFilters(){return[this]}getFilters(){return[this]}}class bu extends sM{constructor(e,n){super(),this.filters=e,this.op=n,this.Pe=null}static create(e,n){return new bu(e,n)}matches(e){return iM(this)?this.filters.find((n=>!n.matches(e)))===void 0:this.filters.find((n=>n.matches(e)))!==void 0}getFlattenedFilters(){return this.Pe!==null||(this.Pe=this.filters.reduce(((e,n)=>e.concat(n.getFlattenedFilters())),[])),this.Pe}getFilters(){return Object.assign([],this.filters)}}function iM(t){return t.op==="and"}function oM(t){return Ite(t)&&iM(t)}function Ite(t){for(const e of t.filters)if(e instanceof bu)return!1;return!0}function JS(t){if(t instanceof ei)return t.field.canonicalString()+t.op.toString()+Rm(t.value);if(oM(t))return t.filters.map((e=>JS(e))).join(",");{const e=t.filters.map((n=>JS(n))).join(",");return`${t.op}(${e})`}}function aM(t,e){return t instanceof ei?(function(r,s){return s instanceof ei&&r.op===s.op&&r.field.isEqual(s.field)&&vu(r.value,s.value)})(t,e):t instanceof bu?(function(r,s){return s instanceof bu&&r.op===s.op&&r.filters.length===s.filters.length?r.filters.reduce(((i,o,a)=>i&&aM(o,s.filters[a])),!0):!1})(t,e):void pn(19439)}function lM(t){return t instanceof ei?(function(n){return`${n.field.canonicalString()} ${n.op} ${Rm(n.value)}`})(t):t instanceof bu?(function(n){return n.op.toString()+" {"+n.getFilters().map(lM).join(" ,")+"}"})(t):"Filter"}class Tte extends ei{constructor(e,n,r){super(e,n,r),this.key=on.fromName(r.referenceValue)}matches(e){const n=on.comparator(e.key,this.key);return this.matchesComparison(n)}}class Ste extends ei{constructor(e,n){super(e,"in",n),this.keys=uM("in",n)}matches(e){return this.keys.some((n=>n.isEqual(e.key)))}}class $te extends ei{constructor(e,n){super(e,"not-in",n),this.keys=uM("not-in",n)}matches(e){return!this.keys.some((n=>n.isEqual(e.key)))}}function uM(t,e){return(e.arrayValue?.values||[]).map((n=>on.fromName(n.referenceValue)))}class Cte extends ei{constructor(e,n){super(e,"array-contains",n)}matches(e){const n=e.data.field(this.field);return zC(n)&&vy(n.arrayValue,this.value)}}class Ete extends ei{constructor(e,n){super(e,"in",n)}matches(e){const n=e.data.field(this.field);return n!==null&&vy(this.value.arrayValue,n)}}class kte extends ei{constructor(e,n){super(e,"not-in",n)}matches(e){if(vy(this.value.arrayValue,{nullValue:"NULL_VALUE"}))return!1;const n=e.data.field(this.field);return n!==null&&n.nullValue===void 0&&!vy(this.value.arrayValue,n)}}class Nte extends ei{constructor(e,n){super(e,"array-contains-any",n)}matches(e){const n=e.data.field(this.field);return!(!zC(n)||!n.arrayValue.values)&&n.arrayValue.values.some((r=>vy(this.value.arrayValue,r)))}}class Ate{constructor(e,n=null,r=[],s=[],i=null,o=null,a=null){this.path=e,this.collectionGroup=n,this.orderBy=r,this.filters=s,this.limit=i,this.startAt=o,this.endAt=a,this.Te=null}}function $5(t,e=null,n=[],r=[],s=null,i=null,o=null){return new Ate(t,e,n,r,s,i,o)}function VC(t){const e=kn(t);if(e.Te===null){let n=e.path.canonicalString();e.collectionGroup!==null&&(n+="|cg:"+e.collectionGroup),n+="|f:",n+=e.filters.map((r=>JS(r))).join(","),n+="|ob:",n+=e.orderBy.map((r=>(function(i){return i.field.canonicalString()+i.dir})(r))).join(","),yx(e.limit)||(n+="|l:",n+=e.limit),e.startAt&&(n+="|lb:",n+=e.startAt.inclusive?"b:":"a:",n+=e.startAt.position.map((r=>Rm(r))).join(",")),e.endAt&&(n+="|ub:",n+=e.endAt.inclusive?"a:":"b:",n+=e.endAt.position.map((r=>Rm(r))).join(",")),e.Te=n}return e.Te}function BC(t,e){if(t.limit!==e.limit||t.orderBy.length!==e.orderBy.length)return!1;for(let n=0;n<t.orderBy.length;n++)if(!_te(t.orderBy[n],e.orderBy[n]))return!1;if(t.filters.length!==e.filters.length)return!1;for(let n=0;n<t.filters.length;n++)if(!aM(t.filters[n],e.filters[n]))return!1;return t.collectionGroup===e.collectionGroup&&!!t.path.isEqual(e.path)&&!!S5(t.startAt,e.startAt)&&S5(t.endAt,e.endAt)}function ZS(t){return on.isDocumentKey(t.path)&&t.collectionGroup===null&&t.filters.length===0}class vx{constructor(e,n=null,r=[],s=[],i=null,o="F",a=null,l=null){this.path=e,this.collectionGroup=n,this.explicitOrderBy=r,this.filters=s,this.limit=i,this.limitType=o,this.startAt=a,this.endAt=l,this.Ie=null,this.Ee=null,this.de=null,this.startAt,this.endAt}}function Rte(t,e,n,r,s,i,o,a){return new vx(t,e,n,r,s,i,o,a)}function UC(t){return new vx(t)}function C5(t){return t.filters.length===0&&t.limit===null&&t.startAt==null&&t.endAt==null&&(t.explicitOrderBy.length===0||t.explicitOrderBy.length===1&&t.explicitOrderBy[0].field.isKeyField())}function Dte(t){return t.collectionGroup!==null}function uy(t){const e=kn(t);if(e.Ie===null){e.Ie=[];const n=new Set;for(const i of e.explicitOrderBy)e.Ie.push(i),n.add(i.field.canonicalString());const r=e.explicitOrderBy.length>0?e.explicitOrderBy[e.explicitOrderBy.length-1].dir:"asc";(function(o){let a=new ri(Wi.comparator);return o.filters.forEach((l=>{l.getFlattenedFilters().forEach((u=>{u.isInequality()&&(a=a.add(u.field))}))})),a})(e).forEach((i=>{n.has(i.canonicalString())||i.isKeyField()||e.Ie.push(new _b(i,r))})),n.has(Wi.keyField().canonicalString())||e.Ie.push(new _b(Wi.keyField(),r))}return e.Ie}function cu(t){const e=kn(t);return e.Ee||(e.Ee=Ote(e,uy(t))),e.Ee}function Ote(t,e){if(t.limitType==="F")return $5(t.path,t.collectionGroup,e,t.filters,t.limit,t.startAt,t.endAt);{e=e.map((s=>{const i=s.dir==="desc"?"asc":"desc";return new _b(s.field,i)}));const n=t.endAt?new xb(t.endAt.position,t.endAt.inclusive):null,r=t.startAt?new xb(t.startAt.position,t.startAt.inclusive):null;return $5(t.path,t.collectionGroup,e,t.filters,t.limit,n,r)}}function e$(t,e,n){return new vx(t.path,t.collectionGroup,t.explicitOrderBy.slice(),t.filters.slice(),e,n,t.startAt,t.endAt)}function bx(t,e){return BC(cu(t),cu(e))&&t.limitType===e.limitType}function cM(t){return`${VC(cu(t))}|lt:${t.limitType}`}function dm(t){return`Query(target=${(function(n){let r=n.path.canonicalString();return n.collectionGroup!==null&&(r+=" collectionGroup="+n.collectionGroup),n.filters.length>0&&(r+=`, filters: [${n.filters.map((s=>lM(s))).join(", ")}]`),yx(n.limit)||(r+=", limit: "+n.limit),n.orderBy.length>0&&(r+=`, orderBy: [${n.orderBy.map((s=>(function(o){return`${o.field.canonicalString()} (${o.dir})`})(s))).join(", ")}]`),n.startAt&&(r+=", startAt: ",r+=n.startAt.inclusive?"b:":"a:",r+=n.startAt.position.map((s=>Rm(s))).join(",")),n.endAt&&(r+=", endAt: ",r+=n.endAt.inclusive?"a:":"b:",r+=n.endAt.position.map((s=>Rm(s))).join(",")),`Target(${r})`})(cu(t))}; limitType=${t.limitType})`}function xx(t,e){return e.isFoundDocument()&&(function(r,s){const i=s.key.path;return r.collectionGroup!==null?s.key.hasCollectionId(r.collectionGroup)&&r.path.isPrefixOf(i):on.isDocumentKey(r.path)?r.path.isEqual(i):r.path.isImmediateParentOf(i)})(t,e)&&(function(r,s){for(const i of uy(r))if(!i.field.isKeyField()&&s.data.field(i.field)===null)return!1;return!0})(t,e)&&(function(r,s){for(const i of r.filters)if(!i.matches(s))return!1;return!0})(t,e)&&(function(r,s){return!(r.startAt&&!(function(o,a,l){const u=T5(o,a,l);return o.inclusive?u<=0:u<0})(r.startAt,uy(r),s)||r.endAt&&!(function(o,a,l){const u=T5(o,a,l);return o.inclusive?u>=0:u>0})(r.endAt,uy(r),s))})(t,e)}function Pte(t){return t.collectionGroup||(t.path.length%2==1?t.path.lastSegment():t.path.get(t.path.length-2))}function hM(t){return(e,n)=>{let r=!1;for(const s of uy(t)){const i=Fte(s,e,n);if(i!==0)return i;r=r||s.field.isKeyField()}return 0}}function Fte(t,e,n){const r=t.field.isKeyField()?on.comparator(e.key,n.key):(function(i,o,a){const l=o.data.field(i),u=a.data.field(i);return l!==null&&u!==null?Am(l,u):pn(42886)})(t.field,e,n);switch(t.dir){case"asc":return r;case"desc":return-1*r;default:return pn(19790,{direction:t.dir})}}class vf{constructor(e,n){this.mapKeyFn=e,this.equalsFn=n,this.inner={},this.innerSize=0}get(e){const n=this.mapKeyFn(e),r=this.inner[n];if(r!==void 0){for(const[s,i]of r)if(this.equalsFn(s,e))return i}}has(e){return this.get(e)!==void 0}set(e,n){const r=this.mapKeyFn(e),s=this.inner[r];if(s===void 0)return this.inner[r]=[[e,n]],void this.innerSize++;for(let i=0;i<s.length;i++)if(this.equalsFn(s[i][0],e))return void(s[i]=[e,n]);s.push([e,n]),this.innerSize++}delete(e){const n=this.mapKeyFn(e),r=this.inner[n];if(r===void 0)return!1;for(let s=0;s<r.length;s++)if(this.equalsFn(r[s][0],e))return r.length===1?delete this.inner[n]:r.splice(s,1),this.innerSize--,!0;return!1}forEach(e){wf(this.inner,((n,r)=>{for(const[s,i]of r)e(s,i)}))}isEmpty(){return XL(this.inner)}size(){return this.innerSize}}const Lte=new ls(on.comparator);function sc(){return Lte}const dM=new ls(on.comparator);function W2(...t){let e=dM;for(const n of t)e=e.insert(n.key,n);return e}function fM(t){let e=dM;return t.forEach(((n,r)=>e=e.insert(n,r.overlayedDocument))),e}function kd(){return cy()}function pM(){return cy()}function cy(){return new vf((t=>t.toString()),((t,e)=>t.isEqual(e)))}const Mte=new ls(on.comparator),zte=new ri(on.comparator);function Zn(...t){let e=zte;for(const n of t)e=e.add(n);return e}const Vte=new ri(Jn);function Bte(){return Vte}function WC(t,e){if(t.useProto3Json){if(isNaN(e))return{doubleValue:"NaN"};if(e===1/0)return{doubleValue:"Infinity"};if(e===-1/0)return{doubleValue:"-Infinity"}}return{doubleValue:wb(e)?"-0":e}}function mM(t){return{integerValue:""+t}}function Ute(t,e){return pte(e)?mM(e):WC(t,e)}class _x{constructor(){this._=void 0}}function Wte(t,e,n){return t instanceof Ib?(function(s,i){const o={fields:{[JL]:{stringValue:QL},[eM]:{timestampValue:{seconds:s.seconds,nanos:s.nanoseconds}}}};return i&&MC(i)&&(i=wx(i)),i&&(o.fields[ZL]=i),{mapValue:o}})(n,e):t instanceof by?yM(t,e):t instanceof xy?wM(t,e):(function(s,i){const o=gM(s,i),a=E5(o)+E5(s.Ae);return QS(o)&&QS(s.Ae)?mM(a):WC(s.serializer,a)})(t,e)}function jte(t,e,n){return t instanceof by?yM(t,e):t instanceof xy?wM(t,e):n}function gM(t,e){return t instanceof Tb?(function(r){return QS(r)||(function(i){return!!i&&"doubleValue"in i})(r)})(e)?e:{integerValue:0}:null}class Ib extends _x{}class by extends _x{constructor(e){super(),this.elements=e}}function yM(t,e){const n=vM(e);for(const r of t.elements)n.some((s=>vu(s,r)))||n.push(r);return{arrayValue:{values:n}}}class xy extends _x{constructor(e){super(),this.elements=e}}function wM(t,e){let n=vM(e);for(const r of t.elements)n=n.filter((s=>!vu(s,r)));return{arrayValue:{values:n}}}class Tb extends _x{constructor(e,n){super(),this.serializer=e,this.Ae=n}}function E5(t){return Is(t.integerValue||t.doubleValue)}function vM(t){return zC(t)&&t.arrayValue.values?t.arrayValue.values.slice():[]}function Gte(t,e){return t.field.isEqual(e.field)&&(function(r,s){return r instanceof by&&s instanceof by||r instanceof xy&&s instanceof xy?Nm(r.elements,s.elements,vu):r instanceof Tb&&s instanceof Tb?vu(r.Ae,s.Ae):r instanceof Ib&&s instanceof Ib})(t.transform,e.transform)}class Hte{constructor(e,n){this.version=e,this.transformResults=n}}class hu{constructor(e,n){this.updateTime=e,this.exists=n}static none(){return new hu}static exists(e){return new hu(void 0,e)}static updateTime(e){return new hu(e)}get isNone(){return this.updateTime===void 0&&this.exists===void 0}isEqual(e){return this.exists===e.exists&&(this.updateTime?!!e.updateTime&&this.updateTime.isEqual(e.updateTime):!e.updateTime)}}function Wv(t,e){return t.updateTime!==void 0?e.isFoundDocument()&&e.version.isEqual(t.updateTime):t.exists===void 0||t.exists===e.isFoundDocument()}class Ix{}function bM(t,e){if(!t.hasLocalMutations||e&&e.fields.length===0)return null;if(e===null)return t.isNoDocument()?new _M(t.key,hu.none()):new Jy(t.key,t.data,hu.none());{const n=t.data,r=Za.empty();let s=new ri(Wi.comparator);for(let i of e.fields)if(!s.has(i)){let o=n.field(i);o===null&&i.length>1&&(i=i.popLast(),o=n.field(i)),o===null?r.delete(i):r.set(i,o),s=s.add(i)}return new bf(t.key,r,new Nl(s.toArray()),hu.none())}}function qte(t,e,n){t instanceof Jy?(function(s,i,o){const a=s.value.clone(),l=N5(s.fieldTransforms,i,o.transformResults);a.setAll(l),i.convertToFoundDocument(o.version,a).setHasCommittedMutations()})(t,e,n):t instanceof bf?(function(s,i,o){if(!Wv(s.precondition,i))return void i.convertToUnknownDocument(o.version);const a=N5(s.fieldTransforms,i,o.transformResults),l=i.data;l.setAll(xM(s)),l.setAll(a),i.convertToFoundDocument(o.version,l).setHasCommittedMutations()})(t,e,n):(function(s,i,o){i.convertToNoDocument(o.version).setHasCommittedMutations()})(0,e,n)}function hy(t,e,n,r){return t instanceof Jy?(function(i,o,a,l){if(!Wv(i.precondition,o))return a;const u=i.value.clone(),c=A5(i.fieldTransforms,l,o);return u.setAll(c),o.convertToFoundDocument(o.version,u).setHasLocalMutations(),null})(t,e,n,r):t instanceof bf?(function(i,o,a,l){if(!Wv(i.precondition,o))return a;const u=A5(i.fieldTransforms,l,o),c=o.data;return c.setAll(xM(i)),c.setAll(u),o.convertToFoundDocument(o.version,c).setHasLocalMutations(),a===null?null:a.unionWith(i.fieldMask.fields).unionWith(i.fieldTransforms.map((d=>d.field)))})(t,e,n,r):(function(i,o,a){return Wv(i.precondition,o)?(o.convertToNoDocument(o.version).setHasLocalMutations(),null):a})(t,e,n)}function Kte(t,e){let n=null;for(const r of t.fieldTransforms){const s=e.data.field(r.field),i=gM(r.transform,s||null);i!=null&&(n===null&&(n=Za.empty()),n.set(r.field,i))}return n||null}function k5(t,e){return t.type===e.type&&!!t.key.isEqual(e.key)&&!!t.precondition.isEqual(e.precondition)&&!!(function(r,s){return r===void 0&&s===void 0||!(!r||!s)&&Nm(r,s,((i,o)=>Gte(i,o)))})(t.fieldTransforms,e.fieldTransforms)&&(t.type===0?t.value.isEqual(e.value):t.type!==1||t.data.isEqual(e.data)&&t.fieldMask.isEqual(e.fieldMask))}class Jy extends Ix{constructor(e,n,r,s=[]){super(),this.key=e,this.value=n,this.precondition=r,this.fieldTransforms=s,this.type=0}getFieldMask(){return null}}class bf extends Ix{constructor(e,n,r,s,i=[]){super(),this.key=e,this.data=n,this.fieldMask=r,this.precondition=s,this.fieldTransforms=i,this.type=1}getFieldMask(){return this.fieldMask}}function xM(t){const e=new Map;return t.fieldMask.fields.forEach((n=>{if(!n.isEmpty()){const r=t.data.field(n);e.set(n,r)}})),e}function N5(t,e,n){const r=new Map;vr(t.length===n.length,32656,{Re:n.length,Ve:t.length});for(let s=0;s<n.length;s++){const i=t[s],o=i.transform,a=e.data.field(i.field);r.set(i.field,jte(o,a,n[s]))}return r}function A5(t,e,n){const r=new Map;for(const s of t){const i=s.transform,o=n.data.field(s.field);r.set(s.field,Wte(i,o,e))}return r}class _M extends Ix{constructor(e,n){super(),this.key=e,this.precondition=n,this.type=2,this.fieldTransforms=[]}getFieldMask(){return null}}class Xte extends Ix{constructor(e,n){super(),this.key=e,this.precondition=n,this.type=3,this.fieldTransforms=[]}getFieldMask(){return null}}class Yte{constructor(e,n,r,s){this.batchId=e,this.localWriteTime=n,this.baseMutations=r,this.mutations=s}applyToRemoteDocument(e,n){const r=n.mutationResults;for(let s=0;s<this.mutations.length;s++){const i=this.mutations[s];i.key.isEqual(e.key)&&qte(i,e,r[s])}}applyToLocalView(e,n){for(const r of this.baseMutations)r.key.isEqual(e.key)&&(n=hy(r,e,n,this.localWriteTime));for(const r of this.mutations)r.key.isEqual(e.key)&&(n=hy(r,e,n,this.localWriteTime));return n}applyToLocalDocumentSet(e,n){const r=pM();return this.mutations.forEach((s=>{const i=e.get(s.key),o=i.overlayedDocument;let a=this.applyToLocalView(o,i.mutatedFields);a=n.has(s.key)?null:a;const l=bM(o,a);l!==null&&r.set(s.key,l),o.isValidDocument()||o.convertToNoDocument($n.min())})),r}keys(){return this.mutations.reduce(((e,n)=>e.add(n.key)),Zn())}isEqual(e){return this.batchId===e.batchId&&Nm(this.mutations,e.mutations,((n,r)=>k5(n,r)))&&Nm(this.baseMutations,e.baseMutations,((n,r)=>k5(n,r)))}}class jC{constructor(e,n,r,s){this.batch=e,this.commitVersion=n,this.mutationResults=r,this.docVersions=s}static from(e,n,r){vr(e.mutations.length===r.length,58842,{me:e.mutations.length,fe:r.length});let s=(function(){return Mte})();const i=e.mutations;for(let o=0;o<i.length;o++)s=s.insert(i[o].key,r[o].version);return new jC(e,n,r,s)}}class Qte{constructor(e,n){this.largestBatchId=e,this.mutation=n}getKey(){return this.mutation.key}isEqual(e){return e!==null&&this.mutation===e.mutation}toString(){return`Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`}}class Jte{constructor(e,n){this.count=e,this.unchangedNames=n}}var Ls,nr;function Zte(t){switch(t){case lt.OK:return pn(64938);case lt.CANCELLED:case lt.UNKNOWN:case lt.DEADLINE_EXCEEDED:case lt.RESOURCE_EXHAUSTED:case lt.INTERNAL:case lt.UNAVAILABLE:case lt.UNAUTHENTICATED:return!1;case lt.INVALID_ARGUMENT:case lt.NOT_FOUND:case lt.ALREADY_EXISTS:case lt.PERMISSION_DENIED:case lt.FAILED_PRECONDITION:case lt.ABORTED:case lt.OUT_OF_RANGE:case lt.UNIMPLEMENTED:case lt.DATA_LOSS:return!0;default:return pn(15467,{code:t})}}function IM(t){if(t===void 0)return rc("GRPC error has no .code"),lt.UNKNOWN;switch(t){case Ls.OK:return lt.OK;case Ls.CANCELLED:return lt.CANCELLED;case Ls.UNKNOWN:return lt.UNKNOWN;case Ls.DEADLINE_EXCEEDED:return lt.DEADLINE_EXCEEDED;case Ls.RESOURCE_EXHAUSTED:return lt.RESOURCE_EXHAUSTED;case Ls.INTERNAL:return lt.INTERNAL;case Ls.UNAVAILABLE:return lt.UNAVAILABLE;case Ls.UNAUTHENTICATED:return lt.UNAUTHENTICATED;case Ls.INVALID_ARGUMENT:return lt.INVALID_ARGUMENT;case Ls.NOT_FOUND:return lt.NOT_FOUND;case Ls.ALREADY_EXISTS:return lt.ALREADY_EXISTS;case Ls.PERMISSION_DENIED:return lt.PERMISSION_DENIED;case Ls.FAILED_PRECONDITION:return lt.FAILED_PRECONDITION;case Ls.ABORTED:return lt.ABORTED;case Ls.OUT_OF_RANGE:return lt.OUT_OF_RANGE;case Ls.UNIMPLEMENTED:return lt.UNIMPLEMENTED;case Ls.DATA_LOSS:return lt.DATA_LOSS;default:return pn(39323,{code:t})}}(nr=Ls||(Ls={}))[nr.OK=0]="OK",nr[nr.CANCELLED=1]="CANCELLED",nr[nr.UNKNOWN=2]="UNKNOWN",nr[nr.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",nr[nr.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",nr[nr.NOT_FOUND=5]="NOT_FOUND",nr[nr.ALREADY_EXISTS=6]="ALREADY_EXISTS",nr[nr.PERMISSION_DENIED=7]="PERMISSION_DENIED",nr[nr.UNAUTHENTICATED=16]="UNAUTHENTICATED",nr[nr.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",nr[nr.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",nr[nr.ABORTED=10]="ABORTED",nr[nr.OUT_OF_RANGE=11]="OUT_OF_RANGE",nr[nr.UNIMPLEMENTED=12]="UNIMPLEMENTED",nr[nr.INTERNAL=13]="INTERNAL",nr[nr.UNAVAILABLE=14]="UNAVAILABLE",nr[nr.DATA_LOSS=15]="DATA_LOSS";function ene(){return new TextEncoder}const tne=new dh([4294967295,4294967295],0);function R5(t){const e=ene().encode(t),n=new ML;return n.update(e),new Uint8Array(n.digest())}function D5(t){const e=new DataView(t.buffer),n=e.getUint32(0,!0),r=e.getUint32(4,!0),s=e.getUint32(8,!0),i=e.getUint32(12,!0);return[new dh([n,r],0),new dh([s,i],0)]}class GC{constructor(e,n,r){if(this.bitmap=e,this.padding=n,this.hashCount=r,n<0||n>=8)throw new j2(`Invalid padding: ${n}`);if(r<0)throw new j2(`Invalid hash count: ${r}`);if(e.length>0&&this.hashCount===0)throw new j2(`Invalid hash count: ${r}`);if(e.length===0&&n!==0)throw new j2(`Invalid padding when bitmap length is 0: ${n}`);this.ge=8*e.length-n,this.pe=dh.fromNumber(this.ge)}ye(e,n,r){let s=e.add(n.multiply(dh.fromNumber(r)));return s.compare(tne)===1&&(s=new dh([s.getBits(0),s.getBits(1)],0)),s.modulo(this.pe).toNumber()}we(e){return!!(this.bitmap[Math.floor(e/8)]&1<<e%8)}mightContain(e){if(this.ge===0)return!1;const n=R5(e),[r,s]=D5(n);for(let i=0;i<this.hashCount;i++){const o=this.ye(r,s,i);if(!this.we(o))return!1}return!0}static create(e,n,r){const s=e%8==0?0:8-e%8,i=new Uint8Array(Math.ceil(e/8)),o=new GC(i,s,n);return r.forEach((a=>o.insert(a))),o}insert(e){if(this.ge===0)return;const n=R5(e),[r,s]=D5(n);for(let i=0;i<this.hashCount;i++){const o=this.ye(r,s,i);this.Se(o)}}Se(e){const n=Math.floor(e/8),r=e%8;this.bitmap[n]|=1<<r}}class j2 extends Error{constructor(){super(...arguments),this.name="BloomFilterError"}}class Tx{constructor(e,n,r,s,i){this.snapshotVersion=e,this.targetChanges=n,this.targetMismatches=r,this.documentUpdates=s,this.resolvedLimboDocuments=i}static createSynthesizedRemoteEventForCurrentChange(e,n,r){const s=new Map;return s.set(e,Zy.createSynthesizedTargetChangeForCurrentChange(e,n,r)),new Tx($n.min(),s,new ls(Jn),sc(),Zn())}}class Zy{constructor(e,n,r,s,i){this.resumeToken=e,this.current=n,this.addedDocuments=r,this.modifiedDocuments=s,this.removedDocuments=i}static createSynthesizedTargetChangeForCurrentChange(e,n,r){return new Zy(r,n,Zn(),Zn(),Zn())}}class jv{constructor(e,n,r,s){this.be=e,this.removedTargetIds=n,this.key=r,this.De=s}}class TM{constructor(e,n){this.targetId=e,this.Ce=n}}class SM{constructor(e,n,r=Gi.EMPTY_BYTE_STRING,s=null){this.state=e,this.targetIds=n,this.resumeToken=r,this.cause=s}}class O5{constructor(){this.ve=0,this.Fe=P5(),this.Me=Gi.EMPTY_BYTE_STRING,this.xe=!1,this.Oe=!0}get current(){return this.xe}get resumeToken(){return this.Me}get Ne(){return this.ve!==0}get Be(){return this.Oe}Le(e){e.approximateByteSize()>0&&(this.Oe=!0,this.Me=e)}ke(){let e=Zn(),n=Zn(),r=Zn();return this.Fe.forEach(((s,i)=>{switch(i){case 0:e=e.add(s);break;case 2:n=n.add(s);break;case 1:r=r.add(s);break;default:pn(38017,{changeType:i})}})),new Zy(this.Me,this.xe,e,n,r)}qe(){this.Oe=!1,this.Fe=P5()}Qe(e,n){this.Oe=!0,this.Fe=this.Fe.insert(e,n)}$e(e){this.Oe=!0,this.Fe=this.Fe.remove(e)}Ue(){this.ve+=1}Ke(){this.ve-=1,vr(this.ve>=0,3241,{ve:this.ve})}We(){this.Oe=!0,this.xe=!0}}class nne{constructor(e){this.Ge=e,this.ze=new Map,this.je=sc(),this.Je=iv(),this.He=iv(),this.Ye=new ls(Jn)}Ze(e){for(const n of e.be)e.De&&e.De.isFoundDocument()?this.Xe(n,e.De):this.et(n,e.key,e.De);for(const n of e.removedTargetIds)this.et(n,e.key,e.De)}tt(e){this.forEachTarget(e,(n=>{const r=this.nt(n);switch(e.state){case 0:this.rt(n)&&r.Le(e.resumeToken);break;case 1:r.Ke(),r.Ne||r.qe(),r.Le(e.resumeToken);break;case 2:r.Ke(),r.Ne||this.removeTarget(n);break;case 3:this.rt(n)&&(r.We(),r.Le(e.resumeToken));break;case 4:this.rt(n)&&(this.it(n),r.Le(e.resumeToken));break;default:pn(56790,{state:e.state})}}))}forEachTarget(e,n){e.targetIds.length>0?e.targetIds.forEach(n):this.ze.forEach(((r,s)=>{this.rt(s)&&n(s)}))}st(e){const n=e.targetId,r=e.Ce.count,s=this.ot(n);if(s){const i=s.target;if(ZS(i))if(r===0){const o=new on(i.path);this.et(n,o,uo.newNoDocument(o,$n.min()))}else vr(r===1,20013,{expectedCount:r});else{const o=this._t(n);if(o!==r){const a=this.ut(e),l=a?this.ct(a,e,o):1;if(l!==0){this.it(n);const u=l===2?"TargetPurposeExistenceFilterMismatchBloom":"TargetPurposeExistenceFilterMismatch";this.Ye=this.Ye.insert(n,u)}}}}}ut(e){const n=e.Ce.unchangedNames;if(!n||!n.bits)return null;const{bits:{bitmap:r="",padding:s=0},hashCount:i=0}=n;let o,a;try{o=Ih(r).toUint8Array()}catch(l){if(l instanceof YL)return km("Decoding the base64 bloom filter in existence filter failed ("+l.message+"); ignoring the bloom filter and falling back to full re-query."),null;throw l}try{a=new GC(o,s,i)}catch(l){return km(l instanceof j2?"BloomFilter error: ":"Applying bloom filter failed: ",l),null}return a.ge===0?null:a}ct(e,n,r){return n.Ce.count===r-this.Pt(e,n.targetId)?0:2}Pt(e,n){const r=this.Ge.getRemoteKeysForTarget(n);let s=0;return r.forEach((i=>{const o=this.Ge.ht(),a=`projects/${o.projectId}/databases/${o.database}/documents/${i.path.canonicalString()}`;e.mightContain(a)||(this.et(n,i,null),s++)})),s}Tt(e){const n=new Map;this.ze.forEach(((i,o)=>{const a=this.ot(o);if(a){if(i.current&&ZS(a.target)){const l=new on(a.target.path);this.It(l).has(o)||this.Et(o,l)||this.et(o,l,uo.newNoDocument(l,e))}i.Be&&(n.set(o,i.ke()),i.qe())}}));let r=Zn();this.He.forEach(((i,o)=>{let a=!0;o.forEachWhile((l=>{const u=this.ot(l);return!u||u.purpose==="TargetPurposeLimboResolution"||(a=!1,!1)})),a&&(r=r.add(i))})),this.je.forEach(((i,o)=>o.setReadTime(e)));const s=new Tx(e,n,this.Ye,this.je,r);return this.je=sc(),this.Je=iv(),this.He=iv(),this.Ye=new ls(Jn),s}Xe(e,n){if(!this.rt(e))return;const r=this.Et(e,n.key)?2:0;this.nt(e).Qe(n.key,r),this.je=this.je.insert(n.key,n),this.Je=this.Je.insert(n.key,this.It(n.key).add(e)),this.He=this.He.insert(n.key,this.dt(n.key).add(e))}et(e,n,r){if(!this.rt(e))return;const s=this.nt(e);this.Et(e,n)?s.Qe(n,1):s.$e(n),this.He=this.He.insert(n,this.dt(n).delete(e)),this.He=this.He.insert(n,this.dt(n).add(e)),r&&(this.je=this.je.insert(n,r))}removeTarget(e){this.ze.delete(e)}_t(e){const n=this.nt(e).ke();return this.Ge.getRemoteKeysForTarget(e).size+n.addedDocuments.size-n.removedDocuments.size}Ue(e){this.nt(e).Ue()}nt(e){let n=this.ze.get(e);return n||(n=new O5,this.ze.set(e,n)),n}dt(e){let n=this.He.get(e);return n||(n=new ri(Jn),this.He=this.He.insert(e,n)),n}It(e){let n=this.Je.get(e);return n||(n=new ri(Jn),this.Je=this.Je.insert(e,n)),n}rt(e){const n=this.ot(e)!==null;return n||Dt("WatchChangeAggregator","Detected inactive target",e),n}ot(e){const n=this.ze.get(e);return n&&n.Ne?null:this.Ge.At(e)}it(e){this.ze.set(e,new O5),this.Ge.getRemoteKeysForTarget(e).forEach((n=>{this.et(e,n,null)}))}Et(e,n){return this.Ge.getRemoteKeysForTarget(e).has(n)}}function iv(){return new ls(on.comparator)}function P5(){return new ls(on.comparator)}const rne={asc:"ASCENDING",desc:"DESCENDING"},sne={"<":"LESS_THAN","<=":"LESS_THAN_OR_EQUAL",">":"GREATER_THAN",">=":"GREATER_THAN_OR_EQUAL","==":"EQUAL","!=":"NOT_EQUAL","array-contains":"ARRAY_CONTAINS",in:"IN","not-in":"NOT_IN","array-contains-any":"ARRAY_CONTAINS_ANY"},ine={and:"AND",or:"OR"};class one{constructor(e,n){this.databaseId=e,this.useProto3Json=n}}function t$(t,e){return t.useProto3Json||yx(e)?e:{value:e}}function Sb(t,e){return t.useProto3Json?`${new Date(1e3*e.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+e.nanoseconds).slice(-9)}Z`:{seconds:""+e.seconds,nanos:e.nanoseconds}}function $M(t,e){return t.useProto3Json?e.toBase64():e.toUint8Array()}function ane(t,e){return Sb(t,e.toTimestamp())}function du(t){return vr(!!t,49232),$n.fromTimestamp((function(n){const r=_h(n);return new Ur(r.seconds,r.nanos)})(t))}function HC(t,e){return n$(t,e).canonicalString()}function n$(t,e){const n=(function(s){return new Br(["projects",s.projectId,"databases",s.database])})(t).child("documents");return e===void 0?n:n.child(e)}function CM(t){const e=Br.fromString(t);return vr(RM(e),10190,{key:e.toString()}),e}function r$(t,e){return HC(t.databaseId,e.path)}function lT(t,e){const n=CM(e);if(n.get(1)!==t.databaseId.projectId)throw new Jt(lt.INVALID_ARGUMENT,"Tried to deserialize key from different project: "+n.get(1)+" vs "+t.databaseId.projectId);if(n.get(3)!==t.databaseId.database)throw new Jt(lt.INVALID_ARGUMENT,"Tried to deserialize key from different database: "+n.get(3)+" vs "+t.databaseId.database);return new on(kM(n))}function EM(t,e){return HC(t.databaseId,e)}function lne(t){const e=CM(t);return e.length===4?Br.emptyPath():kM(e)}function s$(t){return new Br(["projects",t.databaseId.projectId,"databases",t.databaseId.database]).canonicalString()}function kM(t){return vr(t.length>4&&t.get(4)==="documents",29091,{key:t.toString()}),t.popFirst(5)}function F5(t,e,n){return{name:r$(t,e),fields:n.value.mapValue.fields}}function une(t,e){let n;if("targetChange"in e){e.targetChange;const r=(function(u){return u==="NO_CHANGE"?0:u==="ADD"?1:u==="REMOVE"?2:u==="CURRENT"?3:u==="RESET"?4:pn(39313,{state:u})})(e.targetChange.targetChangeType||"NO_CHANGE"),s=e.targetChange.targetIds||[],i=(function(u,c){return u.useProto3Json?(vr(c===void 0||typeof c=="string",58123),Gi.fromBase64String(c||"")):(vr(c===void 0||c instanceof Buffer||c instanceof Uint8Array,16193),Gi.fromUint8Array(c||new Uint8Array))})(t,e.targetChange.resumeToken),o=e.targetChange.cause,a=o&&(function(u){const c=u.code===void 0?lt.UNKNOWN:IM(u.code);return new Jt(c,u.message||"")})(o);n=new SM(r,s,i,a||null)}else if("documentChange"in e){e.documentChange;const r=e.documentChange;r.document,r.document.name,r.document.updateTime;const s=lT(t,r.document.name),i=du(r.document.updateTime),o=r.document.createTime?du(r.document.createTime):$n.min(),a=new Za({mapValue:{fields:r.document.fields}}),l=uo.newFoundDocument(s,i,o,a),u=r.targetIds||[],c=r.removedTargetIds||[];n=new jv(u,c,l.key,l)}else if("documentDelete"in e){e.documentDelete;const r=e.documentDelete;r.document;const s=lT(t,r.document),i=r.readTime?du(r.readTime):$n.min(),o=uo.newNoDocument(s,i),a=r.removedTargetIds||[];n=new jv([],a,o.key,o)}else if("documentRemove"in e){e.documentRemove;const r=e.documentRemove;r.document;const s=lT(t,r.document),i=r.removedTargetIds||[];n=new jv([],i,s,null)}else{if(!("filter"in e))return pn(11601,{Rt:e});{e.filter;const r=e.filter;r.targetId;const{count:s=0,unchangedNames:i}=r,o=new Jte(s,i),a=r.targetId;n=new TM(a,o)}}return n}function cne(t,e){let n;if(e instanceof Jy)n={update:F5(t,e.key,e.value)};else if(e instanceof _M)n={delete:r$(t,e.key)};else if(e instanceof bf)n={update:F5(t,e.key,e.data),updateMask:vne(e.fieldMask)};else{if(!(e instanceof Xte))return pn(16599,{Vt:e.type});n={verify:r$(t,e.key)}}return e.fieldTransforms.length>0&&(n.updateTransforms=e.fieldTransforms.map((r=>(function(i,o){const a=o.transform;if(a instanceof Ib)return{fieldPath:o.field.canonicalString(),setToServerValue:"REQUEST_TIME"};if(a instanceof by)return{fieldPath:o.field.canonicalString(),appendMissingElements:{values:a.elements}};if(a instanceof xy)return{fieldPath:o.field.canonicalString(),removeAllFromArray:{values:a.elements}};if(a instanceof Tb)return{fieldPath:o.field.canonicalString(),increment:a.Ae};throw pn(20930,{transform:o.transform})})(0,r)))),e.precondition.isNone||(n.currentDocument=(function(s,i){return i.updateTime!==void 0?{updateTime:ane(s,i.updateTime)}:i.exists!==void 0?{exists:i.exists}:pn(27497)})(t,e.precondition)),n}function hne(t,e){return t&&t.length>0?(vr(e!==void 0,14353),t.map((n=>(function(s,i){let o=s.updateTime?du(s.updateTime):du(i);return o.isEqual($n.min())&&(o=du(i)),new Hte(o,s.transformResults||[])})(n,e)))):[]}function dne(t,e){return{documents:[EM(t,e.path)]}}function fne(t,e){const n={structuredQuery:{}},r=e.path;let s;e.collectionGroup!==null?(s=r,n.structuredQuery.from=[{collectionId:e.collectionGroup,allDescendants:!0}]):(s=r.popLast(),n.structuredQuery.from=[{collectionId:r.lastSegment()}]),n.parent=EM(t,s);const i=(function(u){if(u.length!==0)return AM(bu.create(u,"and"))})(e.filters);i&&(n.structuredQuery.where=i);const o=(function(u){if(u.length!==0)return u.map((c=>(function(f){return{field:fm(f.field),direction:gne(f.dir)}})(c)))})(e.orderBy);o&&(n.structuredQuery.orderBy=o);const a=t$(t,e.limit);return a!==null&&(n.structuredQuery.limit=a),e.startAt&&(n.structuredQuery.startAt=(function(u){return{before:u.inclusive,values:u.position}})(e.startAt)),e.endAt&&(n.structuredQuery.endAt=(function(u){return{before:!u.inclusive,values:u.position}})(e.endAt)),{ft:n,parent:s}}function pne(t){let e=lne(t.parent);const n=t.structuredQuery,r=n.from?n.from.length:0;let s=null;if(r>0){vr(r===1,65062);const c=n.from[0];c.allDescendants?s=c.collectionId:e=e.child(c.collectionId)}let i=[];n.where&&(i=(function(d){const f=NM(d);return f instanceof bu&&oM(f)?f.getFilters():[f]})(n.where));let o=[];n.orderBy&&(o=(function(d){return d.map((f=>(function(g){return new _b(pm(g.field),(function(v){switch(v){case"ASCENDING":return"asc";case"DESCENDING":return"desc";default:return}})(g.direction))})(f)))})(n.orderBy));let a=null;n.limit&&(a=(function(d){let f;return f=typeof d=="object"?d.value:d,yx(f)?null:f})(n.limit));let l=null;n.startAt&&(l=(function(d){const f=!!d.before,m=d.values||[];return new xb(m,f)})(n.startAt));let u=null;return n.endAt&&(u=(function(d){const f=!d.before,m=d.values||[];return new xb(m,f)})(n.endAt)),Rte(e,s,o,i,a,"F",l,u)}function mne(t,e){const n=(function(s){switch(s){case"TargetPurposeListen":return null;case"TargetPurposeExistenceFilterMismatch":return"existence-filter-mismatch";case"TargetPurposeExistenceFilterMismatchBloom":return"existence-filter-mismatch-bloom";case"TargetPurposeLimboResolution":return"limbo-document";default:return pn(28987,{purpose:s})}})(e.purpose);return n==null?null:{"goog-listen-tags":n}}function NM(t){return t.unaryFilter!==void 0?(function(n){switch(n.unaryFilter.op){case"IS_NAN":const r=pm(n.unaryFilter.field);return ei.create(r,"==",{doubleValue:NaN});case"IS_NULL":const s=pm(n.unaryFilter.field);return ei.create(s,"==",{nullValue:"NULL_VALUE"});case"IS_NOT_NAN":const i=pm(n.unaryFilter.field);return ei.create(i,"!=",{doubleValue:NaN});case"IS_NOT_NULL":const o=pm(n.unaryFilter.field);return ei.create(o,"!=",{nullValue:"NULL_VALUE"});case"OPERATOR_UNSPECIFIED":return pn(61313);default:return pn(60726)}})(t):t.fieldFilter!==void 0?(function(n){return ei.create(pm(n.fieldFilter.field),(function(s){switch(s){case"EQUAL":return"==";case"NOT_EQUAL":return"!=";case"GREATER_THAN":return">";case"GREATER_THAN_OR_EQUAL":return">=";case"LESS_THAN":return"<";case"LESS_THAN_OR_EQUAL":return"<=";case"ARRAY_CONTAINS":return"array-contains";case"IN":return"in";case"NOT_IN":return"not-in";case"ARRAY_CONTAINS_ANY":return"array-contains-any";case"OPERATOR_UNSPECIFIED":return pn(58110);default:return pn(50506)}})(n.fieldFilter.op),n.fieldFilter.value)})(t):t.compositeFilter!==void 0?(function(n){return bu.create(n.compositeFilter.filters.map((r=>NM(r))),(function(s){switch(s){case"AND":return"and";case"OR":return"or";default:return pn(1026)}})(n.compositeFilter.op))})(t):pn(30097,{filter:t})}function gne(t){return rne[t]}function yne(t){return sne[t]}function wne(t){return ine[t]}function fm(t){return{fieldPath:t.canonicalString()}}function pm(t){return Wi.fromServerFormat(t.fieldPath)}function AM(t){return t instanceof ei?(function(n){if(n.op==="=="){if(I5(n.value))return{unaryFilter:{field:fm(n.field),op:"IS_NAN"}};if(_5(n.value))return{unaryFilter:{field:fm(n.field),op:"IS_NULL"}}}else if(n.op==="!="){if(I5(n.value))return{unaryFilter:{field:fm(n.field),op:"IS_NOT_NAN"}};if(_5(n.value))return{unaryFilter:{field:fm(n.field),op:"IS_NOT_NULL"}}}return{fieldFilter:{field:fm(n.field),op:yne(n.op),value:n.value}}})(t):t instanceof bu?(function(n){const r=n.getFilters().map((s=>AM(s)));return r.length===1?r[0]:{compositeFilter:{op:wne(n.op),filters:r}}})(t):pn(54877,{filter:t})}function vne(t){const e=[];return t.fields.forEach((n=>e.push(n.canonicalString()))),{fieldPaths:e}}function RM(t){return t.length>=4&&t.get(0)==="projects"&&t.get(2)==="databases"}class sh{constructor(e,n,r,s,i=$n.min(),o=$n.min(),a=Gi.EMPTY_BYTE_STRING,l=null){this.target=e,this.targetId=n,this.purpose=r,this.sequenceNumber=s,this.snapshotVersion=i,this.lastLimboFreeSnapshotVersion=o,this.resumeToken=a,this.expectedCount=l}withSequenceNumber(e){return new sh(this.target,this.targetId,this.purpose,e,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)}withResumeToken(e,n){return new sh(this.target,this.targetId,this.purpose,this.sequenceNumber,n,this.lastLimboFreeSnapshotVersion,e,null)}withExpectedCount(e){return new sh(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,e)}withLastLimboFreeSnapshotVersion(e){return new sh(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,e,this.resumeToken,this.expectedCount)}}class bne{constructor(e){this.yt=e}}function xne(t){const e=pne({parent:t.parent,structuredQuery:t.structuredQuery});return t.limitType==="LAST"?e$(e,e.limit,"L"):e}class _ne{constructor(){this.Cn=new Ine}addToCollectionParentIndex(e,n){return this.Cn.add(n),st.resolve()}getCollectionParents(e,n){return st.resolve(this.Cn.getEntries(n))}addFieldIndex(e,n){return st.resolve()}deleteFieldIndex(e,n){return st.resolve()}deleteAllFieldIndexes(e){return st.resolve()}createTargetIndexes(e,n){return st.resolve()}getDocumentsMatchingTarget(e,n){return st.resolve(null)}getIndexType(e,n){return st.resolve(0)}getFieldIndexes(e,n){return st.resolve([])}getNextCollectionGroupToUpdate(e){return st.resolve(null)}getMinOffset(e,n){return st.resolve(xh.min())}getMinOffsetFromCollectionGroup(e,n){return st.resolve(xh.min())}updateCollectionGroup(e,n,r){return st.resolve()}updateIndexEntries(e,n){return st.resolve()}}class Ine{constructor(){this.index={}}add(e){const n=e.lastSegment(),r=e.popLast(),s=this.index[n]||new ri(Br.comparator),i=!s.has(r);return this.index[n]=s.add(r),i}has(e){const n=e.lastSegment(),r=e.popLast(),s=this.index[n];return s&&s.has(r)}getEntries(e){return(this.index[e]||new ri(Br.comparator)).toArray()}}const L5={didRun:!1,sequenceNumbersCollected:0,targetsRemoved:0,documentsRemoved:0},DM=41943040;class ea{static withCacheSize(e){return new ea(e,ea.DEFAULT_COLLECTION_PERCENTILE,ea.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)}constructor(e,n,r){this.cacheSizeCollectionThreshold=e,this.percentileToCollect=n,this.maximumSequenceNumbersToCollect=r}}ea.DEFAULT_COLLECTION_PERCENTILE=10,ea.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1e3,ea.DEFAULT=new ea(DM,ea.DEFAULT_COLLECTION_PERCENTILE,ea.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),ea.DISABLED=new ea(-1,0,0);class Dm{constructor(e){this.ar=e}next(){return this.ar+=2,this.ar}static ur(){return new Dm(0)}static cr(){return new Dm(-1)}}const M5="LruGarbageCollector",Tne=1048576;function z5([t,e],[n,r]){const s=Jn(t,n);return s===0?Jn(e,r):s}class Sne{constructor(e){this.Ir=e,this.buffer=new ri(z5),this.Er=0}dr(){return++this.Er}Ar(e){const n=[e,this.dr()];if(this.buffer.size<this.Ir)this.buffer=this.buffer.add(n);else{const r=this.buffer.last();z5(n,r)<0&&(this.buffer=this.buffer.delete(r).add(n))}}get maxValue(){return this.buffer.last()[0]}}class $ne{constructor(e,n,r){this.garbageCollector=e,this.asyncQueue=n,this.localStore=r,this.Rr=null}start(){this.garbageCollector.params.cacheSizeCollectionThreshold!==-1&&this.Vr(6e4)}stop(){this.Rr&&(this.Rr.cancel(),this.Rr=null)}get started(){return this.Rr!==null}Vr(e){Dt(M5,`Garbage collection scheduled in ${e}ms`),this.Rr=this.asyncQueue.enqueueAfterDelay("lru_garbage_collection",e,(async()=>{this.Rr=null;try{await this.localStore.collectGarbage(this.garbageCollector)}catch(n){sg(n)?Dt(M5,"Ignoring IndexedDB error during garbage collection: ",n):await rg(n)}await this.Vr(3e5)}))}}class Cne{constructor(e,n){this.mr=e,this.params=n}calculateTargetCount(e,n){return this.mr.gr(e).next((r=>Math.floor(n/100*r)))}nthSequenceNumber(e,n){if(n===0)return st.resolve(gx.ce);const r=new Sne(n);return this.mr.forEachTarget(e,(s=>r.Ar(s.sequenceNumber))).next((()=>this.mr.pr(e,(s=>r.Ar(s))))).next((()=>r.maxValue))}removeTargets(e,n,r){return this.mr.removeTargets(e,n,r)}removeOrphanedDocuments(e,n){return this.mr.removeOrphanedDocuments(e,n)}collect(e,n){return this.params.cacheSizeCollectionThreshold===-1?(Dt("LruGarbageCollector","Garbage collection skipped; disabled"),st.resolve(L5)):this.getCacheSize(e).next((r=>r<this.params.cacheSizeCollectionThreshold?(Dt("LruGarbageCollector",`Garbage collection skipped; Cache size ${r} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`),L5):this.yr(e,n)))}getCacheSize(e){return this.mr.getCacheSize(e)}yr(e,n){let r,s,i,o,a,l,u;const c=Date.now();return this.calculateTargetCount(e,this.params.percentileToCollect).next((d=>(d>this.params.maximumSequenceNumbersToCollect?(Dt("LruGarbageCollector",`Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${d}`),s=this.params.maximumSequenceNumbersToCollect):s=d,o=Date.now(),this.nthSequenceNumber(e,s)))).next((d=>(r=d,a=Date.now(),this.removeTargets(e,r,n)))).next((d=>(i=d,l=Date.now(),this.removeOrphanedDocuments(e,r)))).next((d=>(u=Date.now(),hm()<=Qn.DEBUG&&Dt("LruGarbageCollector",`LRU Garbage Collection
	Counted targets in ${o-c}ms
	Determined least recently used ${s} in `+(a-o)+`ms
	Removed ${i} targets in `+(l-a)+`ms
	Removed ${d} documents in `+(u-l)+`ms
Total Duration: ${u-c}ms`),st.resolve({didRun:!0,sequenceNumbersCollected:s,targetsRemoved:i,documentsRemoved:d}))))}}function Ene(t,e){return new Cne(t,e)}class kne{constructor(){this.changes=new vf((e=>e.toString()),((e,n)=>e.isEqual(n))),this.changesApplied=!1}addEntry(e){this.assertNotApplied(),this.changes.set(e.key,e)}removeEntry(e,n){this.assertNotApplied(),this.changes.set(e,uo.newInvalidDocument(e).setReadTime(n))}getEntry(e,n){this.assertNotApplied();const r=this.changes.get(n);return r!==void 0?st.resolve(r):this.getFromCache(e,n)}getEntries(e,n){return this.getAllFromCache(e,n)}apply(e){return this.assertNotApplied(),this.changesApplied=!0,this.applyChanges(e)}assertNotApplied(){}}class Nne{constructor(e,n){this.overlayedDocument=e,this.mutatedFields=n}}class Ane{constructor(e,n,r,s){this.remoteDocumentCache=e,this.mutationQueue=n,this.documentOverlayCache=r,this.indexManager=s}getDocument(e,n){let r=null;return this.documentOverlayCache.getOverlay(e,n).next((s=>(r=s,this.remoteDocumentCache.getEntry(e,n)))).next((s=>(r!==null&&hy(r.mutation,s,Nl.empty(),Ur.now()),s)))}getDocuments(e,n){return this.remoteDocumentCache.getEntries(e,n).next((r=>this.getLocalViewOfDocuments(e,r,Zn()).next((()=>r))))}getLocalViewOfDocuments(e,n,r=Zn()){const s=kd();return this.populateOverlays(e,s,n).next((()=>this.computeViews(e,n,s,r).next((i=>{let o=W2();return i.forEach(((a,l)=>{o=o.insert(a,l.overlayedDocument)})),o}))))}getOverlayedDocuments(e,n){const r=kd();return this.populateOverlays(e,r,n).next((()=>this.computeViews(e,n,r,Zn())))}populateOverlays(e,n,r){const s=[];return r.forEach((i=>{n.has(i)||s.push(i)})),this.documentOverlayCache.getOverlays(e,s).next((i=>{i.forEach(((o,a)=>{n.set(o,a)}))}))}computeViews(e,n,r,s){let i=sc();const o=cy(),a=(function(){return cy()})();return n.forEach(((l,u)=>{const c=r.get(u.key);s.has(u.key)&&(c===void 0||c.mutation instanceof bf)?i=i.insert(u.key,u):c!==void 0?(o.set(u.key,c.mutation.getFieldMask()),hy(c.mutation,u,c.mutation.getFieldMask(),Ur.now())):o.set(u.key,Nl.empty())})),this.recalculateAndSaveOverlays(e,i).next((l=>(l.forEach(((u,c)=>o.set(u,c))),n.forEach(((u,c)=>a.set(u,new Nne(c,o.get(u)??null)))),a)))}recalculateAndSaveOverlays(e,n){const r=cy();let s=new ls(((o,a)=>o-a)),i=Zn();return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e,n).next((o=>{for(const a of o)a.keys().forEach((l=>{const u=n.get(l);if(u===null)return;let c=r.get(l)||Nl.empty();c=a.applyToLocalView(u,c),r.set(l,c);const d=(s.get(a.batchId)||Zn()).add(l);s=s.insert(a.batchId,d)}))})).next((()=>{const o=[],a=s.getReverseIterator();for(;a.hasNext();){const l=a.getNext(),u=l.key,c=l.value,d=pM();c.forEach((f=>{if(!i.has(f)){const m=bM(n.get(f),r.get(f));m!==null&&d.set(f,m),i=i.add(f)}})),o.push(this.documentOverlayCache.saveOverlays(e,u,d))}return st.waitFor(o)})).next((()=>r))}recalculateAndSaveOverlaysForDocumentKeys(e,n){return this.remoteDocumentCache.getEntries(e,n).next((r=>this.recalculateAndSaveOverlays(e,r)))}getDocumentsMatchingQuery(e,n,r,s){return(function(o){return on.isDocumentKey(o.path)&&o.collectionGroup===null&&o.filters.length===0})(n)?this.getDocumentsMatchingDocumentQuery(e,n.path):Dte(n)?this.getDocumentsMatchingCollectionGroupQuery(e,n,r,s):this.getDocumentsMatchingCollectionQuery(e,n,r,s)}getNextDocuments(e,n,r,s){return this.remoteDocumentCache.getAllFromCollectionGroup(e,n,r,s).next((i=>{const o=s-i.size>0?this.documentOverlayCache.getOverlaysForCollectionGroup(e,n,r.largestBatchId,s-i.size):st.resolve(kd());let a=gy,l=i;return o.next((u=>st.forEach(u,((c,d)=>(a<d.largestBatchId&&(a=d.largestBatchId),i.get(c)?st.resolve():this.remoteDocumentCache.getEntry(e,c).next((f=>{l=l.insert(c,f)}))))).next((()=>this.populateOverlays(e,u,i))).next((()=>this.computeViews(e,l,u,Zn()))).next((c=>({batchId:a,changes:fM(c)})))))}))}getDocumentsMatchingDocumentQuery(e,n){return this.getDocument(e,new on(n)).next((r=>{let s=W2();return r.isFoundDocument()&&(s=s.insert(r.key,r)),s}))}getDocumentsMatchingCollectionGroupQuery(e,n,r,s){const i=n.collectionGroup;let o=W2();return this.indexManager.getCollectionParents(e,i).next((a=>st.forEach(a,(l=>{const u=(function(d,f){return new vx(f,null,d.explicitOrderBy.slice(),d.filters.slice(),d.limit,d.limitType,d.startAt,d.endAt)})(n,l.child(i));return this.getDocumentsMatchingCollectionQuery(e,u,r,s).next((c=>{c.forEach(((d,f)=>{o=o.insert(d,f)}))}))})).next((()=>o))))}getDocumentsMatchingCollectionQuery(e,n,r,s){let i;return this.documentOverlayCache.getOverlaysForCollection(e,n.path,r.largestBatchId).next((o=>(i=o,this.remoteDocumentCache.getDocumentsMatchingQuery(e,n,r,i,s)))).next((o=>{i.forEach(((l,u)=>{const c=u.getKey();o.get(c)===null&&(o=o.insert(c,uo.newInvalidDocument(c)))}));let a=W2();return o.forEach(((l,u)=>{const c=i.get(l);c!==void 0&&hy(c.mutation,u,Nl.empty(),Ur.now()),xx(n,u)&&(a=a.insert(l,u))})),a}))}}class Rne{constructor(e){this.serializer=e,this.Lr=new Map,this.kr=new Map}getBundleMetadata(e,n){return st.resolve(this.Lr.get(n))}saveBundleMetadata(e,n){return this.Lr.set(n.id,(function(s){return{id:s.id,version:s.version,createTime:du(s.createTime)}})(n)),st.resolve()}getNamedQuery(e,n){return st.resolve(this.kr.get(n))}saveNamedQuery(e,n){return this.kr.set(n.name,(function(s){return{name:s.name,query:xne(s.bundledQuery),readTime:du(s.readTime)}})(n)),st.resolve()}}class Dne{constructor(){this.overlays=new ls(on.comparator),this.qr=new Map}getOverlay(e,n){return st.resolve(this.overlays.get(n))}getOverlays(e,n){const r=kd();return st.forEach(n,(s=>this.getOverlay(e,s).next((i=>{i!==null&&r.set(s,i)})))).next((()=>r))}saveOverlays(e,n,r){return r.forEach(((s,i)=>{this.St(e,n,i)})),st.resolve()}removeOverlaysForBatchId(e,n,r){const s=this.qr.get(r);return s!==void 0&&(s.forEach((i=>this.overlays=this.overlays.remove(i))),this.qr.delete(r)),st.resolve()}getOverlaysForCollection(e,n,r){const s=kd(),i=n.length+1,o=new on(n.child("")),a=this.overlays.getIteratorFrom(o);for(;a.hasNext();){const l=a.getNext().value,u=l.getKey();if(!n.isPrefixOf(u.path))break;u.path.length===i&&l.largestBatchId>r&&s.set(l.getKey(),l)}return st.resolve(s)}getOverlaysForCollectionGroup(e,n,r,s){let i=new ls(((u,c)=>u-c));const o=this.overlays.getIterator();for(;o.hasNext();){const u=o.getNext().value;if(u.getKey().getCollectionGroup()===n&&u.largestBatchId>r){let c=i.get(u.largestBatchId);c===null&&(c=kd(),i=i.insert(u.largestBatchId,c)),c.set(u.getKey(),u)}}const a=kd(),l=i.getIterator();for(;l.hasNext()&&(l.getNext().value.forEach(((u,c)=>a.set(u,c))),!(a.size()>=s)););return st.resolve(a)}St(e,n,r){const s=this.overlays.get(r.key);if(s!==null){const o=this.qr.get(s.largestBatchId).delete(r.key);this.qr.set(s.largestBatchId,o)}this.overlays=this.overlays.insert(r.key,new Qte(n,r));let i=this.qr.get(n);i===void 0&&(i=Zn(),this.qr.set(n,i)),this.qr.set(n,i.add(r.key))}}class One{constructor(){this.sessionToken=Gi.EMPTY_BYTE_STRING}getSessionToken(e){return st.resolve(this.sessionToken)}setSessionToken(e,n){return this.sessionToken=n,st.resolve()}}class qC{constructor(){this.Qr=new ri(Ii.$r),this.Ur=new ri(Ii.Kr)}isEmpty(){return this.Qr.isEmpty()}addReference(e,n){const r=new Ii(e,n);this.Qr=this.Qr.add(r),this.Ur=this.Ur.add(r)}Wr(e,n){e.forEach((r=>this.addReference(r,n)))}removeReference(e,n){this.Gr(new Ii(e,n))}zr(e,n){e.forEach((r=>this.removeReference(r,n)))}jr(e){const n=new on(new Br([])),r=new Ii(n,e),s=new Ii(n,e+1),i=[];return this.Ur.forEachInRange([r,s],(o=>{this.Gr(o),i.push(o.key)})),i}Jr(){this.Qr.forEach((e=>this.Gr(e)))}Gr(e){this.Qr=this.Qr.delete(e),this.Ur=this.Ur.delete(e)}Hr(e){const n=new on(new Br([])),r=new Ii(n,e),s=new Ii(n,e+1);let i=Zn();return this.Ur.forEachInRange([r,s],(o=>{i=i.add(o.key)})),i}containsKey(e){const n=new Ii(e,0),r=this.Qr.firstAfterOrEqual(n);return r!==null&&e.isEqual(r.key)}}class Ii{constructor(e,n){this.key=e,this.Yr=n}static $r(e,n){return on.comparator(e.key,n.key)||Jn(e.Yr,n.Yr)}static Kr(e,n){return Jn(e.Yr,n.Yr)||on.comparator(e.key,n.key)}}class Pne{constructor(e,n){this.indexManager=e,this.referenceDelegate=n,this.mutationQueue=[],this.tr=1,this.Zr=new ri(Ii.$r)}checkEmpty(e){return st.resolve(this.mutationQueue.length===0)}addMutationBatch(e,n,r,s){const i=this.tr;this.tr++,this.mutationQueue.length>0&&this.mutationQueue[this.mutationQueue.length-1];const o=new Yte(i,n,r,s);this.mutationQueue.push(o);for(const a of s)this.Zr=this.Zr.add(new Ii(a.key,i)),this.indexManager.addToCollectionParentIndex(e,a.key.path.popLast());return st.resolve(o)}lookupMutationBatch(e,n){return st.resolve(this.Xr(n))}getNextMutationBatchAfterBatchId(e,n){const r=n+1,s=this.ei(r),i=s<0?0:s;return st.resolve(this.mutationQueue.length>i?this.mutationQueue[i]:null)}getHighestUnacknowledgedBatchId(){return st.resolve(this.mutationQueue.length===0?LC:this.tr-1)}getAllMutationBatches(e){return st.resolve(this.mutationQueue.slice())}getAllMutationBatchesAffectingDocumentKey(e,n){const r=new Ii(n,0),s=new Ii(n,Number.POSITIVE_INFINITY),i=[];return this.Zr.forEachInRange([r,s],(o=>{const a=this.Xr(o.Yr);i.push(a)})),st.resolve(i)}getAllMutationBatchesAffectingDocumentKeys(e,n){let r=new ri(Jn);return n.forEach((s=>{const i=new Ii(s,0),o=new Ii(s,Number.POSITIVE_INFINITY);this.Zr.forEachInRange([i,o],(a=>{r=r.add(a.Yr)}))})),st.resolve(this.ti(r))}getAllMutationBatchesAffectingQuery(e,n){const r=n.path,s=r.length+1;let i=r;on.isDocumentKey(i)||(i=i.child(""));const o=new Ii(new on(i),0);let a=new ri(Jn);return this.Zr.forEachWhile((l=>{const u=l.key.path;return!!r.isPrefixOf(u)&&(u.length===s&&(a=a.add(l.Yr)),!0)}),o),st.resolve(this.ti(a))}ti(e){const n=[];return e.forEach((r=>{const s=this.Xr(r);s!==null&&n.push(s)})),n}removeMutationBatch(e,n){vr(this.ni(n.batchId,"removed")===0,55003),this.mutationQueue.shift();let r=this.Zr;return st.forEach(n.mutations,(s=>{const i=new Ii(s.key,n.batchId);return r=r.delete(i),this.referenceDelegate.markPotentiallyOrphaned(e,s.key)})).next((()=>{this.Zr=r}))}ir(e){}containsKey(e,n){const r=new Ii(n,0),s=this.Zr.firstAfterOrEqual(r);return st.resolve(n.isEqual(s&&s.key))}performConsistencyCheck(e){return this.mutationQueue.length,st.resolve()}ni(e,n){return this.ei(e)}ei(e){return this.mutationQueue.length===0?0:e-this.mutationQueue[0].batchId}Xr(e){const n=this.ei(e);return n<0||n>=this.mutationQueue.length?null:this.mutationQueue[n]}}class Fne{constructor(e){this.ri=e,this.docs=(function(){return new ls(on.comparator)})(),this.size=0}setIndexManager(e){this.indexManager=e}addEntry(e,n){const r=n.key,s=this.docs.get(r),i=s?s.size:0,o=this.ri(n);return this.docs=this.docs.insert(r,{document:n.mutableCopy(),size:o}),this.size+=o-i,this.indexManager.addToCollectionParentIndex(e,r.path.popLast())}removeEntry(e){const n=this.docs.get(e);n&&(this.docs=this.docs.remove(e),this.size-=n.size)}getEntry(e,n){const r=this.docs.get(n);return st.resolve(r?r.document.mutableCopy():uo.newInvalidDocument(n))}getEntries(e,n){let r=sc();return n.forEach((s=>{const i=this.docs.get(s);r=r.insert(s,i?i.document.mutableCopy():uo.newInvalidDocument(s))})),st.resolve(r)}getDocumentsMatchingQuery(e,n,r,s){let i=sc();const o=n.path,a=new on(o.child("__id-9223372036854775808__")),l=this.docs.getIteratorFrom(a);for(;l.hasNext();){const{key:u,value:{document:c}}=l.getNext();if(!o.isPrefixOf(u.path))break;u.path.length>o.length+1||cte(ute(c),r)<=0||(s.has(c.key)||xx(n,c))&&(i=i.insert(c.key,c.mutableCopy()))}return st.resolve(i)}getAllFromCollectionGroup(e,n,r,s){pn(9500)}ii(e,n){return st.forEach(this.docs,(r=>n(r)))}newChangeBuffer(e){return new Lne(this)}getSize(e){return st.resolve(this.size)}}class Lne extends kne{constructor(e){super(),this.Nr=e}applyChanges(e){const n=[];return this.changes.forEach(((r,s)=>{s.isValidDocument()?n.push(this.Nr.addEntry(e,s)):this.Nr.removeEntry(r)})),st.waitFor(n)}getFromCache(e,n){return this.Nr.getEntry(e,n)}getAllFromCache(e,n){return this.Nr.getEntries(e,n)}}class Mne{constructor(e){this.persistence=e,this.si=new vf((n=>VC(n)),BC),this.lastRemoteSnapshotVersion=$n.min(),this.highestTargetId=0,this.oi=0,this._i=new qC,this.targetCount=0,this.ai=Dm.ur()}forEachTarget(e,n){return this.si.forEach(((r,s)=>n(s))),st.resolve()}getLastRemoteSnapshotVersion(e){return st.resolve(this.lastRemoteSnapshotVersion)}getHighestSequenceNumber(e){return st.resolve(this.oi)}allocateTargetId(e){return this.highestTargetId=this.ai.next(),st.resolve(this.highestTargetId)}setTargetsMetadata(e,n,r){return r&&(this.lastRemoteSnapshotVersion=r),n>this.oi&&(this.oi=n),st.resolve()}Pr(e){this.si.set(e.target,e);const n=e.targetId;n>this.highestTargetId&&(this.ai=new Dm(n),this.highestTargetId=n),e.sequenceNumber>this.oi&&(this.oi=e.sequenceNumber)}addTargetData(e,n){return this.Pr(n),this.targetCount+=1,st.resolve()}updateTargetData(e,n){return this.Pr(n),st.resolve()}removeTargetData(e,n){return this.si.delete(n.target),this._i.jr(n.targetId),this.targetCount-=1,st.resolve()}removeTargets(e,n,r){let s=0;const i=[];return this.si.forEach(((o,a)=>{a.sequenceNumber<=n&&r.get(a.targetId)===null&&(this.si.delete(o),i.push(this.removeMatchingKeysForTargetId(e,a.targetId)),s++)})),st.waitFor(i).next((()=>s))}getTargetCount(e){return st.resolve(this.targetCount)}getTargetData(e,n){const r=this.si.get(n)||null;return st.resolve(r)}addMatchingKeys(e,n,r){return this._i.Wr(n,r),st.resolve()}removeMatchingKeys(e,n,r){this._i.zr(n,r);const s=this.persistence.referenceDelegate,i=[];return s&&n.forEach((o=>{i.push(s.markPotentiallyOrphaned(e,o))})),st.waitFor(i)}removeMatchingKeysForTargetId(e,n){return this._i.jr(n),st.resolve()}getMatchingKeysForTargetId(e,n){const r=this._i.Hr(n);return st.resolve(r)}containsKey(e,n){return st.resolve(this._i.containsKey(n))}}class OM{constructor(e,n){this.ui={},this.overlays={},this.ci=new gx(0),this.li=!1,this.li=!0,this.hi=new One,this.referenceDelegate=e(this),this.Pi=new Mne(this),this.indexManager=new _ne,this.remoteDocumentCache=(function(s){return new Fne(s)})((r=>this.referenceDelegate.Ti(r))),this.serializer=new bne(n),this.Ii=new Rne(this.serializer)}start(){return Promise.resolve()}shutdown(){return this.li=!1,Promise.resolve()}get started(){return this.li}setDatabaseDeletedListener(){}setNetworkEnabled(){}getIndexManager(e){return this.indexManager}getDocumentOverlayCache(e){let n=this.overlays[e.toKey()];return n||(n=new Dne,this.overlays[e.toKey()]=n),n}getMutationQueue(e,n){let r=this.ui[e.toKey()];return r||(r=new Pne(n,this.referenceDelegate),this.ui[e.toKey()]=r),r}getGlobalsCache(){return this.hi}getTargetCache(){return this.Pi}getRemoteDocumentCache(){return this.remoteDocumentCache}getBundleCache(){return this.Ii}runTransaction(e,n,r){Dt("MemoryPersistence","Starting transaction:",e);const s=new zne(this.ci.next());return this.referenceDelegate.Ei(),r(s).next((i=>this.referenceDelegate.di(s).next((()=>i)))).toPromise().then((i=>(s.raiseOnCommittedEvent(),i)))}Ai(e,n){return st.or(Object.values(this.ui).map((r=>()=>r.containsKey(e,n))))}}class zne extends dte{constructor(e){super(),this.currentSequenceNumber=e}}class KC{constructor(e){this.persistence=e,this.Ri=new qC,this.Vi=null}static mi(e){return new KC(e)}get fi(){if(this.Vi)return this.Vi;throw pn(60996)}addReference(e,n,r){return this.Ri.addReference(r,n),this.fi.delete(r.toString()),st.resolve()}removeReference(e,n,r){return this.Ri.removeReference(r,n),this.fi.add(r.toString()),st.resolve()}markPotentiallyOrphaned(e,n){return this.fi.add(n.toString()),st.resolve()}removeTarget(e,n){this.Ri.jr(n.targetId).forEach((s=>this.fi.add(s.toString())));const r=this.persistence.getTargetCache();return r.getMatchingKeysForTargetId(e,n.targetId).next((s=>{s.forEach((i=>this.fi.add(i.toString())))})).next((()=>r.removeTargetData(e,n)))}Ei(){this.Vi=new Set}di(e){const n=this.persistence.getRemoteDocumentCache().newChangeBuffer();return st.forEach(this.fi,(r=>{const s=on.fromPath(r);return this.gi(e,s).next((i=>{i||n.removeEntry(s,$n.min())}))})).next((()=>(this.Vi=null,n.apply(e))))}updateLimboDocument(e,n){return this.gi(e,n).next((r=>{r?this.fi.delete(n.toString()):this.fi.add(n.toString())}))}Ti(e){return 0}gi(e,n){return st.or([()=>st.resolve(this.Ri.containsKey(n)),()=>this.persistence.getTargetCache().containsKey(e,n),()=>this.persistence.Ai(e,n)])}}class $b{constructor(e,n){this.persistence=e,this.pi=new vf((r=>mte(r.path)),((r,s)=>r.isEqual(s))),this.garbageCollector=Ene(this,n)}static mi(e,n){return new $b(e,n)}Ei(){}di(e){return st.resolve()}forEachTarget(e,n){return this.persistence.getTargetCache().forEachTarget(e,n)}gr(e){const n=this.wr(e);return this.persistence.getTargetCache().getTargetCount(e).next((r=>n.next((s=>r+s))))}wr(e){let n=0;return this.pr(e,(r=>{n++})).next((()=>n))}pr(e,n){return st.forEach(this.pi,((r,s)=>this.br(e,r,s).next((i=>i?st.resolve():n(s)))))}removeTargets(e,n,r){return this.persistence.getTargetCache().removeTargets(e,n,r)}removeOrphanedDocuments(e,n){let r=0;const s=this.persistence.getRemoteDocumentCache(),i=s.newChangeBuffer();return s.ii(e,(o=>this.br(e,o,n).next((a=>{a||(r++,i.removeEntry(o,$n.min()))})))).next((()=>i.apply(e))).next((()=>r))}markPotentiallyOrphaned(e,n){return this.pi.set(n,e.currentSequenceNumber),st.resolve()}removeTarget(e,n){const r=n.withSequenceNumber(e.currentSequenceNumber);return this.persistence.getTargetCache().updateTargetData(e,r)}addReference(e,n,r){return this.pi.set(r,e.currentSequenceNumber),st.resolve()}removeReference(e,n,r){return this.pi.set(r,e.currentSequenceNumber),st.resolve()}updateLimboDocument(e,n){return this.pi.set(n,e.currentSequenceNumber),st.resolve()}Ti(e){let n=e.key.toString().length;return e.isFoundDocument()&&(n+=Bv(e.data.value)),n}br(e,n,r){return st.or([()=>this.persistence.Ai(e,n),()=>this.persistence.getTargetCache().containsKey(e,n),()=>{const s=this.pi.get(n);return st.resolve(s!==void 0&&s>r)}])}getCacheSize(e){return this.persistence.getRemoteDocumentCache().getSize(e)}}class XC{constructor(e,n,r,s){this.targetId=e,this.fromCache=n,this.Es=r,this.ds=s}static As(e,n){let r=Zn(),s=Zn();for(const i of n.docChanges)switch(i.type){case 0:r=r.add(i.doc.key);break;case 1:s=s.add(i.doc.key)}return new XC(e,n.fromCache,r,s)}}class Vne{constructor(){this._documentReadCount=0}get documentReadCount(){return this._documentReadCount}incrementDocumentReadCount(e){this._documentReadCount+=e}}class Bne{constructor(){this.Rs=!1,this.Vs=!1,this.fs=100,this.gs=(function(){return gQ()?8:fte(mo())>0?6:4})()}initialize(e,n){this.ps=e,this.indexManager=n,this.Rs=!0}getDocumentsMatchingQuery(e,n,r,s){const i={result:null};return this.ys(e,n).next((o=>{i.result=o})).next((()=>{if(!i.result)return this.ws(e,n,s,r).next((o=>{i.result=o}))})).next((()=>{if(i.result)return;const o=new Vne;return this.Ss(e,n,o).next((a=>{if(i.result=a,this.Vs)return this.bs(e,n,o,a.size)}))})).next((()=>i.result))}bs(e,n,r,s){return r.documentReadCount<this.fs?(hm()<=Qn.DEBUG&&Dt("QueryEngine","SDK will not create cache indexes for query:",dm(n),"since it only creates cache indexes for collection contains","more than or equal to",this.fs,"documents"),st.resolve()):(hm()<=Qn.DEBUG&&Dt("QueryEngine","Query:",dm(n),"scans",r.documentReadCount,"local documents and returns",s,"documents as results."),r.documentReadCount>this.gs*s?(hm()<=Qn.DEBUG&&Dt("QueryEngine","The SDK decides to create cache indexes for query:",dm(n),"as using cache indexes may help improve performance."),this.indexManager.createTargetIndexes(e,cu(n))):st.resolve())}ys(e,n){if(C5(n))return st.resolve(null);let r=cu(n);return this.indexManager.getIndexType(e,r).next((s=>s===0?null:(n.limit!==null&&s===1&&(n=e$(n,null,"F"),r=cu(n)),this.indexManager.getDocumentsMatchingTarget(e,r).next((i=>{const o=Zn(...i);return this.ps.getDocuments(e,o).next((a=>this.indexManager.getMinOffset(e,r).next((l=>{const u=this.Ds(n,a);return this.Cs(n,u,o,l.readTime)?this.ys(e,e$(n,null,"F")):this.vs(e,u,n,l)}))))})))))}ws(e,n,r,s){return C5(n)||s.isEqual($n.min())?st.resolve(null):this.ps.getDocuments(e,r).next((i=>{const o=this.Ds(n,i);return this.Cs(n,o,r,s)?st.resolve(null):(hm()<=Qn.DEBUG&&Dt("QueryEngine","Re-using previous result from %s to execute query: %s",s.toString(),dm(n)),this.vs(e,o,n,lte(s,gy)).next((a=>a)))}))}Ds(e,n){let r=new ri(hM(e));return n.forEach(((s,i)=>{xx(e,i)&&(r=r.add(i))})),r}Cs(e,n,r,s){if(e.limit===null)return!1;if(r.size!==n.size)return!0;const i=e.limitType==="F"?n.last():n.first();return!!i&&(i.hasPendingWrites||i.version.compareTo(s)>0)}Ss(e,n,r){return hm()<=Qn.DEBUG&&Dt("QueryEngine","Using full collection scan to execute query:",dm(n)),this.ps.getDocumentsMatchingQuery(e,n,xh.min(),r)}vs(e,n,r,s){return this.ps.getDocumentsMatchingQuery(e,r,s).next((i=>(n.forEach((o=>{i=i.insert(o.key,o)})),i)))}}const YC="LocalStore",Une=3e8;class Wne{constructor(e,n,r,s){this.persistence=e,this.Fs=n,this.serializer=s,this.Ms=new ls(Jn),this.xs=new vf((i=>VC(i)),BC),this.Os=new Map,this.Ns=e.getRemoteDocumentCache(),this.Pi=e.getTargetCache(),this.Ii=e.getBundleCache(),this.Bs(r)}Bs(e){this.documentOverlayCache=this.persistence.getDocumentOverlayCache(e),this.indexManager=this.persistence.getIndexManager(e),this.mutationQueue=this.persistence.getMutationQueue(e,this.indexManager),this.localDocuments=new Ane(this.Ns,this.mutationQueue,this.documentOverlayCache,this.indexManager),this.Ns.setIndexManager(this.indexManager),this.Fs.initialize(this.localDocuments,this.indexManager)}collectGarbage(e){return this.persistence.runTransaction("Collect garbage","readwrite-primary",(n=>e.collect(n,this.Ms)))}}function jne(t,e,n,r){return new Wne(t,e,n,r)}async function PM(t,e){const n=kn(t);return await n.persistence.runTransaction("Handle user change","readonly",(r=>{let s;return n.mutationQueue.getAllMutationBatches(r).next((i=>(s=i,n.Bs(e),n.mutationQueue.getAllMutationBatches(r)))).next((i=>{const o=[],a=[];let l=Zn();for(const u of s){o.push(u.batchId);for(const c of u.mutations)l=l.add(c.key)}for(const u of i){a.push(u.batchId);for(const c of u.mutations)l=l.add(c.key)}return n.localDocuments.getDocuments(r,l).next((u=>({Ls:u,removedBatchIds:o,addedBatchIds:a})))}))}))}function Gne(t,e){const n=kn(t);return n.persistence.runTransaction("Acknowledge batch","readwrite-primary",(r=>{const s=e.batch.keys(),i=n.Ns.newChangeBuffer({trackRemovals:!0});return(function(a,l,u,c){const d=u.batch,f=d.keys();let m=st.resolve();return f.forEach((g=>{m=m.next((()=>c.getEntry(l,g))).next((y=>{const v=u.docVersions.get(g);vr(v!==null,48541),y.version.compareTo(v)<0&&(d.applyToRemoteDocument(y,u),y.isValidDocument()&&(y.setReadTime(u.commitVersion),c.addEntry(y)))}))})),m.next((()=>a.mutationQueue.removeMutationBatch(l,d)))})(n,r,e,i).next((()=>i.apply(r))).next((()=>n.mutationQueue.performConsistencyCheck(r))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(r,s,e.batch.batchId))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(r,(function(a){let l=Zn();for(let u=0;u<a.mutationResults.length;++u)a.mutationResults[u].transformResults.length>0&&(l=l.add(a.batch.mutations[u].key));return l})(e)))).next((()=>n.localDocuments.getDocuments(r,s)))}))}function FM(t){const e=kn(t);return e.persistence.runTransaction("Get last remote snapshot version","readonly",(n=>e.Pi.getLastRemoteSnapshotVersion(n)))}function Hne(t,e){const n=kn(t),r=e.snapshotVersion;let s=n.Ms;return n.persistence.runTransaction("Apply remote event","readwrite-primary",(i=>{const o=n.Ns.newChangeBuffer({trackRemovals:!0});s=n.Ms;const a=[];e.targetChanges.forEach(((c,d)=>{const f=s.get(d);if(!f)return;a.push(n.Pi.removeMatchingKeys(i,c.removedDocuments,d).next((()=>n.Pi.addMatchingKeys(i,c.addedDocuments,d))));let m=f.withSequenceNumber(i.currentSequenceNumber);e.targetMismatches.get(d)!==null?m=m.withResumeToken(Gi.EMPTY_BYTE_STRING,$n.min()).withLastLimboFreeSnapshotVersion($n.min()):c.resumeToken.approximateByteSize()>0&&(m=m.withResumeToken(c.resumeToken,r)),s=s.insert(d,m),(function(y,v,b){return y.resumeToken.approximateByteSize()===0||v.snapshotVersion.toMicroseconds()-y.snapshotVersion.toMicroseconds()>=Une?!0:b.addedDocuments.size+b.modifiedDocuments.size+b.removedDocuments.size>0})(f,m,c)&&a.push(n.Pi.updateTargetData(i,m))}));let l=sc(),u=Zn();if(e.documentUpdates.forEach((c=>{e.resolvedLimboDocuments.has(c)&&a.push(n.persistence.referenceDelegate.updateLimboDocument(i,c))})),a.push(qne(i,o,e.documentUpdates).next((c=>{l=c.ks,u=c.qs}))),!r.isEqual($n.min())){const c=n.Pi.getLastRemoteSnapshotVersion(i).next((d=>n.Pi.setTargetsMetadata(i,i.currentSequenceNumber,r)));a.push(c)}return st.waitFor(a).next((()=>o.apply(i))).next((()=>n.localDocuments.getLocalViewOfDocuments(i,l,u))).next((()=>l))})).then((i=>(n.Ms=s,i)))}function qne(t,e,n){let r=Zn(),s=Zn();return n.forEach((i=>r=r.add(i))),e.getEntries(t,r).next((i=>{let o=sc();return n.forEach(((a,l)=>{const u=i.get(a);l.isFoundDocument()!==u.isFoundDocument()&&(s=s.add(a)),l.isNoDocument()&&l.version.isEqual($n.min())?(e.removeEntry(a,l.readTime),o=o.insert(a,l)):!u.isValidDocument()||l.version.compareTo(u.version)>0||l.version.compareTo(u.version)===0&&u.hasPendingWrites?(e.addEntry(l),o=o.insert(a,l)):Dt(YC,"Ignoring outdated watch update for ",a,". Current version:",u.version," Watch version:",l.version)})),{ks:o,qs:s}}))}function Kne(t,e){const n=kn(t);return n.persistence.runTransaction("Get next mutation batch","readonly",(r=>(e===void 0&&(e=LC),n.mutationQueue.getNextMutationBatchAfterBatchId(r,e))))}function Xne(t,e){const n=kn(t);return n.persistence.runTransaction("Allocate target","readwrite",(r=>{let s;return n.Pi.getTargetData(r,e).next((i=>i?(s=i,st.resolve(s)):n.Pi.allocateTargetId(r).next((o=>(s=new sh(e,o,"TargetPurposeListen",r.currentSequenceNumber),n.Pi.addTargetData(r,s).next((()=>s)))))))})).then((r=>{const s=n.Ms.get(r.targetId);return(s===null||r.snapshotVersion.compareTo(s.snapshotVersion)>0)&&(n.Ms=n.Ms.insert(r.targetId,r),n.xs.set(e,r.targetId)),r}))}async function i$(t,e,n){const r=kn(t),s=r.Ms.get(e),i=n?"readwrite":"readwrite-primary";try{n||await r.persistence.runTransaction("Release target",i,(o=>r.persistence.referenceDelegate.removeTarget(o,s)))}catch(o){if(!sg(o))throw o;Dt(YC,`Failed to update sequence numbers for target ${e}: ${o}`)}r.Ms=r.Ms.remove(e),r.xs.delete(s.target)}function V5(t,e,n){const r=kn(t);let s=$n.min(),i=Zn();return r.persistence.runTransaction("Execute query","readwrite",(o=>(function(l,u,c){const d=kn(l),f=d.xs.get(c);return f!==void 0?st.resolve(d.Ms.get(f)):d.Pi.getTargetData(u,c)})(r,o,cu(e)).next((a=>{if(a)return s=a.lastLimboFreeSnapshotVersion,r.Pi.getMatchingKeysForTargetId(o,a.targetId).next((l=>{i=l}))})).next((()=>r.Fs.getDocumentsMatchingQuery(o,e,n?s:$n.min(),n?i:Zn()))).next((a=>(Yne(r,Pte(e),a),{documents:a,Qs:i})))))}function Yne(t,e,n){let r=t.Os.get(e)||$n.min();n.forEach(((s,i)=>{i.readTime.compareTo(r)>0&&(r=i.readTime)})),t.Os.set(e,r)}class B5{constructor(){this.activeTargetIds=Bte()}zs(e){this.activeTargetIds=this.activeTargetIds.add(e)}js(e){this.activeTargetIds=this.activeTargetIds.delete(e)}Gs(){const e={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()};return JSON.stringify(e)}}class Qne{constructor(){this.Mo=new B5,this.xo={},this.onlineStateHandler=null,this.sequenceNumberHandler=null}addPendingMutation(e){}updateMutationState(e,n,r){}addLocalQueryTarget(e,n=!0){return n&&this.Mo.zs(e),this.xo[e]||"not-current"}updateQueryState(e,n,r){this.xo[e]=n}removeLocalQueryTarget(e){this.Mo.js(e)}isLocalQueryTarget(e){return this.Mo.activeTargetIds.has(e)}clearQueryState(e){delete this.xo[e]}getAllActiveQueryTargets(){return this.Mo.activeTargetIds}isActiveQueryTarget(e){return this.Mo.activeTargetIds.has(e)}start(){return this.Mo=new B5,Promise.resolve()}handleUserChange(e,n,r){}setOnlineState(e){}shutdown(){}writeSequenceNumber(e){}notifyBundleLoaded(e){}}class Jne{Oo(e){}shutdown(){}}const U5="ConnectivityMonitor";class W5{constructor(){this.No=()=>this.Bo(),this.Lo=()=>this.ko(),this.qo=[],this.Qo()}Oo(e){this.qo.push(e)}shutdown(){window.removeEventListener("online",this.No),window.removeEventListener("offline",this.Lo)}Qo(){window.addEventListener("online",this.No),window.addEventListener("offline",this.Lo)}Bo(){Dt(U5,"Network connectivity changed: AVAILABLE");for(const e of this.qo)e(0)}ko(){Dt(U5,"Network connectivity changed: UNAVAILABLE");for(const e of this.qo)e(1)}static v(){return typeof window<"u"&&window.addEventListener!==void 0&&window.removeEventListener!==void 0}}let ov=null;function o$(){return ov===null?ov=(function(){return 268435456+Math.round(2147483648*Math.random())})():ov++,"0x"+ov.toString(16)}const uT="RestConnection",Zne={BatchGetDocuments:"batchGet",Commit:"commit",RunQuery:"runQuery",RunAggregationQuery:"runAggregationQuery"};class ere{get $o(){return!1}constructor(e){this.databaseInfo=e,this.databaseId=e.databaseId;const n=e.ssl?"https":"http",r=encodeURIComponent(this.databaseId.projectId),s=encodeURIComponent(this.databaseId.database);this.Uo=n+"://"+e.host,this.Ko=`projects/${r}/databases/${s}`,this.Wo=this.databaseId.database===vb?`project_id=${r}`:`project_id=${r}&database_id=${s}`}Go(e,n,r,s,i){const o=o$(),a=this.zo(e,n.toUriEncodedString());Dt(uT,`Sending RPC '${e}' ${o}:`,a,r);const l={"google-cloud-resource-prefix":this.Ko,"x-goog-request-params":this.Wo};this.jo(l,s,i);const{host:u}=new URL(a),c=Zm(u);return this.Jo(e,a,l,r,c).then((d=>(Dt(uT,`Received RPC '${e}' ${o}: `,d),d)),(d=>{throw km(uT,`RPC '${e}' ${o} failed with error: `,d,"url: ",a,"request:",r),d}))}Ho(e,n,r,s,i,o){return this.Go(e,n,r,s,i)}jo(e,n,r){e["X-Goog-Api-Client"]=(function(){return"gl-js/ fire/"+ng})(),e["Content-Type"]="text/plain",this.databaseInfo.appId&&(e["X-Firebase-GMPID"]=this.databaseInfo.appId),n&&n.headers.forEach(((s,i)=>e[i]=s)),r&&r.headers.forEach(((s,i)=>e[i]=s))}zo(e,n){const r=Zne[e];return`${this.Uo}/v1/${n}:${r}`}terminate(){}}class tre{constructor(e){this.Yo=e.Yo,this.Zo=e.Zo}Xo(e){this.e_=e}t_(e){this.n_=e}r_(e){this.i_=e}onMessage(e){this.s_=e}close(){this.Zo()}send(e){this.Yo(e)}o_(){this.e_()}__(){this.n_()}a_(e){this.i_(e)}u_(e){this.s_(e)}}const io="WebChannelConnection";class nre extends ere{constructor(e){super(e),this.c_=[],this.forceLongPolling=e.forceLongPolling,this.autoDetectLongPolling=e.autoDetectLongPolling,this.useFetchStreams=e.useFetchStreams,this.longPollingOptions=e.longPollingOptions}Jo(e,n,r,s,i){const o=o$();return new Promise(((a,l)=>{const u=new zL;u.setWithCredentials(!0),u.listenOnce(VL.COMPLETE,(()=>{try{switch(u.getLastErrorCode()){case Vv.NO_ERROR:const d=u.getResponseJson();Dt(io,`XHR for RPC '${e}' ${o} received:`,JSON.stringify(d)),a(d);break;case Vv.TIMEOUT:Dt(io,`RPC '${e}' ${o} timed out`),l(new Jt(lt.DEADLINE_EXCEEDED,"Request time out"));break;case Vv.HTTP_ERROR:const f=u.getStatus();if(Dt(io,`RPC '${e}' ${o} failed with status:`,f,"response text:",u.getResponseText()),f>0){let m=u.getResponseJson();Array.isArray(m)&&(m=m[0]);const g=m?.error;if(g&&g.status&&g.message){const y=(function(b){const x=b.toLowerCase().replace(/_/g,"-");return Object.values(lt).indexOf(x)>=0?x:lt.UNKNOWN})(g.status);l(new Jt(y,g.message))}else l(new Jt(lt.UNKNOWN,"Server responded with status "+u.getStatus()))}else l(new Jt(lt.UNAVAILABLE,"Connection failed."));break;default:pn(9055,{l_:e,streamId:o,h_:u.getLastErrorCode(),P_:u.getLastError()})}}finally{Dt(io,`RPC '${e}' ${o} completed.`)}}));const c=JSON.stringify(s);Dt(io,`RPC '${e}' ${o} sending request:`,s),u.send(n,"POST",c,r,15)}))}T_(e,n,r){const s=o$(),i=[this.Uo,"/","google.firestore.v1.Firestore","/",e,"/channel"],o=WL(),a=UL(),l={httpSessionIdParam:"gsessionid",initMessageHeaders:{},messageUrlParams:{database:`projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},sendRawJson:!0,supportsCrossDomainXhr:!0,internalChannelParams:{forwardChannelRequestTimeoutMs:6e5},forceLongPolling:this.forceLongPolling,detectBufferingProxy:this.autoDetectLongPolling},u=this.longPollingOptions.timeoutSeconds;u!==void 0&&(l.longPollingTimeout=Math.round(1e3*u)),this.useFetchStreams&&(l.useFetchStreams=!0),this.jo(l.initMessageHeaders,n,r),l.encodeInitMessageHeaders=!0;const c=i.join("");Dt(io,`Creating RPC '${e}' stream ${s}: ${c}`,l);const d=o.createWebChannel(c,l);this.I_(d);let f=!1,m=!1;const g=new tre({Yo:v=>{m?Dt(io,`Not sending because RPC '${e}' stream ${s} is closed:`,v):(f||(Dt(io,`Opening RPC '${e}' stream ${s} transport.`),d.open(),f=!0),Dt(io,`RPC '${e}' stream ${s} sending:`,v),d.send(v))},Zo:()=>d.close()}),y=(v,b,x)=>{v.listen(b,($=>{try{x($)}catch(S){setTimeout((()=>{throw S}),0)}}))};return y(d,U2.EventType.OPEN,(()=>{m||(Dt(io,`RPC '${e}' stream ${s} transport opened.`),g.o_())})),y(d,U2.EventType.CLOSE,(()=>{m||(m=!0,Dt(io,`RPC '${e}' stream ${s} transport closed`),g.a_(),this.E_(d))})),y(d,U2.EventType.ERROR,(v=>{m||(m=!0,km(io,`RPC '${e}' stream ${s} transport errored. Name:`,v.name,"Message:",v.message),g.a_(new Jt(lt.UNAVAILABLE,"The operation could not be completed")))})),y(d,U2.EventType.MESSAGE,(v=>{if(!m){const b=v.data[0];vr(!!b,16349);const x=b,$=x?.error||x[0]?.error;if($){Dt(io,`RPC '${e}' stream ${s} received error:`,$);const S=$.status;let E=(function(D){const A=Ls[D];if(A!==void 0)return IM(A)})(S),L=$.message;E===void 0&&(E=lt.INTERNAL,L="Unknown error status: "+S+" with message "+$.message),m=!0,g.a_(new Jt(E,L)),d.close()}else Dt(io,`RPC '${e}' stream ${s} received:`,b),g.u_(b)}})),y(a,BL.STAT_EVENT,(v=>{v.stat===KS.PROXY?Dt(io,`RPC '${e}' stream ${s} detected buffering proxy`):v.stat===KS.NOPROXY&&Dt(io,`RPC '${e}' stream ${s} detected no buffering proxy`)})),setTimeout((()=>{g.__()}),0),g}terminate(){this.c_.forEach((e=>e.close())),this.c_=[]}I_(e){this.c_.push(e)}E_(e){this.c_=this.c_.filter((n=>n===e))}}function cT(){return typeof document<"u"?document:null}function Sx(t){return new one(t,!0)}class LM{constructor(e,n,r=1e3,s=1.5,i=6e4){this.Mi=e,this.timerId=n,this.d_=r,this.A_=s,this.R_=i,this.V_=0,this.m_=null,this.f_=Date.now(),this.reset()}reset(){this.V_=0}g_(){this.V_=this.R_}p_(e){this.cancel();const n=Math.floor(this.V_+this.y_()),r=Math.max(0,Date.now()-this.f_),s=Math.max(0,n-r);s>0&&Dt("ExponentialBackoff",`Backing off for ${s} ms (base delay: ${this.V_} ms, delay with jitter: ${n} ms, last attempt: ${r} ms ago)`),this.m_=this.Mi.enqueueAfterDelay(this.timerId,s,(()=>(this.f_=Date.now(),e()))),this.V_*=this.A_,this.V_<this.d_&&(this.V_=this.d_),this.V_>this.R_&&(this.V_=this.R_)}w_(){this.m_!==null&&(this.m_.skipDelay(),this.m_=null)}cancel(){this.m_!==null&&(this.m_.cancel(),this.m_=null)}y_(){return(Math.random()-.5)*this.V_}}const j5="PersistentStream";class MM{constructor(e,n,r,s,i,o,a,l){this.Mi=e,this.S_=r,this.b_=s,this.connection=i,this.authCredentialsProvider=o,this.appCheckCredentialsProvider=a,this.listener=l,this.state=0,this.D_=0,this.C_=null,this.v_=null,this.stream=null,this.F_=0,this.M_=new LM(e,n)}x_(){return this.state===1||this.state===5||this.O_()}O_(){return this.state===2||this.state===3}start(){this.F_=0,this.state!==4?this.auth():this.N_()}async stop(){this.x_()&&await this.close(0)}B_(){this.state=0,this.M_.reset()}L_(){this.O_()&&this.C_===null&&(this.C_=this.Mi.enqueueAfterDelay(this.S_,6e4,(()=>this.k_())))}q_(e){this.Q_(),this.stream.send(e)}async k_(){if(this.O_())return this.close(0)}Q_(){this.C_&&(this.C_.cancel(),this.C_=null)}U_(){this.v_&&(this.v_.cancel(),this.v_=null)}async close(e,n){this.Q_(),this.U_(),this.M_.cancel(),this.D_++,e!==4?this.M_.reset():n&&n.code===lt.RESOURCE_EXHAUSTED?(rc(n.toString()),rc("Using maximum backoff delay to prevent overloading the backend."),this.M_.g_()):n&&n.code===lt.UNAUTHENTICATED&&this.state!==3&&(this.authCredentialsProvider.invalidateToken(),this.appCheckCredentialsProvider.invalidateToken()),this.stream!==null&&(this.K_(),this.stream.close(),this.stream=null),this.state=e,await this.listener.r_(n)}K_(){}auth(){this.state=1;const e=this.W_(this.D_),n=this.D_;Promise.all([this.authCredentialsProvider.getToken(),this.appCheckCredentialsProvider.getToken()]).then((([r,s])=>{this.D_===n&&this.G_(r,s)}),(r=>{e((()=>{const s=new Jt(lt.UNKNOWN,"Fetching auth token failed: "+r.message);return this.z_(s)}))}))}G_(e,n){const r=this.W_(this.D_);this.stream=this.j_(e,n),this.stream.Xo((()=>{r((()=>this.listener.Xo()))})),this.stream.t_((()=>{r((()=>(this.state=2,this.v_=this.Mi.enqueueAfterDelay(this.b_,1e4,(()=>(this.O_()&&(this.state=3),Promise.resolve()))),this.listener.t_())))})),this.stream.r_((s=>{r((()=>this.z_(s)))})),this.stream.onMessage((s=>{r((()=>++this.F_==1?this.J_(s):this.onNext(s)))}))}N_(){this.state=5,this.M_.p_((async()=>{this.state=0,this.start()}))}z_(e){return Dt(j5,`close with error: ${e}`),this.stream=null,this.close(4,e)}W_(e){return n=>{this.Mi.enqueueAndForget((()=>this.D_===e?n():(Dt(j5,"stream callback skipped by getCloseGuardedDispatcher."),Promise.resolve())))}}}class rre extends MM{constructor(e,n,r,s,i,o){super(e,"listen_stream_connection_backoff","listen_stream_idle","health_check_timeout",n,r,s,o),this.serializer=i}j_(e,n){return this.connection.T_("Listen",e,n)}J_(e){return this.onNext(e)}onNext(e){this.M_.reset();const n=une(this.serializer,e),r=(function(i){if(!("targetChange"in i))return $n.min();const o=i.targetChange;return o.targetIds&&o.targetIds.length?$n.min():o.readTime?du(o.readTime):$n.min()})(e);return this.listener.H_(n,r)}Y_(e){const n={};n.database=s$(this.serializer),n.addTarget=(function(i,o){let a;const l=o.target;if(a=ZS(l)?{documents:dne(i,l)}:{query:fne(i,l).ft},a.targetId=o.targetId,o.resumeToken.approximateByteSize()>0){a.resumeToken=$M(i,o.resumeToken);const u=t$(i,o.expectedCount);u!==null&&(a.expectedCount=u)}else if(o.snapshotVersion.compareTo($n.min())>0){a.readTime=Sb(i,o.snapshotVersion.toTimestamp());const u=t$(i,o.expectedCount);u!==null&&(a.expectedCount=u)}return a})(this.serializer,e);const r=mne(this.serializer,e);r&&(n.labels=r),this.q_(n)}Z_(e){const n={};n.database=s$(this.serializer),n.removeTarget=e,this.q_(n)}}class sre extends MM{constructor(e,n,r,s,i,o){super(e,"write_stream_connection_backoff","write_stream_idle","health_check_timeout",n,r,s,o),this.serializer=i}get X_(){return this.F_>0}start(){this.lastStreamToken=void 0,super.start()}K_(){this.X_&&this.ea([])}j_(e,n){return this.connection.T_("Write",e,n)}J_(e){return vr(!!e.streamToken,31322),this.lastStreamToken=e.streamToken,vr(!e.writeResults||e.writeResults.length===0,55816),this.listener.ta()}onNext(e){vr(!!e.streamToken,12678),this.lastStreamToken=e.streamToken,this.M_.reset();const n=hne(e.writeResults,e.commitTime),r=du(e.commitTime);return this.listener.na(r,n)}ra(){const e={};e.database=s$(this.serializer),this.q_(e)}ea(e){const n={streamToken:this.lastStreamToken,writes:e.map((r=>cne(this.serializer,r)))};this.q_(n)}}class ire{}class ore extends ire{constructor(e,n,r,s){super(),this.authCredentials=e,this.appCheckCredentials=n,this.connection=r,this.serializer=s,this.ia=!1}sa(){if(this.ia)throw new Jt(lt.FAILED_PRECONDITION,"The client has already been terminated.")}Go(e,n,r,s){return this.sa(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((([i,o])=>this.connection.Go(e,n$(n,r),s,i,o))).catch((i=>{throw i.name==="FirebaseError"?(i.code===lt.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),i):new Jt(lt.UNKNOWN,i.toString())}))}Ho(e,n,r,s,i){return this.sa(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((([o,a])=>this.connection.Ho(e,n$(n,r),s,o,a,i))).catch((o=>{throw o.name==="FirebaseError"?(o.code===lt.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),o):new Jt(lt.UNKNOWN,o.toString())}))}terminate(){this.ia=!0,this.connection.terminate()}}class are{constructor(e,n){this.asyncQueue=e,this.onlineStateHandler=n,this.state="Unknown",this.oa=0,this._a=null,this.aa=!0}ua(){this.oa===0&&(this.ca("Unknown"),this._a=this.asyncQueue.enqueueAfterDelay("online_state_timeout",1e4,(()=>(this._a=null,this.la("Backend didn't respond within 10 seconds."),this.ca("Offline"),Promise.resolve()))))}ha(e){this.state==="Online"?this.ca("Unknown"):(this.oa++,this.oa>=1&&(this.Pa(),this.la(`Connection failed 1 times. Most recent error: ${e.toString()}`),this.ca("Offline")))}set(e){this.Pa(),this.oa=0,e==="Online"&&(this.aa=!1),this.ca(e)}ca(e){e!==this.state&&(this.state=e,this.onlineStateHandler(e))}la(e){const n=`Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;this.aa?(rc(n),this.aa=!1):Dt("OnlineStateTracker",n)}Pa(){this._a!==null&&(this._a.cancel(),this._a=null)}}const jd="RemoteStore";class lre{constructor(e,n,r,s,i){this.localStore=e,this.datastore=n,this.asyncQueue=r,this.remoteSyncer={},this.Ta=[],this.Ia=new Map,this.Ea=new Set,this.da=[],this.Aa=i,this.Aa.Oo((o=>{r.enqueueAndForget((async()=>{xf(this)&&(Dt(jd,"Restarting streams for network reachability change."),await(async function(l){const u=kn(l);u.Ea.add(4),await e0(u),u.Ra.set("Unknown"),u.Ea.delete(4),await $x(u)})(this))}))})),this.Ra=new are(r,s)}}async function $x(t){if(xf(t))for(const e of t.da)await e(!0)}async function e0(t){for(const e of t.da)await e(!1)}function zM(t,e){const n=kn(t);n.Ia.has(e.targetId)||(n.Ia.set(e.targetId,e),eE(n)?ZC(n):ig(n).O_()&&JC(n,e))}function QC(t,e){const n=kn(t),r=ig(n);n.Ia.delete(e),r.O_()&&VM(n,e),n.Ia.size===0&&(r.O_()?r.L_():xf(n)&&n.Ra.set("Unknown"))}function JC(t,e){if(t.Va.Ue(e.targetId),e.resumeToken.approximateByteSize()>0||e.snapshotVersion.compareTo($n.min())>0){const n=t.remoteSyncer.getRemoteKeysForTarget(e.targetId).size;e=e.withExpectedCount(n)}ig(t).Y_(e)}function VM(t,e){t.Va.Ue(e),ig(t).Z_(e)}function ZC(t){t.Va=new nne({getRemoteKeysForTarget:e=>t.remoteSyncer.getRemoteKeysForTarget(e),At:e=>t.Ia.get(e)||null,ht:()=>t.datastore.serializer.databaseId}),ig(t).start(),t.Ra.ua()}function eE(t){return xf(t)&&!ig(t).x_()&&t.Ia.size>0}function xf(t){return kn(t).Ea.size===0}function BM(t){t.Va=void 0}async function ure(t){t.Ra.set("Online")}async function cre(t){t.Ia.forEach(((e,n)=>{JC(t,e)}))}async function hre(t,e){BM(t),eE(t)?(t.Ra.ha(e),ZC(t)):t.Ra.set("Unknown")}async function dre(t,e,n){if(t.Ra.set("Online"),e instanceof SM&&e.state===2&&e.cause)try{await(async function(s,i){const o=i.cause;for(const a of i.targetIds)s.Ia.has(a)&&(await s.remoteSyncer.rejectListen(a,o),s.Ia.delete(a),s.Va.removeTarget(a))})(t,e)}catch(r){Dt(jd,"Failed to remove targets %s: %s ",e.targetIds.join(","),r),await Cb(t,r)}else if(e instanceof jv?t.Va.Ze(e):e instanceof TM?t.Va.st(e):t.Va.tt(e),!n.isEqual($n.min()))try{const r=await FM(t.localStore);n.compareTo(r)>=0&&await(function(i,o){const a=i.Va.Tt(o);return a.targetChanges.forEach(((l,u)=>{if(l.resumeToken.approximateByteSize()>0){const c=i.Ia.get(u);c&&i.Ia.set(u,c.withResumeToken(l.resumeToken,o))}})),a.targetMismatches.forEach(((l,u)=>{const c=i.Ia.get(l);if(!c)return;i.Ia.set(l,c.withResumeToken(Gi.EMPTY_BYTE_STRING,c.snapshotVersion)),VM(i,l);const d=new sh(c.target,l,u,c.sequenceNumber);JC(i,d)})),i.remoteSyncer.applyRemoteEvent(a)})(t,n)}catch(r){Dt(jd,"Failed to raise snapshot:",r),await Cb(t,r)}}async function Cb(t,e,n){if(!sg(e))throw e;t.Ea.add(1),await e0(t),t.Ra.set("Offline"),n||(n=()=>FM(t.localStore)),t.asyncQueue.enqueueRetryable((async()=>{Dt(jd,"Retrying IndexedDB access"),await n(),t.Ea.delete(1),await $x(t)}))}function UM(t,e){return e().catch((n=>Cb(t,n,e)))}async function Cx(t){const e=kn(t),n=Sh(e);let r=e.Ta.length>0?e.Ta[e.Ta.length-1].batchId:LC;for(;fre(e);)try{const s=await Kne(e.localStore,r);if(s===null){e.Ta.length===0&&n.L_();break}r=s.batchId,pre(e,s)}catch(s){await Cb(e,s)}WM(e)&&jM(e)}function fre(t){return xf(t)&&t.Ta.length<10}function pre(t,e){t.Ta.push(e);const n=Sh(t);n.O_()&&n.X_&&n.ea(e.mutations)}function WM(t){return xf(t)&&!Sh(t).x_()&&t.Ta.length>0}function jM(t){Sh(t).start()}async function mre(t){Sh(t).ra()}async function gre(t){const e=Sh(t);for(const n of t.Ta)e.ea(n.mutations)}async function yre(t,e,n){const r=t.Ta.shift(),s=jC.from(r,e,n);await UM(t,(()=>t.remoteSyncer.applySuccessfulWrite(s))),await Cx(t)}async function wre(t,e){e&&Sh(t).X_&&await(async function(r,s){if((function(o){return Zte(o)&&o!==lt.ABORTED})(s.code)){const i=r.Ta.shift();Sh(r).B_(),await UM(r,(()=>r.remoteSyncer.rejectFailedWrite(i.batchId,s))),await Cx(r)}})(t,e),WM(t)&&jM(t)}async function G5(t,e){const n=kn(t);n.asyncQueue.verifyOperationInProgress(),Dt(jd,"RemoteStore received new credentials");const r=xf(n);n.Ea.add(3),await e0(n),r&&n.Ra.set("Unknown"),await n.remoteSyncer.handleCredentialChange(e),n.Ea.delete(3),await $x(n)}async function vre(t,e){const n=kn(t);e?(n.Ea.delete(2),await $x(n)):e||(n.Ea.add(2),await e0(n),n.Ra.set("Unknown"))}function ig(t){return t.ma||(t.ma=(function(n,r,s){const i=kn(n);return i.sa(),new rre(r,i.connection,i.authCredentials,i.appCheckCredentials,i.serializer,s)})(t.datastore,t.asyncQueue,{Xo:ure.bind(null,t),t_:cre.bind(null,t),r_:hre.bind(null,t),H_:dre.bind(null,t)}),t.da.push((async e=>{e?(t.ma.B_(),eE(t)?ZC(t):t.Ra.set("Unknown")):(await t.ma.stop(),BM(t))}))),t.ma}function Sh(t){return t.fa||(t.fa=(function(n,r,s){const i=kn(n);return i.sa(),new sre(r,i.connection,i.authCredentials,i.appCheckCredentials,i.serializer,s)})(t.datastore,t.asyncQueue,{Xo:()=>Promise.resolve(),t_:mre.bind(null,t),r_:wre.bind(null,t),ta:gre.bind(null,t),na:yre.bind(null,t)}),t.da.push((async e=>{e?(t.fa.B_(),await Cx(t)):(await t.fa.stop(),t.Ta.length>0&&(Dt(jd,`Stopping write stream with ${t.Ta.length} pending writes`),t.Ta=[]))}))),t.fa}class tE{constructor(e,n,r,s,i){this.asyncQueue=e,this.timerId=n,this.targetTimeMs=r,this.op=s,this.removalCallback=i,this.deferred=new Dd,this.then=this.deferred.promise.then.bind(this.deferred.promise),this.deferred.promise.catch((o=>{}))}get promise(){return this.deferred.promise}static createAndSchedule(e,n,r,s,i){const o=Date.now()+r,a=new tE(e,n,o,s,i);return a.start(r),a}start(e){this.timerHandle=setTimeout((()=>this.handleDelayElapsed()),e)}skipDelay(){return this.handleDelayElapsed()}cancel(e){this.timerHandle!==null&&(this.clearTimeout(),this.deferred.reject(new Jt(lt.CANCELLED,"Operation cancelled"+(e?": "+e:""))))}handleDelayElapsed(){this.asyncQueue.enqueueAndForget((()=>this.timerHandle!==null?(this.clearTimeout(),this.op().then((e=>this.deferred.resolve(e)))):Promise.resolve()))}clearTimeout(){this.timerHandle!==null&&(this.removalCallback(this),clearTimeout(this.timerHandle),this.timerHandle=null)}}function nE(t,e){if(rc("AsyncQueue",`${e}: ${t}`),sg(t))return new Jt(lt.UNAVAILABLE,`${e}: ${t}`);throw t}class _m{static emptySet(e){return new _m(e.comparator)}constructor(e){this.comparator=e?(n,r)=>e(n,r)||on.comparator(n.key,r.key):(n,r)=>on.comparator(n.key,r.key),this.keyedMap=W2(),this.sortedSet=new ls(this.comparator)}has(e){return this.keyedMap.get(e)!=null}get(e){return this.keyedMap.get(e)}first(){return this.sortedSet.minKey()}last(){return this.sortedSet.maxKey()}isEmpty(){return this.sortedSet.isEmpty()}indexOf(e){const n=this.keyedMap.get(e);return n?this.sortedSet.indexOf(n):-1}get size(){return this.sortedSet.size}forEach(e){this.sortedSet.inorderTraversal(((n,r)=>(e(n),!1)))}add(e){const n=this.delete(e.key);return n.copy(n.keyedMap.insert(e.key,e),n.sortedSet.insert(e,null))}delete(e){const n=this.get(e);return n?this.copy(this.keyedMap.remove(e),this.sortedSet.remove(n)):this}isEqual(e){if(!(e instanceof _m)||this.size!==e.size)return!1;const n=this.sortedSet.getIterator(),r=e.sortedSet.getIterator();for(;n.hasNext();){const s=n.getNext().key,i=r.getNext().key;if(!s.isEqual(i))return!1}return!0}toString(){const e=[];return this.forEach((n=>{e.push(n.toString())})),e.length===0?"DocumentSet ()":`DocumentSet (
  `+e.join(`  
`)+`
)`}copy(e,n){const r=new _m;return r.comparator=this.comparator,r.keyedMap=e,r.sortedSet=n,r}}class H5{constructor(){this.ga=new ls(on.comparator)}track(e){const n=e.doc.key,r=this.ga.get(n);r?e.type!==0&&r.type===3?this.ga=this.ga.insert(n,e):e.type===3&&r.type!==1?this.ga=this.ga.insert(n,{type:r.type,doc:e.doc}):e.type===2&&r.type===2?this.ga=this.ga.insert(n,{type:2,doc:e.doc}):e.type===2&&r.type===0?this.ga=this.ga.insert(n,{type:0,doc:e.doc}):e.type===1&&r.type===0?this.ga=this.ga.remove(n):e.type===1&&r.type===2?this.ga=this.ga.insert(n,{type:1,doc:r.doc}):e.type===0&&r.type===1?this.ga=this.ga.insert(n,{type:2,doc:e.doc}):pn(63341,{Rt:e,pa:r}):this.ga=this.ga.insert(n,e)}ya(){const e=[];return this.ga.inorderTraversal(((n,r)=>{e.push(r)})),e}}class Om{constructor(e,n,r,s,i,o,a,l,u){this.query=e,this.docs=n,this.oldDocs=r,this.docChanges=s,this.mutatedKeys=i,this.fromCache=o,this.syncStateChanged=a,this.excludesMetadataChanges=l,this.hasCachedResults=u}static fromInitialDocuments(e,n,r,s,i){const o=[];return n.forEach((a=>{o.push({type:0,doc:a})})),new Om(e,n,_m.emptySet(n),o,r,s,!0,!1,i)}get hasPendingWrites(){return!this.mutatedKeys.isEmpty()}isEqual(e){if(!(this.fromCache===e.fromCache&&this.hasCachedResults===e.hasCachedResults&&this.syncStateChanged===e.syncStateChanged&&this.mutatedKeys.isEqual(e.mutatedKeys)&&bx(this.query,e.query)&&this.docs.isEqual(e.docs)&&this.oldDocs.isEqual(e.oldDocs)))return!1;const n=this.docChanges,r=e.docChanges;if(n.length!==r.length)return!1;for(let s=0;s<n.length;s++)if(n[s].type!==r[s].type||!n[s].doc.isEqual(r[s].doc))return!1;return!0}}class bre{constructor(){this.wa=void 0,this.Sa=[]}ba(){return this.Sa.some((e=>e.Da()))}}class xre{constructor(){this.queries=q5(),this.onlineState="Unknown",this.Ca=new Set}terminate(){(function(n,r){const s=kn(n),i=s.queries;s.queries=q5(),i.forEach(((o,a)=>{for(const l of a.Sa)l.onError(r)}))})(this,new Jt(lt.ABORTED,"Firestore shutting down"))}}function q5(){return new vf((t=>cM(t)),bx)}async function _re(t,e){const n=kn(t);let r=3;const s=e.query;let i=n.queries.get(s);i?!i.ba()&&e.Da()&&(r=2):(i=new bre,r=e.Da()?0:1);try{switch(r){case 0:i.wa=await n.onListen(s,!0);break;case 1:i.wa=await n.onListen(s,!1);break;case 2:await n.onFirstRemoteStoreListen(s)}}catch(o){const a=nE(o,`Initialization of query '${dm(e.query)}' failed`);return void e.onError(a)}n.queries.set(s,i),i.Sa.push(e),e.va(n.onlineState),i.wa&&e.Fa(i.wa)&&rE(n)}async function Ire(t,e){const n=kn(t),r=e.query;let s=3;const i=n.queries.get(r);if(i){const o=i.Sa.indexOf(e);o>=0&&(i.Sa.splice(o,1),i.Sa.length===0?s=e.Da()?0:1:!i.ba()&&e.Da()&&(s=2))}switch(s){case 0:return n.queries.delete(r),n.onUnlisten(r,!0);case 1:return n.queries.delete(r),n.onUnlisten(r,!1);case 2:return n.onLastRemoteStoreUnlisten(r);default:return}}function Tre(t,e){const n=kn(t);let r=!1;for(const s of e){const i=s.query,o=n.queries.get(i);if(o){for(const a of o.Sa)a.Fa(s)&&(r=!0);o.wa=s}}r&&rE(n)}function Sre(t,e,n){const r=kn(t),s=r.queries.get(e);if(s)for(const i of s.Sa)i.onError(n);r.queries.delete(e)}function rE(t){t.Ca.forEach((e=>{e.next()}))}var a$,K5;(K5=a$||(a$={})).Ma="default",K5.Cache="cache";class $re{constructor(e,n,r){this.query=e,this.xa=n,this.Oa=!1,this.Na=null,this.onlineState="Unknown",this.options=r||{}}Fa(e){if(!this.options.includeMetadataChanges){const r=[];for(const s of e.docChanges)s.type!==3&&r.push(s);e=new Om(e.query,e.docs,e.oldDocs,r,e.mutatedKeys,e.fromCache,e.syncStateChanged,!0,e.hasCachedResults)}let n=!1;return this.Oa?this.Ba(e)&&(this.xa.next(e),n=!0):this.La(e,this.onlineState)&&(this.ka(e),n=!0),this.Na=e,n}onError(e){this.xa.error(e)}va(e){this.onlineState=e;let n=!1;return this.Na&&!this.Oa&&this.La(this.Na,e)&&(this.ka(this.Na),n=!0),n}La(e,n){if(!e.fromCache||!this.Da())return!0;const r=n!=="Offline";return(!this.options.qa||!r)&&(!e.docs.isEmpty()||e.hasCachedResults||n==="Offline")}Ba(e){if(e.docChanges.length>0)return!0;const n=this.Na&&this.Na.hasPendingWrites!==e.hasPendingWrites;return!(!e.syncStateChanged&&!n)&&this.options.includeMetadataChanges===!0}ka(e){e=Om.fromInitialDocuments(e.query,e.docs,e.mutatedKeys,e.fromCache,e.hasCachedResults),this.Oa=!0,this.xa.next(e)}Da(){return this.options.source!==a$.Cache}}class GM{constructor(e){this.key=e}}class HM{constructor(e){this.key=e}}class Cre{constructor(e,n){this.query=e,this.Ya=n,this.Za=null,this.hasCachedResults=!1,this.current=!1,this.Xa=Zn(),this.mutatedKeys=Zn(),this.eu=hM(e),this.tu=new _m(this.eu)}get nu(){return this.Ya}ru(e,n){const r=n?n.iu:new H5,s=n?n.tu:this.tu;let i=n?n.mutatedKeys:this.mutatedKeys,o=s,a=!1;const l=this.query.limitType==="F"&&s.size===this.query.limit?s.last():null,u=this.query.limitType==="L"&&s.size===this.query.limit?s.first():null;if(e.inorderTraversal(((c,d)=>{const f=s.get(c),m=xx(this.query,d)?d:null,g=!!f&&this.mutatedKeys.has(f.key),y=!!m&&(m.hasLocalMutations||this.mutatedKeys.has(m.key)&&m.hasCommittedMutations);let v=!1;f&&m?f.data.isEqual(m.data)?g!==y&&(r.track({type:3,doc:m}),v=!0):this.su(f,m)||(r.track({type:2,doc:m}),v=!0,(l&&this.eu(m,l)>0||u&&this.eu(m,u)<0)&&(a=!0)):!f&&m?(r.track({type:0,doc:m}),v=!0):f&&!m&&(r.track({type:1,doc:f}),v=!0,(l||u)&&(a=!0)),v&&(m?(o=o.add(m),i=y?i.add(c):i.delete(c)):(o=o.delete(c),i=i.delete(c)))})),this.query.limit!==null)for(;o.size>this.query.limit;){const c=this.query.limitType==="F"?o.last():o.first();o=o.delete(c.key),i=i.delete(c.key),r.track({type:1,doc:c})}return{tu:o,iu:r,Cs:a,mutatedKeys:i}}su(e,n){return e.hasLocalMutations&&n.hasCommittedMutations&&!n.hasLocalMutations}applyChanges(e,n,r,s){const i=this.tu;this.tu=e.tu,this.mutatedKeys=e.mutatedKeys;const o=e.iu.ya();o.sort(((c,d)=>(function(m,g){const y=v=>{switch(v){case 0:return 1;case 2:case 3:return 2;case 1:return 0;default:return pn(20277,{Rt:v})}};return y(m)-y(g)})(c.type,d.type)||this.eu(c.doc,d.doc))),this.ou(r),s=s??!1;const a=n&&!s?this._u():[],l=this.Xa.size===0&&this.current&&!s?1:0,u=l!==this.Za;return this.Za=l,o.length!==0||u?{snapshot:new Om(this.query,e.tu,i,o,e.mutatedKeys,l===0,u,!1,!!r&&r.resumeToken.approximateByteSize()>0),au:a}:{au:a}}va(e){return this.current&&e==="Offline"?(this.current=!1,this.applyChanges({tu:this.tu,iu:new H5,mutatedKeys:this.mutatedKeys,Cs:!1},!1)):{au:[]}}uu(e){return!this.Ya.has(e)&&!!this.tu.has(e)&&!this.tu.get(e).hasLocalMutations}ou(e){e&&(e.addedDocuments.forEach((n=>this.Ya=this.Ya.add(n))),e.modifiedDocuments.forEach((n=>{})),e.removedDocuments.forEach((n=>this.Ya=this.Ya.delete(n))),this.current=e.current)}_u(){if(!this.current)return[];const e=this.Xa;this.Xa=Zn(),this.tu.forEach((r=>{this.uu(r.key)&&(this.Xa=this.Xa.add(r.key))}));const n=[];return e.forEach((r=>{this.Xa.has(r)||n.push(new HM(r))})),this.Xa.forEach((r=>{e.has(r)||n.push(new GM(r))})),n}cu(e){this.Ya=e.Qs,this.Xa=Zn();const n=this.ru(e.documents);return this.applyChanges(n,!0)}lu(){return Om.fromInitialDocuments(this.query,this.tu,this.mutatedKeys,this.Za===0,this.hasCachedResults)}}const sE="SyncEngine";class Ere{constructor(e,n,r){this.query=e,this.targetId=n,this.view=r}}class kre{constructor(e){this.key=e,this.hu=!1}}class Nre{constructor(e,n,r,s,i,o){this.localStore=e,this.remoteStore=n,this.eventManager=r,this.sharedClientState=s,this.currentUser=i,this.maxConcurrentLimboResolutions=o,this.Pu={},this.Tu=new vf((a=>cM(a)),bx),this.Iu=new Map,this.Eu=new Set,this.du=new ls(on.comparator),this.Au=new Map,this.Ru=new qC,this.Vu={},this.mu=new Map,this.fu=Dm.cr(),this.onlineState="Unknown",this.gu=void 0}get isPrimaryClient(){return this.gu===!0}}async function Are(t,e,n=!0){const r=JM(t);let s;const i=r.Tu.get(e);return i?(r.sharedClientState.addLocalQueryTarget(i.targetId),s=i.view.lu()):s=await qM(r,e,n,!0),s}async function Rre(t,e){const n=JM(t);await qM(n,e,!0,!1)}async function qM(t,e,n,r){const s=await Xne(t.localStore,cu(e)),i=s.targetId,o=t.sharedClientState.addLocalQueryTarget(i,n);let a;return r&&(a=await Dre(t,e,i,o==="current",s.resumeToken)),t.isPrimaryClient&&n&&zM(t.remoteStore,s),a}async function Dre(t,e,n,r,s){t.pu=(d,f,m)=>(async function(y,v,b,x){let $=v.view.ru(b);$.Cs&&($=await V5(y.localStore,v.query,!1).then((({documents:R})=>v.view.ru(R,$))));const S=x&&x.targetChanges.get(v.targetId),E=x&&x.targetMismatches.get(v.targetId)!=null,L=v.view.applyChanges($,y.isPrimaryClient,S,E);return Y5(y,v.targetId,L.au),L.snapshot})(t,d,f,m);const i=await V5(t.localStore,e,!0),o=new Cre(e,i.Qs),a=o.ru(i.documents),l=Zy.createSynthesizedTargetChangeForCurrentChange(n,r&&t.onlineState!=="Offline",s),u=o.applyChanges(a,t.isPrimaryClient,l);Y5(t,n,u.au);const c=new Ere(e,n,o);return t.Tu.set(e,c),t.Iu.has(n)?t.Iu.get(n).push(e):t.Iu.set(n,[e]),u.snapshot}async function Ore(t,e,n){const r=kn(t),s=r.Tu.get(e),i=r.Iu.get(s.targetId);if(i.length>1)return r.Iu.set(s.targetId,i.filter((o=>!bx(o,e)))),void r.Tu.delete(e);r.isPrimaryClient?(r.sharedClientState.removeLocalQueryTarget(s.targetId),r.sharedClientState.isActiveQueryTarget(s.targetId)||await i$(r.localStore,s.targetId,!1).then((()=>{r.sharedClientState.clearQueryState(s.targetId),n&&QC(r.remoteStore,s.targetId),l$(r,s.targetId)})).catch(rg)):(l$(r,s.targetId),await i$(r.localStore,s.targetId,!0))}async function Pre(t,e){const n=kn(t),r=n.Tu.get(e),s=n.Iu.get(r.targetId);n.isPrimaryClient&&s.length===1&&(n.sharedClientState.removeLocalQueryTarget(r.targetId),QC(n.remoteStore,r.targetId))}async function Fre(t,e,n){const r=Wre(t);try{const s=await(function(o,a){const l=kn(o),u=Ur.now(),c=a.reduce(((m,g)=>m.add(g.key)),Zn());let d,f;return l.persistence.runTransaction("Locally write mutations","readwrite",(m=>{let g=sc(),y=Zn();return l.Ns.getEntries(m,c).next((v=>{g=v,g.forEach(((b,x)=>{x.isValidDocument()||(y=y.add(b))}))})).next((()=>l.localDocuments.getOverlayedDocuments(m,g))).next((v=>{d=v;const b=[];for(const x of a){const $=Kte(x,d.get(x.key).overlayedDocument);$!=null&&b.push(new bf(x.key,$,rM($.value.mapValue),hu.exists(!0)))}return l.mutationQueue.addMutationBatch(m,u,b,a)})).next((v=>{f=v;const b=v.applyToLocalDocumentSet(d,y);return l.documentOverlayCache.saveOverlays(m,v.batchId,b)}))})).then((()=>({batchId:f.batchId,changes:fM(d)})))})(r.localStore,e);r.sharedClientState.addPendingMutation(s.batchId),(function(o,a,l){let u=o.Vu[o.currentUser.toKey()];u||(u=new ls(Jn)),u=u.insert(a,l),o.Vu[o.currentUser.toKey()]=u})(r,s.batchId,n),await t0(r,s.changes),await Cx(r.remoteStore)}catch(s){const i=nE(s,"Failed to persist write");n.reject(i)}}async function KM(t,e){const n=kn(t);try{const r=await Hne(n.localStore,e);e.targetChanges.forEach(((s,i)=>{const o=n.Au.get(i);o&&(vr(s.addedDocuments.size+s.modifiedDocuments.size+s.removedDocuments.size<=1,22616),s.addedDocuments.size>0?o.hu=!0:s.modifiedDocuments.size>0?vr(o.hu,14607):s.removedDocuments.size>0&&(vr(o.hu,42227),o.hu=!1))})),await t0(n,r,e)}catch(r){await rg(r)}}function X5(t,e,n){const r=kn(t);if(r.isPrimaryClient&&n===0||!r.isPrimaryClient&&n===1){const s=[];r.Tu.forEach(((i,o)=>{const a=o.view.va(e);a.snapshot&&s.push(a.snapshot)})),(function(o,a){const l=kn(o);l.onlineState=a;let u=!1;l.queries.forEach(((c,d)=>{for(const f of d.Sa)f.va(a)&&(u=!0)})),u&&rE(l)})(r.eventManager,e),s.length&&r.Pu.H_(s),r.onlineState=e,r.isPrimaryClient&&r.sharedClientState.setOnlineState(e)}}async function Lre(t,e,n){const r=kn(t);r.sharedClientState.updateQueryState(e,"rejected",n);const s=r.Au.get(e),i=s&&s.key;if(i){let o=new ls(on.comparator);o=o.insert(i,uo.newNoDocument(i,$n.min()));const a=Zn().add(i),l=new Tx($n.min(),new Map,new ls(Jn),o,a);await KM(r,l),r.du=r.du.remove(i),r.Au.delete(e),iE(r)}else await i$(r.localStore,e,!1).then((()=>l$(r,e,n))).catch(rg)}async function Mre(t,e){const n=kn(t),r=e.batch.batchId;try{const s=await Gne(n.localStore,e);YM(n,r,null),XM(n,r),n.sharedClientState.updateMutationState(r,"acknowledged"),await t0(n,s)}catch(s){await rg(s)}}async function zre(t,e,n){const r=kn(t);try{const s=await(function(o,a){const l=kn(o);return l.persistence.runTransaction("Reject batch","readwrite-primary",(u=>{let c;return l.mutationQueue.lookupMutationBatch(u,a).next((d=>(vr(d!==null,37113),c=d.keys(),l.mutationQueue.removeMutationBatch(u,d)))).next((()=>l.mutationQueue.performConsistencyCheck(u))).next((()=>l.documentOverlayCache.removeOverlaysForBatchId(u,c,a))).next((()=>l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(u,c))).next((()=>l.localDocuments.getDocuments(u,c)))}))})(r.localStore,e);YM(r,e,n),XM(r,e),r.sharedClientState.updateMutationState(e,"rejected",n),await t0(r,s)}catch(s){await rg(s)}}function XM(t,e){(t.mu.get(e)||[]).forEach((n=>{n.resolve()})),t.mu.delete(e)}function YM(t,e,n){const r=kn(t);let s=r.Vu[r.currentUser.toKey()];if(s){const i=s.get(e);i&&(n?i.reject(n):i.resolve(),s=s.remove(e)),r.Vu[r.currentUser.toKey()]=s}}function l$(t,e,n=null){t.sharedClientState.removeLocalQueryTarget(e);for(const r of t.Iu.get(e))t.Tu.delete(r),n&&t.Pu.yu(r,n);t.Iu.delete(e),t.isPrimaryClient&&t.Ru.jr(e).forEach((r=>{t.Ru.containsKey(r)||QM(t,r)}))}function QM(t,e){t.Eu.delete(e.path.canonicalString());const n=t.du.get(e);n!==null&&(QC(t.remoteStore,n),t.du=t.du.remove(e),t.Au.delete(n),iE(t))}function Y5(t,e,n){for(const r of n)r instanceof GM?(t.Ru.addReference(r.key,e),Vre(t,r)):r instanceof HM?(Dt(sE,"Document no longer in limbo: "+r.key),t.Ru.removeReference(r.key,e),t.Ru.containsKey(r.key)||QM(t,r.key)):pn(19791,{wu:r})}function Vre(t,e){const n=e.key,r=n.path.canonicalString();t.du.get(n)||t.Eu.has(r)||(Dt(sE,"New document in limbo: "+n),t.Eu.add(r),iE(t))}function iE(t){for(;t.Eu.size>0&&t.du.size<t.maxConcurrentLimboResolutions;){const e=t.Eu.values().next().value;t.Eu.delete(e);const n=new on(Br.fromString(e)),r=t.fu.next();t.Au.set(r,new kre(n)),t.du=t.du.insert(n,r),zM(t.remoteStore,new sh(cu(UC(n.path)),r,"TargetPurposeLimboResolution",gx.ce))}}async function t0(t,e,n){const r=kn(t),s=[],i=[],o=[];r.Tu.isEmpty()||(r.Tu.forEach(((a,l)=>{o.push(r.pu(l,e,n).then((u=>{if((u||n)&&r.isPrimaryClient){const c=u?!u.fromCache:n?.targetChanges.get(l.targetId)?.current;r.sharedClientState.updateQueryState(l.targetId,c?"current":"not-current")}if(u){s.push(u);const c=XC.As(l.targetId,u);i.push(c)}})))})),await Promise.all(o),r.Pu.H_(s),await(async function(l,u){const c=kn(l);try{await c.persistence.runTransaction("notifyLocalViewChanges","readwrite",(d=>st.forEach(u,(f=>st.forEach(f.Es,(m=>c.persistence.referenceDelegate.addReference(d,f.targetId,m))).next((()=>st.forEach(f.ds,(m=>c.persistence.referenceDelegate.removeReference(d,f.targetId,m)))))))))}catch(d){if(!sg(d))throw d;Dt(YC,"Failed to update sequence numbers: "+d)}for(const d of u){const f=d.targetId;if(!d.fromCache){const m=c.Ms.get(f),g=m.snapshotVersion,y=m.withLastLimboFreeSnapshotVersion(g);c.Ms=c.Ms.insert(f,y)}}})(r.localStore,i))}async function Bre(t,e){const n=kn(t);if(!n.currentUser.isEqual(e)){Dt(sE,"User change. New user:",e.toKey());const r=await PM(n.localStore,e);n.currentUser=e,(function(i,o){i.mu.forEach((a=>{a.forEach((l=>{l.reject(new Jt(lt.CANCELLED,o))}))})),i.mu.clear()})(n,"'waitForPendingWrites' promise is rejected due to a user change."),n.sharedClientState.handleUserChange(e,r.removedBatchIds,r.addedBatchIds),await t0(n,r.Ls)}}function Ure(t,e){const n=kn(t),r=n.Au.get(e);if(r&&r.hu)return Zn().add(r.key);{let s=Zn();const i=n.Iu.get(e);if(!i)return s;for(const o of i){const a=n.Tu.get(o);s=s.unionWith(a.view.nu)}return s}}function JM(t){const e=kn(t);return e.remoteStore.remoteSyncer.applyRemoteEvent=KM.bind(null,e),e.remoteStore.remoteSyncer.getRemoteKeysForTarget=Ure.bind(null,e),e.remoteStore.remoteSyncer.rejectListen=Lre.bind(null,e),e.Pu.H_=Tre.bind(null,e.eventManager),e.Pu.yu=Sre.bind(null,e.eventManager),e}function Wre(t){const e=kn(t);return e.remoteStore.remoteSyncer.applySuccessfulWrite=Mre.bind(null,e),e.remoteStore.remoteSyncer.rejectFailedWrite=zre.bind(null,e),e}class Eb{constructor(){this.kind="memory",this.synchronizeTabs=!1}async initialize(e){this.serializer=Sx(e.databaseInfo.databaseId),this.sharedClientState=this.Du(e),this.persistence=this.Cu(e),await this.persistence.start(),this.localStore=this.vu(e),this.gcScheduler=this.Fu(e,this.localStore),this.indexBackfillerScheduler=this.Mu(e,this.localStore)}Fu(e,n){return null}Mu(e,n){return null}vu(e){return jne(this.persistence,new Bne,e.initialUser,this.serializer)}Cu(e){return new OM(KC.mi,this.serializer)}Du(e){return new Qne}async terminate(){this.gcScheduler?.stop(),this.indexBackfillerScheduler?.stop(),this.sharedClientState.shutdown(),await this.persistence.shutdown()}}Eb.provider={build:()=>new Eb};class jre extends Eb{constructor(e){super(),this.cacheSizeBytes=e}Fu(e,n){vr(this.persistence.referenceDelegate instanceof $b,46915);const r=this.persistence.referenceDelegate.garbageCollector;return new $ne(r,e.asyncQueue,n)}Cu(e){const n=this.cacheSizeBytes!==void 0?ea.withCacheSize(this.cacheSizeBytes):ea.DEFAULT;return new OM((r=>$b.mi(r,n)),this.serializer)}}class u${async initialize(e,n){this.localStore||(this.localStore=e.localStore,this.sharedClientState=e.sharedClientState,this.datastore=this.createDatastore(n),this.remoteStore=this.createRemoteStore(n),this.eventManager=this.createEventManager(n),this.syncEngine=this.createSyncEngine(n,!e.synchronizeTabs),this.sharedClientState.onlineStateHandler=r=>X5(this.syncEngine,r,1),this.remoteStore.remoteSyncer.handleCredentialChange=Bre.bind(null,this.syncEngine),await vre(this.remoteStore,this.syncEngine.isPrimaryClient))}createEventManager(e){return(function(){return new xre})()}createDatastore(e){const n=Sx(e.databaseInfo.databaseId),r=(function(i){return new nre(i)})(e.databaseInfo);return(function(i,o,a,l){return new ore(i,o,a,l)})(e.authCredentials,e.appCheckCredentials,r,n)}createRemoteStore(e){return(function(r,s,i,o,a){return new lre(r,s,i,o,a)})(this.localStore,this.datastore,e.asyncQueue,(n=>X5(this.syncEngine,n,0)),(function(){return W5.v()?new W5:new Jne})())}createSyncEngine(e,n){return(function(s,i,o,a,l,u,c){const d=new Nre(s,i,o,a,l,u);return c&&(d.gu=!0),d})(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,e.initialUser,e.maxConcurrentLimboResolutions,n)}async terminate(){await(async function(n){const r=kn(n);Dt(jd,"RemoteStore shutting down."),r.Ea.add(5),await e0(r),r.Aa.shutdown(),r.Ra.set("Unknown")})(this.remoteStore),this.datastore?.terminate(),this.eventManager?.terminate()}}u$.provider={build:()=>new u$};class Gre{constructor(e){this.observer=e,this.muted=!1}next(e){this.muted||this.observer.next&&this.Ou(this.observer.next,e)}error(e){this.muted||(this.observer.error?this.Ou(this.observer.error,e):rc("Uncaught Error in snapshot listener:",e.toString()))}Nu(){this.muted=!0}Ou(e,n){setTimeout((()=>{this.muted||e(n)}),0)}}const $h="FirestoreClient";class Hre{constructor(e,n,r,s,i){this.authCredentials=e,this.appCheckCredentials=n,this.asyncQueue=r,this.databaseInfo=s,this.user=ao.UNAUTHENTICATED,this.clientId=PC.newId(),this.authCredentialListener=()=>Promise.resolve(),this.appCheckCredentialListener=()=>Promise.resolve(),this._uninitializedComponentsProvider=i,this.authCredentials.start(r,(async o=>{Dt($h,"Received user=",o.uid),await this.authCredentialListener(o),this.user=o})),this.appCheckCredentials.start(r,(o=>(Dt($h,"Received new app check token=",o),this.appCheckCredentialListener(o,this.user))))}get configuration(){return{asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,authCredentials:this.authCredentials,appCheckCredentials:this.appCheckCredentials,initialUser:this.user,maxConcurrentLimboResolutions:100}}setCredentialChangeListener(e){this.authCredentialListener=e}setAppCheckTokenChangeListener(e){this.appCheckCredentialListener=e}terminate(){this.asyncQueue.enterRestrictedMode();const e=new Dd;return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async()=>{try{this._onlineComponents&&await this._onlineComponents.terminate(),this._offlineComponents&&await this._offlineComponents.terminate(),this.authCredentials.shutdown(),this.appCheckCredentials.shutdown(),e.resolve()}catch(n){const r=nE(n,"Failed to shutdown persistence");e.reject(r)}})),e.promise}}async function hT(t,e){t.asyncQueue.verifyOperationInProgress(),Dt($h,"Initializing OfflineComponentProvider");const n=t.configuration;await e.initialize(n);let r=n.initialUser;t.setCredentialChangeListener((async s=>{r.isEqual(s)||(await PM(e.localStore,s),r=s)})),e.persistence.setDatabaseDeletedListener((()=>t.terminate())),t._offlineComponents=e}async function Q5(t,e){t.asyncQueue.verifyOperationInProgress();const n=await qre(t);Dt($h,"Initializing OnlineComponentProvider"),await e.initialize(n,t.configuration),t.setCredentialChangeListener((r=>G5(e.remoteStore,r))),t.setAppCheckTokenChangeListener(((r,s)=>G5(e.remoteStore,s))),t._onlineComponents=e}async function qre(t){if(!t._offlineComponents)if(t._uninitializedComponentsProvider){Dt($h,"Using user provided OfflineComponentProvider");try{await hT(t,t._uninitializedComponentsProvider._offline)}catch(e){const n=e;if(!(function(s){return s.name==="FirebaseError"?s.code===lt.FAILED_PRECONDITION||s.code===lt.UNIMPLEMENTED:!(typeof DOMException<"u"&&s instanceof DOMException)||s.code===22||s.code===20||s.code===11})(n))throw n;km("Error using user provided cache. Falling back to memory cache: "+n),await hT(t,new Eb)}}else Dt($h,"Using default OfflineComponentProvider"),await hT(t,new jre(void 0));return t._offlineComponents}async function ZM(t){return t._onlineComponents||(t._uninitializedComponentsProvider?(Dt($h,"Using user provided OnlineComponentProvider"),await Q5(t,t._uninitializedComponentsProvider._online)):(Dt($h,"Using default OnlineComponentProvider"),await Q5(t,new u$))),t._onlineComponents}function Kre(t){return ZM(t).then((e=>e.syncEngine))}async function J5(t){const e=await ZM(t),n=e.eventManager;return n.onListen=Are.bind(null,e.syncEngine),n.onUnlisten=Ore.bind(null,e.syncEngine),n.onFirstRemoteStoreListen=Rre.bind(null,e.syncEngine),n.onLastRemoteStoreUnlisten=Pre.bind(null,e.syncEngine),n}function ez(t){const e={};return t.timeoutSeconds!==void 0&&(e.timeoutSeconds=t.timeoutSeconds),e}const Z5=new Map;const tz="firestore.googleapis.com",eO=!0;class tO{constructor(e){if(e.host===void 0){if(e.ssl!==void 0)throw new Jt(lt.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");this.host=tz,this.ssl=eO}else this.host=e.host,this.ssl=e.ssl??eO;if(this.isUsingEmulator=e.emulatorOptions!==void 0,this.credentials=e.credentials,this.ignoreUndefinedProperties=!!e.ignoreUndefinedProperties,this.localCache=e.localCache,e.cacheSizeBytes===void 0)this.cacheSizeBytes=DM;else{if(e.cacheSizeBytes!==-1&&e.cacheSizeBytes<Tne)throw new Jt(lt.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");this.cacheSizeBytes=e.cacheSizeBytes}ate("experimentalForceLongPolling",e.experimentalForceLongPolling,"experimentalAutoDetectLongPolling",e.experimentalAutoDetectLongPolling),this.experimentalForceLongPolling=!!e.experimentalForceLongPolling,this.experimentalForceLongPolling?this.experimentalAutoDetectLongPolling=!1:e.experimentalAutoDetectLongPolling===void 0?this.experimentalAutoDetectLongPolling=!0:this.experimentalAutoDetectLongPolling=!!e.experimentalAutoDetectLongPolling,this.experimentalLongPollingOptions=ez(e.experimentalLongPollingOptions??{}),(function(r){if(r.timeoutSeconds!==void 0){if(isNaN(r.timeoutSeconds))throw new Jt(lt.INVALID_ARGUMENT,`invalid long polling timeout: ${r.timeoutSeconds} (must not be NaN)`);if(r.timeoutSeconds<5)throw new Jt(lt.INVALID_ARGUMENT,`invalid long polling timeout: ${r.timeoutSeconds} (minimum allowed value is 5)`);if(r.timeoutSeconds>30)throw new Jt(lt.INVALID_ARGUMENT,`invalid long polling timeout: ${r.timeoutSeconds} (maximum allowed value is 30)`)}})(this.experimentalLongPollingOptions),this.useFetchStreams=!!e.useFetchStreams}isEqual(e){return this.host===e.host&&this.ssl===e.ssl&&this.credentials===e.credentials&&this.cacheSizeBytes===e.cacheSizeBytes&&this.experimentalForceLongPolling===e.experimentalForceLongPolling&&this.experimentalAutoDetectLongPolling===e.experimentalAutoDetectLongPolling&&(function(r,s){return r.timeoutSeconds===s.timeoutSeconds})(this.experimentalLongPollingOptions,e.experimentalLongPollingOptions)&&this.ignoreUndefinedProperties===e.ignoreUndefinedProperties&&this.useFetchStreams===e.useFetchStreams}}class Ex{constructor(e,n,r,s){this._authCredentials=e,this._appCheckCredentials=n,this._databaseId=r,this._app=s,this.type="firestore-lite",this._persistenceKey="(lite)",this._settings=new tO({}),this._settingsFrozen=!1,this._emulatorOptions={},this._terminateTask="notTerminated"}get app(){if(!this._app)throw new Jt(lt.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");return this._app}get _initialized(){return this._settingsFrozen}get _terminated(){return this._terminateTask!=="notTerminated"}_setSettings(e){if(this._settingsFrozen)throw new Jt(lt.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");this._settings=new tO(e),this._emulatorOptions=e.emulatorOptions||{},e.credentials!==void 0&&(this._authCredentials=(function(r){if(!r)return new Qee;switch(r.type){case"firstParty":return new tte(r.sessionIndex||"0",r.iamToken||null,r.authTokenFactory||null);case"provider":return r.client;default:throw new Jt(lt.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")}})(e.credentials))}_getSettings(){return this._settings}_getEmulatorOptions(){return this._emulatorOptions}_freezeSettings(){return this._settingsFrozen=!0,this._settings}_delete(){return this._terminateTask==="notTerminated"&&(this._terminateTask=this._terminate()),this._terminateTask}async _restart(){this._terminateTask==="notTerminated"?await this._terminate():this._terminateTask="notTerminated"}toJSON(){return{app:this._app,databaseId:this._databaseId,settings:this._settings}}_terminate(){return(function(n){const r=Z5.get(n);r&&(Dt("ComponentProvider","Removing Datastore"),Z5.delete(n),r.terminate())})(this),Promise.resolve()}}function Xre(t,e,n,r={}){t=Od(t,Ex);const s=Zm(e),i=t._getSettings(),o={...i,emulatorOptions:t._getEmulatorOptions()},a=`${e}:${n}`;s&&(YF(`https://${a}`),QF("Firestore",!0)),i.host!==tz&&i.host!==a&&km("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.");const l={...i,host:a,ssl:s,emulatorOptions:r};if(!zd(l,o)&&(t._setSettings(l),r.mockUserToken)){let u,c;if(typeof r.mockUserToken=="string")u=r.mockUserToken,c=ao.MOCK_USER;else{u=aQ(r.mockUserToken,t._app?.options.projectId);const d=r.mockUserToken.sub||r.mockUserToken.user_id;if(!d)throw new Jt(lt.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");c=new ao(d)}t._authCredentials=new Jee(new GL(u,c))}}class kx{constructor(e,n,r){this.converter=n,this._query=r,this.type="query",this.firestore=e}withConverter(e){return new kx(this.firestore,e,this._query)}}class ti{constructor(e,n,r){this.converter=n,this._key=r,this.type="document",this.firestore=e}get _path(){return this._key.path}get id(){return this._key.path.lastSegment()}get path(){return this._key.path.canonicalString()}get parent(){return new fh(this.firestore,this.converter,this._key.path.popLast())}withConverter(e){return new ti(this.firestore,e,this._key)}toJSON(){return{type:ti._jsonSchemaVersion,referencePath:this._key.toString()}}static fromJSON(e,n,r){if(Qy(n,ti._jsonSchema))return new ti(e,r||null,new on(Br.fromString(n.referencePath)))}}ti._jsonSchemaVersion="firestore/documentReference/1.0",ti._jsonSchema={type:zs("string",ti._jsonSchemaVersion),referencePath:zs("string")};class fh extends kx{constructor(e,n,r){super(e,n,UC(r)),this._path=r,this.type="collection"}get id(){return this._query.path.lastSegment()}get path(){return this._query.path.canonicalString()}get parent(){const e=this._path.popLast();return e.isEmpty()?null:new ti(this.firestore,null,new on(e))}withConverter(e){return new fh(this.firestore,e,this._path)}}function nz(t,e,...n){if(t=sa(t),HL("collection","path",e),t instanceof Ex){const r=Br.fromString(e,...n);return p5(r),new fh(t,null,r)}{if(!(t instanceof ti||t instanceof fh))throw new Jt(lt.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const r=t._path.child(Br.fromString(e,...n));return p5(r),new fh(t.firestore,null,r)}}function rz(t,e,...n){if(t=sa(t),arguments.length===1&&(e=PC.newId()),HL("doc","path",e),t instanceof Ex){const r=Br.fromString(e,...n);return f5(r),new ti(t,null,new on(r))}{if(!(t instanceof ti||t instanceof fh))throw new Jt(lt.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const r=t._path.child(Br.fromString(e,...n));return f5(r),new ti(t.firestore,t instanceof fh?t.converter:null,new on(r))}}const nO="AsyncQueue";class rO{constructor(e=Promise.resolve()){this.Xu=[],this.ec=!1,this.tc=[],this.nc=null,this.rc=!1,this.sc=!1,this.oc=[],this.M_=new LM(this,"async_queue_retry"),this._c=()=>{const r=cT();r&&Dt(nO,"Visibility state changed to "+r.visibilityState),this.M_.w_()},this.ac=e;const n=cT();n&&typeof n.addEventListener=="function"&&n.addEventListener("visibilitychange",this._c)}get isShuttingDown(){return this.ec}enqueueAndForget(e){this.enqueue(e)}enqueueAndForgetEvenWhileRestricted(e){this.uc(),this.cc(e)}enterRestrictedMode(e){if(!this.ec){this.ec=!0,this.sc=e||!1;const n=cT();n&&typeof n.removeEventListener=="function"&&n.removeEventListener("visibilitychange",this._c)}}enqueue(e){if(this.uc(),this.ec)return new Promise((()=>{}));const n=new Dd;return this.cc((()=>this.ec&&this.sc?Promise.resolve():(e().then(n.resolve,n.reject),n.promise))).then((()=>n.promise))}enqueueRetryable(e){this.enqueueAndForget((()=>(this.Xu.push(e),this.lc())))}async lc(){if(this.Xu.length!==0){try{await this.Xu[0](),this.Xu.shift(),this.M_.reset()}catch(e){if(!sg(e))throw e;Dt(nO,"Operation failed with retryable error: "+e)}this.Xu.length>0&&this.M_.p_((()=>this.lc()))}}cc(e){const n=this.ac.then((()=>(this.rc=!0,e().catch((r=>{throw this.nc=r,this.rc=!1,rc("INTERNAL UNHANDLED ERROR: ",sO(r)),r})).then((r=>(this.rc=!1,r))))));return this.ac=n,n}enqueueAfterDelay(e,n,r){this.uc(),this.oc.indexOf(e)>-1&&(n=0);const s=tE.createAndSchedule(this,e,n,r,(i=>this.hc(i)));return this.tc.push(s),s}uc(){this.nc&&pn(47125,{Pc:sO(this.nc)})}verifyOperationInProgress(){}async Tc(){let e;do e=this.ac,await e;while(e!==this.ac)}Ic(e){for(const n of this.tc)if(n.timerId===e)return!0;return!1}Ec(e){return this.Tc().then((()=>{this.tc.sort(((n,r)=>n.targetTimeMs-r.targetTimeMs));for(const n of this.tc)if(n.skipDelay(),e!=="all"&&n.timerId===e)break;return this.Tc()}))}dc(e){this.oc.push(e)}hc(e){const n=this.tc.indexOf(e);this.tc.splice(n,1)}}function sO(t){let e=t.message||"";return t.stack&&(e=t.stack.includes(t.message)?t.stack:t.message+`
`+t.stack),e}function iO(t){return(function(n,r){if(typeof n!="object"||n===null)return!1;const s=n;for(const i of r)if(i in s&&typeof s[i]=="function")return!0;return!1})(t,["next","error","complete"])}class _y extends Ex{constructor(e,n,r,s){super(e,n,r,s),this.type="firestore",this._queue=new rO,this._persistenceKey=s?.name||"[DEFAULT]"}async _terminate(){if(this._firestoreClient){const e=this._firestoreClient.terminate();this._queue=new rO(e),this._firestoreClient=void 0,await e}}}function Yre(t,e){const n=typeof t=="object"?t:tL(),r=typeof t=="string"?t:vb,s=SC(n,"firestore").getImmediate({identifier:r});if(!s._initialized){const i=iQ("firestore");i&&Xre(s,...i)}return s}function sz(t){if(t._terminated)throw new Jt(lt.FAILED_PRECONDITION,"The client has already been terminated.");return t._firestoreClient||Qre(t),t._firestoreClient}function Qre(t){const e=t._freezeSettings(),n=(function(s,i,o,a){return new wte(s,i,o,a.host,a.ssl,a.experimentalForceLongPolling,a.experimentalAutoDetectLongPolling,ez(a.experimentalLongPollingOptions),a.useFetchStreams,a.isUsingEmulator)})(t._databaseId,t._app?.options.appId||"",t._persistenceKey,e);t._componentsProvider||e.localCache?._offlineComponentProvider&&e.localCache?._onlineComponentProvider&&(t._componentsProvider={_offline:e.localCache._offlineComponentProvider,_online:e.localCache._onlineComponentProvider}),t._firestoreClient=new Hre(t._authCredentials,t._appCheckCredentials,t._queue,n,t._componentsProvider&&(function(s){const i=s?._online.build();return{_offline:s?._offline.build(i),_online:i}})(t._componentsProvider))}class el{constructor(e){this._byteString=e}static fromBase64String(e){try{return new el(Gi.fromBase64String(e))}catch(n){throw new Jt(lt.INVALID_ARGUMENT,"Failed to construct data from Base64 string: "+n)}}static fromUint8Array(e){return new el(Gi.fromUint8Array(e))}toBase64(){return this._byteString.toBase64()}toUint8Array(){return this._byteString.toUint8Array()}toString(){return"Bytes(base64: "+this.toBase64()+")"}isEqual(e){return this._byteString.isEqual(e._byteString)}toJSON(){return{type:el._jsonSchemaVersion,bytes:this.toBase64()}}static fromJSON(e){if(Qy(e,el._jsonSchema))return el.fromBase64String(e.bytes)}}el._jsonSchemaVersion="firestore/bytes/1.0",el._jsonSchema={type:zs("string",el._jsonSchemaVersion),bytes:zs("string")};class oE{constructor(...e){for(let n=0;n<e.length;++n)if(e[n].length===0)throw new Jt(lt.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");this._internalPath=new Wi(e)}isEqual(e){return this._internalPath.isEqual(e._internalPath)}}class iz{constructor(e){this._methodName=e}}class fu{constructor(e,n){if(!isFinite(e)||e<-90||e>90)throw new Jt(lt.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: "+e);if(!isFinite(n)||n<-180||n>180)throw new Jt(lt.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: "+n);this._lat=e,this._long=n}get latitude(){return this._lat}get longitude(){return this._long}isEqual(e){return this._lat===e._lat&&this._long===e._long}_compareTo(e){return Jn(this._lat,e._lat)||Jn(this._long,e._long)}toJSON(){return{latitude:this._lat,longitude:this._long,type:fu._jsonSchemaVersion}}static fromJSON(e){if(Qy(e,fu._jsonSchema))return new fu(e.latitude,e.longitude)}}fu._jsonSchemaVersion="firestore/geoPoint/1.0",fu._jsonSchema={type:zs("string",fu._jsonSchemaVersion),latitude:zs("number"),longitude:zs("number")};class pu{constructor(e){this._values=(e||[]).map((n=>n))}toArray(){return this._values.map((e=>e))}isEqual(e){return(function(r,s){if(r.length!==s.length)return!1;for(let i=0;i<r.length;++i)if(r[i]!==s[i])return!1;return!0})(this._values,e._values)}toJSON(){return{type:pu._jsonSchemaVersion,vectorValues:this._values}}static fromJSON(e){if(Qy(e,pu._jsonSchema)){if(Array.isArray(e.vectorValues)&&e.vectorValues.every((n=>typeof n=="number")))return new pu(e.vectorValues);throw new Jt(lt.INVALID_ARGUMENT,"Expected 'vectorValues' field to be a number array")}}}pu._jsonSchemaVersion="firestore/vectorValue/1.0",pu._jsonSchema={type:zs("string",pu._jsonSchemaVersion),vectorValues:zs("object")};const Jre=/^__.*__$/;class Zre{constructor(e,n,r){this.data=e,this.fieldMask=n,this.fieldTransforms=r}toMutation(e,n){return this.fieldMask!==null?new bf(e,this.data,this.fieldMask,n,this.fieldTransforms):new Jy(e,this.data,n,this.fieldTransforms)}}function oz(t){switch(t){case 0:case 2:case 1:return!0;case 3:case 4:return!1;default:throw pn(40011,{Ac:t})}}class aE{constructor(e,n,r,s,i,o){this.settings=e,this.databaseId=n,this.serializer=r,this.ignoreUndefinedProperties=s,i===void 0&&this.Rc(),this.fieldTransforms=i||[],this.fieldMask=o||[]}get path(){return this.settings.path}get Ac(){return this.settings.Ac}Vc(e){return new aE({...this.settings,...e},this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)}mc(e){const n=this.path?.child(e),r=this.Vc({path:n,fc:!1});return r.gc(e),r}yc(e){const n=this.path?.child(e),r=this.Vc({path:n,fc:!1});return r.Rc(),r}wc(e){return this.Vc({path:void 0,fc:!0})}Sc(e){return kb(e,this.settings.methodName,this.settings.bc||!1,this.path,this.settings.Dc)}contains(e){return this.fieldMask.find((n=>e.isPrefixOf(n)))!==void 0||this.fieldTransforms.find((n=>e.isPrefixOf(n.field)))!==void 0}Rc(){if(this.path)for(let e=0;e<this.path.length;e++)this.gc(this.path.get(e))}gc(e){if(e.length===0)throw this.Sc("Document fields must not be empty");if(oz(this.Ac)&&Jre.test(e))throw this.Sc('Document fields cannot begin and end with "__"')}}class ese{constructor(e,n,r){this.databaseId=e,this.ignoreUndefinedProperties=n,this.serializer=r||Sx(e)}Cc(e,n,r,s=!1){return new aE({Ac:e,methodName:n,Dc:r,path:Wi.emptyPath(),fc:!1,bc:s},this.databaseId,this.serializer,this.ignoreUndefinedProperties)}}function az(t){const e=t._freezeSettings(),n=Sx(t._databaseId);return new ese(t._databaseId,!!e.ignoreUndefinedProperties,n)}function lz(t,e,n,r,s,i={}){const o=t.Cc(i.merge||i.mergeFields?2:0,e,n,s);dz("Data must be an object, but it was:",o,r);const a=cz(r,o);let l,u;if(i.merge)l=new Nl(o.fieldMask),u=o.fieldTransforms;else if(i.mergeFields){const c=[];for(const d of i.mergeFields){const f=tse(e,d,n);if(!o.contains(f))throw new Jt(lt.INVALID_ARGUMENT,`Field '${f}' is specified in your field mask but missing from your input data.`);rse(c,f)||c.push(f)}l=new Nl(c),u=o.fieldTransforms.filter((d=>l.covers(d.field)))}else l=null,u=o.fieldTransforms;return new Zre(new Za(a),l,u)}function uz(t,e){if(hz(t=sa(t)))return dz("Unsupported field value:",e,t),cz(t,e);if(t instanceof iz)return(function(r,s){if(!oz(s.Ac))throw s.Sc(`${r._methodName}() can only be used with update() and set()`);if(!s.path)throw s.Sc(`${r._methodName}() is not currently supported inside arrays`);const i=r._toFieldTransform(s);i&&s.fieldTransforms.push(i)})(t,e),null;if(t===void 0&&e.ignoreUndefinedProperties)return null;if(e.path&&e.fieldMask.push(e.path),t instanceof Array){if(e.settings.fc&&e.Ac!==4)throw e.Sc("Nested arrays are not supported");return(function(r,s){const i=[];let o=0;for(const a of r){let l=uz(a,s.wc(o));l==null&&(l={nullValue:"NULL_VALUE"}),i.push(l),o++}return{arrayValue:{values:i}}})(t,e)}return(function(r,s){if((r=sa(r))===null)return{nullValue:"NULL_VALUE"};if(typeof r=="number")return Ute(s.serializer,r);if(typeof r=="boolean")return{booleanValue:r};if(typeof r=="string")return{stringValue:r};if(r instanceof Date){const i=Ur.fromDate(r);return{timestampValue:Sb(s.serializer,i)}}if(r instanceof Ur){const i=new Ur(r.seconds,1e3*Math.floor(r.nanoseconds/1e3));return{timestampValue:Sb(s.serializer,i)}}if(r instanceof fu)return{geoPointValue:{latitude:r.latitude,longitude:r.longitude}};if(r instanceof el)return{bytesValue:$M(s.serializer,r._byteString)};if(r instanceof ti){const i=s.databaseId,o=r.firestore._databaseId;if(!o.isEqual(i))throw s.Sc(`Document reference is for database ${o.projectId}/${o.database} but should be for database ${i.projectId}/${i.database}`);return{referenceValue:HC(r.firestore._databaseId||s.databaseId,r._key.path)}}if(r instanceof pu)return(function(o,a){return{mapValue:{fields:{[tM]:{stringValue:nM},[bb]:{arrayValue:{values:o.toArray().map((u=>{if(typeof u!="number")throw a.Sc("VectorValues must only contain numeric values.");return WC(a.serializer,u)}))}}}}}})(r,s);throw s.Sc(`Unsupported field value: ${FC(r)}`)})(t,e)}function cz(t,e){const n={};return XL(t)?e.path&&e.path.length>0&&e.fieldMask.push(e.path):wf(t,((r,s)=>{const i=uz(s,e.mc(r));i!=null&&(n[r]=i)})),{mapValue:{fields:n}}}function hz(t){return!(typeof t!="object"||t===null||t instanceof Array||t instanceof Date||t instanceof Ur||t instanceof fu||t instanceof el||t instanceof ti||t instanceof iz||t instanceof pu)}function dz(t,e,n){if(!hz(n)||!qL(n)){const r=FC(n);throw r==="an object"?e.Sc(t+" a custom object"):e.Sc(t+" "+r)}}function tse(t,e,n){if((e=sa(e))instanceof oE)return e._internalPath;if(typeof e=="string")return fz(t,e);throw kb("Field path arguments must be of type string or ",t,!1,void 0,n)}const nse=new RegExp("[~\\*/\\[\\]]");function fz(t,e,n){if(e.search(nse)>=0)throw kb(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,t,!1,void 0,n);try{return new oE(...e.split("."))._internalPath}catch{throw kb(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,t,!1,void 0,n)}}function kb(t,e,n,r,s){const i=r&&!r.isEmpty(),o=s!==void 0;let a=`Function ${e}() called with invalid data`;n&&(a+=" (via `toFirestore()`)"),a+=". ";let l="";return(i||o)&&(l+=" (found",i&&(l+=` in field ${r}`),o&&(l+=` in document ${s}`),l+=")"),new Jt(lt.INVALID_ARGUMENT,a+t+l)}function rse(t,e){return t.some((n=>n.isEqual(e)))}class pz{constructor(e,n,r,s,i){this._firestore=e,this._userDataWriter=n,this._key=r,this._document=s,this._converter=i}get id(){return this._key.path.lastSegment()}get ref(){return new ti(this._firestore,this._converter,this._key)}exists(){return this._document!==null}data(){if(this._document){if(this._converter){const e=new sse(this._firestore,this._userDataWriter,this._key,this._document,null);return this._converter.fromFirestore(e)}return this._userDataWriter.convertValue(this._document.data.value)}}get(e){if(this._document){const n=this._document.data.field(mz("DocumentSnapshot.get",e));if(n!==null)return this._userDataWriter.convertValue(n)}}}class sse extends pz{data(){return super.data()}}function mz(t,e){return typeof e=="string"?fz(t,e):e instanceof oE?e._internalPath:e._delegate._internalPath}function ise(t){if(t.limitType==="L"&&t.explicitOrderBy.length===0)throw new Jt(lt.UNIMPLEMENTED,"limitToLast() queries require specifying at least one orderBy() clause")}class ose{convertValue(e,n="none"){switch(Th(e)){case 0:return null;case 1:return e.booleanValue;case 2:return Is(e.integerValue||e.doubleValue);case 3:return this.convertTimestamp(e.timestampValue);case 4:return this.convertServerTimestamp(e,n);case 5:return e.stringValue;case 6:return this.convertBytes(Ih(e.bytesValue));case 7:return this.convertReference(e.referenceValue);case 8:return this.convertGeoPoint(e.geoPointValue);case 9:return this.convertArray(e.arrayValue,n);case 11:return this.convertObject(e.mapValue,n);case 10:return this.convertVectorValue(e.mapValue);default:throw pn(62114,{value:e})}}convertObject(e,n){return this.convertObjectMap(e.fields,n)}convertObjectMap(e,n="none"){const r={};return wf(e,((s,i)=>{r[s]=this.convertValue(i,n)})),r}convertVectorValue(e){const n=e.fields?.[bb].arrayValue?.values?.map((r=>Is(r.doubleValue)));return new pu(n)}convertGeoPoint(e){return new fu(Is(e.latitude),Is(e.longitude))}convertArray(e,n){return(e.values||[]).map((r=>this.convertValue(r,n)))}convertServerTimestamp(e,n){switch(n){case"previous":const r=wx(e);return r==null?null:this.convertValue(r,n);case"estimate":return this.convertTimestamp(yy(e));default:return null}}convertTimestamp(e){const n=_h(e);return new Ur(n.seconds,n.nanos)}convertDocumentKey(e,n){const r=Br.fromString(e);vr(RM(r),9688,{name:e});const s=new wy(r.get(1),r.get(3)),i=new on(r.popFirst(5));return s.isEqual(n)||rc(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`),i}}function gz(t,e,n){let r;return r=t?t.toFirestore(e):e,r}class G2{constructor(e,n){this.hasPendingWrites=e,this.fromCache=n}isEqual(e){return this.hasPendingWrites===e.hasPendingWrites&&this.fromCache===e.fromCache}}class Pd extends pz{constructor(e,n,r,s,i,o){super(e,n,r,s,o),this._firestore=e,this._firestoreImpl=e,this.metadata=i}exists(){return super.exists()}data(e={}){if(this._document){if(this._converter){const n=new Gv(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);return this._converter.fromFirestore(n,e)}return this._userDataWriter.convertValue(this._document.data.value,e.serverTimestamps)}}get(e,n={}){if(this._document){const r=this._document.data.field(mz("DocumentSnapshot.get",e));if(r!==null)return this._userDataWriter.convertValue(r,n.serverTimestamps)}}toJSON(){if(this.metadata.hasPendingWrites)throw new Jt(lt.FAILED_PRECONDITION,"DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");const e=this._document,n={};return n.type=Pd._jsonSchemaVersion,n.bundle="",n.bundleSource="DocumentSnapshot",n.bundleName=this._key.toString(),!e||!e.isValidDocument()||!e.isFoundDocument()?n:(this._userDataWriter.convertObjectMap(e.data.value.mapValue.fields,"previous"),n.bundle=(this._firestore,this.ref.path,"NOT SUPPORTED"),n)}}Pd._jsonSchemaVersion="firestore/documentSnapshot/1.0",Pd._jsonSchema={type:zs("string",Pd._jsonSchemaVersion),bundleSource:zs("string","DocumentSnapshot"),bundleName:zs("string"),bundle:zs("string")};class Gv extends Pd{data(e={}){return super.data(e)}}class Im{constructor(e,n,r,s){this._firestore=e,this._userDataWriter=n,this._snapshot=s,this.metadata=new G2(s.hasPendingWrites,s.fromCache),this.query=r}get docs(){const e=[];return this.forEach((n=>e.push(n))),e}get size(){return this._snapshot.docs.size}get empty(){return this.size===0}forEach(e,n){this._snapshot.docs.forEach((r=>{e.call(n,new Gv(this._firestore,this._userDataWriter,r.key,r,new G2(this._snapshot.mutatedKeys.has(r.key),this._snapshot.fromCache),this.query.converter))}))}docChanges(e={}){const n=!!e.includeMetadataChanges;if(n&&this._snapshot.excludesMetadataChanges)throw new Jt(lt.INVALID_ARGUMENT,"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");return this._cachedChanges&&this._cachedChangesIncludeMetadataChanges===n||(this._cachedChanges=(function(s,i){if(s._snapshot.oldDocs.isEmpty()){let o=0;return s._snapshot.docChanges.map((a=>{const l=new Gv(s._firestore,s._userDataWriter,a.doc.key,a.doc,new G2(s._snapshot.mutatedKeys.has(a.doc.key),s._snapshot.fromCache),s.query.converter);return a.doc,{type:"added",doc:l,oldIndex:-1,newIndex:o++}}))}{let o=s._snapshot.oldDocs;return s._snapshot.docChanges.filter((a=>i||a.type!==3)).map((a=>{const l=new Gv(s._firestore,s._userDataWriter,a.doc.key,a.doc,new G2(s._snapshot.mutatedKeys.has(a.doc.key),s._snapshot.fromCache),s.query.converter);let u=-1,c=-1;return a.type!==0&&(u=o.indexOf(a.doc.key),o=o.delete(a.doc.key)),a.type!==1&&(o=o.add(a.doc),c=o.indexOf(a.doc.key)),{type:ase(a.type),doc:l,oldIndex:u,newIndex:c}}))}})(this,n),this._cachedChangesIncludeMetadataChanges=n),this._cachedChanges}toJSON(){if(this.metadata.hasPendingWrites)throw new Jt(lt.FAILED_PRECONDITION,"QuerySnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");const e={};e.type=Im._jsonSchemaVersion,e.bundleSource="QuerySnapshot",e.bundleName=PC.newId(),this._firestore._databaseId.database,this._firestore._databaseId.projectId;const n=[],r=[],s=[];return this.docs.forEach((i=>{i._document!==null&&(n.push(i._document),r.push(this._userDataWriter.convertObjectMap(i._document.data.value.mapValue.fields,"previous")),s.push(i.ref.path))})),e.bundle=(this._firestore,this.query._query,e.bundleName,"NOT SUPPORTED"),e}}function ase(t){switch(t){case 0:return"added";case 2:case 3:return"modified";case 1:return"removed";default:return pn(61501,{type:t})}}Im._jsonSchemaVersion="firestore/querySnapshot/1.0",Im._jsonSchema={type:zs("string",Im._jsonSchemaVersion),bundleSource:zs("string","QuerySnapshot"),bundleName:zs("string"),bundle:zs("string")};class yz extends ose{constructor(e){super(),this.firestore=e}convertBytes(e){return new el(e)}convertReference(e){const n=this.convertDocumentKey(e,this.firestore._databaseId);return new ti(this.firestore,null,n)}}function lse(t,e,n){t=Od(t,ti);const r=Od(t.firestore,_y),s=gz(t.converter,e);return wz(r,[lz(az(r),"setDoc",t._key,s,t.converter!==null,n).toMutation(t._key,hu.none())])}function use(t,e){const n=Od(t.firestore,_y),r=rz(t),s=gz(t.converter,e);return wz(n,[lz(az(t.firestore),"addDoc",r._key,s,t.converter!==null,{}).toMutation(r._key,hu.exists(!1))]).then((()=>r))}function cse(t,...e){t=sa(t);let n={includeMetadataChanges:!1,source:"default"},r=0;typeof e[r]!="object"||iO(e[r])||(n=e[r++]);const s={includeMetadataChanges:n.includeMetadataChanges,source:n.source};if(iO(e[r])){const l=e[r];e[r]=l.next?.bind(l),e[r+1]=l.error?.bind(l),e[r+2]=l.complete?.bind(l)}let i,o,a;if(t instanceof ti)o=Od(t.firestore,_y),a=UC(t._key.path),i={next:l=>{e[r]&&e[r](hse(o,t,l))},error:e[r+1],complete:e[r+2]};else{const l=Od(t,kx);o=Od(l.firestore,_y),a=l._query;const u=new yz(o);i={next:c=>{e[r]&&e[r](new Im(o,u,l,c))},error:e[r+1],complete:e[r+2]},ise(t._query)}return(function(u,c,d,f){const m=new Gre(f),g=new $re(c,m,d);return u.asyncQueue.enqueueAndForget((async()=>_re(await J5(u),g))),()=>{m.Nu(),u.asyncQueue.enqueueAndForget((async()=>Ire(await J5(u),g)))}})(sz(o),a,s,i)}function wz(t,e){return(function(r,s){const i=new Dd;return r.asyncQueue.enqueueAndForget((async()=>Fre(await Kre(r),s,i))),i.promise})(sz(t),e)}function hse(t,e,n){const r=n.docs.get(e._key),s=new yz(t);return new Pd(t,s,e._key,r,new G2(n.hasPendingWrites,n.fromCache),e.converter)}(function(e,n=!0){(function(s){ng=s})(eg),Cm(new Vd("firestore",((r,{instanceIdentifier:s,options:i})=>{const o=r.getProvider("app").getImmediate(),a=new _y(new Zee(r.getProvider("auth-internal")),new nte(o,r.getProvider("app-check-internal")),(function(u,c){if(!Object.prototype.hasOwnProperty.apply(u.options,["projectId"]))throw new Jt(lt.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');return new wy(u.options.projectId,c)})(o,s),o);return i={useFetchStreams:n,...i},a._setSettings(i),a}),"PUBLIC").setMultipleInstances(!0)),hh(u5,c5,e),hh(u5,c5,"esm2020")})();const wa={apiKey:"AIzaSyAmFHywT73BxDTh07vdWxv6cnRht8whtq0",authDomain:"chat-f3713.firebaseapp.com",projectId:"chat-f3713",storageBucket:"chat-f3713.firebasestorage.app",messagingSenderId:"652361597425",appId:"1:652361597425:web:9543be8df5218dd31bc450",measurementId:"G-P1S5TQ385P"};let dT=null,Iy=null,Gd=null;try{dT=eL(wa),Iy=Xee(dT),Gd=Yre(dT),console.log("Firebase initialized")}catch(t){console.error("Firebase init error:",t)}function dse({onLogin:t}){const[e,n]=lr.useState(""),[r,s]=lr.useState(""),[i,o]=lr.useState("candidate"),[a,l]=lr.useState(""),u=async c=>{c.preventDefault(),l("");try{if(!Iy){t({email:e,role:i,displayName:e.split("@")[0]});return}const f=(await OZ(Iy,e,r)).user;t({uid:f.uid,email:f.email,role:i,displayName:f.displayName||f.email.split("@")[0]})}catch(d){l(d.message||"Login failed")}};return et.jsxs("div",{className:"bg-white rounded-2xl shadow p-6",children:[et.jsx("h2",{className:"text-lg font-semibold mb-4",children:"Login"}),et.jsxs("form",{onSubmit:u,className:"space-y-3",children:[et.jsx("input",{required:!0,value:e,onChange:c=>n(c.target.value),placeholder:"Email",className:"w-full p-3 border rounded-lg"}),et.jsx("input",{required:!0,value:r,onChange:c=>s(c.target.value),placeholder:"Password",type:"password",className:"w-full p-3 border rounded-lg"}),et.jsxs("div",{className:"flex items-center gap-3",children:[et.jsx("label",{className:"text-sm",children:"Role:"}),et.jsxs("select",{value:i,onChange:c=>o(c.target.value),className:"p-2 border rounded",children:[et.jsx("option",{value:"candidate",children:"Candidate"}),et.jsx("option",{value:"interviewer",children:"Interviewer"})]})]}),a&&et.jsx("div",{className:"text-red-500 text-sm",children:a}),et.jsx("button",{className:"w-full bg-indigo-600 text-white py-3 rounded-lg font-medium",children:"Login"}),et.jsx("div",{className:"text-xs text-slate-500 pt-2",children:"Demo note: If you haven't created users in Firebase, create them in the Firebase Console or use register."})]})]})}function fse({onRegister:t}){const[e,n]=lr.useState(""),[r,s]=lr.useState(""),[i,o]=lr.useState(""),[a,l]=lr.useState("candidate"),[u,c]=lr.useState(""),d=async f=>{f.preventDefault(),c("");try{if(!Iy){t({email:e,displayName:i||e.split("@")[0],role:a});return}const m=await DZ(Iy,e,r);await FZ(m.user,{displayName:i}),t({uid:m.user.uid,email:m.user.email,displayName:i,role:a})}catch(m){c(m.message||"Register failed")}};return et.jsxs("div",{className:"bg-white rounded-2xl shadow p-6",children:[et.jsx("h2",{className:"text-lg font-semibold mb-4",children:"Register"}),et.jsxs("form",{onSubmit:d,className:"space-y-3",children:[et.jsx("input",{required:!0,value:i,onChange:f=>o(f.target.value),placeholder:"Full name",className:"w-full p-3 border rounded-lg"}),et.jsx("input",{required:!0,value:e,onChange:f=>n(f.target.value),placeholder:"Email",className:"w-full p-3 border rounded-lg"}),et.jsx("input",{required:!0,value:r,onChange:f=>s(f.target.value),placeholder:"Password",type:"password",className:"w-full p-3 border rounded-lg"}),et.jsxs("div",{className:"flex items-center gap-3",children:[et.jsx("label",{className:"text-sm",children:"Role:"}),et.jsxs("select",{value:a,onChange:f=>l(f.target.value),className:"p-2 border rounded",children:[et.jsx("option",{value:"candidate",children:"Candidate"}),et.jsx("option",{value:"interviewer",children:"Interviewer"})]})]}),u&&et.jsx("div",{className:"text-red-500 text-sm",children:u}),et.jsx("button",{className:"w-full bg-sky-600 text-white py-3 rounded-lg font-medium",children:"Create account"}),et.jsx("div",{className:"text-xs text-slate-500 pt-2",children:"Tip: Enable Email/Password auth in Firebase console to use real auth."})]})]})}function oO({title:t,streamRef:e,muted:n=!1}){return et.jsxs("div",{className:"bg-white rounded-2xl shadow p-3",children:[et.jsx("div",{className:"text-sm font-medium mb-2",children:t}),et.jsx("div",{className:"bg-black rounded-lg overflow-hidden",style:{height:360},children:et.jsx("video",{ref:e,autoPlay:!0,playsInline:!0,muted:n,className:"w-full h-full object-cover bg-black"})})]})}function pse({status:t}){return et.jsxs("div",{className:"bg-white rounded-2xl shadow p-4 space-y-3",children:[et.jsx("h3",{className:"text-md font-semibold",children:"Monitoring"}),et.jsxs("div",{className:"grid grid-cols-2 gap-2 text-sm",children:[et.jsxs("div",{className:"p-2 border rounded",children:[et.jsx("div",{className:"text-xs text-slate-500",children:"Face present"}),et.jsx("div",{className:t.facePresent?"text-green-600 font-medium":"text-red-500",children:String(t.facePresent)})]}),et.jsxs("div",{className:"p-2 border rounded",children:[et.jsx("div",{className:"text-xs text-slate-500",children:"Multiple faces"}),et.jsx("div",{className:t.multipleFaces?"text-red-600 font-medium":"text-green-600",children:String(t.multipleFaces)})]}),et.jsxs("div",{className:"p-2 border rounded",children:[et.jsx("div",{className:"text-xs text-slate-500",children:"Eyes closed"}),et.jsx("div",{className:t.eyesClosed?"text-red-600 font-medium":"text-green-600",children:String(t.eyesClosed)})]}),et.jsxs("div",{className:"p-2 border rounded",children:[et.jsx("div",{className:"text-xs text-slate-500",children:"Phone detected"}),et.jsx("div",{className:t.phoneDetected?"text-red-600 font-medium":"text-green-600",children:String(t.phoneDetected)})]})]}),et.jsxs("div",{children:[et.jsx("div",{className:"text-xs text-slate-500",children:"Live transcript"}),et.jsx("div",{className:"h-28 overflow-auto p-2 bg-slate-50 border rounded text-sm",children:t.transcript||"-"})]}),et.jsxs("div",{children:[et.jsx("div",{className:"text-xs text-slate-500",children:"Speaking score"}),et.jsxs("div",{className:"mt-1",children:[et.jsx("div",{className:"w-full h-4 bg-slate-200 rounded",children:et.jsx("div",{className:"h-4 rounded bg-emerald-500",style:{width:`${Math.min(100,Math.max(0,t.score||0))}%`}})}),et.jsxs("div",{className:"text-xs text-slate-600 mt-1",children:[Math.round(t.score||0)," / 100"]})]})]})]})}const mse=1e-7,gse=1e-4;class Nx{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class n0{refCount(e){return Yo("refCount")}incRef(e){return Yo("incRef")}timerAvailable(){return!0}time(e){return Yo("time")}read(e){return Yo("read")}readSync(e){return Yo("readSync")}readToGPU(e,n){return Yo("readToGPU")}numDataIds(){return Yo("numDataIds")}disposeData(e,n){return Yo("disposeData")}write(e,n,r){return Yo("write")}move(e,n,r,s,i){return Yo("move")}createTensorFromGPUData(e,n,r){return Yo("createTensorFromGPUData")}memory(){return Yo("memory")}floatPrecision(){return Yo("floatPrecision")}epsilon(){return this.floatPrecision()===32?mse:gse}dispose(){return Yo("dispose")}}function Yo(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function lE(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Hu(t,e,n)}function yse(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Hu(t,n,r),Hu(e,n,r)}function Ch(t,e,n){return Math.max(t,Math.min(e,n))}function Ax(t){return t%2===0?t:t+1}function Hu(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function vz(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function wse(t,e){const n=Math.random();return e*n+(1-n)*t}function vse(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function J(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Ni(t,e,n=""){J(zn(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function _f(t){J(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ue(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function bse(t){return t.length===0}function bz(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function zn(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Hd(t){return t%1===0}function xse(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function Nb(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function _se(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return lE(e),e}function Fd(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function c$(t,e=s=>0,n,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(t()){s();return}o++;const l=e(o);if(n!=null&&o>=n){i();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function uE(t,e){let n=1,r=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(t[i]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function On(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),J(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),J(t.every(r=>Hd(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function gc(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:On(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(i!=null){if(i[o]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(i[o]==null||i[o]>a)&&t[a]===1&&(n.push(t[a]),r.push(a)),i[o]<=a&&o++}t[a]!==1&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function ii(t,e){return as(t,e)}function as(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function xz(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function _z(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function cE(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Ty(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function Iz(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function ou(t){return typeof t=="string"||t instanceof String}function Tz(t){return typeof t=="boolean"}function Ab(t){return typeof t=="number"}function If(t){return Array.isArray(t)?If(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":Ab(t)?"float32":ou(t)?"string":Tz(t)?"bool":"float32"}function Eh(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Rb(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function Qt(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Sz(t,e,n,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=n[t+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<i;l++)s[l]=Sz(t+l*a,o,n,r)}return s}function $a(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,i)=>s*i)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Sz(0,t,e,n)}function $z(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function Rx(t,e){const n=Ei(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ei(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function hE(t,e){const n=t.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return $a(t,new Float32Array(n));if(e==="int32")return $a(t,new Int32Array(n));if(e==="bool")return $a(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function la(t){t.forEach(e=>{J(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Al(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function Tf(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function ic(t){return t&&t.then&&typeof t.then=="function"}const aO="tfjsflags";class dE{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ise,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(De().getBool("IS_TEST")||De().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];De().getBool("IS_TEST")||De().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(ic(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);aO in e&&e[aO].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=Sse(s,i)})}}function Ise(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(Tse(e,r[0],r[1]),r.join("="))),e}function Tse(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function Sse(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function De(){return Dx}let Dx=null;function $se(t){Dx=t}let fT;function Cz(){if(fT==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");fT=t}return fT}function Cse(){const t=Cz();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function fE(t,e){const n=Cse();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const og="Abs",Sf="Acos",$f="Acosh",Uh="Add",ag="AddN",r0="All",s0="Any",lg="ArgMax",ug="ArgMin",Cf="Asin",Ef="Asinh",kf="Atan",Nf="Atanh",Af="Atan2",cg="AvgPool",i0="AvgPoolGrad",hg="AvgPool3D",o0="AvgPool3DGrad",dg="BatchMatMul",fg="BatchToSpaceND",a0="Bincount",pg="BitwiseAnd",pE="BroadcastTo",l0="BroadcastArgs",Rf="Cast",Df="Ceil",Of="ClipByValue",u0="Complex",mg="ComplexAbs",gg="Concat",yg="Conv2D",c0="Conv2DBackpropFilter",wg="Conv2DBackpropInput",vg="Conv3D",h0="Conv3DBackpropFilterV2",d0="Conv3DBackpropInputV2",Pf="Cos",Ff="Cosh",f0="Cumprod",bg="Cumsum",p0="CropAndResize",m0="DenseBincount",g0="DepthToSpace",xg="DepthwiseConv2dNative",y0="DepthwiseConv2dNativeBackpropFilter",w0="DepthwiseConv2dNativeBackpropInput",v0="Diag",_g="Dilation2D",Sy="Dilation2DBackpropInput",$y="Dilation2DBackpropFilter",b0="Draw",Lf="RealDiv",x0="Einsum",Mf="Elu",_0="EluGrad",zf="Erf",Ig="Equal",Vf="Exp",Tg="ExpandDims",Bf="Expm1",I0="FFT",T0="Fill",S0="FlipLeftRight",Uf="Floor",Wf="FloorDiv",Sg="FusedBatchNorm",$g="GatherV2",$0="GatherNd",Cg="Greater",jf="GreaterEqual",Gf="Identity",C0="IFFT",E0="Imag",Hf="IsFinite",qf="IsInf",Kf="IsNan",Eg="LeakyRelu",kg="Less",Ng="LessEqual",k0="LinSpace",Xf="Log",Yf="Log1p",Ag="LogicalAnd",Rg="LogicalNot",Dg="LogicalOr",Ez="LogicalXor",mE="LogSoftmax",kz="LowerBound",Og="LRN",N0="LRNGrad",Nz="MatrixBandPart",Pg="Max",Qf="Maximum",Fg="MaxPool",A0="MaxPoolGrad",Lg="MaxPool3D",R0="MaxPool3DGrad",D0="MaxPoolWithArgmax",Mg="Mean",zg="Min",Jf="Minimum",Vg="MirrorPad",Zf="Mod",O0="Multinomial",ep="Multiply",Bg="Neg",Ug="NotEqual",P0="NonMaxSuppressionV3",F0="NonMaxSuppressionV4",L0="NonMaxSuppressionV5",Wg="OnesLike",jg="OneHot",Gg="Pack",Hg="PadV2",Az="Pool",tp="Pow",qg="Prelu",Kg="Prod",M0="RaggedGather",z0="RaggedRange",V0="RaggedTensorToTensor",B0="Range",U0="Real",np="Reciprocal",rp="Relu",Xg="Reshape",Yg="ResizeNearestNeighbor",W0="ResizeNearestNeighborGrad",Qg="ResizeBilinear",j0="ResizeBilinearGrad",sp="Relu6",Jg="Reverse",ip="Round",op="Rsqrt",G0="ScatterNd",H0="TensorScatterUpdate",q0="SearchSorted",Zg="Select",ap="Selu",e1="Slice",lp="Sin",up="Sinh",cp="Sign",hp="Sigmoid",dp="Softplus",fp="Sqrt",t1="Sum",n1="SpaceToBatchND",r1="SplitV",s1="Softmax",K0="SparseFillEmptyRows",X0="SparseReshape",Y0="SparseSegmentMean",Q0="SparseSegmentSum",J0="SparseToDense",pp="SquaredDifference",Z0="Square",i1="StaticRegexReplace",ew="StridedSlice",tw="StringNGrams",nw="StringSplit",rw="StringToHashBucketFast",mp="Sub",gp="Tan",yp="Tanh",wp="Tile",sw="TopK",iw="Transform",ph="Transpose",ow="Unique",o1="Unpack",a1="UnsortedSegmentSum",Rz="UpperBound",l1="ZerosLike",vp="Step",Cy="FromPixels",aw="RotateWithOffset",Pm="_FusedMatMul",Fm="FusedConv2D",Lm="FusedDepthwiseConv2D";function _a(...t){De().getBool("IS_TEST")||De().getBool("PROD")||console.warn(...t)}function Ese(...t){De().getBool("IS_TEST")||De().getBool("PROD")||console.log(...t)}const Mm=fE("kernelRegistry",()=>new Map),Ey=fE("gradRegistry",()=>new Map);function zm(t,e){const n=yE(t,e);return Mm.get(n)}function Db(t){return Ey.get(t)}function ky(t){const e=Mm.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===t&&n.push(o)}return n}function lw(t){const{kernelName:e,backendName:n}=t,r=yE(e,n);Mm.has(r)&&_a(`The kernel '${e}' for backend '${n}' is already registered`),Mm.set(r,t)}function gE(t){const{kernelName:e}=t;Ey.has(e)&&De().getBool("DEBUG")&&_a(`Overriding the gradient for '${e}'`),Ey.set(e,t)}function Dz(t,e){const n=yE(t,e);if(!Mm.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);Mm.delete(n)}function Oz(t){if(!Ey.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);Ey.delete(t)}function Pz(t,e){ky(t).forEach(r=>{const s=Object.assign({},r,{backendName:e});lw(s)})}function yE(t,e){return`${e}_${t}`}function Fz(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var pT,lO;function kse(){if(lO)return pT;lO=1,pT=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(F,P,K){this.low=F|0,this.high=P|0,this.unsigned=!!K}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function n(F){return(F&&F.__isLong__)===!0}e.isLong=n;var r={},s={};function i(F,P){var K,j,se;return P?(F>>>=0,(se=0<=F&&F<256)&&(j=s[F],j)?j:(K=a(F,(F|0)<0?-1:0,!0),se&&(s[F]=K),K)):(F|=0,(se=-128<=F&&F<128)&&(j=r[F],j)?j:(K=a(F,F<0?-1:0,!1),se&&(r[F]=K),K))}e.fromInt=i;function o(F,P){if(isNaN(F))return P?x:b;if(P){if(F<0)return x;if(F>=g)return R}else{if(F<=-y)return D;if(F+1>=y)return L}return F<0?o(-F,P).neg():a(F%m|0,F/m|0,P)}e.fromNumber=o;function a(F,P,K){return new e(F,P,K)}e.fromBits=a;var l=Math.pow;function u(F,P,K){if(F.length===0)throw Error("empty string");if(F==="NaN"||F==="Infinity"||F==="+Infinity"||F==="-Infinity")return b;if(typeof P=="number"?(K=P,P=!1):P=!!P,K=K||10,K<2||36<K)throw RangeError("radix");var j;if((j=F.indexOf("-"))>0)throw Error("interior hyphen");if(j===0)return u(F.substring(1),P,K).neg();for(var se=o(l(K,8)),fe=b,me=0;me<F.length;me+=8){var ye=Math.min(8,F.length-me),oe=parseInt(F.substring(me,me+ye),K);if(ye<8){var ue=o(l(K,ye));fe=fe.mul(ue).add(o(oe))}else fe=fe.mul(se),fe=fe.add(o(oe))}return fe.unsigned=P,fe}e.fromString=u;function c(F,P){return typeof F=="number"?o(F,P):typeof F=="string"?u(F,P):a(F.low,F.high,typeof P=="boolean"?P:F.unsigned)}e.fromValue=c;var d=65536,f=1<<24,m=d*d,g=m*m,y=g/2,v=i(f),b=i(0);e.ZERO=b;var x=i(0,!0);e.UZERO=x;var $=i(1);e.ONE=$;var S=i(1,!0);e.UONE=S;var E=i(-1);e.NEG_ONE=E;var L=a(-1,2147483647,!1);e.MAX_VALUE=L;var R=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=R;var D=a(0,-2147483648,!1);e.MIN_VALUE=D;var A=e.prototype;return A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},A.toString=function(P){if(P=P||10,P<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(D)){var K=o(P),j=this.div(K),se=j.mul(K).sub(this);return j.toString(P)+se.toInt().toString(P)}else return"-"+this.neg().toString(P);for(var fe=o(l(P,6),this.unsigned),me=this,ye="";;){var oe=me.div(fe),ue=me.sub(oe.mul(fe)).toInt()>>>0,_e=ue.toString(P);if(me=oe,me.isZero())return _e+ye;for(;_e.length<6;)_e="0"+_e;ye=""+_e+ye}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var P=this.high!=0?this.high:this.low,K=31;K>0&&(P&1<<K)==0;K--);return this.high!=0?K+33:K+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(this.low&1)===1},A.isEven=function(){return(this.low&1)===0},A.equals=function(P){return n(P)||(P=c(P)),this.unsigned!==P.unsigned&&this.high>>>31===1&&P.high>>>31===1?!1:this.high===P.high&&this.low===P.low},A.eq=A.equals,A.notEquals=function(P){return!this.eq(P)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(P){return this.comp(P)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(P){return this.comp(P)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(P){return this.comp(P)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(P){return this.comp(P)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(P){if(n(P)||(P=c(P)),this.eq(P))return 0;var K=this.isNegative(),j=P.isNegative();return K&&!j?-1:!K&&j?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add($)},A.neg=A.negate,A.add=function(P){n(P)||(P=c(P));var K=this.high>>>16,j=this.high&65535,se=this.low>>>16,fe=this.low&65535,me=P.high>>>16,ye=P.high&65535,oe=P.low>>>16,ue=P.low&65535,_e=0,Y=0,re=0,Te=0;return Te+=fe+ue,re+=Te>>>16,Te&=65535,re+=se+oe,Y+=re>>>16,re&=65535,Y+=j+ye,_e+=Y>>>16,Y&=65535,_e+=K+me,_e&=65535,a(re<<16|Te,_e<<16|Y,this.unsigned)},A.subtract=function(P){return n(P)||(P=c(P)),this.add(P.neg())},A.sub=A.subtract,A.multiply=function(P){if(this.isZero())return b;if(n(P)||(P=c(P)),t){var K=t.mul(this.low,this.high,P.low,P.high);return a(K,t.get_high(),this.unsigned)}if(P.isZero())return b;if(this.eq(D))return P.isOdd()?D:b;if(P.eq(D))return this.isOdd()?D:b;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(v)&&P.lt(v))return o(this.toNumber()*P.toNumber(),this.unsigned);var j=this.high>>>16,se=this.high&65535,fe=this.low>>>16,me=this.low&65535,ye=P.high>>>16,oe=P.high&65535,ue=P.low>>>16,_e=P.low&65535,Y=0,re=0,Te=0,Pe=0;return Pe+=me*_e,Te+=Pe>>>16,Pe&=65535,Te+=fe*_e,re+=Te>>>16,Te&=65535,Te+=me*ue,re+=Te>>>16,Te&=65535,re+=se*_e,Y+=re>>>16,re&=65535,re+=fe*ue,Y+=re>>>16,re&=65535,re+=me*oe,Y+=re>>>16,re&=65535,Y+=j*_e+se*ue+fe*oe+me*ye,Y&=65535,a(Te<<16|Pe,Y<<16|re,this.unsigned)},A.mul=A.multiply,A.divide=function(P){if(n(P)||(P=c(P)),P.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&P.low===-1&&P.high===-1)return this;var K=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,P.low,P.high);return a(K,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:b;var j,se,fe;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return x;if(P.gt(this.shru(1)))return S;fe=x}else{if(this.eq(D)){if(P.eq($)||P.eq(E))return D;if(P.eq(D))return $;var me=this.shr(1);return j=me.div(P).shl(1),j.eq(b)?P.isNegative()?$:E:(se=this.sub(P.mul(j)),fe=j.add(se.div(P)),fe)}else if(P.eq(D))return this.unsigned?x:b;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();fe=b}for(se=this;se.gte(P);){j=Math.max(1,Math.floor(se.toNumber()/P.toNumber()));for(var ye=Math.ceil(Math.log(j)/Math.LN2),oe=ye<=48?1:l(2,ye-48),ue=o(j),_e=ue.mul(P);_e.isNegative()||_e.gt(se);)j-=oe,ue=o(j,this.unsigned),_e=ue.mul(P);ue.isZero()&&(ue=$),fe=fe.add(ue),se=se.sub(_e)}return fe},A.div=A.divide,A.modulo=function(P){if(n(P)||(P=c(P)),t){var K=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,P.low,P.high);return a(K,t.get_high(),this.unsigned)}return this.sub(this.div(P).mul(P))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return a(~this.low,~this.high,this.unsigned)},A.and=function(P){return n(P)||(P=c(P)),a(this.low&P.low,this.high&P.high,this.unsigned)},A.or=function(P){return n(P)||(P=c(P)),a(this.low|P.low,this.high|P.high,this.unsigned)},A.xor=function(P){return n(P)||(P=c(P)),a(this.low^P.low,this.high^P.high,this.unsigned)},A.shiftLeft=function(P){return n(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):a(0,this.low<<P-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(P){return n(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):a(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(P){if(n(P)&&(P=P.toInt()),P&=63,P===0)return this;var K=this.high;if(P<32){var j=this.low;return a(j>>>P|K<<32-P,K>>>P,this.unsigned)}else return P===32?a(K,0,this.unsigned):a(K>>>P-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},A.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var P=this.high,K=this.low;return[K&255,K>>>8&255,K>>>16&255,K>>>24,P&255,P>>>8&255,P>>>16&255,P>>>24]},A.toBytesBE=function(){var P=this.high,K=this.low;return[P>>>24,P>>>16&255,P>>>8&255,P&255,K>>>24,K>>>16&255,K>>>8&255,K&255]},e.fromBytes=function(P,K,j){return j?e.fromBytesLE(P,K):e.fromBytesBE(P,K)},e.fromBytesLE=function(P,K){return new e(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,K)},e.fromBytesBE=function(P,K){return new e(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],K)},pT}var Lz=kse();const Mz=bC(Lz),Nse=WF({__proto__:null,default:Mz},[Lz]);const _d=Mz||Nse;function uw(t){return _d.fromString(t,!0,16)}const zz=uw("c3a5c85c97cb3127"),xd=uw("b492b66fbe98f273"),co=uw("9ae16a3b2f90404f");function h$(t){return t.xor(t.shru(47))}function Vz(t,e,n){const r=t.slice(e,e+n);return _d.fromBytes(Array.from(r),!0,!0)}function kr(t,e){return Vz(t,e,8)}function uO(t,e){return Vz(t,e,4)}function Zs(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function mh(t,e,n=uw("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Ase(t,e,n,r,s,i){s=s.add(t),i=Zs(i.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(n),i=i.add(Zs(s,44)),[s.add(r),i.add(o)]}function av(t,e,n,r){return Ase(kr(t,e),kr(t,e+8),kr(t,e+16),kr(t,e+24),n,r)}function Rse(t,e=t.length){if(e>=8){const n=co.add(e*2),r=kr(t,0).add(co),s=kr(t,e-8),i=Zs(s,37).mul(n).add(r),o=Zs(r,25).add(s).mul(n);return mh(i,o,n)}if(e>=4){const n=co.add(e*2),r=uO(t,0);return mh(r.shl(3).add(e),uO(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],i=n+(r<<8),o=e+(s<<2);return h$(co.mul(i).xor(zz.mul(o))).mul(co)}return co}function Dse(t,e=t.length){const n=co.add(e*2),r=kr(t,0).mul(xd),s=kr(t,8),i=kr(t,e-8).mul(n),o=kr(t,e-16).mul(co);return mh(Zs(r.add(s),43).add(Zs(i,30)).add(o),r.add(Zs(s.add(co),18)).add(i),n)}function Ose(t,e=t.length){const n=co.add(e*2),r=kr(t,0).mul(co),s=kr(t,8),i=kr(t,e-8).mul(n),o=kr(t,e-16).mul(co),a=Zs(r.add(s),43).add(Zs(i,30)).add(o),l=mh(a,r.add(Zs(s.add(co),18)).add(i),n),u=kr(t,16).mul(n),c=kr(t,24),d=a.add(kr(t,e-32)).mul(n),f=l.add(kr(t,e-24)).mul(n);return mh(Zs(u.add(c),43).add(Zs(d,30)).add(f),u.add(Zs(c.add(r),18)).add(d),n)}function Bz(t,e=t.length){const n=_d.fromNumber(81,!0);if(e<=32)return e<=16?Rse(t,e):Dse(t,e);if(e<=64)return Ose(t,e);let r=n,s=n.mul(xd).add(113),i=h$(s.mul(co).add(113)).mul(co),o=[_d.UZERO,_d.UZERO],a=[_d.UZERO,_d.UZERO];r=r.mul(co).add(kr(t,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do r=Zs(r.add(s).add(o[0]).add(kr(t,l+8)),37).mul(xd),s=Zs(s.add(o[1]).add(kr(t,l+48)),42).mul(xd),r=r.xor(a[1]),s=s.add(o[0]).add(kr(t,l+40)),i=Zs(i.add(a[0]),33).mul(xd),o=av(t,l,o[1].mul(xd),r.add(a[0])),a=av(t,l+32,i.add(a[1]),s.add(kr(t,l+16))),[i,r]=[r,i],l+=64;while(l!==u);const d=xd.add(i.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=Zs(r.add(s).add(o[0]).add(kr(t,l+8)),37).mul(d),s=Zs(s.add(o[1]).add(kr(t,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(kr(t,l+40))),i=Zs(i.add(a[0]),33).mul(d),o=av(t,l,o[1].mul(d),r.add(a[0])),a=av(t,l+32,i.add(a[1]),s.add(kr(t,l+16))),[i,r]=[r,i],mh(mh(o[0],a[0],d).add(h$(s).mul(zz)).add(i),mh(o[1],a[1],d).add(r),d)}function yc(t,e){return e==="string"?mu(t):Wh([t],e)}function Pse(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function Wh(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=xu(t)),De().getBool("DEBUG")&&xz(t,e),Pse(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Ti(){return De().platform.now()}function Uz(t,e){return De().platform.fetch(t,e)}function mu(t,e="utf-8"){return e=e||"utf-8",De().platform.encode(t,e)}function oc(t,e="utf-8"){return e=e||"utf-8",De().platform.decode(t,e)}function Ms(t){return De().platform.isTypedArray!=null?De().platform.isTypedArray(t):Fz(t)}function xu(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||ic(t)||t==null||Ms(t)&&n)e.push(t);else if(Array.isArray(t)||Ms(t))for(let r=0;r<t.length;++r)xu(t[r],e,n);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)xu(t[s],e,n)}return e}const Wz=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:zn,arraysEqualWithNull:bz,assert:J,assertNonNegativeIntegerDimensions:la,assertNonNull:_f,assertShapesMatch:Ni,bytesFromStringArray:Iz,bytesPerElement:Ty,checkConversionForErrors:xz,clamp:Ch,computeStrides:Qt,convertBackendValuesAndArrayBuffer:$z,createScalarValue:yc,createShuffledIndices:_se,decodeString:oc,distSquared:vse,encodeString:mu,fetch:Uz,fingerPrint64:Bz,flatten:xu,getArrayFromDType:as,getTypedArrayFromDType:ii,hasEncodingLoss:cE,hexToLong:uw,indexToLoc:Tf,inferDtype:If,inferFromImplicitShape:uE,isBoolean:Tz,isFunction:Eh,isInt:Hd,isNumber:Ab,isPromise:ic,isScalarShape:bse,isString:ou,isTypedArray:Ms,isValidDtype:_z,locToIndex:Al,makeOnesTypedArray:Rx,makeZerosNestedTypedArray:hE,makeZerosTypedArray:Ei,nearestDivisor:Rb,nearestLargerEven:Ax,now:Ti,parseAxisParam:On,randUniform:wse,repeatedTry:c$,rightPad:Fd,shuffle:lE,shuffleCombo:yse,sizeFromShape:Ue,sizeToSquarishShape:Nb,squeezeShape:gc,sum:vz,swap:Hu,tanh:xse,toNestedArray:$a,toTypedArray:Wh},Symbol.toStringTag,{value:"Module"}));class Fse{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new Mse)}profileKernel(e,n,r){let s;const i=()=>{s=r()};let o;const a=Ti();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const u of s)u.dataSync();o=Promise.resolve({kernelMs:Ti()-a})}if(De().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{Lse(d,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],i,l[2])})})}}function Lse(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class Mse{logKernelProfile(e,n,r,s,i,o){const a=typeof s=="number"?Fd(`${s}ms`,9):s.error,l=Fd(e,25),u=n.rank,c=n.size,d=Fd(n.shape.toString(),14);let f="";for(const m in i){const g=i[m];if(g!=null){const y=g.shape||n.shape,v=y.length;f+=`${m}: ${v}D ${v>0?y:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${d}	%c${c}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function zse(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const d in c){const f=c[d];let m=!1;for(let g=0;g<e.length;g++)if(r[f.id]){u.outputs.forEach(y=>r[y.id]=!0),m=!0,s[u.id]=!0;break}if(m)break}}const i={};i[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(i[u.outputs[d].id]){for(const f in c)i[c[f].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const u=t[l];if(s[u.id]&&o[u.id]){const c={};for(const f in u.inputs){const m=u.inputs[f];r[m.id]&&(c[f]=m)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}function Vse(t,e,n,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const u=t[l.id];u!=null?o.push(u):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=n(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=i.inputs[l];if(!zn(u.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=u;else{const d=t[c.id];t[c.id]=r(d,u),d.dispose()}}}}const cO=20,I2=3,mT=7;function Bse(t,e,n,r){const s=Qt(e),i=Use(t,e,n,s),o=e.length,a=Hv(t,e,n,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function Use(t,e,n,r){const s=Ue(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=n==="complex64"?q2(t):t;if(a>1)for(let u=0;u<s/i;u++){const c=u*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],H2(l[c+d],0,n).length)}return o}function H2(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(mT))} + ${parseFloat(t[1].toFixed(mT))}j`:ou(t)?r=`'${t}'`:n==="bool"?r=jz(t):r=parseFloat(t.toFixed(mT)).toString(),Fd(r,e)}function jz(t){return t===0?"false":"true"}function Hv(t,e,n,r,s,i=!0){const o=n==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(n==="complex64"){const y=q2(t);return[H2(y[0],0,n)]}return n==="bool"?[jz(t[0])]:[t[0].toString()]}if(l===1){if(a>cO){const v=I2*o;let b=Array.from(t.slice(0,v)),x=Array.from(t.slice((a-I2)*o,a*o));return n==="complex64"&&(b=q2(b),x=q2(x)),["["+b.map(($,S)=>H2($,s[S],n)).join(", ")+", ..., "+x.map(($,S)=>H2($,s[a-I2+S],n)).join(", ")+"]"]}return["["+(n==="complex64"?q2(t):Array.from(t)).map((v,b)=>H2(v,s[b],n)).join(", ")+"]"]}const u=e.slice(1),c=r.slice(1),d=r[0]*o,f=[];if(a>cO){for(let y=0;y<I2;y++){const v=y*d,b=v+d;f.push(...Hv(t.slice(v,b),u,n,c,s,!1))}f.push("...");for(let y=a-I2;y<a;y++){const v=y*d,b=v+d;f.push(...Hv(t.slice(v,b),u,n,c,s,y===a-1))}}else for(let y=0;y<a;y++){const v=y*d,b=v+d;f.push(...Hv(t.slice(v,b),u,n,c,s,y===a-1))}const m=l===2?",":"";f[0]="["+(a>0?f[0]+m:"");for(let y=1;y<f.length-1;y++)f[y]=" "+f[y]+m;let g=`,
`;for(let y=2;y<l;y++)g+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":g),f}function q2(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class ms{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=Ue(e),r!=null){const s=r.length;J(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||as(n,this.size),this.strides=Qt(e)}set(e,...n){n.length===0&&(n=[0]),J(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return $l().makeTensor(this.values,this.shape,this.dtype)}}let $l=null,mm=null;function Wse(t){$l=t}function jse(t){mm=t}class Rn{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=Ue(e),this.strides=Qt(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return mm.buffer(this.shape,this.dtype,e)}bufferSync(){return mm.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return $a(this.shape,e,this.dtype==="complex64")}arraySync(){return $a(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=$l().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>oc(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),$l().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=$l().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>oc(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await $l().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),$l().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return mm.print(this,e)}clone(){return this.throwIfDisposed(),mm.clone(this)}toString(e=!1){const n=this.dataSync();return Bse(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),mm.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),$l().makeVariable(this,e,n,r)}}Object.defineProperty(Rn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function Ke(){return fE("Tensor",()=>Rn)}Ke();class Vm extends Rn{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!zn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);$l().disposeTensor(this),this.dataId=e.dataId,$l().incRef(this,null)}dispose(){$l().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Vm,Symbol.hasInstance,{value:t=>t instanceof Rn&&t.assign!=null&&t.assign instanceof Function});var Ob;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(Ob||(Ob={}));var d$;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(d$||(d$={}));var f$;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(f$||(f$={}));var p$;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(p$||(p$={}));var m$;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(m$||(m$={}));const Gse={float32:p$,int32:d$,bool:f$,complex64:m$};function go(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Gse[t][e]}function cw(t){return go(t,"int32")}function Gz(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function Hz(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}function ts(t,e){if(t.dtype===e.dtype)return[t,e];const n=go(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function qz(t,e){J(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function Ox(t,e){return e.some(n=>n.id===t.id)}function ac(t){const e=[];return Kz(t,e,new Set),e}function Kz(t,e,n){if(t==null)return;if(t instanceof Rn){e.push(t);return}if(!Hse(t))return;const r=t;for(const s in r){const i=r[s];n.has(i)||(n.add(i),Kz(i,e,n))}}function Hse(t){return Array.isArray(t)||typeof t=="object"}const Xz=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:qz,getTensorsInContainer:ac,isTensorInList:Ox,makeTypesMatch:ts},Symbol.toStringTag,{value:"Module"}));function gT(t){return t.kernelName!=null}class hO{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Bm{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new hO}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(_a(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Fse(this.backendInstance),!0}setupRegisteredKernels(){ky(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ky(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof n0)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,_a(`Initialization of backend ${e} failed`),_a(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return _a(`Initialization of backend ${e} failed`),_a(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,i=this.readSync(n),o=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Bm.nextTensorId++}nextVariableId(){return Bm.nextVariableId++}clone(e){const n=we.runKernel(Gf,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},u={dtype:a};return we.runKernel(Rf,l,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,i,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(zm(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-n-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=gT(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(gT(e)){const{kernelName:g,inputs:y,attrs:v}=e;this.backendName==null&&this.backend;const b=zm(g,this.backendName);J(b!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),a=()=>{const x=this.backend.numDataIds();l=b.kernelFunc({inputs:y,attrs:v,backend:this.backend});const $=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,x,$);const S=$.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(s){const E=this.getTensorsForGradient(g,y,S);r=this.saveTensorsForBackwardMode(E)}return S}}else{const{forwardFunc:g}=e,y=v=>{s&&(r=v.map(b=>this.keep(this.clone(b))))};a=()=>{const v=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,y));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,v,b),b}}const{inputs:c,attrs:d}=e,f=gT(e)?null:e.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(m=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),n=m.outputs)}),s&&this.addTapeNode(u,c,n,f,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(g=>c[g]!=null?c[g].shape:null),outputShapes:n.map(g=>g.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=Db(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(J(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(u=>n[u])):a=i.map(u=>n[u]);const l=r.filter((u,c)=>o[c]);return a.concat(l)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&ou(e[0])&&(i=e.map(l=>mu(l)));const o=s.write(i,n,r),a=new Rn(n,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),u=Iz(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,n,r,s){r=r||"float32";const i={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:i}=e,o=new Rn(s,i,r,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new Vm(e,n,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Ty(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Vm||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Ty(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:i},l=Db(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=u=>(u=u.map((c,d)=>{if(c==null){const f=r[d],m=Ei(f.size,f.dtype);return this.makeTensor(m,f.shape,f.dtype)}return c}),s(u.length>1?u:u[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=ac(e),r=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,n,r,s=!1){if(J(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));J(i instanceof Rn,()=>"The result y returned by f() must be a tensor.");const o=zse(this.state.activeTape,n,i);if(!s&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??qse(i.shape),Vse(a,o,u=>this.tidy(u),Kse);const l=n.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return J(Eh(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{J(n.every(a=>a instanceof Rn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...n,l),J(r.value instanceof Rn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),J(Eh(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const u=r.gradFunc(a,l),c=Array.isArray(u)?u:[u];J(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),J(c.every(f=>f instanceof Rn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((f,m)=>{d[m]=()=>f}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Ti(),r=await this.backend.time(e);return r.wallMs=Ti()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new hO;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Bm.nextTensorId=0;Bm.nextVariableId=0;function qse(t){const e=Rx(Ue(t),"float32");return we.makeTensor(e,t,"float32")}function Yz(){const t=Cz();if(t._tfengine==null){const e=new dE(t);t._tfengine=new Bm(e)}return $se(t._tfengine.ENV),Wse(()=>t._tfengine),t._tfengine}const we=Yz();function Kse(t,e){const n={a:t,b:e};return we.runKernel(Uh,n)}function Xse(){return typeof navigator<"u"&&navigator!=null}let g$;function Yse(t){g$=t}function wE(t){if(g$!==void 0)return g$;if(t||Xse()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function vE(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Qz=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:vE,isMobile:wE,mockIsMobile:Yse},Symbol.toStringTag,{value:"Module"}));const ko=De();ko.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ko.registerFlag("IS_BROWSER",()=>vE());ko.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ko.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ko.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ko.registerFlag("PROD",()=>!1);ko.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ko.getBool("DEBUG"));ko.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ko.registerFlag("IS_TEST",()=>!1);ko.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ko.getBool("DEBUG"));ko.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ko.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ko.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function _u(t,e){let n=t;if(Ms(t))return e==="string"?[]:[t.length];if(Gz(t)){const s=t.channels||"RGBA";return[t.height,t.width*s.length]}else if(Hz(t))return[t.buffer.size/(e==null?4:Ty(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Ms(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&De().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Jz(t,r,[]),r}function Jz(t,e,n){if(n=n||[],!Array.isArray(t)&&!Ms(t)){J(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}J(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),J(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)Jz(t[s],r,n.concat(s))}function dO(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function ee(t,e,n,r="numeric"){if(t instanceof Ke())return dO(r,t.dtype,e,n),t;let s=If(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),dO(r,s,e,n),t==null||!Ms(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const i=_u(t,s);!Ms(t)&&!Array.isArray(t)&&(t=[t]);const a=s!=="string"?Wh(t,s):xu(t,[],!0);return we.makeTensor(a,i,s)}function Ny(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((i,o)=>ee(i,`${e}[${o}]`,n,r))}const Px="__op";function ve(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Px;const s=(...i)=>{we.startScope(n);try{const o=r(...i);return ic(o)&&console.error("Cannot return a Promise inside of tidy."),we.endScope(o),o}catch(o){throw we.endScope(null),o}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function Qse(t,e){const n=ee(t,"real","complex"),r=ee(e,"imag","complex");Ni(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return we.runKernel(u0,s)}const Iu=ve({complex_:Qse});function jh(t,e,n,r){if(r==null)r=If(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Hz(t)||Gz(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return we.backend.createTensorFromGPUData(t,e||n,r)}if(!Ms(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){la(e);const s=Ue(e),i=Ue(n);J(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<n.length;++o){const a=n[o],l=o===n.length-1?a!==Ue(e.slice(o)):!0;J(n[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Ms(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?Wh(t,r):xu(t,[],!0),we.makeTensor(t,e,r)}function Eo(t,e,n){const r=_u(t,n);return jh(t,e,r,n)}const qd={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class jl{static join(e){return new jl(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>Ms(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=n+s.byteLength;this.shards.push({buffer:s,start:n,end:i}),n=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=n-e,i=new ArrayBuffer(s),o=new Uint8Array(i);let a=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],d=e+a-u.start,f=a,g=Math.min(n,u.end)-u.start,y=new Uint8Array(u.buffer,d,g-d);if(o.set(y,f),a+=y.length,n<u.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(s){return e<s.start?-1:e>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=Jse(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Jse(t,e){let n=0,r=t.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,i=e(t[s]);if(i===0)return s;i<0?r=s:n=s+1}return-1}function Zz(){De().set("PROD",!0)}function eV(){De().set("DEBUG",!0)}function tV(){De().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function nV(t){De().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function rV(){we.disposeVariables()}function Ya(){return we}function Pb(){return we.memory()}function sV(t){return we.profile(t)}function ke(t,e){return we.tidy(t,e)}function en(t){ac(t).forEach(n=>n.dispose())}function Ts(t){return we.keep(t)}function iV(t){return we.time(t)}function oV(t){return we.setBackend(t)}function aV(){return we.ready()}function bE(){return we.backendName}function lV(t){we.removeBackend(t)}function uV(t){return we.findBackend(t)}function cV(t){return we.findBackendFactory(t)}function Fx(t,e,n=1){return we.registerBackend(t,e,n)}function Lx(){return we.backend}function hV(t,e){De().setPlatform(t,e)}const kh=4;async function y$(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(t)?t[o].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async d=>{const f=await l.bytes(),m=f.reduce((v,b)=>v+b.length,0)+kh*f.length,g=new Uint8Array(m);let y=0;for(let v=0;v<f.length;v++){const b=f[v],x=new Uint8Array(new Uint32Array([b.length]).buffer);g.set(x,y),y+=kh,g.set(b,y),y+=b.length}d(g)});r.push(c)}else r.push(l.data());e!=null&&(u.group=e),n.push(u)}const i=await Promise.all(r);return{data:tie(i),specs:n}}function xE(t,e){const n=new jl(t),r={};let s=0;for(const i of e){const o=Zse(i,(a,l)=>n.slice(s+a,s+l));r[i.name]=dV(i,n.slice(s,s+o)),s+=o}return r}function Zse(t,e){const n=Ue(t.shape);let r;if("quantization"in t){const s=t.quantization;r=qd[s.dtype]}else if(t.dtype==="string"){let s=0;for(let i=0;i<n;i++)s+=kh+new Uint32Array(e(s,s+kh))[0];return s}else r=qd[t.dtype];return n*r}async function eie(t,e){const n=Ue(t.shape);let r;if("quantization"in t){const s=t.quantization;r=qd[s.dtype]}else if(t.dtype==="string"){let s=0;for(let i=0;i<n;i++)s+=kh+new Uint32Array(await e(s,s+kh))[0];return s}else r=qd[t.dtype];return n*r}function dV(t,e){const n=t.name,r=t.dtype,s=t.shape,i=Ue(s);let o,a=0;if("quantization"in t){const l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=qd[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){o=new Float32Array(c.length);for(let d=0;d<c.length;d++){const f=c[d];o[d]=f*l.scale+l.min}}else if(l.dtype==="float16")o=aie()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);o=new Int32Array(c.length);for(let d=0;d<c.length;d++){const f=c[d];o[d]=Math.round(f*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=i*u}else if(r==="string"){const l=Ue(t.shape);o=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(a,a+kh))[0];a+=kh;const d=new Uint8Array(e.slice(a,a+c));o.push(d),a+=c}}else{const l=qd[r];if(r==="float32")o=new Float32Array(e);else if(r==="int32")o=new Int32Array(e);else if(r==="bool")o=new Uint8Array(e);else if(r==="complex64"){o=new Float32Array(e);const u=new Float32Array(o.length/2),c=new Float32Array(o.length/2);for(let g=0;g<u.length;g++)u[g]=o[g*2],c[g]=o[g*2+1];const d=Eo(u,s,"float32"),f=Eo(c,s,"float32"),m=Iu(d,f);return d.dispose(),f.dispose(),m}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=i*l}return Eo(o,s,r)}async function fO(t,e,n){let r=new Uint8Array(e);for(;r.byteLength<n;){const{done:s,value:i}=await t.read();if(s&&i==null){const a=n-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const o=new Uint8Array(r.length+i.byteLength);o.set(r,0),o.set(new Uint8Array(i),r.length),r=o}return r.buffer}async function fV(t,e){const n={},r=t.getReader();let s=new ArrayBuffer(0);for(const i of e){const o=await eie(i,async(u,c)=>(s=await fO(r,s,c),s.slice(u,c)));s=await fO(r,s,o);const a=s.slice(0,o);s=s.slice(o);const l=dV(i,a);if(n[i.name]=l,bE()==="webgpu"){const u=Lx();"uploadToGPU"in u&&Ue(l.shape)>=De().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function tie(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(i=>{if(e+=i.byteLength,n.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const _E=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function pO(t){return _E?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function nie(t){if(_E)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function rie(t){if(_E){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function pV(t){return jl.join(t)}function mO(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const n=t.split("/");return n[n.length-1]}function mV(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function IE(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}async function TE(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),IE(t,n,r)}function hw(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:pO(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:pO(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new jl(t.weightData).byteLength}}function Fb(t){const e=[];for(const n of t)e.push(...n.weights);return e}function sie(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function iie(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function oie(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function aie(){const t=sie(),e=iie(),n=oie();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o],l=t[n[a>>10]+(a&1023)]+e[a>>10];i[o]=l}return new Float32Array(s)}}class Qr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Qr.instance==null&&(Qr.instance=new Qr),Qr.instance}static registerSaveRouter(e){Qr.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Qr.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Qr.getHandlers(e,"save")}static getLoadHandlers(e,n){return Qr.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?Qr.getInstance().loadRouters:Qr.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&s.push(a)}),s}}const lie=t=>Qr.registerSaveRouter(t),uie=t=>Qr.registerLoadRouter(t),gV=t=>Qr.getSaveHandlers(t),yV=(t,e)=>Qr.getLoadHandlers(t,e);const w$="tensorflowjs",v$=1,Nd="models_store",ih="model_info_store";function wV(){if(!De().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function b$(t){const e=t.result;e.createObjectStore(Nd,{keyPath:"modelPath"}),e.createObjectStore(ih,{keyPath:"modelPath"})}class Kd{constructor(e){if(this.indexedDB=wV(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const i=this.indexedDB.open(w$,v$);i.onupgradeneeded=()=>b$(i),i.onsuccess=()=>{const o=i.result;if(n==null){const a=o.transaction(Nd,"readonly"),u=a.objectStore(Nd).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=c=>(o.close(),s(u.error)),a.oncomplete=()=>o.close()}else{n.weightData=jl.join(n.weightData);const a=hw(n),l=o.transaction(ih,"readwrite");let u=l.objectStore(ih),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(f){return s(f)}let d;c.onsuccess=()=>{d=o.transaction(Nd,"readwrite");const f=d.objectStore(Nd);let m;try{m=f.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a})}catch(g){return s(g)}m.onsuccess=()=>r({modelArtifactsInfo:a}),m.onerror=g=>{u=l.objectStore(ih);const y=u.delete(this.modelPath);y.onsuccess=()=>(o.close(),s(m.error)),y.onerror=v=>(o.close(),s(m.error))}},c.onerror=f=>(o.close(),s(c.error)),l.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},i.onerror=o=>s(i.error)})}}Kd.URL_SCHEME="indexeddb://";const vV=t=>De().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Kd.URL_SCHEME)?cie(t.slice(Kd.URL_SCHEME.length)):null;Qr.registerSaveRouter(vV);Qr.registerLoadRouter(vV);function cie(t){return new Kd(t)}function hie(t){return t.startsWith(Kd.URL_SCHEME)?t.slice(Kd.URL_SCHEME.length):t}class die{constructor(){this.indexedDB=wV()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(w$,v$);r.onupgradeneeded=()=>b$(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(ih,"readonly"),a=i.objectStore(ih).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),n(a.error)),i.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=hie(e),new Promise((n,r)=>{const s=this.indexedDB.open(w$,v$);s.onupgradeneeded=()=>b$(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(ih,"readwrite"),a=o.objectStore(ih),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),d=()=>{u=i.transaction(Nd,"readwrite");const m=u.objectStore(Nd).delete(e);m.onsuccess=()=>n(l.result.modelArtifactsInfo),m.onerror=g=>r(l.error)};c.onsuccess=d,c.onerror=f=>(d(),i.close(),r(l.error))}},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>{u==null?i.close():u.oncomplete=()=>i.close()}},s.onerror=i=>r(s.error)})}}const qu="/",gm="tensorflowjs_models",bV="info",fie="model_topology",pie="weight_specs",mie="weight_data",gie="model_metadata";function xV(t){return{info:[gm,t,bV].join(qu),topology:[gm,t,fie].join(qu),weightSpecs:[gm,t,pie].join(qu),weightData:[gm,t,mie].join(qu),modelMetadata:[gm,t,gie].join(qu)}}function _V(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function yie(t){const e=t.split(qu);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(qu)}function wie(t){return t.startsWith(Xd.URL_SCHEME)?t.slice(Xd.URL_SCHEME.length):t}class Xd{constructor(e){if(!De().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=xV(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=hw(e),i=jl.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,nie(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw _V(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=rie(o),n}}Xd.URL_SCHEME="localstorage://";const IV=t=>De().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Xd.URL_SCHEME)?vie(t.slice(Xd.URL_SCHEME.length)):null;Qr.registerSaveRouter(IV);Qr.registerLoadRouter(IV);function vie(t){return new Xd(t)}class bie{constructor(){J(De().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),J(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=gm+qu,r=qu+bV;for(let s=0;s<this.LS.length;++s){const i=this.LS.key(s);if(i.startsWith(n)&&i.endsWith(r)){const o=yie(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=wie(e);const n=xV(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return _V(n),r}}const Tm="://";class lo{constructor(){this.managers={}}static getInstance(){return lo.instance==null&&(lo.instance=new lo),lo.instance}static registerManager(e,n){J(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Tm)&&(e=e.slice(0,e.indexOf(Tm))),J(e.length>0,()=>"scheme must not be an empty string.");const r=lo.getInstance();J(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=lo.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(lo.getInstance().managers)}}function qv(t){if(t.indexOf(Tm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${lo.getSchemes().join(",")}`);return{scheme:t.split(Tm)[0],path:t.split(Tm)[1]}}async function TV(t,e,n=!1){J(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=Qr.getLoadHandlers(t);J(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),J(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],i=Qr.getSaveHandlers(e);J(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),J(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=i[0],a=qv(t).scheme,l=qv(t).path,u=a===qv(t).scheme,c=await s.load();n&&u&&await lo.getManager(a).removeModel(l);const d=await o.save(c);return n&&!u&&await lo.getManager(a).removeModel(l),d.modelArtifactsInfo}async function xie(){const t=lo.getSchemes(),e={};for(const n of t){const r=await lo.getManager(n).listModels();for(const s in r){const i=n+Tm+s;e[i]=r[s]}}return e}async function _ie(t){const e=qv(t);return lo.getManager(e.scheme).removeModel(e.path)}async function Iie(t,e){return TV(t,e,!1)}async function Tie(t,e){return TV(t,e,!0)}class Sie{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!De().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Fz(e)}}if(De().get("IS_BROWSER")){De().setPlatform("browser",new Sie);try{lo.registerManager(Xd.URL_SCHEME,new bie)}catch{}try{lo.registerManager(Kd.URL_SCHEME,new die)}catch{}}const $ie={importFetch:()=>require("node-fetch")};let yT;class Cie{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return De().global.fetch!=null?De().global.fetch(e,n):(yT==null&&(yT=$ie.importFetch()),yT(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}De().get("IS_NODE")&&!De().get("IS_BROWSER")&&De().setPlatform("node",new Cie);function En(t,e="float32",n){return e=e||"float32",la(t),new ms(t,e,n)}function Eie(t,e){const n=ee(t,"x","cast");if(!_z(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return we.runKernel(Rf,r,s)}const gt=ve({cast_:Eie});function kie(t){const n={x:ee(t,"x","clone","string_or_numeric")};return we.runKernel(Gf,n)}const Rl=ve({clone_:kie});function Mx(t,e=!1){console.log(t.toString(e))}Yz();const Nie={buffer:En,cast:gt,clone:Rl,print:Mx};jse(Nie);function Aie(t,e){let n=ee(t,"a","add"),r=ee(e,"b","add");[n,r]=ts(n,r);const s={a:n,b:r};return we.runKernel(Uh,s)}const tt=ve({add_:Aie});function Rie(t,e){let n=ee(t,"a","floorDiv"),r=ee(e,"b","floorDiv");[n,r]=ts(n,r);const s={a:n,b:r};return we.runKernel(Wf,s)}const dw=ve({floorDiv_:Rie});function Die(t,e){let n=ee(t,"a","div"),r=ee(e,"b","div");if([n,r]=ts(n,r),n.dtype==="int32"&&r.dtype==="int32")return dw(n,r);const s={a:n,b:r},i={};return we.runKernel(Lf,s,i)}const St=ve({div_:Die});function Oie(t,e){let n=ee(t,"a","mul"),r=ee(e,"b","mul");[n,r]=ts(n,r);const s={a:n,b:r};return we.runKernel(ep,s)}const be=ve({mul_:Oie});function Pie(t){const e=ee(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return we.runKernel(mg,n)}else{const n={x:e};return we.runKernel(og,n)}}const fs=ve({abs_:Pie});function Fie(t){const n={x:ee(t,"x","acos")};return we.runKernel(Sf,n)}const zx=ve({acos_:Fie});function Lie(t){const n={x:ee(t,"x","acosh")};return we.runKernel($f,n)}const Vx=ve({acosh_:Lie});function Mie(t){J(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),J(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,i)=>ee(s,`tensors${i}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!zn(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return we.runKernel(ag,r)}const SE=ve({addN_:Mie});function zie(t,e=null,n=!1){const s={x:ee(t,"x","all","bool")},i={axis:e,keepDims:n};return we.runKernel(r0,s,i)}const fw=ve({all_:zie});function Vie(t,e=null,n=!1){const s={x:ee(t,"x","any","bool")},i={axis:e,keepDims:n};return we.runKernel(s0,s,i)}const Um=ve({any_:Vie});function Bie(t,e=0){const r={x:ee(t,"x","argMax")},s={axis:e};return we.runKernel(lg,r,s)}const Nh=ve({argMax_:Bie});function Uie(t,e=0){const r={x:ee(t,"x","argMin")},s={axis:e};return we.runKernel(ug,r,s)}const Bx=ve({argMin_:Uie});function Wie(t){const n={x:ee(t,"x","asin")};return we.runKernel(Cf,n)}const Ux=ve({asin_:Wie});function jie(t){const n={x:ee(t,"x","asinh")};return we.runKernel(Ef,n)}const Wx=ve({asinh_:jie});function Gie(t){const n={x:ee(t,"x","atan")};return we.runKernel(kf,n)}const jx=ve({atan_:Gie});function Hie(t,e){let n=ee(t,"a","atan2"),r=ee(e,"b","atan2");[n,r]=ts(n,r);const s={a:n,b:r};return we.runKernel(Af,s)}const Gx=ve({atan2_:Hie});function qie(t){const n={x:ee(t,"x","atanh")};return we.runKernel(Nf,n)}const Hx=ve({atanh_:qie});function pw(t,e,n,r,s="NHWC",i){const o=t[3],a=[...e,o],l=vc(s);return ai(t,a,n,i,r,null,null,l)}function il(t,e,n,r,s,i,o="channelsLast"){const[a,l]=Ay(e);let u;if(o==="channelsLast")u=[a,l,t[3],t[3]];else if(o==="channelsFirst")u=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return ai(t,u,n,r,s,i,!1,o)}function wc(t,e,n,r,s,i,o="NDHWC"){const[a,l,u]=x$(e);let c,d;if(o==="NDHWC")d="channelsLast",c=[a,l,u,t[4],t[4]];else if(o==="NCDHW")d="channelsFirst",c=[a,l,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return Gh(t,c,n,r,s,!1,d,i)}function ai(t,e,n,r,s,i,o=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,d]=t;else if(a==="channelsFirst")[l,d,u,c]=t;else throw new Error(`Unknown dataFormat ${a}`);const[f,m,,g]=e,[y,v]=Ay(n),[b,x]=Ay(r),$=Sm(f,b),S=Sm(m,x),{padInfo:E,outHeight:L,outWidth:R}=Yie(s,u,c,y,v,$,S,i,a),D=o?g*d:g;let A;return a==="channelsFirst"?A=[l,D,L,R]:a==="channelsLast"&&(A=[l,L,R,D]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:L,outWidth:R,outChannels:D,padInfo:E,strideHeight:y,strideWidth:v,filterHeight:f,filterWidth:m,effectiveFilterHeight:$,effectiveFilterWidth:S,dilationHeight:b,dilationWidth:x,inShape:t,outShape:A,filterShape:e}}function Gh(t,e,n,r,s,i=!1,o="channelsLast",a){let[l,u,c,d,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d,f]=t;else if(o==="channelsFirst")[l,f,u,c,d]=t;else throw new Error(`Unknown dataFormat ${o}`);const[m,g,y,,v]=e,[b,x,$]=x$(n),[S,E,L]=x$(r),R=Sm(m,S),D=Sm(g,E),A=Sm(y,L),{padInfo:F,outDepth:P,outHeight:K,outWidth:j}=Qie(s,u,c,d,b,x,$,R,D,A,a),se=i?v*f:v;let fe;return o==="channelsFirst"?fe=[l,se,P,K,j]:o==="channelsLast"&&(fe=[l,P,K,j,se]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:d,inChannels:f,outDepth:P,outHeight:K,outWidth:j,outChannels:se,padInfo:F,strideDepth:b,strideHeight:x,strideWidth:$,filterDepth:m,filterHeight:g,filterWidth:y,effectiveFilterDepth:R,effectiveFilterHeight:D,effectiveFilterWidth:A,dilationDepth:S,dilationHeight:E,dilationWidth:L,inShape:t,outShape:fe,filterShape:e}}function Kie(t,e,n,r,s){r==null&&(r=$E(t,e,n));const i=t[0],o=t[1],a=Ry((i-e+2*r)/n+1,s),l=Ry((o-e+2*r)/n+1,s);return[a,l]}function Xie(t,e,n,r,s,i){s==null&&(s=$E(t,e[0],r[0]));const o=[0,0,0,n];for(let a=0;a<3;a++)t[a]+2*s>=e[a]&&(o[a]=Ry((t[a]-e[a]+2*s)/r[a]+1,i));return o}function $E(t,e,n,r=1){const s=Sm(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function Ay(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function x$(t){return typeof t=="number"?[t,t,t]:t}function Sm(t,e){return e<=1?t:t+(t-1)*(e-1)}function Yie(t,e,n,r,s,i,o,a,l){let u,c,d;if(typeof t=="number"){u={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const m=Kie([e,n],i,r,t,a);c=m[0],d=m[1]}else if(t==="same"){c=Math.ceil(e/r),d=Math.ceil(n/s);const f=Math.max(0,(c-1)*r+i-e),m=Math.max(0,(d-1)*s+o-n),g=Math.floor(f/2),y=f-g,v=Math.floor(m/2),b=m-v;u={top:g,bottom:y,left:v,right:b,type:"SAME"}}else if(t==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/r),d=Math.ceil((n-o+1)/s);else if(typeof t=="object"){const f=l==="channelsLast"?t[1][0]:t[2][0],m=l==="channelsLast"?t[1][1]:t[2][1],g=l==="channelsLast"?t[2][0]:t[3][0],y=l==="channelsLast"?t[2][1]:t[3][1];u={top:f,bottom:m,left:g,right:y,type:f===0&&m===0&&g===0&&y===0?"VALID":"EXPLICIT"},c=Ry((e-i+f+m)/r+1,a),d=Ry((n-o+g+y)/s+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:u,outHeight:c,outWidth:d}}function Qie(t,e,n,r,s,i,o,a,l,u,c){let d,f,m,g;if(t==="valid"&&(t=0),typeof t=="number"){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const v=Xie([e,n,r,1],[a,l,u],1,[s,i,o],t,c);f=v[0],m=v[1],g=v[2]}else if(t==="same"){f=Math.ceil(e/s),m=Math.ceil(n/i),g=Math.ceil(r/o);const y=(f-1)*s+a-e,v=(m-1)*i+l-n,b=(g-1)*o+u-r,x=Math.floor(y/2),$=y-x,S=Math.floor(v/2),E=v-S,L=Math.floor(b/2),R=b-L;d={top:S,bottom:E,left:L,right:R,front:x,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outDepth:f,outHeight:m,outWidth:g}}function Ry(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ah(t){const[e,n,r]=Ay(t);return e===1&&n===1&&r===1}function Ai(t,e){return Ah(t)||Ah(e)}function Yd(t){return Ay(t).every(e=>e>0)}function vc(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function wo(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")J(Hd(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{J(Hd(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}function Jie(t,e){const r={x:ee(t,"x","reshape","string_or_numeric")},s={shape:e};return we.runKernel(Xg,r,s)}const Ie=ve({reshape_:Jie});function Zie(t,e,n,r,s){const i=ee(t,"x","avgPool","float32"),o=1;J(Ai(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=Ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),wo("avgPool",r,s);const u={x:a},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let d=we.runKernel(cg,u,c);return d=gt(d,i.dtype),l?Ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const u1=ve({avgPool_:Zie});function eoe(t,e,n,r,s,i="NDHWC"){const o=ee(t,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=Ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),J(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),J(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),wo("avgPool3d",r,s);const u={x:a},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i};let d=we.runKernel(hg,u,c);return d=gt(d,a.dtype),l?Ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const qx=ve({avgPool3d_:eoe});function toe(t,e=0){J(t.length>=1,()=>"Pass at least one tensor to concat");const n=Ny(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),n.length===1)return Rl(n[0]);const r=n,s={axis:e};return we.runKernel(gg,r,s)}const Gr=ve({concat_:toe});function noe(t,e,n=!1,r=!1){let s=ee(t,"a","matMul"),i=ee(e,"b","matMul");[s,i]=ts(s,i);const o={a:s,b:i},a={transposeA:n,transposeB:r};return we.runKernel(dg,o,a)}const An=ve({matMul_:noe});function roe(t){const n={x:ee(t,"x","sigmoid","float32")};return we.runKernel(hp,n)}const Ca=ve({sigmoid_:roe});function soe(t,e,n){const r=ee(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},i={begin:e,size:n};return we.runKernel(e1,s,i)}const cn=ve({slice_:soe});function ioe(t){const n={x:ee(t,"x","tanh","float32")};return we.runKernel(yp,n)}const lc=ve({tanh_:ioe});function ooe(t,e,n,r,s,i){const o=ee(t,"forgetBias","basicLSTMCell"),a=ee(e,"lstmKernel","basicLSTMCell"),l=ee(n,"lstmBias","basicLSTMCell"),u=ee(r,"data","basicLSTMCell"),c=ee(s,"c","basicLSTMCell"),d=ee(i,"h","basicLSTMCell"),f=Gr([u,d],1),m=An(f,a),g=tt(m,l),y=g.shape[0],v=g.shape[1]/4,b=[y,v],x=cn(g,[0,0],b),$=cn(g,[0,v],b),S=cn(g,[0,v*2],b),E=cn(g,[0,v*3],b),L=tt(be(Ca(x),lc($)),be(c,Ca(tt(o,S)))),R=be(lc(L),Ca(E));return[L,R]}const CE=ve({basicLSTMCell_:ooe});function aoe(t,e,n){const r=ee(t,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);J(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),J(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),J(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const i={x:r},o={blockShape:e,crops:n};return we.runKernel(fg,i,o)}const c1=ve({batchToSpaceND_:aoe});function loe(t){let e;return t.rank===0||t.rank===1?e=Ie(t,[1,1,1,t.size]):t.rank===2?e=Ie(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=Ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}function uoe(t,e,n,r,s,i){i==null&&(i=.001);const o=ee(t,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(n,"variance","batchNorm");let u;s!=null&&(u=ee(s,"scale","batchNorm"));let c;r!=null&&(c=ee(r,"offset","batchNorm")),J(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:loe(o),scale:u,offset:c,mean:a,variance:l},m={varianceEpsilon:i},g=we.runKernel(Sg,f,m);return Ie(g,o.shape)}const bp=ve({batchNorm_:uoe});function coe(t,e,n,r,s,i){const o=ee(t,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(n,"variance","batchNorm");let u;s!=null&&(u=ee(s,"scale","batchNorm"));let c;return r!=null&&(c=ee(r,"offset","batchNorm")),J(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),J(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),J(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),bp(o,a,l,c,u,i)}const Kx=ve({batchNorm2d_:coe});function hoe(t,e,n,r,s,i){const o=ee(t,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(n,"variance","batchNorm");let u;s!=null&&(u=ee(s,"scale","batchNorm"));let c;return r!=null&&(c=ee(r,"offset","batchNorm")),J(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),J(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),J(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),bp(o,a,l,c,u,i)}const Xx=ve({batchNorm3d_:hoe});function doe(t,e,n,r,s,i){const o=ee(t,"x","batchNorm"),a=ee(e,"mean","batchNorm"),l=ee(n,"variance","batchNorm");let u;s!=null&&(u=ee(s,"scale","batchNorm"));let c;return r!=null&&(c=ee(r,"offset","batchNorm")),J(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),J(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),J(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),bp(o,a,l,c,u,i)}const Yx=ve({batchNorm4d_:doe});function foe(t,e,n){const r=ee(t,"x","bincount"),s=ee(e,"weights","bincount");J(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),J(n>=0,()=>`size must be non-negative, but got ${n}.`),J(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const i={x:r,weights:s},o={size:n};return we.runKernel(a0,i,o)}const Qx=ve({bincount_:foe});function poe(t,e){const n=ee(t,"x","bitwiseAnd"),r=ee(e,"y","bitwiseAnd");if(!zn(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return we.runKernel(pg,s)}const EE=ve({bitwiseAnd_:poe});function moe(t,e){const n=ee(t,"s0","broadcastArgs","int32"),r=ee(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return we.runKernel(l0,s)}const kE=ve({broadcastArgs_:moe});function goe(t,e){let n=ee(t,"broadcastTo","x");const r=n.shape;if(la(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const u=n.shape.slice();for(;u.length<e.length;)u.unshift(1);n=Ie(n,u)}const s=n.shape,i=Array.from(e);for(let u=e.length-1;u>=0;u--)if(s[u]===e[u])i[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(i.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Rl(n);const a={x:n},l={reps:i};return we.runKernel(wp,a,l)}const gh=ve({broadcastTo_:goe});function yoe(t){const n={x:ee(t,"x","ceil","float32")};return we.runKernel(Df,n)}const Jx=ve({ceil_:yoe});function Hh(t,e,n){la(t),n=n||If(e);const r={shape:t,value:e,dtype:n};return we.runKernel(T0,{},r)}function woe(t,e,n){const r=ee(t,"x","clipByValue");if(J(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return Hh(r.shape,e,r.dtype);const s={x:r},i={clipValueMin:e,clipValueMax:n};return we.runKernel(Of,s,i)}const Hi=ve({clipByValue_:woe});function voe(t){return Gr(t,0)}const Zx=ve({concat1d_:voe});function boe(t,e){return Gr(t,e)}const e_=ve({concat2d_:boe});function xoe(t,e){return Gr(t,e)}const t_=ve({concat3d_:xoe});function _oe(t,e){return Gr(t,e)}const n_=ve({concat4d_:_oe});function Ioe(t,e,n,r,s="NHWC",i=[1,1],o){const a=ee(t,"x","conv2d","float32"),l=ee(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=Ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),J(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),wo("conv2d",r,o);const d=s==="NHWC"?u.shape[3]:u.shape[1];J(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),J(Ai(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),J(Yd(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),J(Yd(n),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:u,filter:l},m={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},g=we.runKernel(yg,f,m);return c?Ie(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Tu=ve({conv2d_:Ioe});function Toe(t,e,n,r,s="NWC",i=1,o){const a=ee(t,"x","conv1d"),l=ee(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=Ie(a,[1,a.shape[0],a.shape[1]])),J(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),J(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),wo("conv1d",r,o),J(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),J(Ai(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),J(Yd(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),J(Yd(n),()=>"Error in conv1D: Stride should be larger than 0."),J(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=Ie(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=Ie(u,[u.shape[0],1,u.shape[1],u.shape[2]]),v=Tu(f,d,[1,n],r,"NHWC",[1,i],o);return c?Ie(v,[v.shape[2],v.shape[3]]):Ie(v,[v.shape[0],v.shape[2],v.shape[3]])}const mw=ve({conv1d_:Toe});function Soe(t,e,n,r,s,i="NHWC",o){J(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,u=!1;e.rank===3&&(u=!0,l=Ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),J(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),J(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),J(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=i==="NHWC"?a[3]:a[1],d=i==="NHWC"?l.shape[3]:l.shape[1];J(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),J(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),wo("conv2dDerInput",s,o);const f={dy:l,filter:n},m={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a},g=we.runKernel(wg,f,m);return u?Ie(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const NE=ve({conv2DBackpropInput_:Soe});function $oe(t,e,n,r,s,i){const o=ee(t,"x","conv2dTranspose"),a=ee(e,"filter","conv2dTranspose");return NE(n,o,a,r,s,"NHWC",i)}const gw=ve({conv2dTranspose_:$oe});function Coe(t,e,n,r,s="NDHWC",i=[1,1,1]){const o=ee(t,"x","conv3d"),a=ee(e,"filter","conv3d");let l=o,u=!1;o.rank===4&&(u=!0,l=Ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),J(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),J(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),J(Ai(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),J(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),J(Yd(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),J(Yd(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},d={strides:n,pad:r,dataFormat:s,dilations:i},f=we.runKernel(vg,c,d);return u?Ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const r_=ve({conv3d_:Coe});function Eoe(t,e,n,r,s){J(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,o=e,a=!1;e.rank===4&&(a=!0,o=Ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=o.shape[4];J(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),J(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),J(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),J(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),J(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:o,filter:n},d={pad:s,strides:r,inputShape:i},f=we.runKernel(d0,c,d);return a?Ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const SV=ve({conv3DBackpropInput_:Eoe});function koe(t,e,n,r,s){const i=ee(t,"x","conv3dTranspose"),o=ee(e,"filter","conv3dTranspose");return SV(n,i,o,r,s)}const s_=ve({conv3dTranspose_:koe});function Noe(t){const n={x:ee(t,"x","cos","float32")};return we.runKernel(Pf,n)}const h1=ve({cos_:Noe});function Aoe(t){const n={x:ee(t,"x","cosh","float32")};return we.runKernel(Ff,n)}const yw=ve({cosh_:Aoe});function Roe(t,e=0,n=!1,r=!1){const i={x:ee(t,"x","cumprod")},o={axis:e,exclusive:n,reverse:r};return we.runKernel(f0,i,o)}const Wm=ve({cumprod_:Roe});function Doe(t,e=0,n=!1,r=!1){const i={x:ee(t,"x","cumsum")},o={axis:e,exclusive:n,reverse:r};return we.runKernel(bg,i,o)}const ww=ve({cumsum_:Doe});function Ooe(t,e,n,r=!1){const s=ee(t,"x","denseBincount"),i=ee(e,"weights","denseBincount");J(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),J(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),J(n>=0,()=>`size must be non-negative, but got ${n}.`),J(i.size===s.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`);const o={x:s,weights:i},a={size:n,binaryOutput:r};return we.runKernel(m0,o,a)}const Dy=ve({denseBincount_:Ooe});function Poe(t,e,n="NHWC"){const r=ee(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],i=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];J(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),J(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),J(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${r.shape}`),J(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:n};return we.runKernel(g0,a,l)}const i_=ve({depthToSpace_:Poe});function Foe(t,e,n,r,s="NHWC",i=[1,1],o){const a=ee(t,"x","depthwiseConv2d","float32"),l=ee(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=Ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),J(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=s==="NHWC"?u.shape[3]:u.shape[1];J(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),wo("depthwiseConv2d",r,o);const f={x:u,filter:l},m={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},g=we.runKernel(xg,f,m);return c?Ie(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const xp=ve({depthwiseConv2d_:Foe});function Loe(t){const n={x:ee(t,"x","diag")};return we.runKernel(v0,n)}const AE=ve({diag_:Loe});function Moe(t,e,n,r,s=[1,1],i="NHWC"){const o=ee(t,"x","dilation2d"),a=ee(e,"filter","dilation2d");J(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),J(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),J(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,u=!1;o.rank===3&&(l=Ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),J(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},d={strides:n,pad:r,dilations:s},f=we.runKernel(_g,c,d);return u?Ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const o_=ve({dilation2d_:Moe});function Qd(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const i=n-1-s,o=t[i]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(i)}return r}function $s(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],i=e.length-r-1,o=e[i];(s==null||s===1&&o>1)&&n.unshift(i)}return n}function _n(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let s=0;s<n;s++){let i=t[t.length-s-1];i==null&&(i=1);let o=e[e.length-s-1];if(o==null&&(o=1),i===1)r[n-s-1]=o;else if(o===1)r[n-s-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else r[n-s-1]=i}return r}const $V=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:_n,getBroadcastDims:Qd,getReductionAxes:$s},Symbol.toStringTag,{value:"Module"}));function zoe(t,e){let n=ee(t,"a","equal","string_or_numeric"),r=ee(e,"b","equal","string_or_numeric");[n,r]=ts(n,r),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Ig,s)}const No=ve({equal_:zoe});function Voe(t,e,n){const r=ee(e,"a","where"),s=ee(n,"b","where"),i=ee(t,"condition","where","bool"),o=_n(_n(i.shape,r.shape),s.shape),a=gh(i,o),l=gh(r,o),u=gh(s,o),c={condition:a,t:l,e:u};return we.runKernel(Zg,c)}const Bs=ve({where_:Voe});function Boe(t){const n={x:ee(t,"x","zerosLike")};return we.runKernel(l1,n)}const jn=ve({zerosLike_:Boe});function Uoe(t,e){let n=ee(t,"a","div"),r=ee(e,"b","div");[n,r]=ts(n,r);const s=St(n,r),i=jn(s),o=No(r,i);return Bs(o,i,s)}const a_=ve({divNoNan_:Uoe});function Woe(t,e){const n=ee(t,"t1","dot"),r=ee(e,"t2","dot");J((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],i=r.rank===1?r.size:r.shape[0];if(J(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),n.rank===1&&r.rank===1){const o=Ie(n,[1,-1]),a=Ie(r,[-1,1]),l=An(o,a);return Ie(l,[])}else if(n.rank===1&&r.rank===2){const o=Ie(n,[1,-1]),a=Ie(r,[r.shape[0],r.shape[1]]),l=An(o,a);return Ie(l,[l.size])}else if(n.rank===2&&r.rank===1){const o=Ie(r,[-1,1]),a=An(n,o);return Ie(a,[a.size])}else{const o=Ie(r,[r.shape[0],r.shape[1]]);return An(n,o)}}const l_=ve({dot_:Woe});function joe(t,...e){const n=e.map((s,i)=>ee(s,`tensors${i}`,"einsum")),r={equation:t};return we.runKernel(x0,n,r)}const rh=ve({einsum_:joe});function Goe(t){const n={x:ee(t,"x","elu","float32")};return we.runKernel(Mf,n)}const _p=ve({elu_:Goe});function Hoe(t,e){const n=ee(t,"x","ensureShape","string_or_numeric");if(!bz(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const RE=ve({ensureShape_:Hoe});function qoe(t){let e=ee(t,"x","erf");J(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=gt(e,"float32"));const n={x:e};return we.runKernel(zf,n)}const vw=ve({erf_:qoe});function DE(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function CV(t,e,n){const r=t.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)n.indexOf(a)===-1?s.push(t[i++]):s.push(e[o++]);return s}function li(t,e){const n=[],r=t.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&n.push(t[i]);const s=e.map(i=>t[i]);return[n,s]}function gs(t,e){const n=e.map(r=>1);return CV(t,n,e)}function Ri(t,e,n){J(DE(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function ns(t,e){if(DE(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function qh(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function ys(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function Koe(t,e=null,n=!1){const s={x:ee(t,"x","max")},i={reductionIndices:e,keepDims:n};return we.runKernel(Pg,s,i)}const ra=ve({max_:Koe});function Xoe(t,e=null,n=!1){const s={x:ee(t,"x","min")},i={axis:e,keepDims:n};return we.runKernel(zg,s,i)}const Jd=ve({min_:Xoe});function Yoe(t,e){let n=ee(t,"base","pow"),r=ee(e,"exp","pow");[n,r]=ts(n,r);const s={a:n,b:r};return we.runKernel(tp,s)}const Ll=ve({pow_:Yoe});function Xt(t,e){if((Ms(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ms(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return jh(t,[],[],e)}function Qoe(t){const n={x:ee(t,"x","sqrt","float32")};return we.runKernel(fp,n)}const js=ve({sqrt_:Qoe});function Joe(t){const e=ee(t,"x","square"),n={};return we.runKernel("Square",{x:e},n)}const wr=ve({square_:Joe});function Zoe(t,e=null,n=!1){let r=ee(t,"x","sum");r.dtype==="bool"&&(r=gt(r,"int32"));const s={x:r},i={axis:e,keepDims:n};return we.runKernel(t1,s,i)}const Ot=ve({sum_:Zoe});function eae(t,e="euclidean",n=null,r=!1){t=ee(t,"x","norm");const s=EV(t,e,n);let i=s.shape;if(r){const o=On(n,t.shape);i=gs(s.shape,o)}return Ie(s,i)}function EV(t,e,n=null){if(t.rank===0)return fs(t);if(t.rank!==1&&n===null)return EV(Ie(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Ot(fs(t),n);if(e===1/0)return ra(fs(t),n);if(e===-1/0)return Jd(fs(t),n);if(e==="euclidean"||e===2)return js(Ot(Ll(fs(t),Xt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return ra(Ot(fs(t),n[0]),n[1]-1);if(e===1/0)return ra(Ot(fs(t),n[1]),n[0]);if(e===-1/0)return Jd(Ot(fs(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return js(Ot(wr(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ip=ve({norm_:eae});function tae(t,e=null,n=!1){return Ip(t,"euclidean",e,n)}const u_=ve({euclideanNorm_:tae});function nae(t){const n={x:ee(t,"x","exp")};return we.runKernel(Vf,n)}const ki=ve({exp_:nae});function rae(t,e=0){const n=ee(t,"x","expandDims","string_or_numeric");J(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return we.runKernel(Tg,r,s)}const os=ve({expandDims_:rae});function sae(t){const n={x:ee(t,"x","expm1")};return we.runKernel(Bf,n)}const c_=ve({expm1_:sae});function iae(t,e){const n=ee(t,"x","tile","string_or_numeric");J(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return we.runKernel(wp,r,s)}const na=ve({tile_:iae});function oae(t,e,n,r="float32"){e==null&&(e=t);const s=En([t,e],r),i=t<=e?t:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=Ie(s.toTensor(),[t,e]);if(n==null)return o;if(n.length===1)return na(os(o,0),[n[0],1,1]);if(n.length===2)return na(os(os(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return na(os(os(os(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const bw=ve({eye_:oae});function aae(t){const n={x:ee(t,"x","floor","float32")};return we.runKernel(Uf,n)}const Tp=ve({floor_:aae});function lae(t,e,n=0,r=0){const s=ee(t,"x","gather"),i=ee(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:n,batchDims:r};return we.runKernel($g,o,a)}const Sp=ve({gather_:lae});function uae(t,e){let n=ee(t,"a","greater","string_or_numeric"),r=ee(e,"b","greater","string_or_numeric");[n,r]=ts(n,r),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Cg,s)}const Ki=ve({greater_:uae});function cae(t,e){let n=ee(t,"a","greaterEqual","string_or_numeric"),r=ee(e,"b","greaterEqual","string_or_numeric");[n,r]=ts(n,r),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(jf,s)}const $u=ve({greaterEqual_:cae});function hae(t){const n={input:ee(t,"input","imag")};return we.runKernel(E0,n)}const d1=ve({imag_:hae});function dae(t){const n={x:ee(t,"x","isFinite")};return we.runKernel(Hf,n)}const h_=ve({isFinite_:dae});function fae(t){const n={x:ee(t,"x","isInf")};return we.runKernel(qf,n)}const d_=ve({isInf_:fae});function pae(t){const n={x:ee(t,"x","isNaN")};return we.runKernel(Kf,n)}const f_=ve({isNaN_:pae});function mae(t,e=.2){const r={x:ee(t,"x","leakyRelu")},s={alpha:e};return we.runKernel(Eg,r,s)}const f1=ve({leakyRelu_:mae});function gae(t,e){let n=ee(t,"a","less","string_or_numeric"),r=ee(e,"b","less","string_or_numeric");[n,r]=ts(n,r),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(kg,s)}const Zd=ve({less_:gae});function yae(t,e){let n=ee(t,"a","lessEqual","string_or_numeric"),r=ee(e,"b","lessEqual","string_or_numeric");[n,r]=ts(n,r),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Ng,s)}const bc=ve({lessEqual_:yae});function OE(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return we.runKernel(k0,{},r)}function wae(t,e=5,n=1,r=1,s=.5){const i=ee(t,"x","localResponseNormalization");J(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),J(Hd(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=Ie(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},u={depthRadius:e,bias:n,alpha:r,beta:s},c=we.runKernel(Og,l,u);return a?Ie(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const p_=ve({localResponseNormalization_:wae});function vae(t){const n={x:ee(t,"x","log","float32")};return we.runKernel(Xf,n)}const Ao=ve({log_:vae});function bae(t){const n={x:ee(t,"x","log1p")};return we.runKernel(Yf,n)}const p1=ve({log1p_:bae});function kV(t){return J(Eh(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const r=ee(e,"x","tf.grad","string_or_numeric"),s=n!=null?ee(n,"dy","tf.grad"):null;return we.tidy(()=>{const{value:i,grads:o}=we.gradients(()=>t(r),[r],s);return s!=null&&Ni(i.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),m_(o),o[0]})}}function NV(t){return J(Eh(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{J(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Ny(e,"args","tf.grads","string_or_numeric"),s=n!=null?ee(n,"dy","tf.grads"):null;return we.tidy(()=>{const{value:i,grads:o}=we.gradients(()=>t(...r),r,s);return s!=null&&Ni(i.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),m_(o),o})}}function AV(t){return J(Eh(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{J(e instanceof Rn,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),J(n==null||n instanceof Rn,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=we.gradients(()=>t(e),[e],n);return m_(r),{grad:r[0],value:s}}}function RV(t){return J(Eh(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{J(Array.isArray(e)&&e.every(s=>s instanceof Rn),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),J(n==null||n instanceof Rn,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=we.gradients(()=>t(...e),e,n);return n!=null&&Ni(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),m_(r.grads),r}}function PE(t,e){J(Eh(t),()=>"The f passed in variableGrads(f) must be a function"),J(e==null||Array.isArray(e)&&e.every(u=>u instanceof Vm),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const u in we.registeredVariables)e.push(we.registeredVariables[u])}const r=n?e.filter(u=>!u.trainable):null,s=e.length;e=e.filter(u=>u.trainable),J(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const i=!0,{value:o,grads:a}=we.gradients(t,e,null,i);J(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),J(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:o,grads:l}}function Ml(t){return we.customGrad(t)}function m_(t){if(t.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function xae(t){const n={x:ee(t,"x","neg")};return we.runKernel(Bg,n)}const $r=ve({neg_:xae});function _ae(t){const n={x:ee(t,"x","softplus")};return we.runKernel(dp,n)}const Kh=ve({softplus_:_ae});function Iae(t){const e=ee(t,"x","logSigmoid");return Ml(r=>({value:$r(Kh($r(r))),gradFunc:o=>be(o,Ca($r(r)))}))(e)}const g_=ve({logSigmoid_:Iae});function Tae(t,e){let n=ee(t,"a","sub"),r=ee(e,"b","sub");[n,r]=ts(n,r);const s={a:n,b:r};return we.runKernel(mp,s)}const $t=ve({sub_:Tae});function Sae(t,e=-1){const n=ee(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Ml((s,i)=>{const a=ra(s,e,!0),l=$t(s,a),u=$t(gt(l,"float32"),Ao(Ot(ki(l),e,!0)));return i([u]),{value:u,gradFunc:(d,f)=>{const[m]=f,g=!0,y=ki(m);return $t(d,be(Ot(d,e,g),y))}}})(n)}const xw=ve({logSoftmax_:Sae});function $ae(t,e=null,n=!1){const r=ee(t,"x","logSumExp"),s=On(e,r.shape),i=ra(r,s,!0),o=$t(r,i),a=ki(o),l=Ot(a,s),u=Ao(l),c=tt(Ie(i,u.shape),u);if(n){const d=gs(c.shape,s);return Ie(c,d)}return c}const m1=ve({logSumExp_:$ae});function Cae(t,e){const n=ee(t,"a","logicalAnd","bool"),r=ee(e,"b","logicalAnd","bool");_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Ag,s)}const ka=ve({logicalAnd_:Cae});function Eae(t){const n={x:ee(t,"x","logicalNot","bool")};return we.runKernel(Rg,n)}const g1=ve({logicalNot_:Eae});function kae(t,e){const n=ee(t,"a","logicalOr","bool"),r=ee(e,"b","logicalOr","bool");_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Dg,s)}const _w=ve({logicalOr_:kae});function Nae(t,e){const n=ee(t,"a","logicalXor","bool"),r=ee(e,"b","logicalXor","bool");return _n(n.shape,r.shape),ka(_w(t,e),g1(ka(t,e)))}const y_=ve({logicalXor_:Nae});const lv=2147483648;function Aae(t,e,n="left"){const r=ee(t,"sortedSequence","searchSorted"),s=ee(e,"values","searchSorted"),i=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],a=Ie(r,[-1,i]),l=Ie(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ue(l.shape)>=lv)throw new Error(`values tensor size must less than ${lv}`);if(a.shape[1]>=lv)throw new Error(`trailing dim_size must less than ${lv} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:l},c={side:n};return we.runKernel(q0,u,c)}const Iw=ve({searchSorted_:Aae});function FE(t,e){return Iw(t,e,"left")}function Rae(t,e,n,r,s){const i=ee(t,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=Ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),J(Ai(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),wo("maxPool",r,s);const u={x:a},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s},d=we.runKernel(Fg,u,c);return l?Ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const y1=ve({maxPool_:Rae});function Dae(t,e=[1,1,1],n,r,s,i="NDHWC"){const o=ee(t,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=Ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),J(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),wo("maxPool3d",r,s);const u={x:a},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i},d=we.runKernel(Lg,u,c);return l?Ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const w_=ve({maxPool3d_:Dae});function Oae(t,e,n,r,s=!1){const o={x:ee(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},l=we.runKernel(D0,o,a);return{result:l[0],indexes:l[1]}}const LE=ve({maxPoolWithArgmax_:Oae});function Pae(t,e){let n=ee(t,"a","maximum"),r=ee(e,"b","maximum");[n,r]=ts(n,r),n.dtype==="bool"&&(n=gt(n,"int32"),r=gt(r,"int32")),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Qf,s)}const Gl=ve({maximum_:Pae});function Fae(t,e=null,n=!1){const s={x:ee(t,"x","mean")},i={axis:e,keepDims:n};return we.runKernel(Mg,s,i)}const Wr=ve({mean_:Fae});function ps(t,e="float32"){if(la(t),e==="complex64"){const r=ps(t,"float32"),s=ps(t,"float32");return Iu(r,s)}const n=Ei(Ue(t),e);return we.makeTensor(n,t,e)}function fo(t,e="float32"){if(la(t),e==="complex64"){const r=fo(t,"float32"),s=ps(t,"float32");return Iu(r,s)}const n=Rx(Ue(t),e);return we.makeTensor(n,t,e)}function ME(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=ee(t,"x","meshgrid",t instanceof Rn?t.dtype:"float32");if(e===void 0)return[r];let s=ee(e,"y","meshgrid",e instanceof Rn?e.dtype:"float32");const i=Ue(r.shape),o=Ue(s.shape);return n==="xy"?(r=Ie(r,[1,-1]),s=Ie(s,[-1,1]),[An(fo([o,1],r.dtype),r),An(s,fo([1,i],s.dtype))]):(r=Ie(r,[-1,1]),s=Ie(s,[1,-1]),[An(r,fo([1,o],r.dtype)),An(fo([i,1],s.dtype),s)])}function Lae(t,e){let n=ee(t,"a","minimum"),r=ee(e,"b","minimum");[n,r]=ts(n,r),n.dtype==="bool"&&(n=gt(n,"int32"),r=gt(r,"int32")),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Jf,s)}const uc=ve({minimum_:Lae});function Mae(t,e,n){J(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=ee(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");J(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let a=0;a<r.rank;a++)J(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),J(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const i={paddings:e,mode:n},o={x:r};return we.runKernel(Vg,o,i)}const v_=ve({mirrorPad_:Mae});function zae(t,e){let n=ee(t,"a","mod"),r=ee(e,"b","mod");[n,r]=ts(n,r);const s={a:n,b:r};return we.runKernel(Zf,s)}const b_=ve({mod_:zae});function Vae(t,e=null,n=!1){t=ee(t,"x","moments");const r=On(e,t.shape),s=Wr(t,r,n);let i=s.shape;n||(i=gs(s.shape,r));const o=wr($t(gt(t,"float32"),Ie(s,i))),a=Wr(o,r,n);return{mean:s,variance:a}}const w1=ve({moments_:Vae});function Bae(t,e,n,r){const s=ee(e,"data","multiRNNCell"),i=Ny(n,"c","multiRNNCell"),o=Ny(r,"h","multiRNNCell");let a=s;const l=[];for(let d=0;d<t.length;d++){const f=t[d](a,i[d],o[d]);l.push(f[0]),l.push(f[1]),a=f[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}const zE=ve({multiRNNCell_:Bae});function Uae(t,e,n,r=!1){const s=ee(t,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const l={logits:o===1?Ie(s,[1,-1]):s},u={numSamples:e,seed:n,normalized:r},c=we.runKernel(O0,l,u);return o===1?Ie(c,[c.size]):c}const VE=ve({multinomial_:Uae});function Wae(t,e){let n=ee(t,"a","notEqual","string_or_numeric"),r=ee(e,"b","notEqual","string_or_numeric");[n,r]=ts(n,r),_n(n.shape,r.shape);const s={a:n,b:r};return we.runKernel(Ug,s)}const Rh=ve({notEqual_:Wae});function jae(t,e,n=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:ee(t,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:n,offValue:r};return we.runKernel(jg,o,a)}const ef=ve({oneHot_:jae});function Gae(t){const n={x:ee(t,"x","onesLike")};return we.runKernel(Wg,n)}const Ro=ve({onesLike_:Gae});function Hae(t,e){const n=ee(t,"v1","outerProduct"),r=ee(e,"v2","outerProduct");J(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=Ie(n,[-1,1]),i=Ie(r,[1,-1]);return An(s,i)}const BE=ve({outerProduct_:Hae});function qae(t,e,n=0){const r=ee(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},i={x:r};return we.runKernel(Hg,i,s)}const Cu=ve({pad_:qae});function Kae(t,e,n=0){return J(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Cu(t,[e],n)}const UE=ve({pad1d_:Kae});function Xae(t,e,n=0){return J(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Cu(t,e,n)}const WE=ve({pad2d_:Xae});function Yae(t,e,n=0){return J(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Cu(t,e,n)}const jE=ve({pad3d_:Yae});function Qae(t,e,n=0){return J(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Cu(t,e,n)}const GE=ve({pad4d_:Qae});function Jae(t,e,n){const r=ee(t,"x","spaceToBatchND");J(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),J(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),J(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+n[l-1][0]+n[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},i={blockShape:e,paddings:n};return we.runKernel(n1,s,i)}const v1=ve({spaceToBatchND_:Jae});function Zae(t,e,n,r,s,i,o){s==null&&(s=[1,1]),i==null&&(i=1),r===0&&(r="valid");const a=ee(t,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=Ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(Ai(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const c=il(l.shape,e,i,s,r),d=[c.dilationHeight,c.dilationWidth];let f;r==="same"?f=tle([c.filterHeight,c.filterWidth],d):f=[[0,0],[0,0]];const m=d[0]===1&&d[1]===1,[g,y]=ele([c.inHeight,c.inWidth],d,f),v=m?r:"valid",b=m?l:v1(l,d,g),$=(n==="avg"?()=>u1(b,e,i,v,o):()=>y1(b,e,i,v,o))(),S=m?$:c1($,d,y);return u?Ie(S,[S.shape[1],S.shape[2],S.shape[3]]):S}function ele(t,e,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),i=t.concat(r,s),o=e.map((c,d)=>(c-i[d]%c)%c),a=s.map((c,d)=>c+o[d]),l=e.map((c,d)=>[r[d],a[d]]),u=e.map((c,d)=>[0,o[d]]);return[l,u]}function tle(t,e){const r=t.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}const x_=ve({pool_:Zae});function nle(t,e){const n=ee(t,"x","prelu"),r=ee(e,"alpha","prelu"),s={x:n,alpha:r};return we.runKernel(qg,s)}const b1=ve({prelu_:nle});function rle(t,e=null,n=!1){let r=ee(t,"x","prod");r.dtype==="bool"&&(r=gt(r,"int32"));const s={x:r},i={axis:e,keepDims:n};return we.runKernel(Kg,s,i)}const __=ve({prod_:rle});function sle(t,e,n,r){const s=t.map((c,d)=>ee(c,`tensors${d}`,"raggedGather","int32")),i=ee(e,"paramsDenseValues","raggedGather"),o=ee(n,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:i,indices:o},l={outputRaggedRank:r},u=we.runKernel(M0,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const HE=ve({raggedGather_:sle});function ile(t,e,n){const r=ee(t,"starts","raggedRange"),s=ee(e,"limits","raggedRange",r.dtype),i=ee(n,"deltas","raggedRange",r.dtype),o={starts:r,limits:s,deltas:i},a=we.runKernel(z0,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const qE=ve({raggedRange_:ile});function ole(t,e,n,r,s){const i=ee(t,"shape","raggedTensorToTensor","int32"),o=ee(e,"values","raggedTensorToTensor"),a=ee(n,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((d,f)=>ee(d,`tensors${f}`,"raggedTensorToTensor","int32")),u={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:s};return we.runKernel(V0,u,c)}const KE=ve({raggedTensorToTensor_:ole});function ale(t,e,n){la(t);const r=Ue(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let i=0;i<r;i++)s[i]=e();return we.makeTensor(s,t,n)}const XE=ve({rand_:ale});var Kv={exports:{}},lle=Kv.exports,gO;function ule(){return gO||(gO=1,(function(t){(function(e,n,r){function s(l){var u=this,c=a();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function i(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function o(l,u){var c=new s(l),d=u&&u.state,f=c.next;return f.int32=function(){return c.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&i(d,c),f.state=function(){return i(c,{})}),f}function a(){var l=4022871197,u=function(c){c=String(c);for(var d=0;d<c.length;d++){l+=c.charCodeAt(d);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=o:this.alea=o})(lle,t)})(Kv)),Kv.exports}var Xv={exports:{}},cle=Xv.exports,yO;function hle(){return yO||(yO=1,(function(t){(function(e,n,r){function s(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var u=new s(a),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&i(c,u),d.state=function(){return i(u,{})}),d}n&&n.exports?n.exports=o:this.xor128=o})(cle,t)})(Xv)),Xv.exports}var Yv={exports:{}},dle=Yv.exports,wO;function fle(){return wO||(wO=1,(function(t){(function(e,n,r){function s(a){var l=this,u="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var u=new s(a),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&i(c,u),d.state=function(){return i(u,{})}),d}n&&n.exports?n.exports=o:this.xorwow=o})(dle,t)})(Yv)),Yv.exports}var Qv={exports:{}},ple=Qv.exports,vO;function mle(){return vO||(vO=1,(function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var c=l.x,d=l.i,f,m;return f=c[d],f^=f>>>7,m=f^f<<24,f=c[d+1&7],m^=f^f>>>10,f=c[d+3&7],m^=f^f>>>3,f=c[d+4&7],m^=f^f<<7,f=c[d+7&7],f=f^f<<13,m^=f^f<<9,c[d]=m,l.i=d+1&7,m};function u(c,d){var f,m=[];if(d===(d|0))m[0]=d;else for(d=""+d,f=0;f<d.length;++f)m[f&7]=m[f&7]<<15^d.charCodeAt(f)+m[f+1&7]<<13;for(;m.length<8;)m.push(0);for(f=0;f<8&&m[f]===0;++f);for(f==8?m[7]=-1:m[f],c.x=m,c.i=0,f=256;f>0;--f)c.next()}u(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var u=new s(a),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},d.int32=u.next,d.quick=d,c&&(c.x&&i(c,u),d.state=function(){return i(u,{})}),d}n&&n.exports?n.exports=o:this.xorshift7=o})(ple,t)})(Qv)),Qv.exports}var Jv={exports:{}},gle=Jv.exports,bO;function yle(){return bO||(bO=1,(function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var c=l.w,d=l.X,f=l.i,m,g;return l.w=c=c+1640531527|0,g=d[f+34&127],m=d[f=f+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,g=d[f]=g^m,l.i=f,g+(c^c>>>16)|0};function u(c,d){var f,m,g,y,v,b=[],x=128;for(d===(d|0)?(m=d,d=null):(d=d+"\0",m=0,x=Math.max(x,d.length)),g=0,y=-32;y<x;++y)d&&(m^=d.charCodeAt((y+32)%d.length)),y===0&&(v=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,y>=0&&(v=v+1640531527|0,f=b[y&127]^=m+v,g=f==0?g+1:0);for(g>=128&&(b[(d&&d.length||0)&127]=-1),g=127,y=512;y>0;--y)m=b[g+34&127],f=b[g=g+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,b[g]=m^f;c.w=v,c.X=b,c.i=g}u(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var u=new s(a),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},d.int32=u.next,d.quick=d,c&&(c.X&&i(c,u),d.state=function(){return i(u,{})}),d}n&&n.exports?n.exports=o:this.xor4096=o})(gle,t)})(Jv)),Jv.exports}var Zv={exports:{}},wle=Zv.exports,xO;function vle(){return xO||(xO=1,(function(t){(function(e,n,r){function s(a){var l=this,u="";l.next=function(){var d=l.b,f=l.c,m=l.d,g=l.a;return d=d<<25^d>>>7^f,f=f-m|0,m=m<<24^m>>>8^g,g=g-d|0,l.b=d=d<<20^d>>>12^f,l.c=f=f-m|0,l.d=m<<16^f>>>16^g,l.a=g-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var u=new s(a),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(f+m)/(1<<21);while(g===0);return g},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&i(c,u),d.state=function(){return i(u,{})}),d}n&&n.exports?n.exports=o:this.tychei=o})(wle,t)})(Zv)),Zv.exports}var eb={exports:{}};const ble={},xle=Object.freeze(Object.defineProperty({__proto__:null,default:ble},Symbol.toStringTag,{value:"Module"})),_le=xC(xle);var Ile=eb.exports,_O;function Tle(){return _O||(_O=1,(function(t){(function(e,n,r){var s=256,i=6,o=52,a="random",l=r.pow(s,i),u=r.pow(2,o),c=u*2,d=s-1,f;function m(S,E,L){var R=[];E=E==!0?{entropy:!0}:E||{};var D=b(v(E.entropy?[S,$(n)]:S??x(),3),R),A=new g(R),F=function(){for(var P=A.g(i),K=l,j=0;P<u;)P=(P+j)*s,K*=s,j=A.g(1);for(;P>=c;)P/=2,K/=2,j>>>=1;return(P+j)/K};return F.int32=function(){return A.g(4)|0},F.quick=function(){return A.g(4)/4294967296},F.double=F,b($(A.S),n),(E.pass||L||function(P,K,j,se){return se&&(se.S&&y(se,A),P.state=function(){return y(A,{})}),j?(r[a]=P,K):P})(F,D,"global"in E?E.global:this==r,E.state)}function g(S){var E,L=S.length,R=this,D=0,A=R.i=R.j=0,F=R.S=[];for(L||(S=[L++]);D<s;)F[D]=D++;for(D=0;D<s;D++)F[D]=F[A=d&A+S[D%L]+(E=F[D])],F[A]=E;(R.g=function(P){for(var K,j=0,se=R.i,fe=R.j,me=R.S;P--;)K=me[se=d&se+1],j=j*s+me[d&(me[se]=me[fe=d&fe+K])+(me[fe]=K)];return R.i=se,R.j=fe,j})(s)}function y(S,E){return E.i=S.i,E.j=S.j,E.S=S.S.slice(),E}function v(S,E){var L=[],R=typeof S,D;if(E&&R=="object")for(D in S)try{L.push(v(S[D],E-1))}catch{}return L.length?L:R=="string"?S:S+"\0"}function b(S,E){for(var L=S+"",R,D=0;D<L.length;)E[d&D]=d&(R^=E[d&D]*19)+L.charCodeAt(D++);return $(E)}function x(){try{var S;return f&&(S=f.randomBytes)?S=S(s):(S=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(S)),$(S)}catch{var E=e.navigator,L=E&&E.plugins;return[+new Date,e,L,e.screen,$(n)]}}function $(S){return String.fromCharCode.apply(0,S)}if(b(r.random(),n),t.exports){t.exports=m;try{f=_le}catch{}}else r["seed"+a]=m})(typeof self<"u"?self:Ile,[],Math)})(eb)),eb.exports}var wT,IO;function Sle(){if(IO)return wT;IO=1;var t=ule(),e=hle(),n=fle(),r=mle(),s=yle(),i=vle(),o=Tle();return o.alea=t,o.xor128=e,o.xorwow=n,o.xorshift7=r,o.xor4096=s,o.tychei=i,wT=o,wT}var x1=Sle();const $le=.001,DV=.1;function Cle(t,e,n){return n==null&&(n=YE()),_$(t,e,(r,s)=>QE(r,s,n))}function YE(){return we.backend.floatPrecision()===32?$le:DV}function _$(t,e,n){let r=!0;if((Ms(t)||Ms(e))&&(r=!1),Ms(t)&&Ms(e)&&(r=!0),r){const o=t.constructor.name,a=e.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(t)&&Array.isArray(e)){const o=_u(t),a=_u(e);if(!zn(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const s=Ms(t)?t:xu(t),i=Ms(e)?e:xu(e);if(s.length!==i.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${i.length}.
Actual:   ${s}.
Expected: ${i}.`);for(let o=0;o<i.length;++o){const a=s[o],l=i[o];if(!n(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${s}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function Ele(t,e){t().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function kle(t,e){const n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return ou(t)||ou(t[0])||ou(e)||ou(e[0])?_$(t,n,(r,s)=>r==s):_$(t,e,(r,s)=>QE(r,s,0))}function Nle(t,e,n){if(n==null&&(n=YE()),!QE(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function QE(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function Ale(t,e,n){for(let r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error(`Value out of range:${t[r]} low: ${e}, high: ${n}`)}function Rle(t,e){const n=new Float32Array(t),r=new Float32Array(e);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function OV(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?OV(n):t[e]=mu(n)}return t}function Dle(t){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(t),new Promise(n=>{e.addEventListener("loadeddata",r=>n(e)),e.load()})}async function Ole(t){await t.play(),"requestVideoFrameCallback"in t&&await new Promise(e=>{t.requestVideoFrameCallback(e)})}const PV=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:DV,createVideoElement:Dle,encodeStrings:OV,expectArrayBuffersEqual:Rle,expectArraysClose:Cle,expectArraysEqual:kle,expectNumbersClose:Nle,expectPromiseToFail:Ele,expectValuesInRange:Ale,play:Ole,testEpsilon:YE},Symbol.toStringTag,{value:"Module"}));class JE{constructor(e,n,r,s,i){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=x1.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,i,o;do s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*a,n=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Ple{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const i=s||Math.random();this.randu=x1.alea(i.toString()),this.randn=new JE(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,i,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),i=this.randu(),i<n||Math.log(i)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class Fle{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=x1.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function Lle(t,e,n=1,r="float32",s){if(la(t),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const i=new Ple(e,n,r,s),o=En(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const ZE=ve({randomGamma_:Lle});function Mle(t,e=0,n=1,r,s){if(la(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const i=new JE(e,n,r,!1,s),o=En(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Tw=ve({randomNormal_:Mle});function zle(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Tw(t,0,1,e,n)}const ek=ve({randomStandardNormal_:zle});function Vle(t,e=0,n=1,r="float32",s){la(t);const i=En(t,r),o=new Fle(e,n,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const xc=ve({randomUniform_:Vle});function Ble(t,e,n,r){return xc(t,e,n,"int32",r)}const tk=ve({randomUniformInt_:Ble});function Dh(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return we.runKernel(B0,{},s)}function Ule(t){const n={input:ee(t,"input","real")};return we.runKernel(U0,n)}const tf=ve({real_:Ule});function Wle(t){const n={x:ee(t,"x","reciprocal")};return we.runKernel(np,n)}const I_=ve({reciprocal_:Wle});function jle(t){const n={x:ee(t,"x","relu")};return we.runKernel(rp,n)}const ol=ve({relu_:jle});function Gle(t){const n={x:ee(t,"x","relu6")};return we.runKernel(sp,n)}const Sw=ve({relu6_:Gle});function Hle(t,e){const r={x:ee(t,"x","reverse")},s={dims:e};return we.runKernel(Jg,r,s)}const ia=ve({reverse_:Hle});function qle(t){const e=ee(t,"x","reverse");return J(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),ia(e,0)}const nk=ve({reverse1d_:qle});function Kle(t,e){const n=ee(t,"x","reverse");return J(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),ia(n,e)}const rk=ve({reverse2d_:Kle});function Xle(t,e){const n=ee(t,"x","reverse");return J(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),ia(n,e)}const sk=ve({reverse3d_:Xle});function Yle(t,e){const n=ee(t,"x","reverse");return J(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),ia(n,e)}const ik=ve({reverse4d_:Yle});function Qle(t){const n={x:ee(t,"x","round")};return we.runKernel(ip,n)}const $w=ve({round_:Qle});function Jle(t){const n={x:ee(t,"x","rsqrt","float32")};return we.runKernel(op,n)}const Cw=ve({rsqrt_:Jle});function Zle(t){const n={x:ee(t,"x","selu")};return we.runKernel(ap,n)}const Ew=ve({selu_:Zle});function eue(t,e,n,r,s,i=[1,1],o="NHWC"){const a=ee(t,"x","separableConv2d"),l=ee(e,"depthwiseFilter","separableConv2d"),u=ee(n,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(a.rank===3&&(d=!0,c=Ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");J(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),J(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),J(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),J(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),J(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const f=l.shape[2],m=l.shape[3];J(u.shape[2]===f*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*m}, but got ${u.shape[2]}.`);const g=xp(c,l,r,s,o,i),v=Tu(g,u,1,"valid",o);return d?Ie(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const kw=ve({separableConv2d_:eue});async function tue(t,e){const n=ee(t,"x","setdiff1d"),r=ee(e,"y","setdiff1d");J(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),J(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),J(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),i=await r.data(),o=new Set(i);let a=0;for(let c=0;c<s.length;c++)o.has(s[c])||a++;const l=new ms([a],n.dtype),u=new ms([a],"int32");for(let c=0,d=0;c<s.length;c++)o.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}const ok=tue;function nue(t){const n={x:ee(t,"x","sign")};return we.runKernel(cp,n)}const T_=ve({sign_:nue});function rue(t){const n={x:ee(t,"x","sin","float32")};return we.runKernel(lp,n)}const Nw=ve({sin_:rue});function sue(t){const n={x:ee(t,"x","sinh")};return we.runKernel(up,n)}const Aw=ve({sinh_:sue});function iue(t,e,n){const r=ee(t,"x","slice1d");return J(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),cn(r,[e],[n])}const _1=ve({slice1d_:iue});function oue(t,e,n){const r=ee(t,"x","slice2d");return J(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),cn(r,e,n)}const Rw=ve({slice2d_:oue});function aue(t,e,n){const r=ee(t,"x","slice3d");return J(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),cn(r,e,n)}const I1=ve({slice3d_:aue});function lue(t,e,n){const r=ee(t,"x","slice4d");return J(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),cn(r,e,n)}const nf=ve({slice4d_:lue});function uue(t,e=-1){const n=ee(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return we.runKernel(s1,r,s)}const T1=ve({softmax_:uue});function cue(t){J(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return we.runKernel(I0,e)}const S1=ve({fft_:cue});function hue(t){J(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return we.runKernel(C0,e)}const rf=ve({ifft_:hue});function due(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=Ie(t,[n,e]);r=rf(s)}else{const s=[n,2*(e-1)],i=Ie(tf(t),[n,e]),o=Ie(d1(t),[n,e]),a=ia(cn(i,[0,1],[n,e-2]),1),l=be(ia(cn(o,[0,1],[n,e-2]),1),Xt(-1)),u=Gr([i,a],1),c=Gr([o,l],1),d=Ie(Iu(u,c),[s[0],s[1]]);r=rf(d)}if(r=tf(r),t.rank===3&&t.shape[0]!==0){const s=r,i=t.shape[0];r=Ie(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}const Dw=ve({irfft_:due});function fue(t,e,n=0){const s={x:ee(t,"x","split")},i={numOrSizeSplits:e,axis:n};return we.runKernel(r1,s,i)}const po=ve({split_:fue});function pue(t,e){J(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const g=t.shape.map(v=>0),y=t.shape.map(v=>v);y[t.shape.length-1]=e,s=cn(t,g,y),n=e}else if(e!=null&&e>n){const g=t.shape.map(y=>y);g[t.shape.length-1]=e-n,s=Gr([t,ps(g)],t.shape.length-1),n=e}else s=t;const i=jn(s),o=Ie(Iu(s,i),[r,n]),a=S1(o),l=Math.floor(n/2)+1,u=tf(a),c=d1(a),d=po(u,[l,n-l],u.shape.length-1),f=po(c,[l,n-l],c.shape.length-1),m=s.shape.slice();return m[s.shape.length-1]=l,Ie(Iu(d[0],f[0]),m)}const $1=ve({rfft_:pue});function mue(t,e){let n=ee(t,"a","squaredDifference"),r=ee(e,"b","squaredDifference");[n,r]=ts(n,r),_n(n.shape,r.shape);const s={a:n,b:r},i={};return we.runKernel(pp,s,i)}const Ow=ve({squaredDifference_:mue});function gue(t,e){const n=ee(t,"x","squeeze","string_or_numeric");return Ie(n,gc(n.shape,e).newShape)}const Vr=ve({squeeze_:gue});function yue(t,e=0){const n=Ny(t,"tensors","stack","string_or_numeric");J(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&J(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return we.runKernel(Gg,r,s)}const qi=ve({stack_:yue});function wue(t,e=0){const r={x:ee(t,"x","step")},s={alpha:e};return we.runKernel(vp,r,s)}const Xh=ve({step_:wue});function vue(t,e,n,r,s=0,i=0,o=0,a=0,l=0){const c={x:ee(t,"x","stridedSlice","string_or_numeric")},d={begin:e,end:n,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return we.runKernel(ew,c,d)}const S_=ve({stridedSlice_:vue});function bue(t){const n={x:ee(t,"x","tan","float32")};return we.runKernel(gp,n)}const $_=ve({tan_:bue});function Zr(t,e){_f(t);const n=_u(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return jh(t,null,n,e)}function rl(t,e,n){if(_f(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=_u(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return jh(t,e,r,n)}function C_(t,e,n){if(_f(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=_u(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return jh(t,e,r,n)}function ak(t,e,n){if(_f(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=_u(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return jh(t,e,r,n)}function lk(t,e,n){if(_f(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=_u(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return jh(t,e,r,n)}function uk(t,e,n){if(_f(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=_u(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,jh(t,e,r,n)}function ck(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(i+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(i+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(i+` update.rank != ${s+t.length-r}`);for(let o=0;o<s;++o)if(n.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==t[o+r])throw new Error(i+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${t[o+s]})`)}function E_(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}ck(n,e,t)}function Yh(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=n.length;let o=1;for(let d=s;d<i;++d)o*=n[d];const a=s<1?1:s,l=Ue(e.shape)/a,u=[...Qt(n.slice(0,s)),1],c=Ue(n);return{sliceRank:s,numUpdates:l,sliceSize:o,strides:u,outputSize:c}}const FV=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Yh,validateInput:E_,validateUpdateShape:ck},Symbol.toStringTag,{value:"Module"}));function xue(t,e,n){const r=ee(t,"tensor","tensorScatterupdate"),s=ee(e,"indices","tensorScatterupdate","int32"),i=ee(n,"updates","tensorScatterupdate");if(E_(i,s,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);const o={tensor:r,indices:s,updates:i},a={};return we.runKernel(H0,o,a)}const hk=ve({tensorScatterUpdate_:xue});function _ue(t,e=1,n=!0){const r=ee(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:r},o={k:e,sorted:n},[a,l]=we.runKernel(sw,i,o);return{values:a,indices:l}}const k_=ve({topk_:_ue});function Iue(t,e=0,n=1,r,s){if(la(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new JE(e,n,r,!0,s),o=En(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Pw=ve({truncatedNormal_:Iue});function Tue(t,e=0){const n=ee(t,"x","unique","string_or_numeric");J(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[i,o]=we.runKernel(ow,r,s);return{values:i,indices:o}}const N_=ve({unique_:Tue});function Sue(t,e,n){const r=ee(t,"x","unsortedSegmentSum"),s=ee(e,"segmentIds","unsortedSegmentSum","int32");J(Hd(n),()=>"numSegments must be of dtype int");const i={x:r,segmentIds:s},o={numSegments:n};return we.runKernel(a1,i,o)}const Fw=ve({unsortedSegmentSum_:Sue});function $ue(t,e=0){const n=ee(t,"x","unstack","string_or_numeric");J(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return we.runKernel(o1,r,s)}const oa=ve({unstack_:$ue});function dk(t,e){return Iw(t,e,"right")}function A_(t,e=!0,n,r){return we.makeVariable(t,e,n,r)}function R_(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const r=En(t,"int32"),s=En([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const o=r.indexToLoc(n[i]),a=i*t.length;s.values.set(o,a)}return s.toTensor()}async function Cue(t){const e=ee(t,"condition","whereAsync","bool"),n=await e.data(),r=R_(e.shape,n);return t!==e&&e.dispose(),r}const D_=Cue;async function Eue(t,e,n){const r=ee(t,"tensor","boolMask"),s=ee(e,"mask","boolMask","bool"),i=n??0,o=s.rank,a=r.shape;J(o>0,()=>"mask cannot be scalar"),Ni(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let y=i;y<i+o;y++)l*=a[y];const u=a.slice(0,i).concat([l],a.slice(i+o)),c=Ie(r,u),d=Ie(s,[-1]),f=await D_(d),m=Vr(f,[1]),g=Sp(c,m,i);return t!==r&&r.dispose(),e!==s&&s.dispose(),m.dispose(),c.dispose(),d.dispose(),f.dispose(),g}const fk=Eue;function kue(t,e,n){const r=ee(t,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),J(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{J(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:e};return r.dtype==="complex64"?ke(()=>{let o=tf(r),a=d1(r);return o=we.runKernel(ph,{x:o},i),a=we.runKernel(ph,{x:a},i),n&&(a=$r(a)),Iu(o,a)}):we.runKernel(ph,s,i)}const Mn=ve({transpose_:kue});function Nue(t,e,n,r,s=!0){const i=ee(t,"v","movingAverage"),o=ee(e,"x","movingAverage"),a=ee(n,"decay","movingAverage");qz(i,o),J(zn(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=Xt(1),u=$t(l,a);let c=be($t(o,i),u);if(s){J(r!=null,()=>"When using zeroDebias: true, step is required.");const d=ee(r,"step","movingAverage");c=St(c,$t(l,Ll(a,d)))}return tt(i,c)}const pk=ve({movingAverage_:Nue});function Aue(t,e,n){la(n);const r=ee(t,"indices","scatterND","int32"),s=ee(e,"updates","scatterND");E_(s,r,n);const i={indices:r,updates:s},o={shape:n};return we.runKernel(G0,i,o)}const mk=ve({scatterND_:Aue});function Rue(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,i=t.rank>1?t.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Due(t,e,n,r=0){la(n);const s=ee(t,"sparseIndices","sparseToDense","int32"),i=ee(e,"sparseValues","sparseToDense","string_or_numeric"),o=ee(r,"defaultValue","sparseToDense",i.dtype);Rue(s,i,n,o);const a={sparseIndices:s,sparseValues:i,defaultValue:o},l={outputShape:n};return we.runKernel(J0,a,l)}const gk=ve({sparseToDense_:Due});function Oue(t,e){const n=ee(e,"indices","gatherND","int32"),s={params:ee(t,"x","gatherND","string_or_numeric"),indices:n};return we.runKernel($0,s)}const yk=ve({gatherND_:Oue});function Pue(t,e){if(e==null)return t.shape.slice();if(zn(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}function Fue(t,e,n,r){const s=ee(t,"x","dropout");if(J(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),J(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof Rn?s.clone():s;const i=Pue(s,n),o=1-e,a=St(Tp(tt(xc(i,0,1,"float32",r),o)),o);return be(s,a)}const O_=ve({dropout_:Fue});function P_(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Lw(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let i=0;i<t;++i){const o=2*Math.PI*i/(t+r-1);s[i]=e-n*Math.cos(o)}return Zr(s,"float32")}async function Lue(t,e,n=1){const r=ee(t,"predictions","inTopK"),s=ee(e,"targets","inTopK");J(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),J(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Ni(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];J(n>0&&n<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`);const o=await r.data(),a=await s.data(),[l,u]=[o.length/i,i],c=ii("bool",l);for(let d=0;d<l;d++){const f=d*u,m=o.subarray(f,f+u),g=[];for(let y=0;y<m.length;y++)g.push({value:m[y],index:y});g.sort((y,v)=>v.value-y.value),c[d]=0;for(let y=0;y<n;y++)if(g[y].index===a[d]){c[d]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),Eo(c,s.shape,"bool")}const wk=Lue;function Mue(t,e,n,r,s,i="NHWC",o){let a=t;t.rank===3&&(a=Ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Ie(e,[1,e.shape[0],e.shape[1],e.shape[2]])),J(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),J(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),J(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=i==="NHWC"?a.shape[3]:a.shape[1],c=i==="NHWC"?l.shape[3]:l.shape[1];J(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),J(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),wo("conv2dDerFilter",s,o);const d={x:a,dy:l},f={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:n};return we.runKernel(c0,d,f)}const vk=ve({conv2DBackpropFilter_:Mue});function F_(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return be(t,Xh(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function L_(t,e){let n=e;const r=$s(t.shape,e.shape);return r.length>0&&(n=Ot(n,r)),Ie(n,t.shape)}function M_(t,e,n,r){if(e==="linear")return t;if(e==="relu")return ol(t);if(e==="elu")return _p(t);if(e==="relu6")return Sw(t);if(e==="prelu")return b1(t,n);if(e==="leakyrelu")return f1(t,r);if(e==="sigmoid")return Ca(t);throw new Error(`Unknown fused activation ${e}.`)}const z_=(t,e)=>!(t>0)||e==="linear";function zue({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",z_(we.state.gradientDepth,l)===!1){J(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let L=Tu(t,e,n,r,s,i,o);return a!=null&&(L=tt(L,a)),M_(L,l,u,c)}const d=ee(t,"x","conv2d","float32"),f=ee(e,"filter","conv2d","float32");let m=d,g=!1;d.rank===3&&(g=!0,m=Ie(d,[1,d.shape[0],d.shape[1],d.shape[2]])),J(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),J(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),wo("fused conv2d",r,o);const y=s==="NHWC"?m.shape[3]:m.shape[1];J(f.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${f.shape[2]}.`),J(Ai(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const v=ai(m.shape,f.shape,n,i,r,o);let b;a!=null&&(b=ee(a,"bias","fused conv2d"),[b]=ts(b,d),s==="NHWC"?_n(v.outShape,b.shape):(J(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),J(b.shape.length===0||b.shape[0]===v.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${v.outChannels})`)));let x;if(u!=null){const L=u.shape;if(J(L.length<=1||L.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${L.length}.`),L.length===1)J(L[0]===1||L[0]===v.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${L}) is not compatible with the number of output channels (${v.outChannels}).`);else if(L.length===3)try{_n(L,v.outShape)}catch{const D=`Error in fused conv2d: PReLU activation weights (${L}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(D)}x=ee(u,"prelu weights","fused conv2d")}const $=(L,R)=>{J(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[D,A,F,P]=R,K=F_(L,F,l);J(Ah(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const j=NE(A.shape,K,D,n,r),se=vk(A,K,D.shape,n,r),fe=[j,se];if(P!=null){const me=L_(P,K);fe.push(me)}return fe},S={x:m,filter:f,bias:b,preluActivationWeights:x},E={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Ml((R,D,A)=>{let F=we.runKernel(Fm,S,E);return A([D,R,F]),g&&(F=Ie(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:$}})(m,f):Ml((R,D,A,F)=>{let P=we.runKernel(Fm,S,E);return F([D,R,P,A]),g&&(P=Ie(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:$}})(m,f,b)}const LV=ve({fusedConv2d_:zue});function Vue(t,e,n,r,s,i=[1,1],o){let a=t;t.rank===3&&(a=Ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:n};return we.runKernel(y0,u,c)}const MV=ve({depthwiseConv2dNativeBackpropFilter_:Vue});function Bue(t,e,n,r,s,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=Ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:n},c={strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:t},d=we.runKernel(w0,u,c);return l?Ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const zV=ve({depthwiseConv2dNativeBackpropInput_:Bue});function Uue({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(z_(we.state.gradientDepth,l)===!1){let E=xp(t,e,n,r,s,i,o);return a!=null&&(E=tt(E,a)),M_(E,l,u,c)}const d=ee(t,"x","depthwiseConv2d","float32"),f=ee(e,"filter","depthwiseConv2d","float32");let m=d,g=!1;d.rank===3&&(g=!0,m=Ie(d,[1,d.shape[0],d.shape[1],d.shape[2]])),J(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),J(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),J(m.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),i==null&&(i=[1,1]),J(Ai(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),wo("fused depthwiseConv2d",r,o);const y=ai(m.shape,f.shape,n,i,r,o,!0);let v;a!=null&&(v=ee(a,"bias","fused conv2d"),[v]=ts(v,d),_n(y.outShape,v.shape));let b;u!=null&&(b=ee(u,"prelu weights","fused depthwiseConv2d"));const x=(E,L)=>{J(Ah(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[R,D,A,F]=L,P=F_(E,A,l),K=zV(D.shape,P,R,n,r,i,o),j=MV(D,P,R.shape,n,r,i,o);if(F!=null){const se=L_(v,P);return[K,j,se]}return[K,j]},$={x:m,filter:f,bias:v,preluActivationWeights:b},S={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Ml((L,R,D)=>{let A=we.runKernel(Lm,$,S);return D([R,L,A]),g&&(A=Ie(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(m,f):Ml((L,R,D,A)=>{let F=we.runKernel(Lm,$,S);return A([R,L,F,D]),g&&(F=Ie(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:x}})(m,f,v)}const Wue=ve({fusedDepthwiseConv2d_:Uue});function jue({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(z_(we.state.gradientDepth,i)===!1){let P=An(t,e,n,r);return s!=null&&(P=tt(P,s)),M_(P,i,o,a)}let l=ee(t,"a","fused matMul"),u=ee(e,"b","fused matMul");[l,u]=ts(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=r?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),y=u.shape.slice(0,-2),v=Ue(g),b=Ue(y);J(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);const $=_n(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,m]),S=n?Ie(l,[v,c,f]):Ie(l,[v,f,c]),E=r?Ie(u,[b,m,d]):Ie(u,[b,d,m]);let L;s!=null&&(L=ee(s,"bias","fused matMul"),[L]=ts(L,l),_n($,L.shape));let R;o!=null&&(R=ee(o,"prelu weights","fused matMul"));const D=(P,K)=>{const[j,se,fe,me]=K,ye=F_(Ie(P,fe.shape),fe,i);let oe,ue;if(!n&&!r?(oe=An(ye,se,!1,!0),ue=An(j,ye,!0,!1)):!n&&r?(oe=An(ye,se,!1,!1),ue=An(ye,j,!0,!1)):n&&!r?(oe=An(se,ye,!1,!0),ue=An(j,ye,!1,!1)):(oe=An(se,ye,!0,!0),ue=An(ye,j,!0,!0)),s!=null){const _e=L_(me,ye);return[oe,ue,_e]}else return[oe,ue]},A={a:S,b:E,bias:L,preluActivationWeights:R},F={transposeA:n,transposeB:r,activation:i,leakyreluAlpha:a};return s==null?Ml((K,j,se)=>{const fe=we.runKernel(Pm,A,F);return se([K,j,fe]),{value:Ie(fe,$),gradFunc:D}})(S,E):Ml((K,j,se,fe)=>{const me=we.runKernel(Pm,A,F);return fe([K,j,me,se]),{value:Ie(me,$),gradFunc:D}})(S,E,L)}const I$=ve({fusedMatMul_:jue});const bk=Object.freeze(Object.defineProperty({__proto__:null,conv2d:LV,depthwiseConv2d:Wue,matMul:I$},Symbol.toStringTag,{value:"Module"}));function Gue(t){return Lw(t,.54,.46)}const Hue=ve({hammingWindow_:Gue});function que(t){return Lw(t,.5,.5)}const VV=ve({hannWindow_:que});function Kue(t,e,n,r=!1,s=0){let i=0;const o=[];for(;i+e<=t.size;)o.push(cn(t,i,e)),i+=n;if(r)for(;i<t.size;){const a=i+e-t.size,l=Gr([cn(t,i,e-a),Hh([a],s)]);o.push(l),i+=n}return o.length===0?rl([],[0,e]):Ie(Gr(o),[o.length,e])}const BV=ve({frame_:Kue});function Xue(t,e,n,r,s=VV){r==null&&(r=P_(e));const i=BV(t,e,n),o=be(i,s(e));return $1(o,r)}const Yue=ve({stft_:Xue});function Que(t,e,n,r,s="bilinear",i=0){const o=ee(t,"image","cropAndResize"),a=ee(e,"boxes","cropAndResize","float32"),l=ee(n,"boxInd","cropAndResize","int32"),u=a.shape[0];J(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),J(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),J(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),J(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),J(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),J(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:o,boxes:a,boxInd:l},d={method:s,extrapolationValue:i,cropSize:r};return we.runKernel(p0,c,d)}const Jue=ve({cropAndResize_:Que});function Zue(t){const e=ee(t,"image","flipLeftRight","float32");J(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return we.runKernel(S0,n,{})}const ece=ve({flipLeftRight_:Zue});function tce(t){const e=ee(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];J(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),J(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,na(e,s)}const nce=ve({grayscaleToRGB_:tce});function rce(t){const e=ee(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];J(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),J(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,i=gt(e,"float32"),o=Zr([.2989,.587,.114]);let a;switch(e.rank){case 2:a=rh("ij,j->i",i,o);break;case 3:a=rh("ijk,k->ij",i,o);break;case 4:a=rh("ijkl,l->ijk",i,o);break;case 5:a=rh("ijklm,m->ijkl",i,o);break;case 6:a=rh("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=os(a,-1),gt(a,s)}const sce=ve({rgbToGrayscale_:rce});function ice(t,e,n=0,r=.5){const s=ee(t,"image","rotateWithOffset","float32");J(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const i={image:s},o={radians:e,fillValue:n,center:r};return we.runKernel(aw,i,o)}const oce=ve({rotateWithOffset_:ice});function C1(t,e,n,r,s,i){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=t.shape[0];return n=Math.min(n,o),J(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),J(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),J(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),J(e.rank===1,()=>"scores must be a 1D tensor"),J(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),J(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}function ace(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=ee(t,"boxes","nonMaxSuppression","float32"),o=ee(e,"scores","nonMaxSuppression","float32"),a=C1(i,o,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return we.runKernel(P0,{boxes:i,scores:o},l)}const lce=ve({nonMaxSuppression_:ace});function uce(t,e,n){const r=cce(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function cce(t,e,n){return dce(t,e,n||hce)}function hce(t,e){return t>e?1:t<e?-1:0}function dce(t,e,n){let r=0,s=t.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=n(e,t[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}function V_(t,e,n,r,s){return xk(t,e,n,r,s,0)}function B_(t,e,n,r,s,i){return xk(t,e,n,r,s,0,!1,i,!0)}function U_(t,e,n,r,s,i){return xk(t,e,n,r,s,i,!0)}function xk(t,e,n,r,s,i,o=!1,a=!1,l=!1){const u=[];for(let v=0;v<e.length;v++)e[v]>s&&u.push({score:e[v],boxIndex:v,suppressBeginIndex:0});u.sort(TO);const c=i>0?-.5/i:0,d=[],f=[];for(;d.length<n&&u.length>0;){const v=u.pop(),{score:b,boxIndex:x,suppressBeginIndex:$}=v;if(b<s)break;let S=!1;for(let E=d.length-1;E>=$;--E){const L=fce(t,x,d[E]);if(L>=r){S=!0;break}if(v.score=v.score*pce(r,c,L),v.score<=s)break}v.suppressBeginIndex=d.length,S||(v.score===b?(d.push(x),f.push(v.score)):v.score>s&&uce(u,v,TO))}const m=d.length,g=n-m;a&&g>0&&(d.push(...new Array(g).fill(0)),f.push(...new Array(g).fill(0)));const y={selectedIndices:d};return o&&(y.selectedScores=f),l&&(y.validOutputs=m),y}function fce(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),f=Math.max(s[1],s[3]),m=(a-i)*(l-o),g=(d-u)*(f-c);if(m<=0||g<=0)return 0;const y=Math.max(i,u),v=Math.max(o,c),b=Math.min(a,d),x=Math.min(l,f),$=Math.max(b-y,0)*Math.max(x-v,0);return $/(m+g-$)}function pce(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function TO(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}async function mce(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=ee(t,"boxes","nonMaxSuppressionAsync"),o=ee(e,"scores","nonMaxSuppressionAsync"),a=C1(i,o,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:d}=V_(u,c,n,r,s);return i!==t&&i.dispose(),o!==e&&o.dispose(),Zr(d,"int32")}const gce=mce;function yce(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=ee(t,"boxes","nonMaxSuppression"),a=ee(e,"scores","nonMaxSuppression"),l=C1(o,a,n,r,s,i);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u={boxes:o,scores:a},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:i},d=we.runKernel(L0,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}const wce=ve({nonMaxSuppressionWithScore_:yce});async function vce(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=ee(t,"boxes","nonMaxSuppressionAsync"),a=ee(e,"scores","nonMaxSuppressionAsync"),l=C1(o,a,n,r,s,i);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:f,selectedScores:m}=U_(c,d,n,r,s,i);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Zr(f,"int32"),selectedScores:Zr(m)}}const bce=vce;function xce(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=ee(t,"boxes","nonMaxSuppression"),a=ee(e,"scores","nonMaxSuppression"),l=C1(o,a,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,f={boxes:o,scores:a},m={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:i},g=we.runKernel(F0,f,m);return{selectedIndices:g[0],validOutputs:g[1]}}const _ce=ve({nonMaxSuppressionPadded_:xce});async function Ice(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=ee(t,"boxes","nonMaxSuppressionAsync"),a=ee(e,"scores","nonMaxSuppressionAsync"),l=C1(o,a,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[f,m]=await Promise.all([o.data(),a.data()]),{selectedIndices:g,validOutputs:y}=B_(f,m,u,c,d,i);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Zr(g,"int32"),validOutputs:Xt(y,"int32")}}const Tce=Ice;function Sce(t,e,n=!1,r=!1){const s=ee(t,"images","resizeBilinear");J(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),J(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),J(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=Ie(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:r,size:e},u=we.runKernel(Qg,a,l);return o?Ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const UV=ve({resizeBilinear_:Sce});function $ce(t,e,n=!1,r=!1){const s=ee(t,"images","resizeNearestNeighbor");J(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),J(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),J(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),J(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=Ie(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:r,size:e},u=we.runKernel(Yg,a,l);return o?Ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const WV=ve({resizeNearestNeighbor_:$ce});function Cce(t,e="binary",n=!1,r=.5){const s=ee(t,"image","threshold"),i=.2989,o=.587,a=.114,l=s.shape[0]*s.shape[1];let u=be(Zr([r]),255),c,d,f,m;if(J(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),J(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),J(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),J(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,d,f]=po(s,[1,1,1],-1);const v=be(c,i),b=be(d,o),x=be(f,a);m=tt(tt(v,b),x)}else m=t;if(e==="otsu"){const v=Qx(gt($w(m),"int32"),Eo([]),256);u=Ece(v,l)}const g=n?bc(m,u):Ki(m,u);return gt(be(g,255),"int32")}function Ece(t,e){let n=Zr([-1]),r=Zr([0]),s=Zr([0]),i,o,a,l,u,c;for(let d=0;d<t.size-1;d++){i=cn(t,0,d+1),o=cn(t,d+1),u=St(Ot(i),e),c=St(Ot(o),e);const f=Ot(be(i,Dh(0,i.size)));a=St(f,Ot(i));const m=Hh(o.shape,i.size),g=tt(Dh(0,o.size),m),y=be(o,g);l=St(Ot(y),Ot(o));const v=$t(a,l),b=$t(a,l),x=be(u,c);s=be(be(x,v),b);const $=Ki(s,r);r=Bs($,s,r),n=Bs($,Zr([d]),n)}return n}const kce=ve({threshold_:Cce});function Nce(t,e,n="nearest",r="constant",s=0,i){const o=ee(t,"image","transform","float32"),a=ee(e,"transforms","transform","float32");J(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),J(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),J(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},u={interpolation:n,fillMode:r,fillValue:s,outputShape:i};return we.runKernel(iw,l,u)}const Ace=ve({transform_:Nce});function Rce(t,e,n){const r=ee(t,"a","bandPart");J(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);let a,l;typeof e=="number"?(J(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),J(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=ee(e<0?i:e,"numLower","bandPart")):(J(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Bs(Zd(e,0),i,uc(e,i))),typeof n=="number"?(J(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),J(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),l=ee(n<0?o:n,"numUpper","bandPart")):(J(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Bs(Zd(n,0),o,uc(n,o)));const u=Ie(Dh(0,i,1,"int32"),[-1,1]),c=Dh(0,o,1,"int32"),d=$t(u,c),f=ka(bc(d,a),$u(d,$r(l))),m=ps([i,o],r.dtype);return Ie(qi(oa(Ie(r,[-1,i,o])).map(g=>Bs(f,g,m))),s)}const Dce=ve({bandPart_:Rce});function Oce(t){let e;if(Array.isArray(t)){e=!1,J(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let i=1;i<t.length;++i)J(t[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[i].shape[0]} vs. ${s})`)}else e=!0,t=po(t,t.shape[0],0).map(s=>Vr(s,[0]));J(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(we.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=be(Ot(be(n[o],i)),n[o]);i=$t(i,a)}return St(i,Ip(i,"euclidean"))}));return e?qi(n,0):n}const Pce=ve({gramSchmidt_:Oce});function Fce(t,e=!1){if(J(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return SO(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=oa(Ie(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],i=[];r.forEach(l=>{const[u,c]=SO(l,e);s.push(u),i.push(c)});const o=Ie(qi(s,0),t.shape),a=Ie(qi(i,0),t.shape);return[o,a]}}function SO(t,e=!1){return we.tidy(()=>{J(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=bw(n),i=Rl(t);const o=rl([[1]],[1,1]);let a=Rl(o);const l=n>=r?r:n;for(let u=0;u<l;++u){const c=i,d=a,f=s;[a,i,s]=we.tidy(()=>{const m=cn(i,[u,u],[n-u,1]),g=Ip(m),y=cn(i,[u,u],[1,1]),v=Bs(Ki(y,0),rl([[-1]]),rl([[1]])),b=$t(y,be(v,g)),x=St(m,b);x.shape[0]===1?a=Rl(o):a=Gr([o,cn(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const $=$r(St(An(v,b),g)),S=cn(i,[u,0],[n-u,r]),E=be($,a),L=Mn(a);if(u===0)i=$t(S,An(E,An(L,S)));else{const A=$t(S,An(E,An(L,S)));i=Gr([cn(i,[0,0],[u,r]),A],0)}const R=Mn(E),D=cn(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=$t(D,An(An(D,a),R));else{const A=$t(D,An(An(D,a),R));s=Gr([cn(s,[0,0],[n,u]),A],1)}return[a,i,s]}),en([c,d,f])}return!e&&n>r&&(s=cn(s,[0,0],[n,r]),i=cn(i,[0,0],[r,r])),[s,i]})}const Lce=ve({qr_:Fce});var ji;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ji||(ji={}));function Mce(t,e,n=ji.SUM_BY_NONZERO_WEIGHTS){const r=ee(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=ee(e,"weights","computeWeightedLoss"));const i=s==null?r:be(r,s);if(n===ji.NONE)return i;if(n===ji.SUM)return Ot(i);if(n===ji.MEAN){if(s==null)return Wr(i);{const o=r.size/s.size,a=St(Ot(i),Ot(s));return o>1?St(a,Xt(o)):a}}if(n===ji.SUM_BY_NONZERO_WEIGHTS){if(s==null)return St(Ot(i),Xt(r.size));{const o=be(s,fo(r.shape)),a=gt(Ot(Rh(o,Xt(0))),"float32");return St(Ot(i),a)}}throw Error(`Unknown reduction: ${n}`)}const _c=ve({computeWeightedLoss_:Mce});function zce(t,e,n,r=ji.SUM_BY_NONZERO_WEIGHTS){const s=ee(t,"labels","absoluteDifference"),i=ee(e,"predictions","absoluteDifference");let o=null;n!=null&&(o=ee(n,"weights","absoluteDifference")),Ni(s.shape,i.shape,"Error in absoluteDifference: ");const a=fs($t(s,i));return _c(a,o,r)}const Vce=ve({absoluteDifference_:zce});function Bce(t,e,n,r,s=ji.SUM_BY_NONZERO_WEIGHTS){const i=ee(t,"labels","cosineDistance"),o=ee(e,"predictions","cosineDistance");let a=null;r!=null&&(a=ee(r,"weights","cosineDistance")),Ni(i.shape,o.shape,"Error in cosineDistance: ");const l=Xt(1),u=$t(l,Ot(be(i,o),n,!0));return _c(u,a,s)}const Uce=ve({cosineDistance_:Bce});function Wce(t,e,n,r=ji.SUM_BY_NONZERO_WEIGHTS){let s=ee(t,"labels","hingeLoss");const i=ee(e,"predictions","hingeLoss");let o=null;n!=null&&(o=ee(n,"weights","hingeLoss")),Ni(s.shape,i.shape,"Error in hingeLoss: ");const a=Xt(1);s=$t(be(Xt(2),s),a);const l=ol($t(a,be(s,i)));return _c(l,o,r)}const jce=ve({hingeLoss_:Wce});function Gce(t,e,n,r=1,s=ji.SUM_BY_NONZERO_WEIGHTS){const i=ee(t,"labels","huberLoss"),o=ee(e,"predictions","huberLoss");let a=null;n!=null&&(a=ee(n,"weights","huberLoss")),Ni(i.shape,o.shape,"Error in huberLoss: ");const l=Xt(r),u=fs($t(o,i)),c=uc(u,l),d=$t(u,c),f=tt(be(Xt(.5),wr(c)),be(l,d));return _c(f,a,s)}const Hce=ve({huberLoss_:Gce});function qce(t,e,n,r=1e-7,s=ji.SUM_BY_NONZERO_WEIGHTS){const i=ee(t,"labels","logLoss"),o=ee(e,"predictions","logLoss");let a=null;n!=null&&(a=ee(n,"weights","logLoss")),Ni(i.shape,o.shape,"Error in logLoss: ");const l=Xt(1),u=Xt(r),c=$r(be(i,Ao(tt(o,u)))),d=be($t(l,i),Ao(tt($t(l,o),u))),f=$t(c,d);return _c(f,a,s)}const Kce=ve({logLoss_:qce});function Xce(t,e,n,r=ji.SUM_BY_NONZERO_WEIGHTS){const s=ee(t,"labels","meanSquaredError"),i=ee(e,"predictions","meanSquaredError");let o=null;n!=null&&(o=ee(n,"weights","meanSquaredError")),Ni(s.shape,i.shape,"Error in meanSquaredError: ");const a=Ow(s,i);return _c(a,o,r)}const Yce=ve({meanSquaredError_:Xce});function Qce(t,e){const n=ee(t,"labels","sigmoidCrossEntropyWithLogits"),r=ee(e,"logits","sigmoidCrossEntropyWithLogits");Ni(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=ol(r),i=be(r,n),o=p1(ki($r(fs(r))));return tt($t(s,i),o)}function Jce(t,e,n,r=0,s=ji.SUM_BY_NONZERO_WEIGHTS){let i=ee(t,"multiClassLabels","sigmoidCrossEntropy");const o=ee(e,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=ee(n,"weights","sigmoidCrossEntropy")),Ni(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Xt(r),c=Xt(1),d=Xt(.5);i=tt(be(i,$t(c,u)),be(d,u))}const l=Qce(i,o);return _c(l,a,s)}const Zce=ve({sigmoidCrossEntropy_:Jce});function ehe(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Ml((s,i,o)=>{const l=m1(i,[n],!0),u=$t(gt(i,"float32"),l);o([s,u]);const c=$r(be(u,s));return{value:Ot(c,[n]),gradFunc:(m,g)=>{const[y,v]=g,b=gs(m.shape,[n]);return[be(Ie(m,b),$t(gt(y,"float32"),ki(v))),be(Ie(m,b),$t(ki(v),gt(y,"float32")))]}}})(t,e)}function the(t,e,n,r=0,s=ji.SUM_BY_NONZERO_WEIGHTS){let i=ee(t,"onehotLabels","softmaxCrossEntropy");const o=ee(e,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=ee(n,"weights","softmaxCrossEntropy")),Ni(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Xt(r),c=Xt(1),d=Xt(i.shape[1]);i=tt(be(i,$t(c,u)),St(u,d))}const l=ehe(i,o);return _c(l,a,s)}const nhe=ve({softmaxCrossEntropy_:the});function rhe(t,e,n,r){const s=ee(t,"indices","sparseFillEmptyRows","int32"),i=ee(e,"values","sparseFillEmptyRows"),o=ee(n,"denseShape","sparseFillEmptyRows","int32"),a=ee(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:i,denseShape:o,defaultValue:a},u=we.runKernel(K0,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const she=ve({sparseFillEmptyRows_:rhe});function ihe(t,e,n){const r=ee(t,"inputIndices","sparseReshape","int32"),s=ee(e,"inputShape","sparseReshape","int32"),i=ee(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:r,inputShape:s,newShape:i},a=we.runKernel(X0,o);return{outputIndices:a[0],outputShape:a[1]}}const ohe=ve({sparseReshape_:ihe});function ahe(t,e,n){const r=ee(t,"data","sparseSegmentMean"),s=ee(e,"indices","sparseSegmentMean","int32"),i=ee(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return we.runKernel(Y0,o)}const lhe=ve({sparseSegmentMean_:ahe});function uhe(t,e,n){const r=ee(t,"data","sparseSegmentSum"),s=ee(e,"indices","sparseSegmentSum","int32"),i=ee(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return we.runKernel(Q0,o)}const che=ve({sparseSegmentSum_:uhe});function hhe(t,e,n,r,s,i,o,a){const l=ee(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=ee(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a},d={data:l,dataSplits:u},f=we.runKernel(tw,d,c);return{nGrams:f[0],nGramsSplits:f[1]}}const dhe=ve({stringNGrams_:hhe});function fhe(t,e,n=!0){const r=ee(t,"input","stringSplit","string"),s=ee(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const i={skipEmpty:n},o={input:r,delimiter:s},a=we.runKernel(nw,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const phe=ve({stringSplit_:fhe});function mhe(t,e){const n=ee(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return we.runKernel(rw,s,r)}const ghe=ve({stringToHashBucketFast_:mhe});function yhe(t,e,n,r=!0){const s=ee(t,"input","staticRegexReplace","string"),i={pattern:e,rewrite:n,replaceGlobal:r};return we.runKernel(i1,{x:s},i)}const whe=ve({staticRegexReplace_:yhe});const _k={fft:S1,ifft:rf,rfft:$1,irfft:Dw},Ik={hammingWindow:Hue,hannWindow:VV,frame:BV,stft:Yue},Ci={flipLeftRight:ece,grayscaleToRGB:nce,resizeNearestNeighbor:WV,resizeBilinear:UV,rgbToGrayscale:sce,rotateWithOffset:oce,cropAndResize:Jue,nonMaxSuppression:lce,nonMaxSuppressionAsync:gce,nonMaxSuppressionWithScore:wce,nonMaxSuppressionWithScoreAsync:bce,nonMaxSuppressionPadded:_ce,nonMaxSuppressionPaddedAsync:Tce,threshold:kce,transform:Ace},W_={bandPart:Dce,gramSchmidt:Pce,qr:Lce},Tk={absoluteDifference:Vce,computeWeightedLoss:_c,cosineDistance:Uce,hingeLoss:jce,huberLoss:Hce,logLoss:Kce,meanSquaredError:Yce,sigmoidCrossEntropy:Zce,softmaxCrossEntropy:nhe},Sk={sparseFillEmptyRows:she,sparseReshape:ohe,sparseSegmentMean:lhe,sparseSegmentSum:che},$k={stringNGrams:dhe,stringSplit:phe,stringToHashBucketFast:ghe,staticRegexReplace:whe};const vhe=new Map,T$=new Map;class $p{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class Ia{constructor(){this.classNameMap={}}static getMap(){return Ia.instance==null&&(Ia.instance=new Ia),Ia.instance}static register(e){Ia.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function it(t,e,n){J(t.className!=null,()=>"Class being registered does not have the static className property defined."),J(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),J(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const r=n,s=e+">"+r;return Ia.register(t),vhe.set(s,t),T$.set(t,s),t}function bhe(t){return T$.has(t)?T$.get(t):t.className}const jV=Object.freeze(Object.defineProperty({__proto__:null,Serializable:$p,SerializationMap:Ia,getRegisteredName:bhe,registerClass:it},Symbol.toStringTag,{value:"Module"}));class Eu extends $p{minimize(e,n=!1,r){const{value:s,grads:i}=this.computeGradients(e,r);if(r!=null){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return en(i),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return PE(e,n)}dispose(){this.iterations_!=null&&en(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Xt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Eu,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});class j_ extends Eu{static get className(){return"Adadelta"}constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=we.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=we.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:ke(()=>jn(i).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:ke(()=>jn(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;ke(()=>{const c=tt(be(l,this.rho),be(wr(a),1-this.rho)),d=be(St(js(tt(u,this.epsilon)),js(tt(l,this.epsilon))),a),f=tt(be(u,this.rho),be(wr(d),1-this.rho));l.assign(c),u.assign(f);const m=tt(be(d,-this.learningRate),i);i.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(en(this.accumulatedGrads.map(e=>e.variable)),en(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}class G_ extends Eu{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=we.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:ke(()=>Hh(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const a=this.accumulatedGrads[s].variable;ke(()=>{const l=tt(a,wr(o));a.assign(l);const u=tt(be(St(o,js(tt(l,we.backend.epsilon()))),-this.learningRate),i);i.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&en(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}class H_ extends Eu{static get className(){return"Adam"}constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ke(()=>{this.accBeta1=Xt(n).variable(),this.accBeta2=Xt(r).variable()}),s==null&&(this.epsilon=we.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);ke(()=>{const r=$t(1,this.accBeta1),s=$t(1,this.accBeta2);n.forEach((i,o)=>{const a=we.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:ke(()=>jn(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:ke(()=>jn(a).variable(l))});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,f=tt(be(c,this.beta1),be(u,1-this.beta1)),m=tt(be(d,this.beta2),be(wr(u),1-this.beta2)),g=St(f,r),y=St(m,s);c.assign(f),d.assign(m);const v=tt(be(St(g,tt(js(y),this.epsilon)),-this.learningRate),a);a.assign(v)}),this.accBeta1.assign(be(this.accBeta1,this.beta1)),this.accBeta2.assign(be(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&en(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&en(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),ke(()=>{this.accBeta1.assign(Ll(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ll(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}class q_ extends Eu{static get className(){return"Adamax"}constructor(e,n,r,s=null,i=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ke(()=>{this.iteration=Xt(0).variable(),this.accBeta1=Xt(n).variable()}),s==null&&(this.epsilon=we.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);ke(()=>{const r=$t(1,this.accBeta1),s=St(-this.learningRate,tt(be(this.iteration,this.decay),1));n.forEach((i,o)=>{const a=we.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:jn(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:jn(a).variable(l)});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,f=tt(be(c,this.beta1),be(u,1-this.beta1)),m=be(d,this.beta2),g=fs(u),y=Gl(m,g);c.assign(f),d.assign(y);const v=tt(be(St(s,r),St(f,tt(y,this.epsilon))),a);a.assign(v)}),this.iteration.assign(tt(this.iteration,1)),this.accBeta1.assign(be(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&en(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&en(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}class Mw extends Eu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const o=we.registeredVariables[r];ke(()=>{const a=tt(be(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ts(Xt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}class K_ extends Mw{static get className(){return"Momentum"}constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Xt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=we.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:ke(()=>jn(i).variable(!1))});const o=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&ke(()=>{let l;const u=tt(be(this.m,o),a);this.useNesterov?l=tt(be(this.c,tt(a,be(u,this.m))),i):l=tt(be(this.c,u),i),o.assign(u),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&en(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}class X_ extends Eu{static get className(){return"RMSProp"}constructor(e,n=.9,r=0,s=null,i=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,s==null&&(this.epsilon=we.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=we.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:ke(()=>jn(i).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:ke(()=>jn(i).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:ke(()=>jn(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;ke(()=>{const c=tt(be(l,this.decay),be(wr(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,f=tt(be(d,this.decay),be(a,1-this.decay)),m=St(be(a,this.learningRate),js($t(c,tt(wr(f),this.epsilon)))),g=tt(be(u,this.momentum),m);l.assign(c),d.assign(f),u.assign(g);const y=$t(i,g);i.assign(y)}else{const d=tt(be(l,this.decay),be(wr(a),1-this.decay)),f=tt(be(u,this.momentum),St(be(a,this.learningRate),js(tt(d,this.epsilon))));l.assign(d),u.assign(f);const m=$t(i,f);i.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&en(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&en(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&en(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}const xhe=[j_,G_,H_,q_,K_,X_,Mw];function _he(){for(const t of xhe)it(t)}const Ihe="model",The=".json",She=".weights.bin";function $O(t){return new Promise(e=>setTimeout(e)).then(t)}class sf{constructor(e){if(!De().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(sf.URL_SCHEME)&&(e=e.slice(sf.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Ihe),this.modelJsonFileName=e+The,this.weightDataFileName=e+She}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=jl.join(e.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=mV(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await $O(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await $O(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:hw(e)}}}}sf.URL_SCHEME="downloads://";class $he{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const i=JSON.parse(s.target.result),o=i.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=TE(i,u=>this.loadWeights(u));e(l)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const o of e)n.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[n,o])}loadWeightsFile(e,n){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;r(a)},i.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(i=>mO(i.name)),s={};for(const i of e)i.paths.forEach(o=>{const a=mO(o);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const Che=t=>De().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(sf.URL_SCHEME)?Ehe(t.slice(sf.URL_SCHEME.length)):null;Qr.registerSaveRouter(Che);function Ehe(t="model"){return new sf(t)}function khe(t){return new $he(t)}function CO(t,e,n,r){o(t),n=n??0,r=r??1,a(n,r);let s=0;const i=l=>(l.then(u=>{const c=n+ ++s/t.length*(r-n);return e(c),u}),l);function o(l){J(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){J(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),J(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),J(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(t.map(i))}async function GV(t,e){e==null&&(e={});const n=e.fetchFunc==null?De().platform.fetch:e.fetchFunc,r=t.map(d=>n(d,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await CO(r,e.onProgress,0,.5)).map(d=>d.arrayBuffer());return e.onProgress==null?await Promise.all(a):await CO(a,e.onProgress,.5,1)}function Nhe(t,e){var n;const r=e.fetchFunc==null?De().platform.fetch:e.fetchFunc;let s=0,i;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async o=>{for(var a;s<t.length;){i||(i=(await r(t[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await i.read();if(l){s++,i=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,s/t.length);continue}o.enqueue(u);return}o.close()}})}async function HV(t,e="",n,r){return qV(o=>GV(o,{requestInit:r}))(t,e,n)}function qV(t){return async(e,n="",r)=>{const s=e.map(()=>!1),i={},o=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((m,g)=>{let y=0;m.weights.forEach(v=>{const b="quantization"in v?v.quantization.dtype:v.dtype,x=qd[b]*Ue(v.shape),$=()=>{s[g]=!0,i[g]==null&&(i[g]=[]),i[g].push({manifestEntry:v,groupOffset:y,sizeBytes:x})};r!=null?r.forEach((S,E)=>{S===v.name&&($(),o[E]=!0)}):$(),a.push(v.name),y+=x})}),!o.every(m=>m)){const m=r.filter((g,y)=>!o[y]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((m,g,y)=>(g&&m.push(y),m),[]),u=[];l.forEach(m=>{e[m].paths.forEach(g=>{const y=n+(n.endsWith("/")?"":"/")+g;u.push(y)})});const c=await t(u),d={};let f=0;return l.forEach(m=>{const g=e[m].paths.length,y=new jl(c.slice(f,f+g));i[m].forEach(b=>{const x=y.slice(b.groupOffset,b.groupOffset+b.sizeBytes),$=xE(x,[b.manifestEntry]);for(const S in $)d[S]=$[S]}),f+=g}),d}}const Ahe="application/octet-stream",Rhe="application/json";class Ck{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(J(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=De().platform.fetch,J(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&J(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=mV(e,r);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:Rhe}),"model.json"),e.weightData!=null){const o=jl.join(e.weightData);n.body.append("model.weights.bin",new Blob([o],{type:Ahe}),"model.weights.bin")}const i=await this.fetch(this.path,n);if(i.ok)return{modelArtifactsInfo:hw(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return TE(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),r=Fb(e.weightsManifest),s=()=>Nhe(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=Dhe(n),i=this.weightPathPrefix||r,o=[],a=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(u)):o.push(i+u+s);return this.weightUrlConverter&&o.push(...await Promise.all(a)),o}async loadWeights(e){const n=await this.getWeightUrls(e),r=Fb(e),s=await GV(n,this.loadOptions);return[r,s]}}Ck.URL_SCHEME_REGEX=/^https?:\/\//;function Dhe(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function S$(t){return t.match(Ck.URL_SCHEME_REGEX)!=null}const KV=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>S$(r)):n=S$(t),n)return Ek(t,e)}return null};Qr.registerSaveRouter(KV);Qr.registerLoadRouter(KV);function Ek(t,e){return new Ck(t,e)}function XV(t,e){return Ek(t,e)}class vT{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class YV{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Ohe{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function Phe(t,e,n,r){const s=arguments;return new Ohe(Lb(...s))}function Lb(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new vT(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vT({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vT({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function Fhe(t){return new YV(t)}function Lhe(t){return new YV(t)}const Y_=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:jl,browserFiles:khe,browserHTTPRequest:XV,concatenateArrayBuffers:pV,copyModel:Iie,decodeWeights:xE,decodeWeightsStream:fV,encodeWeights:y$,fromMemory:Phe,fromMemorySync:Lb,getLoadHandlers:yV,getModelArtifactsForJSON:TE,getModelArtifactsForJSONSync:IE,getModelArtifactsInfoForJSON:hw,getSaveHandlers:gV,getWeightSpecs:Fb,http:Ek,isHTTPScheme:S$,listModels:xie,loadWeights:HV,moveModel:Tie,registerLoadRouter:uie,registerSaveRouter:lie,removeModel:_ie,weightsLoaderFactory:qV,withSaveHandler:Fhe,withSaveHandlerSync:Lhe},Symbol.toStringTag,{value:"Module"}));function Mhe(t,e,n){const r=ee(t,"labels","confusionMatrix"),s=ee(e,"predictions","confusionMatrix");J(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),J(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),J(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),J(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),J(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const i=ef(gt(r,"int32"),n),o=ef(gt(s,"int32"),n),a=Mn(i),l=An(a,o);return gt(l,"int32")}const zhe=ve({confusionMatrix_:Mhe});const QV=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:zhe},Symbol.toStringTag,{value:"Module"}));let fd,EO=!1;function JV(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)i=!0;else if(t.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(zm(Cy,we.backendName)!=null){const g={pixels:t},y={numChannels:e};return we.runKernel(Cy,g,y)}const[u,c]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d;if(o)d=t.getContext("2d").getImageData(0,0,u,c).data;else if(r||n)d=t.data;else if(i||s||a){if(fd==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")fd=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else fd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});fd.canvas.width=u,fd.canvas.height=c,fd.drawImage(t,0,0,u,c),d=fd.getImageData(0,0,u,c).data}let f;if(e===4)f=new Int32Array(d);else{const g=u*c;f=new Int32Array(g*e);for(let y=0;y<g;y++)for(let v=0;v<e;++v)f[y*e+v]=d[y*4+v]}return C_(f,[c,u,e],"int32")}function Vhe(t){return t!=null&&t.data instanceof Uint8Array}function Bhe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Uhe(t){return t!=null&&t.width!==0&&t.height!==0}function Whe(t){return Bhe()&&!(t instanceof ImageBitmap)&&Uhe(t)&&!Vhe(t)}async function jhe(t,e=3){let n=null;if(De().getBool("WRAP_TO_IMAGEBITMAP")&&Whe(t)){let r;try{r=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?n=r:n=t}else n=t;return JV(n,e)}function ZV(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}function Ghe(t){const e=t?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function kk(t,e){let n=ee(t,"img","toPixels");if(!(t instanceof Rn)){const u=n;n=gt(u,"int32"),u.dispose()}ZV(n);const[r,s]=n.shape.slice(0,2),i=n.rank===2?1:n.shape[2],o=await n.data(),a=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){const c=[0,0,0,255];for(let f=0;f<i;f++){const m=o[u*i+f];if(n.dtype==="float32"){if(m<0||m>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${m}.`)}else if(n.dtype==="int32"&&(m<0||m>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${m}.`);i===1?(c[0]=m*a,c[1]=m*a,c[2]=m*a):c[f]=m*a}const d=u*4;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(e!=null){EO||zm(b0,we.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),EO=!0),e.width=s,e.height=r;const u=e.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return n!==t&&n.dispose(),l}function Hhe(t,e,n){let r=ee(t,"img","draw");if(!(t instanceof Rn)){const o=r;r=gt(o,"int32"),o.dispose()}ZV(r),Ghe(n?.imageOptions);const s={image:r},i={canvas:e,options:n};we.runKernel(b0,s,i)}const Q_=ve({fromPixels_:JV}),eB=Object.freeze(Object.defineProperty({__proto__:null,draw:Hhe,fromPixels:Q_,fromPixelsAsync:jhe,toPixels:kk},Symbol.toStringTag,{value:"Module"}));function J_(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(Ue(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,i=s[s.length-1];let o=1;for(let d=0;d<s.length-1;++d)o*=s[d];const a=t.shape,l=s.slice();l.pop();let u=1;for(let d=i;d<n;++d)u*=a[d],l.push(a[d]);const c=[...Qt(t.shape).map(d=>d/u),1].slice(0,i);return[l,o,u,c]}const tB=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:J_},Symbol.toStringTag,{value:"Module"}));const $$=-2,qhe=-1;function Nk(t,e,n){const r=t.shape.length;J(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),J(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)J(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function Khe(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function Ak(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function nB(t,e,n,r){const s=[...t];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<n;i++)i===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function rB(t,e,n){return n<=t?n:n-(e-1)}function sB(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function Xhe(t,e,n,r,s,i,o,a,l){const u=t.length;let c=new Array(u),d=new Array(u),f=new Array(u);if(e.length&&n>0){const m=e[0],g=n+1;c=iB(o,m,g,r,t),d=oB(a,m,g,s,t),f=nB(i,m,g,t)}else for(let m=0;m<u;m++)c[m]=lB(o,r,i,t,m,l),d[m]=uB(a,s,i,t,m,l),f[m]=aB(i,m,l);return{begin:c,end:d,strides:f}}function iB(t,e,n,r,s){const i=[...s],o=sB(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=rB(e,n,a);let u=r[l];t&1<<l&&(u=0),i[a]=u}return i}function oB(t,e,n,r,s){const i=[...s],o=sB(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=rB(e,n,a);let u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),i[a]=u}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=Ch(0,i[a],s[a])}return i}function aB(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function lB(t,e,n,r,s,i){let o=e[s];const a=n[s]||1;(t&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=Ch(0,o,l-1),o}function uB(t,e,n,r,s,i){let o=e[s];const a=n[s]||1;(t&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),a>0?o=Ch(0,o,l):o=Ch(-1,o,l-1),o}function Rk(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function Dk(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Z_(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{J(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return n==null?i=new Array(s).fill(-1):typeof n=="number"?i=[n,...new Array(s-1).fill(-1)]:n.length<s?i=n.concat(new Array(s-n.length).fill(-1)):i=n,i=i.map((o,a)=>o>=0?o:(J(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,i]}function Ok(t,e,n,r,s,i,o,a,l){let u;if(r==null?(u=new Array(e.length),u.fill(1)):u=r,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let $=0;$<d.dims;$++)c&&(1<<$&a)!==0&&d.numAddAxisAfterEllipsis++,1<<$&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Yhe(d,f);let m=!0,g=!0,y=!0;const v=[],b=[];for(let $=0;$<t.length;++$){if(f.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const S=!!(f.shrinkAxisMask&1<<$),E=t[$];if(E===-1){v.push(S?1:-1);continue}const L=[f.beginMask&1<<$,f.endMask&1<<$],R=[f.strides[$]>0?0:-1,f.strides[$]>0?E:E-1];if(S&&f.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&f.strides[$]===1;const D=!!(f.beginMask&1<<$&&f.endMask&1<<$);if(f.beginValid&&f.endValid){if(S){const K=f.begin[$]<0?E+f.begin[$]:f.begin[$];if(f.begin[$]=K,f.end[$]=f.begin[$]+1,K<0||K>=E)throw Error(`slice index ${f.begin[$]} of dimension ${$} out of bounds.`)}else f.begin[$]=kO(f.begin[$],0,f.strides[$],E,L,R),f.end[$]=kO(f.end[$],1,f.strides[$],E,L,R);const P=f.strides[$]===1&&f.begin[$]===0&&f.end[$]===E;m=m&&P,g=g&&($===0&&f.strides[$]===1||P)}else m=m&&f.strides[$]===1&&D,g=g&&($===0&&f.strides[$]===1||D);let A,F=!1;if(f.beginValid&&f.endValid?(A=f.end[$]-f.begin[$],F=!0):S?(A=1,F=!0):D&&E>=0&&(f.strides[$]<0?A=-E:A=E,F=!0),F){let P;A===0||A<0!=f.strides[$]<0?P=0:P=Math.trunc(A/f.strides[$])+(A%f.strides[$]!==0?1:0),v.push(P)}else v.push(-1)}for(let $=0;$<f.finalShapeGatherIndices.length;++$){const S=f.finalShapeGatherIndices[$];S>=0?b.push(v[S]):S===$$&&b.push(1)}return{finalShapeSparse:b.filter(($,S)=>f.finalShapeGatherIndices[S]!==$$),finalShape:b,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:f.begin,end:f.end,strides:f.strides}}function Yhe(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push($$),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(qhe),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function kO(t,e,n,r,s,i){if(s[e])return n>0?i[e]:i[e+1&1];{const o=t<0?r+t:t;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const Pk=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Nk,computeFlatOffset:Dk,computeOutShape:Ak,getNormalizedAxes:Xhe,isSliceContinous:Rk,maskToAxes:Khe,parseSliceParams:Z_,sliceInfo:Ok,startForAxis:lB,startIndicesWithElidedDims:iB,stopForAxis:uB,stopIndicesWithElidedDims:oB,stridesForAxis:aB,stridesWithElidedDims:nB},Symbol.toStringTag,{value:"Module"}));const Fk="4.22.0";class Lk{static sgd(e){return new Mw(e)}static momentum(e,n,r=!1){return new K_(e,n,r)}static rmsprop(e,n=.9,r=0,s=null,i=!1){return new X_(e,n,r,s,i)}static adam(e=.001,n=.9,r=.999,s=null){return new H_(e,n,r,s)}static adadelta(e=.001,n=.95,r=null){return new j_(e,n,r)}static adamax(e=.002,n=.9,r=.999,s=null,i=0){return new q_(e,n,r,s,i)}static adagrad(e,n=.1){return new G_(e,n)}}const Qc=Lk;const Qhe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function e4(){return new Promise(t=>Qhe(()=>t()))}function Mk(t,e){const n=t[0].length;t.forEach((s,i)=>{J(s.length===n,()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`)}),J(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,i)=>{for(let o=0;o<n;o++)J(o===e||s[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function gu(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var Cl;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Cl||(Cl={}));function cB(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const i=n[s],o=r[r.length-n.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+t}] = ${i} but shape[${s+t}] = ${a}`)}else r[o]=i}return r}function hB(t){const e={FIRST_DIM_SIZE:Cl.FIRST_DIM_SIZE,VALUE_ROWIDS:Cl.VALUE_ROWIDS,ROW_LENGTHS:Cl.ROW_LENGTHS,ROW_SPLITS:Cl.ROW_SPLITS,ROW_LIMITS:Cl.ROW_LIMITS,ROW_STARTS:Cl.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function dB(t){return t.length===0?0:t[0]===Cl.FIRST_DIM_SIZE?t.length-1:t.length}function fB(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const i=t[s],o=e[s+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-t.length}] = ${i} but ragged tensor input.flatValues.shape[${s-t.length}] = ${o}`)}}const zk=30;function t4(t){return t<=zk?t:Rb(t,Math.floor(Math.sqrt(t)))}function Vk(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}function zw(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const i=e.length;for(let o=0;o<i;++o)s=s.concat([t[o+1]/e[o],e[o]]);s=s.concat(t.slice(i+1))}return s}function Vw(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<t;++o)o>=e*2+1||o%2===1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Bw(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let i=1;i<t.length;++i)i<=e.length?r?s.push(e[i-1]*t[i]):s.push(t[i]/e[i-1]):s.push(t[i]);return s}function Bk(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Uk(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}const n4=1.7580993408473768,r4=1.0507009873554805;const Wk=.3275911,jk=.254829592,Gk=-.284496736,Hk=1.421413741,qk=-1.453152027,Kk=1.061405429;function cc(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function pB(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function mB(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function gB(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function Xk(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function yB(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function wB(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const i=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:n,imag:r}}function vB(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),i=Math.sin(r);return{real:s,imag:i}}const bT="->",Jhe=/->/g,NO=",",AO="...";function Yk(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(Jhe,"").length)/bT.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${bT}").`);const[r,s]=t.split(bT);J(r.indexOf(AO)===-1,()=>`The ellipsis notation ("${AO}") is not supported yet.`);const i=r.split(NO),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<s.length;++f){const m=s[f];if(!i.some(g=>g.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);a.indexOf(m)===-1&&a.push(m)}for(let f=0;f<r.length;++f){const m=r[f];a.indexOf(m)===-1&&m!==NO&&a.push(m)}const l=new Array(i.length);for(let f=0;f<o;++f){if(new Set(i[f].split("")).size!==i[f].length)throw new Error(`Found duplicate axes in input component ${i[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let m=0;m<i[f].length;++m)l[f].push(a.indexOf(i[f][m]))}const u=a.length,c=s.length,d=[];for(let f=c;f<u;++f)d.push(f);return{allDims:a,summedDims:d,idDims:l}}function Qk(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function Jk(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const i=n[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=i[o]:J(r[e[s][o]]===i[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function Zk(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<n.length;++o){const a=n[o],l=Zhe(e,a);for(const u of l)i.indexOf(u)===-1&&(r[o].push(u),i.push(u))}return{path:n,steps:r}}function eN(t){return t.every((e,n)=>e===n)}function Zhe(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function tN(t,e,n=0){let r=[];if(typeof e=="number")J(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);J(s<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=t.shape[n]-o}J(t.shape[n]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}function bB(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function xB(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function _B(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function IB(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function TB(t,e){return`size ${t} must be non-negative, not ${e}`}function SB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function $B(t,e){const n=Ue(t),r=Ue(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function CB(t,e){const n=Ue(t),r=Ue(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}function C$(){return"segment ids must be >= 0"}function EB(){return"segment ids are not increasing"}function kB(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function NB(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function AB(t,e){let n=!1,r;for(t<=zk?(r=t,n=!0):r=Rb(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=Rb(t,r+1);return r}function RB(t,e,n){const r=[],s=t.length;for(let i=0;i<s;i++)i!==e?r.push(t[i]):r.push(n);return r}function nN(t,e,n,r){const s=e.shape.length,i=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${i}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(t.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const o=t.shape[n],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<n;d++)a.push(t.shape[d]),u*=t.shape[d];for(let d=r;d<s;d++)a.push(e.shape[d]);for(let d=n+1;d<i;d++)a.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}const ede=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:nN,computeOutShape:RB,segOpComputeOptimalWindowSize:AB},Symbol.toStringTag,{value:"Module"}));function hc(t){try{return t.map(e=>oc(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function DB(t){return t.map(e=>mu(e))}const rN=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:jk,ERF_A2:Gk,ERF_A3:Hk,ERF_A4:qk,ERF_A5:Kk,ERF_P:Wk,PARALLELIZE_THRESHOLD:zk,get RowPartitionType(){return Cl},SELU_SCALE:r4,SELU_SCALEALPHA:n4,applyActivation:M_,assertAndGetBroadcastShape:_n,assertAxesAreInnerMostDims:Ri,assertParamsConsistent:Mk,assignToTypedArray:yB,axesAreInnerMostDims:DE,calculateShapes:Yh,checkEinsumDimSizes:Jk,checkPadOnDimRoundingMode:wo,combineLocations:CV,combineRaggedTensorToTensorShapes:cB,complexWithEvenIndex:mB,complexWithOddIndex:gB,computeConv2DInfo:ai,computeConv3DInfo:Gh,computeDefaultPad:$E,computeDilation2DInfo:pw,computeOptimalWindowSize:t4,computeOutAndReduceShapes:li,computeOutShape:gu,computePool2DInfo:il,computePool3DInfo:wc,convertConv2DDataFormat:vc,decodeEinsumEquation:Yk,eitherStridesOrDilationsAreOne:Ai,expandShapeToKeepDim:gs,exponent:vB,exponents:wB,fromStringArrayToUint8:DB,fromUint8ToStringArray:hc,getAxesPermutation:ns,getBroadcastDims:Qd,getComplexWithIndex:Xk,getEinsumComputePath:Zk,getEinsumPermutation:Qk,getFusedBiasGradient:L_,getFusedDyActivation:F_,getImageCenter:Vk,getInnerMostAxes:ys,getPermuted:Vw,getRaggedRank:dB,getReductionAxes:$s,getReshaped:zw,getReshapedPermuted:Bw,getRowPartitionTypesHelper:hB,getSliceBeginCoords:Bk,getSliceSize:Uk,getSparseFillEmptyRowsIndicesDenseShapeMismatch:bB,getSparseFillEmptyRowsNegativeIndexErrorMessage:xB,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:_B,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:SB,getSparseReshapeInputOutputMismatchErrorMessage:CB,getSparseReshapeInputOutputMultipleErrorMessage:$B,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:IB,getSparseReshapeNegativeOutputDimErrorMessage:TB,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:NB,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:C$,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:EB,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:kB,getUndoAxesPermutation:qh,isIdentityPermutation:eN,log:Ese,mergeRealAndImagArrays:cc,prepareAndValidate:J_,prepareSplitSize:tN,segment_util:ede,shouldFuse:z_,slice_util:Pk,splitRealAndImagArrays:pB,stridesOrDilationsArePositive:Yd,tupleValuesAreOne:Ah,upcastType:go,validateDefaultValueShape:fB,validateInput:E_,validateUpdateShape:ck,warn:_a},Symbol.toStringTag,{value:"Module"}));const OB=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:V_,nonMaxSuppressionV4Impl:B_,nonMaxSuppressionV5Impl:U_,whereImpl:R_},Symbol.toStringTag,{value:"Module"}));_he();const tde=Object.freeze(Object.defineProperty({__proto__:null,Abs:og,Acos:Sf,Acosh:$f,AdadeltaOptimizer:j_,AdagradOptimizer:G_,AdamOptimizer:H_,AdamaxOptimizer:q_,Add:Uh,AddN:ag,All:r0,Any:s0,ArgMax:lg,ArgMin:ug,Asin:Cf,Asinh:Ef,Atan:kf,Atan2:Af,Atanh:Nf,AvgPool:cg,AvgPool3D:hg,AvgPool3DGrad:o0,AvgPoolGrad:i0,BatchMatMul:dg,BatchToSpaceND:fg,Bincount:a0,BitwiseAnd:pg,BroadcastArgs:l0,BroadcastTo:pE,Cast:Rf,Ceil:Df,ClipByValue:Of,Complex:u0,ComplexAbs:mg,Concat:gg,Conv2D:yg,Conv2DBackpropFilter:c0,Conv2DBackpropInput:wg,Conv3D:vg,Conv3DBackpropFilterV2:h0,Conv3DBackpropInputV2:d0,Cos:Pf,Cosh:Ff,CropAndResize:p0,Cumprod:f0,Cumsum:bg,DataStorage:Nx,DenseBincount:m0,DepthToSpace:g0,DepthwiseConv2dNative:xg,DepthwiseConv2dNativeBackpropFilter:y0,DepthwiseConv2dNativeBackpropInput:w0,Diag:v0,Dilation2D:_g,Dilation2DBackpropFilter:$y,Dilation2DBackpropInput:Sy,Draw:b0,get ENV(){return Dx},Einsum:x0,Elu:Mf,EluGrad:_0,Environment:dE,Equal:Ig,Erf:zf,Exp:Vf,ExpandDims:Tg,Expm1:Bf,FFT:I0,Fill:T0,FlipLeftRight:S0,Floor:Uf,FloorDiv:Wf,FromPixels:Cy,FusedBatchNorm:Sg,FusedConv2D:Fm,FusedDepthwiseConv2D:Lm,GatherNd:$0,GatherV2:$g,Greater:Cg,GreaterEqual:jf,IFFT:C0,Identity:Gf,Imag:E0,IsFinite:Hf,IsInf:qf,IsNan:Kf,KernelBackend:n0,LRN:Og,LRNGrad:N0,LeakyRelu:Eg,Less:kg,LessEqual:Ng,LinSpace:k0,Log:Xf,Log1p:Yf,LogSoftmax:mE,LogicalAnd:Ag,LogicalNot:Rg,LogicalOr:Dg,LogicalXor:Ez,LowerBound:kz,MatrixBandPart:Nz,Max:Pg,MaxPool:Fg,MaxPool3D:Lg,MaxPool3DGrad:R0,MaxPoolGrad:A0,MaxPoolWithArgmax:D0,Maximum:Qf,Mean:Mg,Min:zg,Minimum:Jf,MirrorPad:Vg,Mod:Zf,MomentumOptimizer:K_,Multinomial:O0,Multiply:ep,Neg:Bg,NonMaxSuppressionV3:P0,NonMaxSuppressionV4:F0,NonMaxSuppressionV5:L0,NotEqual:Ug,OP_SCOPE_SUFFIX:Px,OneHot:jg,OnesLike:Wg,Optimizer:Eu,OptimizerConstructors:Lk,Pack:Gg,PadV2:Hg,Pool:Az,Pow:tp,Prelu:qg,Prod:Kg,RMSPropOptimizer:X_,RaggedGather:M0,RaggedRange:z0,RaggedTensorToTensor:V0,Range:B0,get Rank(){return Ob},Real:U0,RealDiv:Lf,Reciprocal:np,get Reduction(){return ji},Relu:rp,Relu6:sp,Reshape:Xg,ResizeBilinear:Qg,ResizeBilinearGrad:j0,ResizeNearestNeighbor:Yg,ResizeNearestNeighborGrad:W0,Reverse:Jg,RotateWithOffset:aw,Round:ip,Rsqrt:op,SGDOptimizer:Mw,ScatterNd:G0,SearchSorted:q0,Select:Zg,Selu:ap,Sigmoid:hp,Sign:cp,Sin:lp,Sinh:up,Slice:e1,Softmax:s1,Softplus:dp,SpaceToBatchND:n1,SparseFillEmptyRows:K0,SparseReshape:X0,SparseSegmentMean:Y0,SparseSegmentSum:Q0,SparseToDense:J0,SplitV:r1,Sqrt:fp,Square:Z0,SquaredDifference:pp,StaticRegexReplace:i1,Step:vp,StridedSlice:ew,StringNGrams:tw,StringSplit:nw,StringToHashBucketFast:rw,Sub:mp,Sum:t1,Tan:gp,Tanh:yp,Tensor:Rn,TensorBuffer:ms,TensorScatterUpdate:H0,Tile:wp,TopK:sw,Transform:iw,Transpose:ph,Unique:ow,Unpack:o1,UnsortedSegmentSum:a1,UpperBound:Rz,Variable:Vm,ZerosLike:l1,_FusedMatMul:Pm,abs:fs,acos:zx,acosh:Vx,add:tt,addN:SE,all:fw,any:Um,argMax:Nh,argMin:Bx,asin:Ux,asinh:Wx,atan:jx,atan2:Gx,atanh:Hx,avgPool:u1,avgPool3d:qx,backend:Lx,backend_util:rN,basicLSTMCell:CE,batchNorm:bp,batchNorm2d:Kx,batchNorm3d:Xx,batchNorm4d:Yx,batchToSpaceND:c1,bincount:Qx,bitwiseAnd:EE,booleanMaskAsync:fk,broadcastArgs:kE,broadcastTo:gh,broadcast_util:$V,browser:eB,buffer:En,cast:gt,ceil:Jx,clipByValue:Hi,clone:Rl,complex:Iu,concat:Gr,concat1d:Zx,concat2d:e_,concat3d:t_,concat4d:n_,conv1d:mw,conv2d:Tu,conv2dTranspose:gw,conv3d:r_,conv3dTranspose:s_,copyRegisteredKernels:Pz,cos:h1,cosh:yw,cosineWindow:Lw,cumprod:Wm,cumsum:ww,customGrad:Ml,denseBincount:Dy,deprecationWarn:nV,depthToSpace:i_,depthwiseConv2d:xp,device_util:Qz,diag:AE,dilation2d:o_,disableDeprecationWarnings:tV,dispose:en,disposeVariables:rV,div:St,divNoNan:a_,dot:l_,dropout:O_,einsum:rh,elu:_p,enableDebugMode:eV,enableProdMode:Zz,enclosingPowerOfTwo:P_,engine:Ya,ensureShape:RE,env:De,equal:No,erf:vw,euclideanNorm:u_,exp:ki,expandDims:os,expm1:c_,eye:bw,fft:S1,fill:Hh,findBackend:uV,findBackendFactory:cV,floor:Tp,floorDiv:dw,fused:bk,gather:Sp,gatherND:yk,gather_util:tB,getBackend:bE,getGradient:Db,getKernel:zm,getKernelsForBackend:ky,grad:kV,grads:NV,greater:Ki,greaterEqual:$u,ifft:rf,imag:d1,image:Ci,inTopKAsync:wk,io:Y_,irfft:Dw,isFinite:h_,isInf:d_,isNaN:f_,keep:Ts,kernel_impls:OB,leakyRelu:f1,less:Zd,lessEqual:bc,linalg:W_,linspace:OE,localResponseNormalization:p_,log:Ao,log1p:p1,logSigmoid:g_,logSoftmax:xw,logSumExp:m1,logicalAnd:ka,logicalNot:g1,logicalOr:_w,logicalXor:y_,losses:Tk,lowerBound:FE,matMul:An,math:QV,max:ra,maxPool:y1,maxPool3d:w_,maxPoolWithArgmax:LE,maximum:Gl,mean:Wr,memory:Pb,meshgrid:ME,min:Jd,minimum:uc,mirrorPad:v_,mod:b_,moments:w1,movingAverage:pk,mul:be,multiRNNCell:zE,multinomial:VE,neg:$r,nextFrame:e4,norm:Ip,notEqual:Rh,oneHot:ef,ones:fo,onesLike:Ro,op:ve,outerProduct:BE,pad:Cu,pad1d:UE,pad2d:WE,pad3d:jE,pad4d:GE,pool:x_,pow:Ll,prelu:b1,print:Mx,prod:__,profile:sV,raggedGather:HE,raggedRange:qE,raggedTensorToTensor:KE,rand:XE,randomGamma:ZE,randomNormal:Tw,randomStandardNormal:ek,randomUniform:xc,randomUniformInt:tk,range:Dh,ready:aV,real:tf,reciprocal:I_,registerBackend:Fx,registerGradient:gE,registerKernel:lw,relu:ol,relu6:Sw,removeBackend:lV,reshape:Ie,reverse:ia,reverse1d:nk,reverse2d:rk,reverse3d:sk,reverse4d:ik,rfft:$1,round:$w,rsqrt:Cw,scalar:Xt,scatterND:mk,scatter_util:FV,searchSorted:Iw,selu:Ew,separableConv2d:kw,serialization:jV,setBackend:oV,setPlatform:hV,setdiff1dAsync:ok,sigmoid:Ca,sign:T_,signal:Ik,sin:Nw,sinh:Aw,slice:cn,slice1d:_1,slice2d:Rw,slice3d:I1,slice4d:nf,slice_util:Pk,softmax:T1,softplus:Kh,spaceToBatchND:v1,sparse:Sk,sparseToDense:gk,spectral:_k,split:po,sqrt:js,square:wr,squaredDifference:Ow,squeeze:Vr,stack:qi,step:Xh,stridedSlice:S_,string:$k,sub:$t,sum:Ot,sumOutType:cw,tan:$_,tanh:lc,tensor:Eo,tensor1d:Zr,tensor2d:rl,tensor3d:C_,tensor4d:ak,tensor5d:lk,tensor6d:uk,tensorScatterUpdate:hk,tensor_util:Xz,test_util:PV,tidy:ke,tile:na,time:iV,topk:k_,train:Qc,transpose:Mn,truncatedNormal:Pw,unique:N_,unregisterGradient:Oz,unregisterKernel:Dz,unsortedSegmentSum:Fw,unstack:oa,upcastType:go,upperBound:dk,util:Wz,valueAndGrad:AV,valueAndGrads:RV,variable:A_,variableGrads:PE,version_core:Fk,where:Bs,whereAsync:D_,zeros:ps,zerosLike:jn},Symbol.toStringTag,{value:"Module"}));const PB={kernelName:og,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(t,Xh(gt(n,"float32"),-1))}}};const nde={kernelName:Sf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=wr(gt(n,"float32")),s=js($t(Xt(1),r));return $r(St(t,s))}}}};const rde={kernelName:$f,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=js($t(wr(gt(n,"float32")),1));return St(t,r)}}}};const sde={kernelName:Uh,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=_n(n.shape,r.shape);return{a:()=>{let a=t;const l=$s(n.shape,s);return l.length>0&&(a=Ot(a,l)),Ie(a,n.shape)},b:()=>{let a=t;const l=$s(r.shape,s);return l.length>0&&(a=Ot(a,l)),Ie(a,r.shape)}}}};const ide={kernelName:ag,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((r,s)=>{n[s]=()=>t.clone()}),n}};const ode={kernelName:lg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>jn(n)}}};const ade={kernelName:ug,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>jn(n)}}};const lde={kernelName:Cf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,js($t(Xt(1),wr(gt(n,"float32")))))}}};const ude={kernelName:Ef,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=js(tt(Xt(1),wr(gt(n,"float32"))));return St(t,r)}}}};const cde={kernelName:Af,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=_n(n.shape,r.shape);return{a:()=>{const a=tt(wr(n),wr(r));let l=be(t,St(r,a));const u=$s(n.shape,s);return u.length>0&&(l=Ot(l,u)),Ie(l,n.shape)},b:()=>{const a=tt(wr(n),wr(r));let l=$r(be(t,St(n,a)));const u=$s(r.shape,s);return u.length>0&&(l=Ot(l,u)),Ie(l,r.shape)}}}};const hde={kernelName:kf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,tt(wr(gt(n,"float32")),1))}}};const dde={kernelName:Nf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,$t(Xt(1),wr(gt(n,"float32"))))}}};function fde(t,e,n,r,s,i){const o=ee(t,"dy","avgPool3dGrad"),a=ee(e,"input","avgPool3dGrad");let l=o,u=a,c=!1;a.rank===4&&(c=!0,l=Ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=Ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),J(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),J(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),wo("avgPool3dGrad",s,i);const d={dy:l,input:u},f={filterSize:n,strides:r,pad:s,dimRoundingMode:i},m=we.runKernel(o0,d,f);return c?Ie(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const pde=ve({avgPool3dGrad_:fde});const mde={kernelName:hg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=n;return{x:()=>pde(t,r,s,i,o,a)}}};function gde(t,e,n,r,s){const i=ee(t,"dy","avgPoolGrad"),o=ee(e,"input","avgPoolGrad");J(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;o.rank===3&&(u=!0,a=Ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=Ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),J(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},d={filterSize:n,strides:r,pad:s},f=we.runKernel(i0,c,d);return u?Ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const yde=ve({avgPoolGrad_:gde});const wde={kernelName:cg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,pad:o}=n;return{x:()=>yde(t,r,s,i,o)}}};const vde={kernelName:dg,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,s]=e,{transposeA:i,transposeB:o}=n;return!i&&!o?{a:()=>An(t,s,!1,!0),b:()=>An(r,t,!0,!1)}:!i&&o?{a:()=>An(t,s,!1,!1),b:()=>An(t,r,!0,!1)}:i&&!o?{a:()=>An(s,t,!1,!0),b:()=>An(r,t,!1,!1)}:{a:()=>An(s,t,!0,!0),b:()=>An(t,r,!0,!0)}}};const bde={kernelName:fg,gradFunc:(t,e,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>v1(t,r,s)}}};const xde={kernelName:pE,gradFunc:(t,e,n)=>{const r=n,s=r.inputShape,i=r.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Ot(t,a,!0)}}};const _de={kernelName:Rf,gradFunc:t=>({x:()=>t.clone()})};const Ide={kernelName:Df,gradFunc:t=>({x:()=>jn(t)})};const Tde={kernelName:Of,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:s,clipValueMax:i}=n;return{x:()=>Bs(ka($u(r,s),bc(r,i)),t,jn(t))}}};const Sde={kernelName:mg,inputsToSave:["x"],gradFunc:PB.gradFunc};const $de={kernelName:gg,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map(l=>l.shape),{axis:s}=n,i=On(s,e[0].shape)[0],o=r.map(l=>l[i]);return po(t,o,i).map(l=>()=>l)}};const Cde={kernelName:yg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=n;return J(Ah(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>NE(r.shape,t,s,o,a,l),filter:()=>vk(r,t,s.shape,o,a,l)}}};const Ede={kernelName:wg,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>Tu(t,s,i,o,a,1,l),filter:()=>vk(t,r,s.shape,i,o,a,l)}}};function kde(t,e,n,r,s){let i=t;t.rank===4&&(i=Ie(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;o.rank===4&&(o=Ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),J(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),J(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),J(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),J(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),J(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);const a={x:i,dy:o},l={strides:r,pad:s,filterShape:n};return we.runKernel(h0,a,l)}const Nde=ve({conv3DBackpropFilter_:kde});const Ade={kernelName:vg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i}=n;J(Ah(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>SV(o.shape,t,a,s,i),filter:()=>Nde(o,t,a.shape,s,i)}}};const Rde={kernelName:Pf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be($r(Nw(gt(n,"float32"))),t)}}};const Dde={kernelName:Ff,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(Aw(gt(n,"float32")),t)}}};const Ode={kernelName:bg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s,exclusive:i,reverse:o}=n;return{x:()=>{const a=ns([s],r.rank);let l=ww(t,s,i,!o);return a!=null&&(l=Mn(l,a)),l}}}};const Pde={kernelName:xg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=n,a=r??[1,1];J(Ah(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return J(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),J(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),J(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),J(Ai(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),wo("depthwiseConv2d",i,o),{x:()=>zV(l.shape,t,u,s,i,a,o),filter:()=>MV(l,t,u.shape,s,i,a,o)}}};const Fde={kernelName:_g,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,i={x:r,filter:s,dy:t},o={x:r,filter:s,dy:t};return{x:()=>we.runKernel(Sy,i,n),filter:()=>we.runKernel($y,o,n)}}};const Lde={kernelName:Mf,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>we.runKernel(_0,r)}}};const Mde={kernelName:zf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=be(ki($r(wr(n))),2/Math.sqrt(Math.PI));return{x:()=>be(t,r)}}};const zde={kernelName:Vf,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(t,n)}}};const Vde={kernelName:Tg,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>Ie(t,n.shape)}}};const Bde={kernelName:Bf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(t,ki(n))}}};const Ude={kernelName:Uf,gradFunc:t=>({x:()=>jn(t)})};const Wde={kernelName:Wf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=_n(n.shape,r.shape);return{a:()=>{const a=St(t,gt(r,"float32")),l=$s(n.shape,s);return l.length>0?Ie(Ot(a,l),n.shape):a},b:()=>{let a=be(t,gt(n,"float32"));const l=$s(r.shape,s);l.length>0&&(a=Ie(Ot(a,l),r.shape));const u=wr(r);return $r(St(a,gt(u,"float32")))}}}};const jde={kernelName:Sg,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[s,i,o,a]=e,l=a??Xt(1),u=$s(i.shape,s.shape),c=[];if(i.rank===1){for(let S=0;S<s.shape.length-1;++S)c.push(s.shape[S]);c.push(1)}const d=$t(s,i),f=be(t,l),m=Cw(tt(o,Xt(r))),g=be(be(be(m,m),m),Xt(-.5));return{x:()=>i.rank===1?Ie(be(be(t,na(Ie(m,[1,1,1,i.shape[0]]),c)),l),s.shape):Ie(be(be(t,m),l),s.shape),mean:()=>{let S=be(be(m,Xt(-1)),f);return i.rank===1&&(S=Ot(S,u)),Ie(S,i.shape)},variance:()=>{let S=be(be(g,d),f);return i.rank===1&&(S=Ot(S,u)),Ie(S,i.shape)},scale:()=>{const S=be(d,m);let E=be(t,S);return i.rank===1&&(E=Ot(E,u)),Ie(E,i.shape)},offset:()=>{let S=t;return i.rank===1&&(S=Ot(S,u)),Ie(S,i.shape)}}}};const Gde={kernelName:$g,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,s]=e,{axis:i,batchDims:o}=n,a=On(i,r.shape)[0],l=(u,c,d)=>()=>{const f=u.shape,m=c.size,g=f.slice(0,a),y=g.length,v=f.slice(i,f.length).slice(1),b=v.length,x=RO(0,y),$=RO(y+1,y+1+b),S=DO([g,[m],v]),E=Ie(d,S),L=Ie(c,[m]),R=DO([[y],x,$]),D=Mn(E,R);let A=Fw(D,L,u.shape[a]);const F=qh(R);return A=Mn(A,F),A};if(o===1){const u=r.shape[0],c=r.split(u,0);return{x:()=>qi(c.map((m,g)=>l(m,s.slice(g,1),t.slice(g,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,t),indices:()=>s}}};function RO(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function DO(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const Hde={kernelName:jf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>jn(n),b:()=>jn(r)}}};const qde={kernelName:Gf,gradFunc:t=>({x:()=>gt(t,"float32")})};const Kde={kernelName:Hf,gradFunc:t=>({x:()=>jn(t)})};const Xde={kernelName:qf,gradFunc:t=>({x:()=>jn(t)})};const Yde={kernelName:Kf,gradFunc:t=>({x:()=>jn(t)})};const Qde={kernelName:Eg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:s}=n,i=Ki(r,0);return{x:()=>Bs(i,t,be(t,s))}}};const Jde={kernelName:Yf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,tt(n,1))}}};const Zde={kernelName:Xf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,gt(n,"float32"))}}};const efe={kernelName:mE,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n;return{logits:()=>{const o=ki(r);return $t(t,be(Ot(t,s,!0),o))}}}};function tfe(t,e,n,r=5,s=1,i=1,o=.5){const a={x:t,y:e,dy:n},l={depthRadius:r,bias:s,alpha:i,beta:o};return we.runKernel(N0,a,l)}const nfe=ve({localResponseNormalizationBackprop_:tfe});const rfe={kernelName:Og,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=n;return{x:()=>nfe(r,s,t,i,o,a,l)}}};function FB(t,e,n,r){return e.rank<n.rank&&(e=Ie(e,gs(e.shape,r))),t.rank<n.rank&&(t=Ie(t,gs(t.shape,r))),{x:()=>be(t,gt(No(n,e),t.dtype))}}const OO={kernelName:Pg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:s}=r,i=e[0],o=e[1],a=On(s,i.shape),l=FB(t,o,i,a);return{x:()=>l.x()}}};const sfe={kernelName:Qf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>be(t,gt($u(n,r),"float32")),b:()=>be(t,gt(Zd(n,r),"float32"))}}};function ife(t,e,n,r,s,i,o){const a=ee(t,"dy","maxPool3dGrad"),l=ee(e,"input","maxPool3dGrad"),u=ee(n,"output","maxPool3dGrad");let c=a,d=l,f=u,m=!1;l.rank===4&&(m=!0,c=Ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=Ie(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=Ie(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),J(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),J(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),J(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),wo("maxPool3dGrad",i,o);const g={dy:c,input:d,output:f},y={filterSize:r,strides:s,pad:i,dimRoundingMode:o},v=we.runKernel(R0,g,y);return m?Ie(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}const ofe=ve({maxPool3dGrad_:ife});const afe={kernelName:Lg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n;return{x:()=>ofe(t,r,s,i,o,a,l)}}};function lfe(t,e,n,r,s,i,o){const a=ee(t,"dy","maxPoolGrad"),l=ee(e,"input","maxPoolGrad"),u=ee(n,"output","maxPoolGrad");J(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),J(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),J(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),wo("maxPoolGrad",i,o);const c={dy:a,input:l,output:u},d={filterSize:r,strides:s,pad:i,dimRoundingMode:o};return we.runKernel(A0,c,d)}const ufe=ve({maxPoolGrad_:lfe});const cfe={kernelName:Fg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a}=n;return{x:()=>ufe(t,r,s,i,o,a)}}};const hfe={kernelName:Mg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n,i=On(s,r.shape),a=li(r.shape,i)[1],l=Ue(a);return{x:()=>{const c=r.shape.slice();i.forEach(m=>{c[m]=1});const d=Ie(t,c);return St(be(d,fo(r.shape,"float32")),l)}}}};const dfe={kernelName:zg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:s}=r,[i,o]=e,a=On(s,i.shape),l=FB(t,o,i,a);return{x:()=>l.x()}}};const ffe={kernelName:Jf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>be(t,gt(bc(n,r),"float32")),b:()=>be(t,gt(Ki(n,r),"float32"))}}};const pfe={kernelName:Vg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,i=s.map(o=>o[0]);return{x:()=>cn(t,i,r.shape)}}};const mfe={kernelName:Zf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=_n(n.shape,r.shape);return{a:()=>{const a=$s(n.shape,s);return a.length>0?Ie(Ot(t,a),n.shape):t},b:()=>{const a=be(t,$r(Tp(St(n,r)))),l=$s(r.shape,s);return l.length>0?Ie(Ot(a,l),r.shape):a}}}};const gfe={kernelName:ep,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=_n(n.shape,r.shape);return{a:()=>{const a=be(t,gt(r,"float32")),l=$s(n.shape,s);return l.length>0?Ie(Ot(a,l),n.shape):a},b:()=>{const a=be(t,gt(n,"float32")),l=$s(r.shape,s);return l.length>0?Ie(Ot(a,l),r.shape):a}}}};const yfe={kernelName:Bg,gradFunc:t=>({x:()=>$r(t)})};const wfe={kernelName:jg,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>ps(n.shape,"float32")}}};const vfe={kernelName:Wg,gradFunc:t=>({x:()=>jn(t)})};const bfe={kernelName:Gg,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return oa(t,r).map(i=>()=>i)}};const PO={kernelName:Hg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,i=s.map(o=>o[0]);return{x:()=>cn(t,i,r.shape)}}};const xfe={kernelName:tp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,s]=e,i=n,o=r,a=_n(i.shape,o.shape);return{a:()=>{const c=gt(o,"float32");let d=be(t,be(c,Ll(i,$t(c,Xt(1)))));const f=$s(i.shape,a);return f.length>0&&(d=Ot(d,f)),Ie(d,i.shape)},b:()=>{const c=Ki(i,0),d=Bs(c,Ao(i),jn(i));let f=be(t,be(s,d));const m=$s(o.shape,a);return m.length>0&&(f=Ot(f,m)),Ie(f,o.shape)}}}};const _fe={kernelName:qg,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,s=Ki(n,0);return{x:()=>Bs(s,t,be(t,r)),alpha:()=>{let i=Bs(s,jn(t),be(t,n));const o=$s(r.shape,t.shape);return o.length>0&&(i=Ot(i,o)),Ie(i,r.shape)}}}};function Ife(t,e,n){const r=t.shape.slice();r[n]=1;const s=Ie(e,r),i=Wm(t,n,!0,!1),o=Wm(t,n,!0,!0),a=be(i,o);return be(s,a)}function Tfe(t,e,n){const r=t.shape.length,s=r-n.length,i=ns(n,r);let o=t;i!=null&&(o=Mn(t,i));const a=o.shape.slice(),u=a.splice(r-n.length,n.length).reduce((f,m)=>f*m,1);a.push(u);const c=o.reshape(a);let d=Ife(c,e,s);if(d=d.reshape(o.shape),i!=null){const f=qh(i);d=Mn(d,f)}return d}const Sfe={kernelName:Kg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n;let i=[];return s==null?i=r.shape.map((o,a)=>a):typeof s=="number"?i=[s]:i=s,{x:()=>Tfe(r,t,i)}}};const $fe={kernelName:Lf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=_n(n.shape,r.shape);return{a:()=>{const a=St(t,gt(r,"float32")),l=$s(n.shape,s);return l.length>0?Ie(Ot(a,l),n.shape):a},b:()=>{let a=be(t,gt(n,"float32"));const l=$s(r.shape,s);l.length>0&&(a=Ie(Ot(a,l),r.shape));const u=wr(r);return $r(St(a,gt(u,"float32")))}}}};const Cfe={kernelName:np,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,$r(wr(n)))}}};const Efe={kernelName:sp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=be(bc(n,6),Xh(n));return{x:()=>be(t,gt(r,"float32"))}}};const kfe={kernelName:rp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(t,gt(Xh(n),"float32"))}}};const Nfe={kernelName:Xg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ie(t,n.shape)}}};const Afe={kernelName:Qg,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s={dy:t,images:r};return{images:()=>we.runKernel(j0,s,n)}}};const Rfe={kernelName:Yg,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s={dy:t,images:r};return{images:()=>we.runKernel(W0,s,n)}}};const Dfe={kernelName:Jg,gradFunc:(t,e,n)=>{const{dims:r}=n,s=On(r,t.shape);return{x:()=>ia(t,s)}}};const Ofe={kernelName:ip,gradFunc:t=>({x:()=>jn(t)})};const Pfe={kernelName:op,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$r(St(t,be(Ll(n,1.5),2)))}}};const Ffe={kernelName:Zg,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>gt(jn(n),"float32"),t:()=>be(t,gt(n,t.dtype)),e:()=>be(t,gt(g1(n),t.dtype))}}};const Lfe={kernelName:ap,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const r=Ki(n,Xt(0)),s=Xt(n4),i=Xt(r4),o=be(t,i),a=be(be(t,s),ki(gt(n,"float32")));return Bs(r,o,a)}}}};const Mfe={kernelName:hp,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(t,be(n,$t(Xt(1),n)))}}};const zfe={kernelName:cp,gradFunc:t=>({x:()=>jn(t)})};const Vfe={kernelName:lp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(h1(gt(n,"float32")),t)}}};const Bfe={kernelName:up,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(yw(gt(n,"float32")),t)}}};const Ufe={kernelName:e1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:s,size:i}=n,o=r.shape,[a,l]=Z_(r,s,i),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>Cu(t,u)}}};const Wfe={kernelName:s1,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:s}=n,i=!0,o=be(t,r);return{logits:()=>$t(o,be(Ot(o,[s],i),r))}}};const jfe={kernelName:dp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(t,Ca(n))}}};const FO={kernelName:n1,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>c1(t,r,s)}}};const LO={kernelName:r1,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Gr(t,r)}}};const Gfe={kernelName:fp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,be(js(gt(n,"float32")),2))}}};const Hfe={kernelName:Z0,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be(t,be(gt(n,"float32"),2))}}};const qfe={kernelName:pp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Xt(2);return{a:()=>be(t,be(s,$t(n,r))),b:()=>be(t,be(s,$t(r,n)))}}};const Kfe={kernelName:vp,gradFunc:t=>({x:()=>jn(t)})};const Xfe={kernelName:mp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=_n(n.shape,r.shape);return{a:()=>{let a=t;const l=$s(n.shape,s);return l.length>0&&(a=Ot(a,l)),Ie(a,n.shape)},b:()=>{let a=t;const l=$s(r.shape,s);return l.length>0&&(a=Ot(a,l)),Ie($r(a),r.shape)}}}};const Yfe={kernelName:t1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,s=r.shape.slice(),{axis:i}=n;On(i,r.shape).forEach(u=>{s[u]=1});const a=Ie(t,s),l=be(a,fo(r.shape,"float32"));return{x:()=>l}}};const Qfe={kernelName:gp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>St(t,wr(h1(n)))}}};const Jfe={kernelName:yp,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>be($t(Xt(1),wr(n)),t)}}};const Zfe={kernelName:wp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:s}=n;return{x:()=>{let o=jn(r);if(r.rank===1)for(let a=0;a<s[0];++a)o=tt(o,cn(t,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=tt(o,cn(t,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)o=tt(o,cn(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)o=tt(o,cn(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}};const epe={kernelName:ph,gradFunc:(t,e,n)=>{const r=n,{perm:s}=r,i=qh(s);return{x:()=>Mn(t,i)}}};const tpe={kernelName:o1,gradFunc:(t,e,n)=>{const r=n,{axis:s}=r;return{value:()=>qi(t,s)}}};const npe={kernelName:a1,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>rpe(t,n)}}};function rpe(t,e){const n=Gl(e,jn(e)),r=Sp(t,n);let s=$u(e,Xt(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=os(s,a+1);s=ka(s,fo(r.shape,"bool"));const o=jn(r);return Bs(s,r,o)}const spe={kernelName:l1,gradFunc:t=>({x:()=>jn(t)})};const ipe=[PB,nde,rde,sde,ide,ode,ade,lde,ude,cde,hde,dde,mde,wde,vde,bde,xde,_de,Ide,Tde,Sde,$de,Ede,Cde,Ade,Rde,Dde,Ode,Pde,Fde,$fe,Lde,Mde,zde,Vde,Bde,Wde,Ude,jde,Gde,Hde,qde,Kde,Xde,Yde,Qde,Jde,Zde,efe,rfe,OO,OO,sfe,afe,cfe,hfe,dfe,ffe,pfe,mfe,gfe,yfe,wfe,vfe,bfe,PO,PO,xfe,_fe,Sfe,Cfe,Efe,kfe,Nfe,Afe,Rfe,Dfe,Ofe,Pfe,Ffe,Lfe,Mfe,zfe,Vfe,Bfe,Ufe,Wfe,jfe,FO,FO,LO,LO,Gfe,qfe,Hfe,Kfe,Xfe,Yfe,Qfe,Jfe,Zfe,epe,tpe,npe,spe];for(const t of ipe)gE(t);Ke().prototype.abs=function(){return this.throwIfDisposed(),fs(this)};Ke().prototype.acos=function(){return this.throwIfDisposed(),zx(this)};Ke().prototype.acosh=function(){return this.throwIfDisposed(),Vx(this)};Ke().prototype.add=function(t){return this.throwIfDisposed(),tt(this,t)};Ke().prototype.all=function(t,e){return this.throwIfDisposed(),fw(this,t,e)};Ke().prototype.any=function(t,e){return this.throwIfDisposed(),Um(this,t,e)};Ke().prototype.argMax=function(t){return this.throwIfDisposed(),Nh(this,t)};Ke().prototype.argMin=function(t){return this.throwIfDisposed(),Bx(this,t)};Ke().prototype.asScalar=function(){return this.throwIfDisposed(),J(this.size===1,()=>"The array must have only 1 element."),Ie(this,[])};Ke().prototype.asType=function(t){return this.throwIfDisposed(),gt(this,t)};Ke().prototype.as1D=function(){return this.throwIfDisposed(),Ie(this,[this.size])};Ke().prototype.as2D=function(t,e){return this.throwIfDisposed(),Ie(this,[t,e])};Ke().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),Ie(this,[t,e,n])};Ke().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),Ie(this,[t,e,n,r])};Ke().prototype.as5D=function(t,e,n,r,s){return this.throwIfDisposed(),Ie(this,[t,e,n,r,s])};Ke().prototype.asin=function(){return this.throwIfDisposed(),Ux(this)};Ke().prototype.asinh=function(){return this.throwIfDisposed(),Wx(this)};Ke().prototype.atan=function(){return this.throwIfDisposed(),jx(this)};Ke().prototype.atan2=function(t){return this.throwIfDisposed(),Gx(this,t)};Ke().prototype.atanh=function(){return this.throwIfDisposed(),Hx(this)};Ke().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),u1(this,t,e,n,r)};Ke().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),c1(this,t,e)};Ke().prototype.batchNorm=function(t,e,n,r,s){return this.throwIfDisposed(),bp(this,t,e,n,r,s)};Ke().prototype.broadcastTo=function(t){return this.throwIfDisposed(),gh(this,t)};Ke().prototype.cast=function(t){return this.throwIfDisposed(),gt(this,t)};Ke().prototype.ceil=function(){return this.throwIfDisposed(),Jx(this)};Ke().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Hi(this,t,e)};Ke().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Rn&&(t=[t]),Gr([this,...t],e)};Ke().prototype.conv1d=function(t,e,n,r,s,i){return this.throwIfDisposed(),mw(this,t,e,n,r,s,i)};Ke().prototype.conv2dTranspose=function(t,e,n,r,s){return this.throwIfDisposed(),gw(this,t,e,n,r,s)};Ke().prototype.conv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),Tu(this,t,e,n,r,s,i)};Ke().prototype.cos=function(){return this.throwIfDisposed(),h1(this)};Ke().prototype.cosh=function(){return this.throwIfDisposed(),yw(this)};Ke().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),Wm(this,t,e,n)};Ke().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),ww(this,t,e,n)};Ke().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),i_(this,t,e)};Ke().prototype.depthwiseConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),xp(this,t,e,n,r,s,i)};Ke().prototype.dilation2d=function(t,e,n,r,s){return this.throwIfDisposed(),o_(this,t,e,n,r,s)};Ke().prototype.divNoNan=function(t){return this.throwIfDisposed(),a_(this,t)};Ke().prototype.div=function(t){return this.throwIfDisposed(),St(this,t)};Ke().prototype.dot=function(t){return this.throwIfDisposed(),l_(this,t)};Ke().prototype.elu=function(){return this.throwIfDisposed(),_p(this)};Ke().prototype.equal=function(t){return this.throwIfDisposed(),No(this,t)};Ke().prototype.erf=function(){return this.throwIfDisposed(),vw(this)};Ke().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),u_(this,t,e)};Ke().prototype.exp=function(){return this.throwIfDisposed(),ki(this)};Ke().prototype.expandDims=function(t){return this.throwIfDisposed(),os(this,t)};Ke().prototype.expm1=function(){return this.throwIfDisposed(),c_(this)};Ke().prototype.fft=function(){return this.throwIfDisposed(),S1(this)};Ke().prototype.flatten=function(){return this.throwIfDisposed(),Ie(this,[this.size])};Ke().prototype.floor=function(){return this.throwIfDisposed(),Tp(this)};Ke().prototype.floorDiv=function(t){return this.throwIfDisposed(),dw(this,t)};Ke().prototype.gather=function(t,e,n){return this.throwIfDisposed(),Sp(this,t,e,n)};Ke().prototype.greaterEqual=function(t){return this.throwIfDisposed(),$u(this,t)};Ke().prototype.greater=function(t){return this.throwIfDisposed(),Ki(this,t)};Ke().prototype.ifft=function(){return this.throwIfDisposed(),rf(this)};Ke().prototype.irfft=function(){return this.throwIfDisposed(),Dw(this)};Ke().prototype.isFinite=function(){return this.throwIfDisposed(),h_(this)};Ke().prototype.isInf=function(){return this.throwIfDisposed(),d_(this)};Ke().prototype.isNaN=function(){return this.throwIfDisposed(),f_(this)};Ke().prototype.leakyRelu=function(t){return this.throwIfDisposed(),f1(this,t)};Ke().prototype.lessEqual=function(t){return this.throwIfDisposed(),bc(this,t)};Ke().prototype.less=function(t){return this.throwIfDisposed(),Zd(this,t)};Ke().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),p_(this,t,e,n,r)};Ke().prototype.logSigmoid=function(){return this.throwIfDisposed(),g_(this)};Ke().prototype.logSoftmax=function(t){return this.throwIfDisposed(),xw(this,t)};Ke().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),m1(this,t,e)};Ke().prototype.log=function(){return this.throwIfDisposed(),Ao(this)};Ke().prototype.log1p=function(){return this.throwIfDisposed(),p1(this)};Ke().prototype.logicalAnd=function(t){return this.throwIfDisposed(),ka(this,t)};Ke().prototype.logicalNot=function(){return this.throwIfDisposed(),g1(this)};Ke().prototype.logicalOr=function(t){return this.throwIfDisposed(),_w(this,t)};Ke().prototype.logicalXor=function(t){return this.throwIfDisposed(),y_(this,t)};Ke().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),An(this,t,e,n)};Ke().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),y1(this,t,e,n,r)};Ke().prototype.max=function(t,e){return this.throwIfDisposed(),ra(this,t,e)};Ke().prototype.maximum=function(t){return this.throwIfDisposed(),Gl(this,t)};Ke().prototype.mean=function(t,e){return this.throwIfDisposed(),Wr(this,t,e)};Ke().prototype.min=function(t,e){return this.throwIfDisposed(),Jd(this,t,e)};Ke().prototype.minimum=function(t){return this.throwIfDisposed(),uc(this,t)};Ke().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),v_(this,t,e)};Ke().prototype.mod=function(t){return this.throwIfDisposed(),b_(this,t)};Ke().prototype.mul=function(t){return this.throwIfDisposed(),be(this,t)};Ke().prototype.neg=function(){return this.throwIfDisposed(),$r(this)};Ke().prototype.norm=function(t,e,n){return this.throwIfDisposed(),Ip(this,t,e,n)};Ke().prototype.notEqual=function(t){return this.throwIfDisposed(),Rh(this,t)};Ke().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),ef(this,t,e,n)};Ke().prototype.onesLike=function(){return this.throwIfDisposed(),Ro(this)};Ke().prototype.pad=function(t,e){return this.throwIfDisposed(),Cu(this,t,e)};Ke().prototype.pool=function(t,e,n,r,s,i){return this.throwIfDisposed(),x_(this,t,e,n,r,s,i)};Ke().prototype.pow=function(t){return this.throwIfDisposed(),Ll(this,t)};Ke().prototype.prelu=function(t){return this.throwIfDisposed(),b1(this,t)};Ke().prototype.prod=function(t,e){return this.throwIfDisposed(),__(this,t,e)};Ke().prototype.reciprocal=function(){return this.throwIfDisposed(),I_(this)};Ke().prototype.relu=function(){return this.throwIfDisposed(),ol(this)};Ke().prototype.relu6=function(){return this.throwIfDisposed(),Sw(this)};Ke().prototype.reshapeAs=function(t){return this.throwIfDisposed(),Ie(this,t.shape)};Ke().prototype.reshape=function(t){return this.throwIfDisposed(),Ie(this,t)};Ke().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),UV(this,t,e,n)};Ke().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),WV(this,t,e,n)};Ke().prototype.reverse=function(t){return this.throwIfDisposed(),ia(this,t)};Ke().prototype.rfft=function(){return this.throwIfDisposed(),$1(this)};Ke().prototype.round=function(){return this.throwIfDisposed(),$w(this)};Ke().prototype.rsqrt=function(){return this.throwIfDisposed(),Cw(this)};Ke().prototype.selu=function(){return this.throwIfDisposed(),Ew(this)};Ke().prototype.separableConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),kw(this,t,e,n,r,s,i)};Ke().prototype.sigmoid=function(){return this.throwIfDisposed(),Ca(this)};Ke().prototype.sign=function(){return this.throwIfDisposed(),T_(this)};Ke().prototype.sin=function(){return this.throwIfDisposed(),Nw(this)};Ke().prototype.sinh=function(){return this.throwIfDisposed(),Aw(this)};Ke().prototype.slice=function(t,e){return this.throwIfDisposed(),cn(this,t,e)};Ke().prototype.softmax=function(t){return this.throwIfDisposed(),T1(this,t)};Ke().prototype.softplus=function(){return this.throwIfDisposed(),Kh(this)};Ke().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),v1(this,t,e)};Ke().prototype.split=function(t,e){return this.throwIfDisposed(),po(this,t,e)};Ke().prototype.sqrt=function(){return this.throwIfDisposed(),js(this)};Ke().prototype.square=function(){return this.throwIfDisposed(),wr(this)};Ke().prototype.squaredDifference=function(t){return this.throwIfDisposed(),Ow(this,t)};Ke().prototype.squeeze=function(t){return this.throwIfDisposed(),Vr(this,t)};Ke().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Rn?[this,t]:[this,...t];return qi(n,e)};Ke().prototype.step=function(t){return this.throwIfDisposed(),Xh(this,t)};Ke().prototype.stridedSlice=function(t,e,n,r,s,i,o,a){return this.throwIfDisposed(),S_(this,t,e,n,r,s,i,o,a)};Ke().prototype.sub=function(t){return this.throwIfDisposed(),$t(this,t)};Ke().prototype.sum=function(t,e){return this.throwIfDisposed(),Ot(this,t,e)};Ke().prototype.tan=function(){return this.throwIfDisposed(),$_(this)};Ke().prototype.tanh=function(){return this.throwIfDisposed(),lc(this)};Ke().prototype.tile=function(t){return this.throwIfDisposed(),na(this,t)};Ke().prototype.toBool=function(){return this.throwIfDisposed(),gt(this,"bool")};Ke().prototype.toFloat=function(){return this.throwIfDisposed(),gt(this,"float32")};Ke().prototype.toInt=function(){return this.throwIfDisposed(),gt(this,"int32")};Ke().prototype.topk=function(t,e){return this.throwIfDisposed(),k_(this,t,e)};Ke().prototype.transpose=function(t){return this.throwIfDisposed(),Mn(this,t)};Ke().prototype.unique=function(t){return this.throwIfDisposed(),N_(this,t)};Ke().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),Fw(this,t,e)};Ke().prototype.unstack=function(t){return this.throwIfDisposed(),oa(this,t)};Ke().prototype.where=function(t,e){return this.throwIfDisposed(),Bs(t,this,e)};Ke().prototype.zerosLike=function(){return this.throwIfDisposed(),jn(this)};class ru extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ru.prototype)}}class nl extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nl.prototype)}}class $e extends Error{constructor(e){super(e),Object.setPrototypeOf(this,$e.prototype)}}class Nn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Nn.prototype)}}class sN extends Error{constructor(e){super(e),Object.setPrototypeOf(this,sN.prototype)}}class LB{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let n;return this.cache.has(e)&&(n=this.cache.get(e),this.cache.delete(e),this.cache.set(e,n)),n}put(e,n){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let n=0;n<this.maxEntries-e;n++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}function of(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}else{const n=new Array(e);return n.fill(t),n}}function su(t,e){if(!t)throw new sN(e)}function MO(t,e){let n=0;for(const r of t)r===e&&n++;return n}function Co(t){return t.length===1?t[0]:t}function yr(t){return Array.isArray(t)?t:[t]}function Wu(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Id(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}let qa={};function iN(t){if(t==null)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function E$(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>E$(e));else{const e=Object.keys(t);for(const n of e){const r=t[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?t[n]=r.value:E$(r))}}}function Uw(t,e={},n={},r="object",s=!1){if(typeof t=="string"){const i=t;let o;if(i in n)o=n[i];else if(i in qa)o=qa[i];else if(o=e[i],o==null)throw new $e(`Unknown ${r}: ${t}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=t;if(i.className==null||i.config==null)throw new $e(`${r}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in n?[a,l]=n[o]:o in qa?[a,l]=qa.className:o in e&&([a,l]=e[o]),a==null)throw new $e(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const m of Object.keys(qa))u[m]=qa[m];for(const m of Object.keys(n))u[m]=n[m];const c=i.config;c.customObjects=u;const d=Object.assign({},qa);for(const m of Object.keys(n))qa[m]=n[m];E$(i.config);const f=l(a,i.config,n,s);return qa=Object.assign({},d),f}else{const u=Object.assign({},qa);for(const d of Object.keys(n))qa[d]=n[d];const c=new a(i.config);return qa=Object.assign({},u),c}}}function ope(t,e){return t<e?-1:t>e?1:0}function uv(t,e){return-1*ope(t,e)}function yh(t){if(t==null)return t;const e=[];for(const n of t)e.indexOf(n)===-1&&e.push(n);return e}function ape(t){if(t==null)throw new $e(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Cp(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new $e(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function oN(t,e,n=0,r=1/0){return su(n>=0),su(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every(s=>typeof s===e)}function ni(t,e){Array.isArray(t)?(J(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,r)=>ni(n,`element ${r+1} of ${e}`))):J(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${MB(t)}.`)}function MB(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>MB(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function lpe(t,e,n){let r=n!=null?n():Ti(),s;return(...o)=>{const a=n!=null?n():Ti();return a-r<e||(r=a,s=t(...o)),s}}function zB(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}let upe=0;function VB(){return upe++}const cv={};function s4(t=""){return t in cv||(cv[t]=0),cv[t]+=1,t+cv[t].toString()}const cpe=["channelsFirst","channelsLast"],hpe=["nearest","bilinear"],dpe=["valid","same","causal"],fpe=["max","avg"],ppe=["sum","mul","concat","ave"];const lm=new Map;function ws(t){Cp(cpe,"DataFormat",t)}function mpe(t){Cp(hpe,"InterpolationFormat",t)}function Na(t){Cp(dpe,"PaddingMode",t)}function BB(t){Cp(fpe,"PoolMode",t)}const dy=[],zO="/";function Ld(t,e){dy.push(t);try{const n=e();return dy.pop(),n}catch(n){throw dy.pop(),n}}function gpe(){return dy.length===0?"":dy.join(zO)+zO}function UB(t){if(!jB(t))throw new Error("Not a valid tensor name: '"+t+"'");return gpe()+t}function WB(t){if(!jB(t))throw new Error("Not a valid tensor name: '"+t+"'");lm.has(t)||lm.set(t,0);const e=lm.get(t);if(lm.set(t,lm.get(t)+1),e>0){const n=`${t}_${e}`;return lm.set(n,1),n}else return t}const ype=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function jB(t){return!!t.match(ype)}function wpe(t){return t===parseInt(t.toString(),10)}function wh(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let r=1;for(let s=e;s<n;++s)r*=t[s];return r}function jm(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function Oh(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function zl(t,e){if(e<t)throw new $e(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let r=t;r<e;++r)n.push(r);return n}let xT;function Vs(){return xT==null&&(xT=Lx().epsilon()),xT}function Vl(){return"channelsLast"}function yu(t,e){return gt(t,e)}function Ww(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),Ie(t,n)}function vpe(t,e){return ke(()=>{if(t.shape.length!==2)throw new $e(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);const n=Ww(t,1);return k$(n,[1,e,1])})}function bpe(t){const e=[wh(t.shape)];return Ie(t,e)}function xpe(t){if(t.rank<=1)throw new $e(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],wh(t.shape,1)];return Ie(t,e)}function Md(t,e,n){return ke(()=>{switch(t.rank){case 1:return _1(t,e,n);case 2:return Rw(t,[e,0],[n,t.shape[1]]);case 3:return I1(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return nf(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return cn(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return cn(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new $e(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function _T(t,e,n){return ke(()=>{switch(t.rank){case 1:return _1(t,e,n);case 2:return Rw(t,[0,e],[t.shape[0],n]);case 3:return I1(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return nf(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new $e(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function hv(t,e,n,r){return ke(()=>{switch(t.rank){case 1:return _1(t,e,n);case 2:switch(r){case 1:return Md(t,e,n);case 2:return _T(t,e,n);default:throw new $e(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Md(t,e,n);case 2:return I1(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return _T(t,e,n);default:throw new $e(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Md(t,e,n);case 2:return nf(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return nf(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return _T(t,e,n);default:throw new $e(`The axis is not within the rank of the tensor ${r}`)}default:throw new $e(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function aN(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),Gr(t,e)}function VO(t,e){switch(t.rank){case 1:return Zx([t,e]);case 2:return e_([t,e],0);case 3:return t_([t,e],0);case 4:return n_([t,e],0);default:throw new $e(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function k$(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new $e(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return na(t,e)}function i4(t,e=0,n=1,r,s){return Tw(t,e,n,r,s)}function wu(t,e,n,r){if(t.rank<2||e.rank<2)throw new Nn(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){const s=t.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(s!==i)throw new Nn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return I$({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?N$(t.rank,r,Vl()):null,activation:n});{const s=t.shape.slice(),i=s.pop();t=Ie(t,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:e.rank},(g,y)=>y===0?e.rank-2:y<=e.rank-2?y-1:y);e=Ie(Mn(e,c),[l,-1]);const d=[...s,...u];return Ie(I$({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?N$(t.rank,r,Vl()):null,activation:n}),d)}}function GB(t,e,n){return ke(()=>(Array.isArray(e)?e=Zr(e,"int32"):e=gt(e,"int32"),Sp(t,e,n)))}function jw(t){return be(t,t)}function N$(t,e,n){const r=e.shape;if(e.rank!==1&&e.rank!==t)throw new $e(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return r.length===1?Ie(e,[1,r[0],1,1,1]):Ie(e,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?Ie(e,[1,1,1,1,r[0]]):Ie(e,[1].concat(r))}else if(t===4){if(n==="channelsFirst")return r.length===1?Ie(e,[1,r[0],1,1]):Ie(e,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?Ie(e,[1,1,1,r[0]]):Ie(e,[1].concat(r))}else if(t===3){if(n==="channelsFirst")return r.length===1?Ie(e,[1,r[0],1]):Ie(e,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?Ie(e,[1,1,r[0]]):Ie(e,[1].concat(r))}else if(t<3)return e;throw new $e(`Unsupported input rank by biasAdd: ${e.rank}`)}function Hl(t,e,n){return ke(()=>(n==null&&(n=Vl()),ws(n),tt(t,N$(t.rank,e,n))))}function _pe(t,e=1){if(e!==1)throw new Nn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return _p(t)}function Ipe(t){return ke(()=>St(t,tt(fs(t),1)))}function HB(t,e,n,r){return ke(()=>O_(t,e,n,r))}function Tpe(t){return ke(()=>{const e=tt(.5,be(.2,t));return Hi(e,0,1)})}function Gw(t,e,n=!1){return n?t():e()}const Spe=["fanIn","fanOut","fanAvg"],$pe=["normal","uniform","truncatedNormal"];function Cpe(t){Cp(Spe,"FanMode",t)}function Epe(t){Cp($pe,"Distribution",t)}class al extends $p{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class lN extends al{apply(e,n){return ps(e,n)}}lN.className="Zeros";it(lN);class o4 extends al{apply(e,n){return fo(e,n)}}o4.className="Ones";it(o4);class uN extends al{constructor(e){if(super(),typeof e!="object")throw new $e(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new $e(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return ke(()=>be(Xt(this.value),fo(e,n)))}getConfig(){return{value:this.value}}}uN.className="Constant";it(uN);class cN extends al{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return xc(e,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}cN.className="RandomUniform";it(cN);class hN extends al{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Nn(`randomNormal does not support dType ${n}.`);return i4(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}hN.className="RandomNormal";it(hN);class dN extends al{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Nn(`truncatedNormal does not support dType ${n}.`);return Pw(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dN.className="TruncatedNormal";it(dN);class fN extends al{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return ke(()=>{if(e.length!==2||e[0]!==e[1])throw new $e("Identity matrix initializer can only be used for 2D square matrices.");return be(this.gain,bw(e[0]))})}getConfig(){return{gain:this.gain}}}fN.className="Identity";it(fN);function kpe(t,e="channelsLast"){let n,r;if(ws(e),t.length===2)n=t[0],r=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){const s=wh(t,2);n=t[1]*s,r=t[0]*s}else if(e==="channelsLast"){const s=wh(t,0,t.length-2);n=t[t.length-2]*s,r=t[t.length-1]*s}}else{const s=wh(t);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}class Do extends al{constructor(e){if(super(),e.scale<0)throw new $e(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Cpe(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Epe(this.distribution),this.seed=e.seed}apply(e,n){const r=kpe(e),s=r[0],i=r[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,s):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(s+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Nn(`${this.getClassName()} does not support dType ${n}.`);return Pw(e,0,a,n,this.seed)}else{const a=Math.sqrt(3*o);return xc(e,-a,a,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Do.className="VarianceScaling";it(Do);class a4 extends Do{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Do.className}}a4.className="GlorotUniform";it(a4);class l4 extends Do{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Do.className}}l4.className="GlorotNormal";it(l4);class u4 extends Do{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Do.className}}u4.className="HeNormal";it(u4);class c4 extends Do{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Do.className}}c4.className="HeUniform";it(c4);class h4 extends Do{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Do.className}}h4.className="LeCunNormal";it(h4);class d4 extends Do{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Do.className}}d4.className="LeCunUniform";it(d4);class pN extends al{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,n){return ke(()=>{if(e.length<2)throw new Nn("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const r=Ue(e.slice(0,-1)),s=e[e.length-1],i=r*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(s,r),Math.min(s,r)],a=i4(o,0,1,n,this.seed),l=W_.qr(a,!1);let u=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return u=be(u,d.sign()),r<s&&(u=u.transpose()),be(Xt(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}pN.className="Orthogonal";it(pN);const BO={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function UO(t,e={}){return Uw(t,Ia.getMap().classNameMap,e,"initializer")}function es(t){return iN(t)}function jr(t){if(typeof t=="string"){const e=t in BO?BO[t]:t;if(e==="GlorotNormal")return new l4;if(e==="GlorotUniform")return new a4;if(e==="HeNormal")return new u4;if(e==="HeUniform")return new c4;if(e==="LeCunNormal")return new h4;if(e==="LeCunUniform")return new d4;{const n={};return n.className=e,n.config={},UO(n)}}else return t instanceof al?t:UO(t)}function A$(t){return Array.isArray(t)&&Array.isArray(t[0])}function Mb(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function dn(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new $e(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function sr(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new $e(`Expected exactly 1 Shape; got ${t.length}`)}else return t}function zb(t){let e=0;for(const n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((r,s)=>r*s);return e}const WO="Variable";class qB{constructor(e,n="float32",r=WO,s=!0,i=null){this.dtype=n??"float32",this.shape=e.shape,this.id=VB(),r=r??WO,this.originalName=UB(r),this.name=WB(this.originalName),this.trainable_=s,this.constraint=i,this.val=A_(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Npe(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Npe(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function R$(t){return t.map(e=>e.read())}function mN(t){t.forEach(e=>{e[0].write(e[1])})}class Ss{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Bl{constructor(e,n,r,s,i,o,a){this.dtype=e,this.shape=n,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=VB(),o!=null&&(this.originalName=UB(o),this.name=WB(this.originalName)),this.rank=n.length}}let Ape=0;class f4{constructor(e,n){this.callArgs=n,this.id=Ape++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const n of this.inboundLayers)n!=null?e.push(n.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Rpe=0;class Pn extends $p{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Rpe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){const r=this.getClassName();n=Wu(r)+"_"+s4(r)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),r=[i].concat(e.inputShape)}this.batchInputShape=r;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new nl(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new $e(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Co(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Co(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ru(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ru(`Layer ${this.name} is not connected, no input to return.`);return Co(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ru(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ru(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Co(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const n=yr(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=yr(this.inputSpec);if(n.length!==r.length)throw new $e(`Layer ${this.name} expects ${r.length} inputs, but it received ${n.length} input tensors. Input received: ${e}`);for(let s=0;s<n.length;s++){const i=n[s],o=r[s];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new $e(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new $e(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new $e(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new $e(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const u in o.axes){const c=Number(u),d=o.axes[u],f=c>=0?l[c]:l[l.length+c];if(d!=null&&[d,null].indexOf(f)===-1)throw new $e(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const u=o.shape[l],c=i.shape[l];if(u!=null&&c!=null&&u!==c)throw new $e(`Input ${s} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();const r=yr(e),s=Ppe(e),i=Fpe(e);if(s===i)throw new $e("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ld(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of yr(e))o.push(a.shape);this.build(Co(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,n);this.supportsMasking&&this.setMaskMetadata(e,o);const a=yr(o),l=[];for(let u of a)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(o=Co(l),this.activityRegularizer!=null)throw new Nn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=Dpe(e),a=this.computeOutputShape(o);let l;const u=Ope(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,d)=>new Bl(u,c,this,yr(e),n,this.name,d)):l=new Bl(u,a,this,yr(e),n,this.name),this.addInboundNode(e,l,null,null,o,a,n),this._refCount++,this.activityRegularizer!=null)throw new Nn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&e[s]!=null&&e[s]!==r&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ru(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const n of this.inboundNodes){const r=JSON.stringify(n.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new ru(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new nl(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zb(this.weights)}build(e){this.built=!0}getWeights(e=!1){return R$(e?this.trainableWeights:this.weights)}setWeights(e){ke(()=>{const n=this.weights;if(n.length!==e.length)throw new $e(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;const r=[],s=R$(n);for(let i=0;i<s.length;++i){const o=s[i],a=n[i],l=e[i];if(!zn(o.shape,l.shape))throw new $e(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}mN(r)})}addWeight(e,n,r,s,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new $e(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():jr("zeros"));const u=s.apply(n,r),c=new qB(u,r,e,o,a);return u.dispose(),i!=null&&this.addLoss(()=>i.apply(c.read())),o==null&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=yr(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(e,n,r){if(!this.supportsMasking)return;const s=this.computeMask(e,r),i=yr(n),o=yr(s);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(e,n,r,s,i,o,a=null){const l=yr(e);n=yr(n),r=yr(r),s=yr(s),i=Mb(i),o=Mb(o);const u=[],c=[],d=[];for(const f of l)u.push(f.sourceLayer),c.push(f.nodeIndex),d.push(f.tensorIndex);new f4({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:n,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let f=0;f<n.length;f++)n[f].sourceLayer=this,n[f].nodeIndex=this.inboundNodes.length-1,n[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Dpe(t){t=yr(t);const e=[];for(const n of t)e.push(n.shape);return Co(e)}function Ope(t){return"float32"}function KB(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{const r=e.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const o=r.inputTensors[i],a=r.inboundLayers[i],l=r.nodeIndices[i],u=KB(o,a,l);for(const c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}function Ppe(t){let e=!0;for(const n of yr(t))if(!(n instanceof Bl)){e=!1;break}return e}function Fpe(t){let e=!0;for(const n of yr(t))if(n instanceof Bl){e=!1;break}return e}class E1 extends Pn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:s4("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new $e("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new $e("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new $e("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];const s=new Bl(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new f4({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new $e(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}E1.className="InputLayer";it(E1);function XB(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new $e("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new E1({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}function Lpe(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return gt(e,t.dtype)}catch{throw new $e(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}class oh{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof oh)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Lpe(e,n),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new $e(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Bl){if(this.id2Value[e.id]==null)throw new $e(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const n=this.name2Id[e];if(n==null)throw new $e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof Bl){if(this.id2Value[e.id]==null)throw new $e(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const n=this.name2Id[e];if(n==null)throw new $e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&en(this.id2Mask)}}const Vb=new LB,Bb=new LB;function Mpe(t){Vb?.setMaxEntries(t),Bb?.setMaxEntries(t)}function K2(t,e,n,r){const s=n==null?!1:n.training,i=Array.isArray(t),o=i?t:[t],a=o.map(g=>g.name),l=[],u=e.names();for(const g of a)u.indexOf(g)!==-1?l.push(e.getValue(g)):l.push(null);const c=a.join(",")+"|"+e.names().sort().join(",");let d=Vb.get(c),f;if(d==null){const g=zpe(o,e);d=g.sorted,f=g.recipientCounts,Vb.put(c,d),Bb.put(c,f)}f={},s||Object.assign(f,Bb.get(c));const m=new oh(e);for(let g=0;g<d.length;++g){const y=d[g],v=y.sourceLayer;if(v instanceof E1)continue;const b=[],x=[],$=[];let S=!1;for(const A of y.inputs){const F=m.getValue(A),P=m.getMask(A);b.push(F),x.push(P),P!=null&&(S=!0),s||(f[A.name]--,f[A.name]===0&&!e.hasKey(A)&&a.indexOf(A.name)===-1&&!F.isDisposed&&A.sourceLayer.stateful!==!0&&$.push(F))}S&&(n=n||{},n.mask=x[0]);const E=yr(v.apply(b,n));let L=null;v.supportsMasking&&(L=v.computeMask(b,x));const R=Bpe(y),D=Array.isArray(R)?R:[R];for(let A=0;A<D.length;++A){m.hasKey(D[A])||m.add(D[A],E[A],Array.isArray(L)?L[0]:L);const F=a.indexOf(D[A].name);F!==-1&&(l[F]=E[A])}s||en($)}return m.disposeMasks(),i?l:l[0]}function zpe(t,e){J(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(t.length===1){const s=jO(t[0],e);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of t){const{sorted:o,recipientMap:a}=jO(i,e);for(const l of o)s.has(l.name)||(n.push(l),s.add(l.name));for(const l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:Vpe(r)}}function Vpe(t){const e={};for(const n in t)e[n]=t[n].size;return e}function jO(t,e){const n=new Set,r=[],s={};for(const a of e.names())n.add(a);const i=[],o=[];for(i.push(t);i.length>0;){const a=i[i.length-1];if(n.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),r.push(a),n.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const u of a.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(a.name),!n.has(u.name)&&i.push(u)}}return{sorted:r,recipientMap:s}}function Bpe(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const s of t.sourceLayer.inboundNodes[r].outputTensors)if(s.id===t.id){n=r;break}e=t.sourceLayer.getOutputAt(n)}return e}const Upe=De();Upe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Mpe);function gN(t,e){return ke(()=>js(Ot(be(t,t),e,!0)))}class Hw extends $p{getConfig(){return{}}}class yN extends Hw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ke(()=>{const n=gN(e,this.axis),r=Hi(n,0,this.maxValue);return be(e,St(r,tt(Vs(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}yN.className="MaxNorm";it(yN);class wN extends Hw{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ke(()=>St(e,tt(Vs(),gN(e,this.axis))))}getConfig(){return{axis:this.axis}}}wN.className="UnitNorm";it(wN);class vN extends Hw{apply(e){return ol(e)}}vN.className="NonNeg";it(vN);class bN extends Hw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ke(()=>{const n=gN(e,this.axis),r=tt(be(this.rate,Hi(n,this.minValue,this.maxValue)),be(1-this.rate,n));return be(e,St(r,tt(Vs(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}bN.className="MinMaxNorm";it(bN);const GO={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Us(t){return iN(t)}function HO(t,e={}){return Uw(t,Ia.getMap().classNameMap,e,"constraint")}function Ws(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in GO?GO[t]:t,config:{}};return HO(n)}else return t instanceof Hw?t:HO(t)}function Wpe(t){return new yN(t)}function jpe(t){return new wN(t)}function Gpe(){return new vN}function Hpe(t){return new bN(t)}const qpe=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Wpe,minMaxNorm:Hpe,nonNeg:Gpe,unitNorm:jpe},Symbol.toStringTag,{value:"Module"}));function Kpe(){return new lN}function Xpe(){return new o4}function Ype(t){return new uN(t)}function Qpe(t){return new cN(t)}function Jpe(t){return new hN(t)}function Zpe(t){return new dN(t)}function eme(t){return new fN(t)}function tme(t){return new Do(t)}function nme(t){return new a4(t)}function rme(t){return new l4(t)}function sme(t){return new u4(t)}function ime(t){return new c4(t)}function ome(t){return new h4(t)}function ame(t){return new d4(t)}function lme(t){return new pN(t)}const ume=Object.freeze(Object.defineProperty({__proto__:null,constant:Ype,glorotNormal:rme,glorotUniform:nme,heNormal:sme,heUniform:ime,identity:eme,leCunNormal:ome,leCunUniform:ame,ones:Xpe,orthogonal:lme,randomNormal:Jpe,randomUniform:Qpe,truncatedNormal:Zpe,varianceScaling:tme,zeros:Kpe},Symbol.toStringTag,{value:"Module"}));async function Yc(t){if(t==null)return;const e=[],n=[],r=[];for(const s in t){const i=t[s];if(typeof i!="number"){const o=i;e.push(o.data()),n.push(s),r.push(o)}}if(e.length>0){const s=await Promise.all(e);for(let i=0;i<s.length;++i)t[n[i]]=s[i][0];en(r)}}function YB(t){if(t!=null)for(const e in t){const n=t[e];typeof n!="number"&&n.dispose()}}var qO;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(qO||(qO={}));const cme=125;class Gm{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,n){}async onEpochEnd(e,n){}async onBatchBegin(e,n){}async onBatchEnd(e,n){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class QB{constructor(e,n=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=n}append(e){this.callbacks.push(e)}setParams(e){for(const n of this.callbacks)n.setParams(e)}setModel(e){for(const n of this.callbacks)n.setModel(e)}async onEpochBegin(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochBegin(e,n)}async onEpochEnd(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochEnd(e,n)}async onBatchBegin(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchBegin(e,n)}async onBatchEnd(e,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchEnd(e,n)}async onTrainBegin(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainEnd(e)}}class hme extends Gm{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});const r=n.size==null?0:n.size;this.seen+=r;for(const s in n){const i=n[s];if(typeof i=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+i*r;else{let o;s in this.totals?o=this.totals[s]:this.totals[s]=0;const a=ke(()=>tt(this.totals[s],be(i,r)));this.totals[s]=a,o?.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?n[r]=this.totals[r]/this.seen:ke(()=>{const s=be(St(1,this.seen),this.totals[r]);n[r]=s,this.totals[r].dispose(),Ts(n[r])}))}}class JB extends Gm{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(const r in n)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(n[r])}async syncData(){const e=[],n=[],r=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),n.push(i),r.push(a)}}const s=await Promise.all(e);for(let i=0;i<s.length;++i)this.history[n[i]][r[i]].dispose(),this.history[n[i]][r[i]]=s[i][0]}}class ZB extends Gm{constructor(e,n){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||e4,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=cme),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Ab(this.yieldEvery)&&(this.maybeWait=lpe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,r){const s=[];this.yield!=null&&(await Yc(r),s.push(this.yield(e,n,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await Yc(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){const r=[];this.epochEnd!=null&&(await Yc(n),r.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,n){this.batchBegin!=null&&(await Yc(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){const r=[];this.batchEnd!=null&&(await Yc(n),r.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):Ab(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await Yc(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Yc(e),await this.trainEnd(e))}}function eU(t,e){return t==null&&(t={}),t instanceof Gm?[t]:Array.isArray(t)&&t[0]instanceof Gm?t:yr(t).map(r=>new ZB(r,e))}class ba{constructor(){}static registerCallbackConstructor(e,n){J(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ba.checkForDuplicate(n),ba.constructors[e]==null&&(ba.constructors[e]=[]),ba.constructors[e].push(n)}static checkForDuplicate(e){for(const n in ba.constructors)ba.constructors[+n].forEach(s=>{if(s===e)throw new $e("Duplicate callback constructor.")})}static clear(){ba.constructors={}}static createCallbacks(e){const n=[];for(const r in ba.constructors){const s=+r;e>=s&&n.push(...ba.constructors[s])}return n.map(r=>new r)}}ba.constructors={};function tU(t,e,n,r,s,i,o,a,l){const u=new JB,c=[new hme,...ba.createCallbacks(e)];t!=null&&c.push(...t),c.push(u);const d=new QB(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:d,history:u}}function Dl(t,e={},n=!1){return Uw(t,Ia.getMap().classNameMap,e,"layer",n)}function Ub(t,e){return ke(()=>{t.dtype!=="float32"&&(t=gt(t,"float32"));const n=Ot(jw(t),e,!0),r=Hh(n.shape,Vs()),s=js(Gl(n,r));return St(t,s)})}function Ep(t,e){return ke(()=>Wr(jw($t(e,t)),-1))}function p4(t,e){return ke(()=>Wr(fs($t(e,t)),-1))}function k1(t,e){return ke(()=>{const n=$t(t,e),r=Hi(fs(t),Vs(),Number.MAX_VALUE),s=fs(St(n,r));return be(100,Wr(s,-1))})}function dme(t,e){return ke(()=>{const n=Hi(e,Vs(),Number.MAX_VALUE),r=Ao(tt(1,n)),s=Hi(t,Vs(),Number.MAX_VALUE),i=Ao(tt(1,s));return Wr(jw($t(r,i)),-1)})}function fme(t,e){return ke(()=>{const n=Gl(0,$t(1,be(t,e)));return Wr(jw(n),-1)})}function pme(t,e){return ke(()=>{const n=Gl(0,$t(1,be(t,e)));return Wr(n,-1)})}function mme(t,e){return ke(()=>{const n=Ot(be(t,e),-1),r=ra(be($t(1,t),e),-1);return Gl(0,tt(1,$t(r,n)))})}function gme(t,e){return ke(()=>{const n=Math.log(2),r=$t(e,t),s=$t(tt(r,Kh(be(-2,r))),n);return Wr(s,-1)})}function Oy(t,e,n=!1){return ke(()=>{if(n)e=T1(e);else{const r=Ot(e,e.shape.length-1,!0);e=St(e,r)}return e=Hi(e,Vs(),1-Vs()),$r(Ot(be(gt(t,"float32"),Ao(e)),e.shape.length-1))})}function Wb(t,e,n=!1){return ke(()=>{const r=gt(Tp(bpe(t)),"int32");e=Hi(e,Vs(),1-Vs());const s=e.shape,i=Ie(ef(r,s[s.length-1]),s);return Oy(i,e,n)})}function yme(t,e){if(!zn(t.shape,e.shape))throw new $e(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return ke(()=>{const n=ol(e),r=$r(fs(e));return tt($t(n,be(e,t)),p1(ki(r)))})}function m4(t,e){return ke(()=>{let n;return n=Hi(e,Vs(),1-Vs()),n=Ao(St(n,$t(1,n))),Wr(yme(t,n),-1)})}function wme(t,e){return ke(()=>{const n=Hi(t,Vs(),1),r=Hi(e,Vs(),1);return Ot(be(t,Ao(St(n,r))),-1)})}function vme(t,e){return ke(()=>{const n=Ao(tt(Vs(),e));return Wr($t(e,be(t,n)),-1)})}function xN(t,e){return ke(()=>{const n=Ub(t,-1),r=Ub(e,-1),s=be(n,r);return $r(Ot(s,-1))})}const jb={meanSquaredError:Ep,meanAbsoluteError:p4,meanAbsolutePercentageError:k1,meanSquaredLogarithmicError:dme,squaredHinge:fme,hinge:pme,categoricalHinge:mme,logcosh:gme,categoricalCrossentropy:Oy,sparseCategoricalCrossentropy:Wb,binaryCrossentropy:m4,kullbackLeiblerDivergence:wme,poisson:vme,cosineProximity:xN};function IT(t){if(typeof t=="string"){if(t in jb)return jb[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new $e(e)}else return t}function _N(t,e){return ke(()=>{const n=be(.5,Ro(e)),r=yu(Ki(e,n),t.dtype);return Wr(No(t,r),-1)})}function IN(t,e){return ke(()=>yu(No(Nh(t,-1),Nh(e,-1)),"float32"))}function nU(t,e){return ke(()=>gt(Ot(ka(No(t,1),No(e,1))),"float32"))}function bme(t,e){return ke(()=>gt(Ot(ka(No(t,1),No(e,0))),"float32"))}function xme(t,e){return ke(()=>gt(Ot(ka(No(t,0),No(e,1))),"float32"))}function rU(t,e){return ke(()=>{const n=nU(t,e),r=xme(t,e),s=tt(n,r);return gt(Bs(Ki(s,0),St(n,s),0),"float32")})}function _me(t,e){return ke(()=>{const n=nU(t,e),r=bme(t,e),s=tt(n,r);return gt(Bs(Ki(s,0),St(n,s),0),"float32")})}function sU(t,e){return m4(t,e)}function iU(t,e){return t.rank===e.rank&&(t=Vr(t,[t.rank-1])),e=Nh(e,-1),e.dtype!==t.dtype&&(e=gt(e,t.dtype)),gt(No(t,e),"float32")}function Ime(t,e){return ke(()=>{const n=t.sub(e).square().sum(),r=t.sub(t.mean()).square().sum();return Xt(1).sub(n.div(r))})}const Tme=Ep,Sme=Ep,$me=p4,Cme=p4,Eme=k1,kme=k1,TN=Oy,Nme=xN,oU=Wb,Gb={binaryAccuracy:_N,categoricalAccuracy:IN,precision:rU,categoricalCrossentropy:TN,sparseCategoricalCrossentropy:oU,mse:Tme,MSE:Sme,mae:$me,MAE:Cme,mape:Eme,MAPE:kme,cosine:Nme};function Ame(t){if(typeof t=="string"&&t in Gb)return Gb[t];if(typeof t!="string"&&t!=null)return t;throw new $e(`Unknown metric ${t}`)}function dv(t){if(su(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(const n of Object.keys(jb))if(jb[n]===t){e=n;break}if(e!==void 0)return e;for(const n of Object.keys(Gb))if(Gb[n]===t){e=n;break}return e!==void 0?e:t.name}}function Rme(t){const e={Adagrad:()=>Qc.adagrad(.01),Adadelta:()=>Qc.adadelta(1,.95,Vs()),Adam:()=>Qc.adam(.001,.9,.999,Vs()),Adamax:()=>Qc.adamax(.002,.9,.999,Vs(),0),RMSProp:()=>Qc.rmsprop(.001,.9,0,Vs()),SGD:()=>Qc.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new $e(`Unknown Optimizer ${t}`)}const KO=1*1024*1024;function XO(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!D$(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const r=JSON.stringify(t);r.length>KO&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${KO}.`)}}function D$(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e)if(typeof n!="string"||!D$(t[n]))return!1;return!0}else if(Array.isArray(t)){for(const e of t)if(!D$(e))return!1;return!0}else return!1;else{const e=typeof t;return e==="string"||e==="number"||e==="boolean"}}function Dme(t,e,n,r=console.log){const s=Pme(t),i=["Layer (type)","Input Shape","Output shape","Param #"];s?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(e*c)));let o;if(!s){i.push("Receives inputs"),o=[];for(const c in t.nodesByDepth)o.push(...t.nodesByDepth[c])}r("_".repeat(e)),Hb(i,n,r),r("=".repeat(e));const a=t.layers;for(let c=0;c<a.length;++c)s?Fme(a[c],n,r):Lme(a[c],n,o,r),r((c===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=Ome(t),u=zb(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(e))}function Ome(t){let e;return t.collectedTrainableWeights!=null?e=zb(t.collectedTrainableWeights):e=zb(t.trainableWeights),e}function Pme(t){let e=!0;const n=[],r=[];for(const s in t.nodesByDepth)n.push(t.nodesByDepth[s]);for(const s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of t.layers){let i=!1;for(const o of s.inboundNodes)if(r.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function Hb(t,e,n=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);n(r)}function Fme(t,e,n){let r,s;try{s=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}const i=t.name,o=t.getClassName(),a=[`${i} (${o})`,s,r,t.countParams().toString()];Hb(a,e,n)}function Lme(t,e,n,r){let s,i;try{i=t.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const o=[];for(const d of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let f=0;f<d.inboundLayers.length;++f){const m=d.inboundLayers[f].name,g=d.nodeIndices[f],y=d.tensorIndices[f];o.push(`${m}[${g}][${y}]`)}const a=t.name,l=t.getClassName(),u=o.length===0?"":o[0],c=[`${a} (${l})`,i,s,t.countParams().toString(),u];Hb(c,e,r);for(let d=1;d<o.length;++d)Hb(["","","","",o[d]],e,r)}function aU(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function Py(t,e){if(t===null)return null;if(typeof t=="string")return Id(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],r=t.length;for(let s=0;s<r;++s){const i=t[s];aU(e,s,i)?n.push(i):n.push(Py(i,e))}return n}else{const n={};for(const r of Object.keys(t)){const s=t[r];if(r==="name"&&typeof s=="string")n[r]=s;else{const i=Id(r);n[i]=Py(s,i)}}return n}}function O$(t,e){if(t==null)return null;if(typeof t=="string")return Wu(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],r=t.length;for(let s=0;s<r;++s){const i=t[s];aU(e,s,i)?n.push(i):n.push(O$(i,e))}return n}else{const n={};for(const r of Object.keys(t)){const s=t[r],i=Wu(r);(r==="name"||r==="className")&&typeof s=="string"?n[i]=s:n[i]=O$(s,r)}return n}}const g4="4.22.0";const Mme=t=>{const e=Object.keys(t);if(e.length===0)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class Sl extends Pn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const x=this.getClassName().toLowerCase();this.name=s4(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],yh(this.inputs).length!==this.inputs.length)throw new $e(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);yh(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const x of this.outputs){const $=x.sourceLayer,S=x.nodeIndex,E=x.tensorIndex;this.outputLayers.push($),this.outputLayersNodeIndices.push(S),this.outputLayersTensorIndices.push(E)}for(const x of this.inputs){const $=x.sourceLayer,S=x.nodeIndex,E=x.tensorIndex;su(S===0,"input layer has >1 nodes"),su(E===0,"input layer has >1 tensors"),this.inputLayers.push($),this.inputLayersNodeIndices.push(S),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){const $=this.inputLayers[x];if(!($ instanceof E1))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${$.getClassName()}.`);this.inputNames.push($.name),this.feedInputShapes.push($.batchInputShape),this.feedInputNames.push($.name)}for(const x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);const n={},r={},s={},i={},o={},a=[],l=(x,$,S,E,L,R)=>{(E==null||L==null||R==null)&&(E=x.sourceLayer,L=x.nodeIndex,R=x.tensorIndex);const D=E.inboundNodes[L];if(S.indexOf(D)!==-1)throw new nl(`The tensor ${x.name} at layer "${E.name}" is part of a cycle.`);if($.indexOf(D)!==-1)return;this.containerNodes.add(Sl.nodeKey(E,L)),E.id in o||(o[E.id]=Object.keys(o).length),S.indexOf(D)===-1&&S.push(D);const A=D.inboundLayers.length;for(let F=0;F<A;F++){const P=D.inputTensors[F],K=D.inboundLayers[F],j=D.nodeIndices[F],se=D.tensorIndices[F];l(P,$,S,K,j,se)}for($.push(D);S.indexOf(D)>=0;)S.splice(S.indexOf(D),1);a.push(D)},u=[],c=[];for(const x of this.outputs)l(x,u,c);const d=a.slice().reverse();for(const x of d){r[x.id]=x,x.id in n||(n[x.id]=0);let $=n[x.id];const S=s[x.outboundLayer.id]==null?0:s[x.outboundLayer.id];$=Math.max($,S),s[x.outboundLayer.id]=$,i[x.outboundLayer.id]=x.outboundLayer,n[x.id]=$;for(let E=0;E<x.inboundLayers.length;E++){const L=x.inboundLayers[E],R=x.nodeIndices[E],D=L.inboundNodes[R],A=n[D.id]==null?0:n[D.id];n[D.id]=Math.max($+1,A),r[D.id]=D}}const f={};for(const x in n){const $=n[x];$ in f||(f[$]=[]),f[$].push(r[x])}const m={};for(const x in s){const $=s[x];$ in m||(m[$]=[]),m[$].push(i[x])}let g=Object.keys(m).map(x=>parseInt(x,10)).sort(uv);this.layers=[];for(const x of g){const $=m[x];$.sort((S,E)=>{const L=o[S.id],R=o[E.id];return L<R?-1:L>R?1:0});for(const S of $)S instanceof Sl&&this.internalContainerRefs.push(S),this.layers.push(S)}this.layersByDepth=m,g=Object.keys(f).map(x=>parseInt(x,10)).sort(uv);const y=this.inputs.slice(),v=[];for(const x of g)for(const $ of f[x]){const S=$.outboundLayer;if(S!=null){for(const E of $.inputTensors)if(y.indexOf(E)===-1)throw new nl(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${S.name}". The following previous layers were accessed without issue: ${v}`);for(const E of $.outputTensors)y.push(E);v.push(S.name)}}this.nodesByDepth=f;const b=this.layers.map(x=>x.name);for(const x of b){const $=b.filter(S=>S===x).length;if($!==1)throw new nl(`The name "${x}" is used ${$} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new f4({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new $e("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.layers)n.push(...r.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){const r={};let s=0;const i=Mme(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=i?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new $e(`Duplicate weight name: ${c}`);r[c]=u,s++}const o=[];for(const a in e){let l=a;if(r[a]==null){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)o.push([r[l],e[a]]);else if(n)throw new $e(`Provided weight data has no target variable: ${a}`);delete r[l]}if(n){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new $e(`${a.length} of ${s} weights are not set: ${a}`)}mN(o)}parseWeights(e){for(const n in Object.keys(e)){const r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],i=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!s.includes(o)).join("/");i!==n&&(e[i]=e[n],delete e[n])}}updatedConfig(){const e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${g4}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){const r=O$(this.updatedConfig());return n?JSON.stringify(r):r}call(e,n){return ke(()=>{e=yr(e);const r=new oh;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],e[s]);return K2(this.outputs,r,n)})}computeMask(e,n){return ke(()=>{e=yr(e);let r;return n==null?r=of(null,e.length):r=yr(n),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const n=Mb(e);if(n.length!==this.inputLayers.length)throw new $e(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<n.length;a++){const l=this.inputLayers[a],u=n[a],c=l.name+"_0_0";r[c]=u}const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(uv);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(y=>y.id).indexOf(c.id)!==-1)continue;const d=[];for(let y=0;y<u.inboundLayers.length;y++){const v=u.inboundLayers[y],b=u.nodeIndices[y],x=u.tensorIndices[y],$=`${v.name}_${b}_${x}`,S=r[$];d.push(S)}const f=c.computeOutputShape(Co(d)),m=Mb(f),g=c.inboundNodes.indexOf(u);for(let y=0;y<m.length;y++){const v=`${c.name}_${g}_${y}`;r[v]=m[y]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],d=`${l.name}_${u}_${c}`;o.push(d)}for(let a=0;a<o.length;a++){const l=o[a];su(l in r),i.push(r[l])}return Co(i)}runInternalGraph(e,n){n==null&&(n=of(null,e.length));const r={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],d=n[l];r[u.id]=[c,d]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(uv);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,f=c.inputTensors,m=c.outputTensors,g=new Array;for(const y of f)y.id in r&&g.push(r[y.id]);if(g.length===f.length){let y={},v,b,x,$;if(c.callArgs!=null&&(y=c.callArgs),g.length===1){const[S,E]=g[0];y.mask==null&&(y.mask=E),x=yr(d.call(S,y)),$=yr(d.computeMask(S,E)),v=[S],b=[E]}else v=g.map(S=>S[0]),b=g.map(S=>S[1]),y.mask==null&&(y.mask=b),x=yr(d.call(v,y)),$=yr(d.computeMask(v,b));if(d.activityRegularizer)throw new Nn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let S=0;S<m.length;++S){const E=m[S],L=x[S],R=$[S];r[E.id]=[L,R]}}}}const i=[],o=[],a=[];for(const l of this.outputs){su(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),i.push(u),o.push(c)}return[i,o,a]}buildNodeConversionMap(e){const n={};let r;for(const s of this.layers){r=s instanceof Sl?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=Sl.nodeKey(s,i);this.containerNodes.has(o)&&(n[o]=r,r+=1)}}return n}getLayer(e,n){if(n!=null)return this.findLayer(n);if(e==null)throw new $e("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new $e(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new $e(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ke(()=>{const e=[];for(const n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){const s=Sl.nodeKey(n,r);this.containerNodes.has(s)&&e.push(...n.calculateLosses())}return e})}getConfig(){const e={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),u=[];for(let d=0;d<o.inboundNodes.length;d++){const f=o.inboundNodes[d],m=Sl.nodeKey(o,d);let g={};if(this.containerNodes.has(m)){if(f.callArgs)try{JSON.stringify(f.callArgs),g=f.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(f.inboundLayers.length>0){const y=[];for(let v=0;v<f.inboundLayers.length;v++){const b=f.inboundLayers[v],x=f.nodeIndices[v],$=f.tensorIndices[v],S=Sl.nodeKey(b,x);let E=n[S];E==null&&(E=0),y.push([b.name,E,$,g])}u.push(y)}}}const c={};c.name=o.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}e.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],u=Sl.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.inputLayersTensorIndices[o];s.push([a.name,c,d])}e.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],u=Sl.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.outputLayersTensorIndices[o];i.push([a.name,c,d])}return e.outputLayers=i,e}static fromConfig(e,n,r={},s=!1){const i={},o={};function a(v,b){v.name in o?o[v.name].push(b):o[v.name]=[b]}function l(v,b){const x=[];let $;for(const S of b){const E=S[0],L=S[1],R=S[2];if($=S[3]==null?{}:S[3],!(E in i)){a(v,b);return}const D=i[E];if(D.inboundNodes.length<=L){a(v,b);return}const A=D.inboundNodes[L];x.push(A.outputTensors[R])}x.length>0&&v.apply(Co(x),$)}function u(v){const b=v.name,x=Dl(v,n.customObjects!=null?n.customObjects:{});x.setFastWeightInitDuringBuild(s),i[b]=x,v.inboundNodes.forEach(S=>{if(!(S instanceof Array))throw new $e(`Corrupted configuration, expected array for nodeData: ${S}`);a(x,S)})}const c=n.name,d=n.layers;for(const v of d)u(v);for(;!ape(o);)for(const v of d){const b=i[v.name];if(b.name in o){const x=o[b.name];delete o[b.name];for(const $ of x)l(b,$)}}const f=[],m=[],g=n.inputLayers;for(const v of g){const b=v[0],x=v[1],$=v[2];su(b in i);const E=i[b].inboundNodes[x].outputTensors;f.push(E[$])}const y=n.outputLayers;for(const v of y){const b=v[0],x=v[1],$=v[2];su(b in i);const E=i[b].inboundNodes[x].outputTensors;m.push(E[$])}return new e({inputs:f,outputs:m,name:c})}get stateful(){if(this._stateful)throw new $e("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ke(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function zme(t,e,n){const r=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(s=>null);if(r===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const s=[];return e.forEach(i=>{i in t?s.push(t[i]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function lU(t,e){return zme(t,e,"classWeight")}async function uU(t,e,n,r){if(n!=null){const s=ke(()=>{if(t.shape.length===1)return Rl(t);if(t.shape.length===2){if(t.shape[1]>1)return Nh(t,1);if(t.shape[1]===1)return Ie(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await s.data());en(s);const o=[];return i.forEach(a=>{if(n[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(n[a])}),Zr(o,"float32")}else return null}function Vme(t,e){return be(t,e)}const Bme=32;function cU(t,e){let n,r;const s=e;n=s.xs,r=s.ys,J(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=YO("input",t.inputNames,n),o=YO("output",t.outputNames,r),a=i[0].shape[0];J(i.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),J(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<i.length;l++)J(i[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<o.length;l++)J(o[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:i,ys:o}}function YO(t,e,n){if(n instanceof Rn)return[n];if(Array.isArray(n))return J(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const r=[];for(const s of e){if(n[s]==null)throw new $e(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(n[s])}return r}}function Ume(t){if(t.length===3)throw new Nn("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function Wme(t,e,n){const r=n.batchesPerEpoch!=null;if(J(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),J(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),J(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),J(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),J(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=n.validationData!=null;let i,o;if(s)if(QO(n.validationData))J(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const v=Ume(n.validationData);i=v.xs,o=v.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;s?u=l.slice().concat(l.map(v=>"val_"+v)):u=l.slice();const c=eU(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:f,history:m}=tU(c,d,n.epochs,null,null,jme(e,n),null,s,u);f.setModel(t),t.history=m,await f.onTrainBegin(),t.stopTraining_=!1;let g=n.initialEpoch==null?0:n.initialEpoch,y=await e.iterator();for(;g<n.epochs;){const v={};await f.onEpochBegin(g);let b=0,x=0;for(r||(y=await e.iterator());!r||b<n.batchesPerEpoch;){const $=await y.next();if(r&&$.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if($.value!=null){const{xs:S,ys:E}=cU(t,$.value),L={};L.batch=x,L.size=S[0].shape[0],await f.onBatchBegin(x,L);const R=[];if(n.classWeight!=null){const F=lU(n.classWeight,t.outputNames);for(let P=0;P<F.length;++P)R.push(await uU(E[P],null,F[P]))}const D=S.concat(E).concat(R),A=a(D);en(D);for(let F=0;F<l.length;++F){const P=l[F],K=A[F];L[P]=K,Ts(K)}await f.onBatchEnd(x,L),YB(L),x++,b++}if(r?b>=n.batchesPerEpoch:$.done){if(s){let S;QO(n.validationData)?S=yr(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):S=yr(t.evaluate(i,o,{batchSize:n.validationBatchSize==null?Bme:n.validationBatchSize,verbose:0}));for(let E=0;E<t.metricsNames.length;++E)v[`val_${t.metricsNames[E]}`]=S[E]}break}if(t.stopTraining_)break}if(await f.onEpochEnd(g,v),g++,t.stopTraining_)break}return await f.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function jme(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function QO(t){return typeof t.iterator=="function"}function Gme(t){return typeof t.next=="function"}async function Hme(t,e,n){n=n||{};const r=n.batches!=null,s=t.testFunction;let i=[];if(n.verbose>0)throw new Nn("Verbose mode is not implemented yet.");J(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const o=Gme(e)?e:await e.iterator();let a=0,l=0;for(;!r||l<n.batches;){const u=await o.next();if(i=ke(()=>{if(u.value){const{xs:c,ys:d}=cU(t,u.value),f=c.concat(d),m=ke(()=>s(f));if(en(f),l===0)for(let y=0;y<m.length;++y)i.push(Xt(0));const g=f[0].shape[0];for(let y=0;y<m.length;++y){const v=m[y],b=i[y];i[y]=ke(()=>tt(i[y],be(g,v))),l>0&&en(b)}en(m),a+=g,++l}return i}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const c=i[u];i[u]=St(i[u],a),en(c)}return Co(i)}function TT(t){J(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function T2(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(r=>Md(r,e,n-e)):Md(t,e,n-e)}function P$(t,e){return ke(()=>t==null?null:Array.isArray(t)?t.map(n=>P$(n,e)):GB(t,e.dtype==="int32"?e:gt(e,"int32")))}function ST(t,e){const n=[];let r=0,s=null;for(;r<t;)s=r+e,s>=t&&(s=t),n.push([r,s]),r=s;return n}function hU(t){const e=[];t instanceof Rn&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(r.rank===1)e.push(Ww(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function vl(t,e){if(t==null)return;const n=[];if(e instanceof Rn)n.push(e.id);else if(Array.isArray(e))e.forEach(s=>n.push(s.id));else if(e!=null)for(const s in e){const i=e[s];n.push(i.id)}const r=[];if(t instanceof Rn)n.indexOf(t.id)===-1&&r.push(t);else if(Array.isArray(t))t.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(t!=null)for(const s in t){const i=t[s];n.indexOf(i.id)===-1&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}function qme(t){return t instanceof Rn}function F$(t){return Array.isArray(t)}function JO(t){return!qme(t)&&!F$(t)}function ZO(t,e,n,r=!0,s=""){if(e==null||e.length===0){if(t!=null){let o=!1;if(F$(t)&&t.length>0)o=!0;else if(JO(t)){for(const a in t)if(t.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new $e(`Error when checking model ${s} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(o=>null);let i;if(JO(t)){t=t,i=[];for(const o of e){if(t[o]==null)throw new $e(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(t[o])}}else if(F$(t)){if(t=t,t.length!==e.length)throw new $e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);i=t}else{if(t=t,e.length>1)throw new $e(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);i=[t]}if(i=hU(i),n!=null)for(let o=0;o<e.length;++o){if(n[o]==null)continue;const a=i[o];if(a.shape.length!==n[o].length)throw new $e(`Error when checking ${s}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<n[o].length;++l){if(l===0&&!r)continue;const u=a.shape[l],c=n[o][l];if(c!=null&&c>=0&&u!==c)throw new $e(`${s} expected a batch of elements where each example has shape [${n[o].slice(1,n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1,n[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function Kme(t,e,n){const r=yh(t.map(i=>i.shape[0]));r.sort();const s=yh(e.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new $e(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>1)throw new $e(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!zn(r,s))throw new $e(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function Xme(t,e,n){const r=[Ep,m4,Oy];for(let s=0;s<t.length;++s){const i=t[s],o=e[s],a=n[s];if(o!=null){if(o===Oy&&i.shape[i.shape.length-1]===1)throw new $e(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){const l=i.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const d=l[c],f=u[c];if(f!=null&&d!==f)throw new $e(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function eP(t,e,n,r=!0,s=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new $e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new $e(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);i=[t]}if(n!=null)for(let o=0;o<e.length;++o){if(n[o]==null)continue;const a=i[o];if(a.shape.length!==n[o].length)throw new $e(`Error when checking ${s}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<n[o].length;++l){if(l===0&&!r)continue;const u=a.shape[l],c=n[o][l];if(c!=null&&c!==u)throw new $e(`Error when checking ${s}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function Yme(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(r=>n);{const r=[];for(const s of e){let i=n.hasOwnProperty(s)?n[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}const Qme="layers-model";class ec extends Sl{constructor(e){super(e),this.isTraining=!1}summary(e,n,r=console.log){if(!this.built)throw new $e("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Dme(this,e,n,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Rme(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Eu))throw new $e("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new $e(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),n.push(IT(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new $e(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(a=>IT(a))}else{const o=IT(e.loss);this.outputs.forEach(a=>{n.push(o)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ld("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const s=Yme(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Ld("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=s[o];(u=>{let d,f,m;for(const g of u){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){const v=this.internalOutputShapes[o];v[v.length-1]===1||this.lossFunctions[o]===m4?["accuracy","acc"].indexOf(g)!==-1?f=_N:["crossentropy","ce"].indexOf(g)!==-1&&(f=sU):this.lossFunctions[o]===Wb?["accuracy","acc"].indexOf(g)!==-1?f=iU:["crossentropy","ce"].indexOf(g)!==-1&&(f=oU):["accuracy","acc"].indexOf(g)!==-1?f=IN:["crossentropy","ce"].indexOf(g)!==-1&&(f=TN);let b;["accuracy","acc"].indexOf(g)!==-1?b="acc":["crossentropy","ce"].indexOf(g)!==-1&&(b="ce"),m=f,d=""+b}else m=Ame(g),d=""+dv(g);let y;Ld(d,()=>{y=m}),i(o,d,y)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,r={}){const s=r.batchSize==null?32:r.batchSize;TT(s);const o=this.standardizeUserDataXY(e,n,!0,s);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,s,r.verbose,r.steps);return Co(u)}finally{vl(o[0],e),vl(o[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),Hme(this,e,n)}checkNumSamples(e,n,r,s="steps"){let i;if(r!=null){if(i=null,n!=null)throw new $e(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new $e(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new $e("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(n),s=r?n:[n],i=this.retrieveSymbolicTensors(s),o=new oh;if(e instanceof Rn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new $e(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new $e(`No value is provided for the model's input ${l.name}`);o.add(l,u)}const a=K2(i,o);return r?a:a[0]}retrieveSymbolicTensors(e){const n=of(null,e.length);let r=e.length;for(const s of this.layers){const i=Array.isArray(s.output)?s.output:[s.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(n[a]=i[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw n.forEach((i,o)=>{i==null&&s.push(e[o])}),new $e(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(e,n=32,r=!1){return ke(()=>{const s=this.checkNumSamples(e);if(r)throw new Nn("Verbose predictLoop() is not implemented yet.");const i=ST(s,n),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)ke(()=>{const u=i[a][0],c=i[a][1],d=T2(e,u,c),f=[];if(Array.isArray(d))for(let g=0;g<d.length;++g)f.push({key:this.inputs[g],value:d[g]});else f.push({key:this.inputs[0],value:d});const m=new oh(f);return K2(this.outputs,m)}).forEach((u,c)=>o[c].push(u));return Co(o.map(a=>Gr(a,0)))})}predict(e,n={}){const r=hU(e);eP(r,this.inputNames,this.feedInputShapes,!1);try{const s=n.batchSize==null?32:n.batchSize;return TT(s),this.predictLoop(r,s)}finally{vl(r,e)}}predictOnBatch(e){eP(e,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,r=!0,s){if(this.optimizer_==null)throw new nl("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===Wb?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=ZO(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=ZO(n,this.feedOutputNames,i,!1,"target"),Kme(e,n),Xme(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new $e(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,r,s,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,n,i,o);if(r!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){const c=lU(s,this.outputNames);u=[];for(let d=0;d<c.length;++d)u.push(await uU(l[d],null,c[d]))}return[a,l,u]}testLoop(e,n,r,s=0,i){return ke(()=>{const o=this.checkNumSamples(n,r,i,"steps"),a=[];if(s>0)throw new Nn("Verbose mode is not implemented yet.");if(i!=null)throw new Nn("steps mode in testLoop() is not implemented yet");{const l=ST(o,r),u=Zr(zl(0,o));for(let c=0;c<l.length;++c){const d=l[c][0],f=l[c][1],m=Md(u,d,f-d),g=P$(n,m),y=e(g);if(c===0)for(let v=0;v<y.length;++v)a.push(Xt(0));for(let v=0;v<y.length;++v){const b=y[v];a[v]=tt(a[v],be(f-d,b))}}for(let c=0;c<a.length;++c)a[c]=St(a[c],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,n=[];for(let r=0;r<e.length;++r){const s=e[r];let i=s;if(MO(e,s)>1){const o=MO(e.slice(0,r),s);i+=`_${o}`}n.push(i)}return n}makeTrainFunction(){return e=>{const n=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const d=[];for(let y=0;y<this.inputs.length;++y)d.push({key:this.inputs[y],value:r[y]});const f=new oh(d),m=K2(this.outputs,f,{training:!0});let g;for(let y=0;y<this.lossFunctions.length;++y){const v=this.lossFunctions[y];let b=v(s[y],m[y]);i[y]!=null&&(b=Vme(b,i[y]));const x=Wr(b);n.push(x),y===0?g=b:g=tt(g,b)}for(let y=0;y<this.metricsTensors.length;++y){let v;if(this.outputs.length>1&&y<this.outputs.length)v=n[y];else{const b=this.metricsTensors[y][0],x=this.metricsTensors[y][1];v=Wr(b(s[x],m[x]))}Ts(v),o.push(v)}return g=Wr(g),this.calculateLosses().forEach(y=>{g=tt(g,y)}),g},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>ke(()=>{const n=[];let r;const s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let u=0;u<this.inputs.length;++u)o.push({key:this.inputs[u],value:s[u]});const a=new oh(o),l=K2(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],d=Wr(c(i[u],l[u]));u===0?r=d:r=tt(r,d),n.push(r)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],d=this.metricsTensors[u][1],f=Wr(c(i[d],l[d]));n.push(f)}return n})}async fit(e,n,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,i,o,a,l,u,c,d,f;try{const m=r.batchSize==null?32:r.batchSize;TT(m);const y=await this.standardizeUserData(e,n,r.sampleWeight,r.classWeight,!1,m);s=y[0],i=y[1],f=y[2];let v=!1,b;if(r.validationData!=null&&r.validationData.length>0){if(v=!0,r.validationData.length===2)l=r.validationData[0],u=r.validationData[1];else throw r.validationData.length===3?new Nn("validationData including sample weights is not supported yet."):new $e(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const F=await this.standardizeUserData(l,u,null,null,!0,m);c=F[0],d=F[1],b=c.concat(d)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){v=!0;const A=Math.floor(s[0].shape[0]*(1-r.validationSplit)),F=s[0].shape[0];c=T2(s,A,F),o=s,s=T2(s,0,A),d=T2(i,A,F),a=i,i=T2(i,0,A),b=c.concat(d)}else r.validationSteps!=null&&(v=!0);const x=s.concat(i).concat(f);this.checkTrainableWeightsConsistency();const $=this.makeTrainFunction(),S=this.getDedupedMetricsNames();let E,L;v?(this.makeTestFunction(),E=this.testFunction,L=S.slice().concat(S.map(A=>"val_"+A))):(E=null,b=[],L=S.slice());const R=eU(r.callbacks,r.yieldEvery);return await this.fitLoop($,x,S,m,r.epochs,r.verbose,R,E,b,r.shuffle,L,r.initialEpoch,null,null)}finally{this.isTraining=!1,vl(s,e),vl(i,n),vl(o,e),vl(a,n),vl(c,l),vl(d,u),f!=null&&en(f)}}async fitLoop(e,n,r,s,i,o,a,l,u,c,d,f,m,g){s==null&&(s=32),i==null&&(i=1),c==null&&(c=!0),f==null&&(f=0);let y=!1;if(l!=null&&u!=null&&(y=!0),g!=null&&(y=!0,m==null))throw new $e("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const v=this.checkNumSamples(n,s,m,"steps_per_epoch");let b;v!=null&&(b=zl(0,v)),o==null&&(o=1);const{callbackList:x,history:$}=tU(a,o,i,f,v,m,s,y,d);x.setModel(this),this.history=$,await x.onTrainBegin(),this.stopTraining_=!1;for(let S=f;S<i;++S){await x.onEpochBegin(S);const E={};if(m!=null)throw new Nn("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Nn("batch shuffling is not implemneted yet");c&&lE(b);const L=Zr(b),R=ST(v,s);for(let D=0;D<R.length;++D){const A={};if(await x.onBatchBegin(D,A),ke(()=>{const F=R[D][0],P=R[D][1],K=Md(L,F,P-F);A.batch=D,A.size=P-F;const j=P$(n,K),se=e(j);for(let fe=0;fe<r.length;++fe){const me=r[fe],ye=se[fe];A[me]=ye,Ts(ye)}if(D===R.length-1&&y){const fe=this.testLoop(l,u,s);for(let me=0;me<r.length;++me){const ye=r[me],oe=fe[me];Ts(oe),E["val_"+ye]=oe}}}),await x.onBatchEnd(D,A),YB(A),this.stopTraining_)break}L.dispose()}if(await x.onEpochEnd(S,E),this.stopTraining_)break}return await x.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,n){return Wme(this,e,n)}async trainOnBatch(e,n){const r=await this.standardizeUserData(e,n),s=r[0],i=r[1],a=this.makeTrainFunction()(s.concat(i)),l=[];for(const u of a){const c=await u.data();l.push(c[0])}return en(a),vl(r[0],e),vl(r[1],n),Co(l)}getNamedWeights(e){const n=[],r=e!=null&&e.trainableOnly,s=r?this.trainableWeights:this.weights,i=this.getWeights(r);for(let o=0;o<s.length;++o)r&&!s[o].trainable||n.push({name:s[o].originalName,tensor:i[o]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=Pb().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-Pb().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Wu(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>Wu(n))}else{const n=Object.keys(this.loss);e={};const r=this.loss;for(const s of n)if(typeof r[s]=="string")e[s]=Wu(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Wu(dv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Wu(dv(e)));{const e={};for(const n in this.metrics)e[n]=Wu(dv(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=Py(e.optimizer_config),r=Dl(n);let s;if(typeof e.loss=="string")s=Id(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(o=>Id(o));else if(e.loss!=null){s={};for(const o in e.loss)s[o]=Id(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Id(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Id(e.metrics[o])}this.compile({loss:s,metrics:i,optimizer:r})}async save(e,n){if(typeof e=="string"){const u=gV(e);if(u.length===0)throw new $e(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new $e(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new $e("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await y$(this.getNamedWeights(n)),a={modelTopology:this.toJSON(null,!1),format:Qme,generatedBy:`TensorFlow.js tfjs-layers v${g4}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:d}=await y$(await this.optimizer.getWeights(),u);r.specs.push(...d),r.data=pV([r.data,c])}return this.userDefinedMetadata!=null&&(XO(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){XO(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}ec.className="Model";it(ec);class dU extends ec{}dU.className="Functional";it(dU);async function Jme(t,e){"modelTopology"in t||(t={modelTopology:t}),t=t;let n=t.modelTopology;n.model_config!=null&&(n=n.model_config);const r=Py(n),s=Dl(r,e);if(t.weightsManifest!=null){const i=await HV(t.weightsManifest,t.pathPrefix,s.weights.map(a=>a.originalName)),o={};for(const a of s.weights)o[a.originalName]=i[a.originalName];s.loadWeights(o),en(i)}return s}async function Zme(t,e){if(e==null&&(e={}),typeof t=="string"){const n=yV(t,e);if(n.length===0)n.push(XV(t,e));else if(n.length>1)throw new $e(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return ege(t,void 0,e)}async function ege(t,e,n){if(n==null&&(n={}),t.load==null)throw new $e("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let s=r.modelTopology;s.model_config!=null&&(s=s.model_config);const i=n.strict==null?!0:n.strict,o=r.weightData!=null&&r.weightSpecs!=null&&i,a=Dl(Py(s),e,o),l=r.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),r.userDefinedMetadata!=null&&a.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new $e("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=tge(r.weightData,r.weightSpecs);a.loadWeights(u,i),a.optimizer!=null&&c.length>0&&await a.optimizer.setWeights(c),en(u),en(c.map(d=>d.tensor))}return a}function tge(t,e){const n=xE(t,e),r={},s=[];return e.forEach(i=>{i.group==="optimizer"?s.push({name:i.name,tensor:n[i.name]}):r[i.name]=n[i.name]}),{modelWeights:r,optimizerWeights:s}}class af extends ec{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:s4("sequential_"),e.layers!=null)for(const n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new $e(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const n=e instanceof af||e instanceof ec;let r;if(n){if(r=e,r.outputs.length!==1)throw new $e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new $e("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new $e("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=XB({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new $e(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new $e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=KB(this.outputs[0])}this.inboundNodes=[],new f4({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:of(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(sr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ec({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,r=console.log){this.built||this.build(),super.summary(e,n,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,r={}){if(!this.built)throw new nl("The model needs to be compiled before being used.");return this.model.evaluate(e,n,r)}async evaluateDataset(e,n){if(!this.built)throw new nl("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,r={}){if(!this.built)throw new nl("The model needs to be compiled before being used.");return this.model.fit(e,n,r)}async fitDataset(e,n){if(!this.built)throw new nl("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,r={},s=!1){let i,o={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new $e("Legacy serialization format not supported yet.");i=n}else J(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=n.layers,delete n.layers,o=n;const a=new e(o);if(!(a instanceof af))throw new Nn(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const c=Dl(l,void 0,s);s&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(e){if(this.model==null)throw new $e("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new $e("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const n of this.layers){const r={};r.className=n.getClassName(),r.config=n.getConfig(),e.push(r)}return{name:this.name,layers:e}}}af.className="Sequential";it(af);function nge(t){return new ec(t)}function rge(t){return new af(t)}function fU(t){return XB(t)}function sge(t,e){ba.registerCallbackConstructor(t,e)}let Xi=class extends $p{getConfig(){return{}}};class pU extends Xi{apply(e,n=1){return _pe(e,n)}}pU.className="elu";it(pU);class mU extends Xi{apply(e){return Ew(e)}}mU.className="selu";it(mU);class gU extends Xi{apply(e){return ol(e)}}gU.className="relu";it(gU);class yU extends Xi{apply(e){return ke(()=>uc(6,ol(e)))}}yU.className="relu6";it(yU);class wU extends Xi{apply(e){return e}}wU.className="linear";it(wU);class vU extends Xi{apply(e){return Ca(e)}}vU.className="sigmoid";it(vU);class bU extends Xi{apply(e){return Tpe(e)}}bU.className="hardSigmoid";it(bU);class xU extends Xi{apply(e){return Kh(e)}}xU.className="softplus";it(xU);class _U extends Xi{apply(e){return Ipe(e)}}_U.className="softsign";it(_U);class IU extends Xi{apply(e){return lc(e)}}IU.className="tanh";it(IU);let SN=class extends Xi{apply(e,n=-1){return T1(e,n)}};SN.className="softmax";it(SN);class TU extends Xi{apply(e,n=-1){return xw(e,n)}}TU.className="logSoftmax";it(TU);class SU extends Xi{apply(e){return ke(()=>ke(()=>{const n=Math.sqrt(2),r=be(.5,tt(1,vw(St(e,n))));return be(e,r)}))}}SU.className="gelu";it(SU);class $U extends Xi{apply(e){return ke(()=>be(.5,be(e,tt(1,lc(be(js(St(2,Math.PI)),tt(e,be(.044715,Ll(e,3)))))))))}}$U.className="gelu_new";it($U);class CU extends Xi{apply(e){return ke(()=>be(e,lc(Kh(e))))}}CU.className="mish";it(CU);class EU extends Xi{apply(e,n=1){return ke(()=>be(Ca(be(e,n)),e))}}EU.className="swish";it(EU);function Ph(t){return t.getClassName()}function $T(t,e={}){return Uw(t,Ia.getMap().classNameMap,e,"activation")}function Fh(t){if(t==null){const e={};return e.className="linear",e.config={},$T(e)}if(typeof t=="string"){const e={};return e.className=t,e.config={},$T(e)}else return t instanceof Xi?t:$T(t)}function $N(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}class kU extends $p{}class qw extends kU{constructor(e){super(),$N(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ke(()=>{let n=ps([1]);return this.hasL1&&(n=tt(n,Ot(be(this.l1,fs(e))))),this.hasL2&&(n=tt(n,Ot(be(this.l2,jw(e))))),Ie(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}qw.className="L1L2";it(qw);function ige(t){return $N(t),new qw({l1:t!=null?t.l1:null,l2:0})}function oge(t){return $N(t),new qw({l2:t!=null?t.l2:null,l1:0})}const tP={l1l2:"L1L2"};function Sr(t){return iN(t)}function nP(t,e={}){return Uw(t,Ia.getMap().classNameMap,e,"regularizer")}function Hr(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in tP?tP[t]:t,config:{}};return nP(n)}else return t instanceof kU?t:nP(t)}class CN extends Pn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=dn(e);let r=ol(e);return this.maxValue!=null&&(r=Hi(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}CN.className="ReLU";it(CN);class EN extends Pn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const r=dn(e);return f1(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}EN.className="LeakyReLU";it(EN);class kN extends Pn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=jr(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Hr(e.alphaRegularizer),this.alphaConstraint=Ws(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new $e(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=sr(e);const n=e.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new Ss({ndim:e.length,axes:r})],this.built=!0}call(e,n){return e=dn(e),b1(e,this.alpha.read())}getConfig(){const e={alphaInitializer:es(this.alphaInitializer),alphaRegularizer:Sr(this.alphaRegularizer),alphaConstraint:Us(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}kN.className="PReLU";it(kN);let NN=class extends Pn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Nn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const r=dn(e);return _p(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};NN.className="ELU";it(NN);class AN extends Pn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){const r=dn(e);return be(r,gt(Ki(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}AN.className="ThresholdedReLU";it(AN);class RN extends Pn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new SN().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){return ke(()=>{let r=dn(e);const s=n.mask;if(s!=null){const i=be($t(fo(r.shape),gt(s,r.dtype)),Xt(-1e9));r=tt(r,i)}return this.axis instanceof Array?this.axis.length>1?ki($t(r,m1(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}RN.className="Softmax";it(RN);function $m(t,e,n){if(typeof t=="number")return of(t,e);if(t.length!==e)throw new $e(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){const s=t[r];if(!wpe(s))throw new $e(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t}function Ol(t,e,n,r,s=1){if(t==null)return t;const i=e+(e-1)*(s-1);let o;return n==="same"?o=t:o=t-i+1,Math.floor((o+r-1)/r)}function iu(t,e,n,r){if(t==null)return null;if(r==="valid")t=t*e+Oh([n-e,0]);else if(r==="same")t=t*e;else throw new $e(`Unsupport padding mode: ${r}.`);return t}function DN(t,e){return ke(()=>(ws(e),e==="channelsFirst"?Mn(t,[0,2,3,1]):t))}function NU(t,e){return ke(()=>(ws(e),e==="channelsFirst"?Mn(t,[0,2,3,4,1]):t))}function age(t,e,n,r=1,s="valid",i,o=1){return ke(()=>{if(i==null&&(i=Vl()),ws(i),t.shape.length!==3)throw new $e(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new $e(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new $e(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(i==="channelsFirst"&&(t=Mn(t,[0,2,1])),s==="causal")throw new Nn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=mw(t,e,r,s==="same"?"same":"valid","NWC",o);return n!=null&&(a=Hl(a,n)),a})}function rP(t,e,n,r=[1,1],s="valid",i,o,a=null){return ke(()=>{if(i==null&&(i=Vl()),ws(i),t.rank!==3&&t.rank!==4)throw new $e(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new $e(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=DN(t,i);if(s==="causal")throw new Nn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=LV({x:l,filter:e,strides:r,pad:s==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),i==="channelsFirst"&&(l=Mn(l,[0,3,1,2])),l})}function lge(t,e,n,r=[1,1,1],s="valid",i,o){return ke(()=>{if(i==null&&(i=Vl()),ws(i),t.rank!==4&&t.rank!==5)throw new $e(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new $e(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=NU(t,i);if(s==="causal")throw new Nn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=r_(a,e,r,s==="same"?"same":"valid","NDHWC",o),n!=null&&(a=Hl(a,n)),i==="channelsFirst"&&(a=Mn(a,[0,4,1,2,3])),a})}class y4 extends Pn{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",y4.verifyArgs(n),this.rank=e,ni(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Nn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=$m(n.kernelSize,e,"kernelSize"),this.strides=$m(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,Na(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,ws(this.dataFormat),this.activation=Fh(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=jr(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ws(n.biasConstraint),this.biasRegularizer=Hr(n.biasRegularizer),this.activityRegularizer=Hr(n.activityRegularizer),this.dilationRate=$m(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new $e(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new $e(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new $e(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(su("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!oN(e.kernelSize,"number",1,3))throw new $e(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ph(this.activation),useBias:this.useBias,biasInitializer:es(this.biasInitializer),biasRegularizer:Sr(this.biasRegularizer),activityRegularizer:Sr(this.activityRegularizer),biasConstraint:Us(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}class N1 extends y4{constructor(e,n){super(e,n),this.kernel=null,N1.verifyArgs(n),this.filters=n.filters,ni(this.filters,"filters"),this.kernelInitializer=jr(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ws(n.kernelConstraint),this.kernelRegularizer=Hr(n.kernelRegularizer)}build(e){e=sr(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new $e(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(e,n){return ke(()=>{e=dn(e);let r;const s=this.bias==null?null:this.bias.read(),i=zB(this.activation.getClassName());if(i!=null&&this.rank===2)r=rP(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)r=age(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=rP(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=lge(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Nn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=sr(e);const n=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<r.length;++i){const o=Ol(r[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);n.push(o)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){const e={filters:this.filters,kernelInitializer:es(this.kernelInitializer),kernelRegularizer:Sr(this.kernelRegularizer),kernelConstraint:Us(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new $e(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class A1 extends N1{constructor(e){super(2,e),A1.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!oN(e.kernelSize,"number",1,2))throw new $e(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}A1.className="Conv2D";it(A1);class R1 extends N1{constructor(e){super(3,e),R1.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new $e(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}R1.className="Conv3D";it(R1);class ON extends A1{constructor(e){if(super(e),this.inputSpec=[new Ss({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new $e(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=sr(e),e.length!==4)throw new $e("Input should have rank 4; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new $e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ss({ndim:4,axes:{[n]:r}})],this.built=!0}call(e,n){return ke(()=>{let r=dn(e);if(r.shape.length!==4)throw new $e(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=s[o],u=s[a],c=this.kernelSize[0],d=this.kernelSize[1],f=this.strides[0],m=this.strides[1],g=iu(l,f,c,this.padding),y=iu(u,m,d,this.padding),v=[i,g,y,this.filters];this.dataFormat!=="channelsLast"&&(r=Mn(r,[0,2,3,1]));let b=gw(r,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=Mn(b,[0,3,1,2])),this.bias!=null&&(b=Hl(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=sr(e);const n=e.slice();let r,s,i;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3):(r=3,s=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[r]=this.filters,n[s]=iu(n[s],l,o,this.padding),n[i]=iu(n[i],u,a,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}ON.className="Conv2DTranspose";it(ON);class PN extends R1{constructor(e){if(super(e),this.inputSpec=[new Ss({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new $e(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=sr(e),e.length!==5)throw new $e("Input should have rank 5; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new $e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ss({ndim:5,axes:{[n]:r}})],this.built=!0}call(e,n){return ke(()=>{let r=dn(e);if(r.shape.length!==5)throw new $e(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const u=s[l],c=s[o],d=s[a],f=this.kernelSize[0],m=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[0],v=this.strides[1],b=this.strides[2],x=iu(u,y,f,this.padding),$=iu(c,v,m,this.padding),S=iu(d,b,g,this.padding),E=[i,x,$,S,this.filters];this.dataFormat!=="channelsLast"&&(r=Mn(r,[0,2,3,4,1]));let L=s_(r,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(L=Mn(L,[0,4,1,2,3])),this.bias!==null&&(L=Hl(L,this.bias.read(),this.dataFormat)),this.activation!==null&&(L=this.activation.apply(L)),L})}computeOutputShape(e){e=sr(e);const n=e.slice();let r,s,i,o;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3,o=4):(r=4,s=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],d=this.strides[1],f=this.strides[2];return n[r]=this.filters,n[s]=iu(n[s],c,a,this.padding),n[i]=iu(n[i],d,l,this.padding),n[o]=iu(n[o],f,u,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}PN.className="Conv3DTranspose";it(PN);class AU extends N1{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new $e("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new $e("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new $e(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=jr(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Hr(n.depthwiseRegularizer),this.depthwiseConstraint=Ws(n.depthwiseConstraint),this.pointwiseInitializer=jr(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Hr(n.pointwiseRegularizer),this.pointwiseConstraint=Ws(n.pointwiseConstraint)}build(e){if(e=sr(e),e.length<this.rank+2)throw new $e(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new $e(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);const r=e[n],s=this.kernelSize.concat([r,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Ss({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(e,n){return ke(()=>{e=dn(e);let r;if(this.rank===1)throw new Nn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Mn(e,[0,2,3,1])),r=kw(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Hl(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=Mn(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=es(this.depthwiseInitializer),e.pointwiseInitializer=es(this.pointwiseInitializer),e.depthwiseRegularizer=Sr(this.depthwiseRegularizer),e.pointwiseRegularizer=Sr(this.pointwiseRegularizer),e.depthwiseConstraint=Us(this.depthwiseConstraint),e.pointwiseConstraint=Us(this.pointwiseConstraint),e}}AU.className="SeparableConv";class FN extends AU{constructor(e){super(2,e)}}FN.className="SeparableConv2D";it(FN);class Kw extends N1{constructor(e){super(1,e),Kw.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!oN(e.kernelSize,"number",1,1))throw new $e(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Kw.className="Conv1D";it(Kw);class LN extends Pn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return ke(()=>{if(e=dn(e),this.dataFormat==="channelsLast"){const r=hv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return hv(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=hv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return hv(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}LN.className="Cropping2D";it(LN);class MN extends Pn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,mpe(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const n=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,r]}else{const n=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],n,r,e[3]]}}call(e,n){return ke(()=>{let r=dn(e);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=Mn(r,[0,2,3,1]);const i=this.size[0]*s[2],o=this.size[1]*s[3],a=this.interpolation==="nearest"?Ci.resizeNearestNeighbor(r,[i,o]):Ci.resizeBilinear(r,[i,o]);return Mn(a,[0,3,1,2])}else{const i=this.size[0]*s[1],o=this.size[1]*s[2];return this.interpolation==="nearest"?Ci.resizeNearestNeighbor(r,[i,o]):Ci.resizeBilinear(r,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}MN.className="UpSampling2D";it(MN);function uge(t,e,n=[1,1],r="valid",s,i){return ke(()=>{s==null&&(s=Vl()),ws(s);let o=DN(t,s);if(t.rank!==4)throw new $e(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new $e(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=xp(o,e,n,r==="same"?"same":"valid","NHWC",i),s==="channelsFirst"&&(o=Mn(o,[0,3,1,2])),o})}class zN extends y4{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=jr(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ws(e.depthwiseConstraint),this.depthwiseRegularizer=Hr(e.depthwiseRegularizer)}build(e){if(e=sr(e),e.length<4)throw new $e(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new $e(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);const r=e[n],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ke(()=>{e=dn(e);let r=uge(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Hl(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=sr(e);const n=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Ol(n,this.kernelSize[0],this.padding,this.strides[0]),o=Ol(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,o]:[e[0],i,o,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=es(this.depthwiseInitializer),e.depthwiseRegularizer=Sr(this.depthwiseRegularizer),e.depthwiseConstraint=Us(this.depthwiseRegularizer),e}}zN.className="DepthwiseConv2D";it(zN);function RU(t,e,n,r){if(Array.isArray(t)){if(e!=null||n!=null)throw new $e("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function s(i){return i==null||Array.isArray(i)?i:[i]}return e=s(e),n=s(n),{inputs:t,initialState:e,constants:n}}function DU(t,e,n,r=!1,s,i,o=!1,a=!1){return ke(()=>{const l=e.shape.length;if(l<3)throw new $e(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(zl(2,l));e=Mn(e,u),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=gt(gt(s,"bool"),"float32"),s.rank===l-1&&(s=os(s,-1)),s=Mn(s,u)),r&&(e=ia(e,0),s!=null&&(s=ia(s,0)));const c=[];let d,f=n;const m=e.shape[0],g=oa(e);let y;s!=null&&(y=oa(s));for(let b=0;b<m;++b){const x=g[b],$=ke(()=>t(x,f));if(s==null)d=$[0],f=$[1];else{const S=ke(()=>{const E=y[b],L=$t(Ro(E),E),R=tt(be($[0],E),be(f[0],L)),D=f.map((A,F)=>tt(be($[1][F],E),be(A,L)));return{output:R,newStates:D}});d=S.output,f=S.newStates}a&&c.push(d)}let v;return a&&(v=qi(c,1)),[d,v,f]})}class ql extends Pn{constructor(e){super(e);let n;if(e.cell==null)throw new $e("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new b4({cells:e.cell}):n=e.cell,n.stateSize==null)throw new $e("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ss({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return zl(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){A$(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const r=n[0];let s;if(this.returnSequences?s=[e[0],e[1],r]:s=[e[0],r],this.returnState){const i=[];for(const o of n)i.push([e[0],o]);return[s].concat(i)}else return s}computeMask(e,n){return ke(()=>{Array.isArray(n)&&(n=n[0]);const r=this.returnSequences?n:null;if(this.returnState){const s=this.states.map(i=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<e;++r)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Nn("Constants support is not implemented in RNN yet.");A$(e)&&(e=e[0]),e=e;const n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Ss({shape:[n,null,...r]});const s=[e[0]].concat(e.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!zn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new $e(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new Ss({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){ke(()=>{if(!this.stateful)throw new ru("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new $e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ps([r,s])):this.states_=[ps([r,this.cell.stateSize])];else if(e==null)en(this.states_),this.keptStates!=null&&(en(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ps([r,s])):this.states_[0]=ps([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new $e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):en(this.states_);for(let s=0;s<this.states_.length;++s){const i=e[s],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,a=[r,o];if(!zn(i.shape,a))throw new $e(`State ${s} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Ts(s.clone()))})}apply(e,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const i=RU(e,r,s,this.numConstants);e=i.inputs,r=i.initialState,s=i.constants;let o=[],a=[];if(r!=null){n.initialState=r,o=o.concat(r),this.stateSpec=[];for(const u of r)this.stateSpec.push(new Ss({shape:u.shape}));a=a.concat(this.stateSpec)}if(s!=null&&(n.constants=s,o=o.concat(s),this.numConstants=s.length),o[0]instanceof Bl){const u=[e].concat(o),c=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=c;const f=super.apply(u,n);return this.inputSpec=d,f}else return super.apply(e,n)}call(e,n){return ke(()=>{const r=n==null?null:n.mask,s=n==null?null:n.training;let i=n==null?null:n.initialState;e=dn(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new $e(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},u=DU((g,y)=>{const v=this.cell.call([g].concat(y),a);return[v[0],v.slice(1)]},e,i,this.goBackwards,r,null,this.unroll,this.returnSequences),c=u[0],d=u[1],f=u[2];this.stateful&&this.resetStates(f,s);const m=this.returnSequences?d:c;return this.returnState?[m].concat(f):m})}getInitialState(e){return ke(()=>{let n=ps(e.shape);return n=Ot(n,[1,2]),n=Ww(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?k$(n,[1,r]):n):this.cell.stateSize>1?[k$(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===ql.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),n)}static fromConfig(e,n,r={}){const s=n.cell,i=Dl(s,r);return new e(Object.assign(n,{cell:i}))}}ql.className="RNN";it(ql);class Xw extends Pn{}class w4 extends Xw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ni(this.units,"units"),this.activation=Fh(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Hr(e.kernelRegularizer),this.recurrentRegularizer=Hr(e.recurrentRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.kernelConstraint=Ws(e.kernelConstraint),this.recurrentConstraint=Ws(e.recurrentConstraint),this.biasConstraint=Ws(e.biasConstraint),this.dropout=jm([1,Oh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=jm([1,Oh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=sr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ke(()=>{if(e=e,e.length!==2)throw new $e(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lh({ones:()=>Ro(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lh({ones:()=>Ro(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=wu(be(e,o),this.kernel.read()):i=wu(e,this.kernel.read()),this.bias!=null&&(i=Hl(i,this.bias.read())),a!=null&&(r=be(r,a));let l=tt(i,wu(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Ph(this.activation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),recurrentInitializer:es(this.recurrentInitializer),biasInitializer:es(this.biasInitializer),kernelRegularizer:Sr(this.kernelRegularizer),recurrentRegularizer:Sr(this.recurrentRegularizer),biasRegularizer:Sr(this.biasRegularizer),activityRegularizer:Sr(this.activityRegularizer),kernelConstraint:Us(this.kernelConstraint),recurrentConstraint:Us(this.recurrentConstraint),biasConstraint:Us(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}w4.className="SimpleRNNCell";it(w4);class VN extends ql{constructor(e){e.cell=new w4(e),super(e)}call(e,n){return ke(()=>{this.cell.dropoutMask!=null&&(en(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(en(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,n){return new e(n)}}VN.className="SimpleRNN";it(VN);class v4 extends Xw{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new $e("GRUCell does not support reset_after parameter set to true.");this.units=e.units,ni(this.units,"units"),this.activation=Fh(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fh(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Hr(e.kernelRegularizer),this.recurrentRegularizer=Hr(e.recurrentRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.kernelConstraint=Ws(e.kernelConstraint),this.recurrentConstraint=Ws(e.recurrentConstraint),this.biasConstraint=Ws(e.biasConstraint),this.dropout=jm([1,Oh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=jm([1,Oh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=sr(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ke(()=>{if(e=e,e.length!==2)throw new $e(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=n.training==null?!1:n.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lh({ones:()=>Ro(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lh({ones:()=>Ro(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(e=be(e,i[0]));let c=wu(e,this.kernel.read());this.useBias&&(c=Hl(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=be(s,o[0]));const d=this.recurrentKernel.read(),[f,m]=po(d,[2*this.units,this.units],d.rank-1),g=wu(s,f),[y,v,b]=po(c,3,c.rank-1),[x,$]=po(g,2,g.rank-1);a=this.recurrentActivation.apply(tt(y,x)),l=this.recurrentActivation.apply(tt(v,$));const S=wu(be(l,s),m);u=this.activation.apply(tt(b,S));const E=tt(be(a,s),be(tt(1,$r(a)),u));return[E,E]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Ph(this.activation),recurrentActivation:Ph(this.recurrentActivation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),recurrentInitializer:es(this.recurrentInitializer),biasInitializer:es(this.biasInitializer),kernelRegularizer:Sr(this.kernelRegularizer),recurrentRegularizer:Sr(this.recurrentRegularizer),biasRegularizer:Sr(this.biasRegularizer),activityRegularizer:Sr(this.activityRegularizer),kernelConstraint:Us(this.kernelConstraint),recurrentConstraint:Us(this.recurrentConstraint),biasConstraint:Us(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}v4.className="GRUCell";it(v4);class BN extends ql{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new v4(e),super(e)}call(e,n){return ke(()=>{this.cell.dropoutMask!=null&&(en(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(en(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}BN.className="GRU";it(BN);class Yw extends Xw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ni(this.units,"units"),this.activation=Fh(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fh(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Hr(e.kernelRegularizer),this.recurrentRegularizer=Hr(e.recurrentRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.kernelConstraint=Ws(e.kernelConstraint),this.recurrentConstraint=Ws(e.recurrentConstraint),this.biasConstraint=Ws(e.biasConstraint),this.dropout=jm([1,Oh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=jm([1,Oh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=sr(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;s=new(n=class extends al{apply(l,u){const c=i.apply([o]),d=new o4().apply([o]),f=i.apply([o*2]);return VO(VO(c,d),f)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return ke(()=>{const r=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new $e(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lh({ones:()=>Ro(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lh({ones:()=>Ro(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,d;0<this.dropout&&this.dropout<1&&(e=be(e,o[0]));let f=wu(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=be(s,a[0])),f=tt(f,wu(s,this.recurrentKernel.read())),this.useBias&&(f=Hl(f,this.bias.read()));const[m,g,y,v]=po(f,4,f.rank-1);l=this.recurrentActivation.apply(m),u=this.recurrentActivation.apply(g),c=tt(be(u,i),be(l,this.activation.apply(y))),d=this.recurrentActivation.apply(v);const b=be(d,this.activation.apply(c));return[b,b,c]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Ph(this.activation),recurrentActivation:Ph(this.recurrentActivation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),recurrentInitializer:es(this.recurrentInitializer),biasInitializer:es(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Sr(this.kernelRegularizer),recurrentRegularizer:Sr(this.recurrentRegularizer),biasRegularizer:Sr(this.biasRegularizer),activityRegularizer:Sr(this.activityRegularizer),kernelConstraint:Us(this.kernelConstraint),recurrentConstraint:Us(this.recurrentConstraint),biasConstraint:Us(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}Yw.className="LSTMCell";it(Yw);class UN extends ql{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Yw(e),super(e)}call(e,n){return ke(()=>{this.cell.dropoutMask!=null&&(en(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(en(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}UN.className="LSTM";it(UN);class b4 extends Xw{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return ke(()=>{e=e;let r=e.slice(1);const s=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?s.push(r.splice(0,a.stateSize.length)):s.push(r.splice(0,1));s.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];r=s[a],a===0?o=[e[0]].concat(r):o=[o[0]].concat(r),o=l.call(o,n),i.push(o.slice(1))}r=[];for(const a of i.slice().reverse())r.push(...a);return[o[0]].concat(r)})}build(e){A$(e)&&(e=e[0]),e=e;let n;this.cells.forEach((r,s)=>{Ld(`RNNCell_${s}`,()=>{r.build(e),Array.isArray(r.stateSize)?n=r.stateSize[0]:n=r.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){const e=super.getConfig(),n=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,n,r={}){const s=[];for(const i of n.cells)s.push(Dl(i,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.cells)n.push(...r.trainableWeights);return n.concat(e)}return e}getWeights(){const e=[];for(const n of this.cells)e.push(...n.weights);return R$(e)}setWeights(e){const n=[];for(const r of this.cells){const s=r.weights.length,i=e.splice(s);for(let o=0;o<r.weights.length;++o)n.push([r.weights[o],i[o]])}mN(n)}}b4.className="StackedRNNCells";it(b4);function Lh(t){const{ones:e,rate:n,training:r=!1,count:s=1,dropoutFunc:i}=t,o=()=>i!=null?i(e(),n):HB(e(),n),a=()=>Gw(o,e,r);return!s||s<=1?Ts(a().clone()):Array(s).fill(void 0).map(a).map(u=>Ts(u.clone()))}var cge=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(t);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(n[r[s]]=t[r[s]]);return n};class OU extends ql{constructor(e){if(e.unroll)throw new Nn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Nn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ss({ndim:5})]}call(e,n){return ke(()=>{if(this.cell.dropoutMask!=null&&(en(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(en(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new $e("ConvRNN2D cell does not support constants");const r=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return ke(()=>{const{stateSize:n}=this.cell,r=e.shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)],o=ps(i);return Array.isArray(n)?Array(n.length).fill(o):[o]})}resetStates(e,n=!1){ke(()=>{if(!this.stateful)throw new ru("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)];if(r[0]==null)throw new $e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ps(i)):this.states_=[ps(i)];else if(e==null)en(this.states_),this.keptStates!=null&&(en(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ps(i)):this.states_[0]=ps(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new $e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):en(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],u=i;if(!zn(l.shape,u))throw new $e(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Ts(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:n,filters:r,kernelSize:s,padding:i,strides:o,dilationRate:a}=this.cell,l=n==="channelsFirst",u=e[l?3:2],c=e[l?4:3],d=Ol(u,s[0],i,o[0],a[0]),f=Ol(c,s[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[r,d,f]:[d,f,r]]}}OU.className="ConvRNN2D";class x4 extends Yw{constructor(e){const{filters:n,kernelSize:r,strides:s,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,ni(this.filters,"filters"),this.kernelSize=$m(r,2,"kernelSize"),this.kernelSize.forEach(l=>ni(l,"kernelSize")),this.strides=$m(s||1,2,"strides"),this.strides.forEach(l=>ni(l,"strides")),this.padding=i||"valid",Na(this.padding),this.dataFormat=o||"channelsLast",ws(this.dataFormat),this.dilationRate=$m(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>ni(l,"dilationRate"))}build(e){var n;e=sr(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new $e(`The channel dimension of the input should be defined. Found ${e[r]}`);const s=e[r],i=4,o=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends al{apply(f,m){const g=u.apply([c]),y=fo([c]),v=u.apply([c*2]);return aN([g,y,v])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return ke(()=>{if(e.length!==3)throw new $e(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=n.training||!1,s=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lh({ones:()=>Ro(s),rate:this.dropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(_e,Y,re)=>!Y||!Y[re]?_e:be(Y[re],_e);let c=u(s,l,0),d=u(s,l,1),f=u(s,l,2),m=u(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lh({ones:()=>Ro(i),rate:this.recurrentDropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let y=u(i,g,0),v=u(i,g,1),b=u(i,g,2),x=u(i,g,3);const $=3,[S,E,L,R]=po(this.kernel.read(),a,$),[D,A,F,P]=this.useBias?po(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,S,D,this.padding),d=this.inputConv(d,E,A,this.padding),f=this.inputConv(f,L,F,this.padding),m=this.inputConv(m,R,P,this.padding);const[K,j,se,fe]=po(this.recurrentKernel.read(),a,$);y=this.recurrentConv(y,K),v=this.recurrentConv(v,j),b=this.recurrentConv(b,se),x=this.recurrentConv(x,fe);const me=this.recurrentActivation.apply(tt(c,y)),ye=this.recurrentActivation.apply(tt(d,v)),oe=tt(be(ye,o),be(me,this.activation.apply(tt(f,b)))),ue=be(this.recurrentActivation.apply(tt(m,x)),this.activation.apply(oe));return[ue,ue,oe]})}getConfig(){const e=super.getConfig(),{units:n}=e,r=cge(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),s)}inputConv(e,n,r,s){const i=Tu(e,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Hl(i,r,this.dataFormat):i}recurrentConv(e,n){return Tu(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}x4.className="ConvLSTM2DCell";it(x4);class WN extends OU{constructor(e){const n=new x4(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}WN.className="ConvLSTM2D";it(WN);class _4 extends Pn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const n=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return r}call(e,n){return ke(()=>{this.invokeCallHook(e,n);const r=dn(e);if(0<this.rate&&this.rate<1){const s=n.training==null?!1:n.training,i=this.getNoiseShape(r);return Gw(()=>HB(r,this.rate,i,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}_4.className="Dropout";it(_4);class jN extends _4{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const n=e.shape;return[n[0],1,n[2]]}}jN.className="SpatialDropout1D";it(jN);class GN extends Pn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,ni(this.units,"units"),this.activation=Fh(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ws(e.kernelConstraint),this.biasConstraint=Ws(e.biasConstraint),this.kernelRegularizer=Hr(e.kernelRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.activityRegularizer=Hr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=sr(e);const n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=sr(e);const n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return ke(()=>{this.invokeCallHook(e,n);const r=dn(e),s=zB(this.activation.getClassName());let i;return s!=null?i=wu(r,this.kernel.read(),s,this.bias?this.bias.read():null):(i=wu(r,this.kernel.read()),this.bias!=null&&(i=Hl(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Ph(this.activation),useBias:this.useBias,kernelInitializer:es(this.kernelInitializer),biasInitializer:es(this.biasInitializer),kernelRegularizer:Sr(this.kernelRegularizer),biasRegularizer:Sr(this.biasRegularizer),activityRegularizer:Sr(this.activityRegularizer),kernelConstraint:Us(this.kernelConstraint),biasConstraint:Us(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}GN.className="Dense";it(GN);class HN extends Pn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=sr(e);for(const n of e.slice(1))if(n==null)throw new $e(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],wh(e,1)]}call(e,n){return ke(()=>{this.invokeCallHook(e,n);let r=dn(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let i=2;i<r.rank;++i)s.push(i);s.push(1),r=Mn(r,s)}return xpe(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(e,n),e}}HN.className="Flatten";it(HN);class qN extends Pn{constructor(e){super(e),this.supportsMasking=!0,this.activation=Fh(e.activation)}call(e,n){return ke(()=>{this.invokeCallHook(e,n);const r=dn(e);return this.activation.apply(r)})}getConfig(){const e={activation:Ph(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}qN.className="Activation";it(qN);class KN extends Pn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return ke(()=>(e=dn(e),vpe(e,this.n)))}getConfig(){const e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}KN.className="RepeatVector";it(KN);class XN extends Pn{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){const r="Total size of new array must be unchanged.",s=n.slice();let i=1,o=null;for(let l=0;l<s.length;++l){const u=s[l];if(this.isUnknown(u))if(o===null)o=l;else throw new $e("Can only specifiy one unknown dimension.");else i*=u}const a=wh(e);if(o!==null){if(i===0||a%i!==0)throw new $e(r);s[o]=a/i}else if(a!==i)throw new $e(r);return s}computeOutputShape(e){let n=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return ke(()=>{this.invokeCallHook(e,n);const r=dn(e),s=r.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return Ie(r,i)})}getConfig(){const e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}}XN.className="Reshape";it(XN);class YN extends Pn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const n=zl(1,e.dims.length+1);if(!zn(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ss({ndim:this.dims.length+1})]}computeOutputShape(e){e=sr(e);const n=e.slice();return this.dims.forEach((r,s)=>{n[s+1]=e[r]}),n}call(e,n){return Mn(dn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}YN.className="Permute";it(YN);class QN extends Pn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){const r=dn(e);return Um(Rh(r,this.maskValue),-1)}call(e,n){return ke(()=>{this.invokeCallHook(e,n);const r=dn(e),o=Um(Rh(r,this.maskValue),-1,!0);return be(r,gt(o,r.dtype))})}}QN.className="Masking";it(QN);class JN extends Pn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(yr(e.inputLength))}this.inputDim=e.inputDim,ni(this.inputDim,"inputDim"),this.outputDim=e.outputDim,ni(this.outputDim,"outputDim"),this.embeddingsInitializer=jr(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Hr(e.embeddingsRegularizer),this.activityRegularizer=Hr(e.activityRegularizer),this.embeddingsConstraint=Ws(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return ke(()=>this.maskZero?(e=dn(e),Rh(e,jn(e))):null)}computeOutputShape(e){if(e=sr(e),this.inputLength==null)return[...e,this.outputDim];const n=yr(this.inputLength);if(n.length!==e.length-1)throw new $e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<n.length;++s){const i=n[s],o=e[s+1];if(i!=null&&o!=null&&i!==o)throw new $e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(n[r]=o),r++}}return[e[0],...n,this.outputDim]}call(e,n){return ke(()=>{this.invokeCallHook(e,n);let r=dn(e);r.dtype!=="int32"&&(r=yu(r,"int32"));const s=GB(this.embeddings.read(),Ie(r,[r.size]));return Ie(s,sr(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:es(this.embeddingsInitializer),embeddingsRegularizer:Sr(this.embeddingsRegularizer),activityRegularizer:Sr(this.activityRegularizer),embeddingsConstraint:Us(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}JN.className="Embedding";it(JN);class kp extends Pn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Nn}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;const r=e.slice(0,e.length-n.length);for(let s=0;s<n.length;++s){const i=e[e.length-n.length+s],o=n[s];if(i==null||o==null||i<0||o<0)r.push(null);else if(i===1)r.push(o);else if(o===1)r.push(i);else{if(i!==o)throw new $e("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));r.push(i)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[sr(e)]),e=e,e.length<2)throw new $e(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(const i of e)i!=null&&i[0]!==null&&n.push(i[0]);if(n=yh(n),n.length>1)throw new $e(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=e.map(i=>i.length);e.indexOf(null)===-1&&yh(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return ke(()=>{if(e=e,this.reshapeRequired){const r=[],s=e.map(i=>i.rank);if(s.indexOf(null)===-1){const i=Oh(s);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=Ww(o,1);r.push(o)}return this.mergeFunction(r)}else{let i=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,d=c[0],f=c.slice(1).concat([d]);let m=Ie(l,[d].concat(wh(c.slice(1))));m=Mn(m,[1,0]),m=Ie(m,f),r.push(m),i=!0}else if(u>1){const c=zl(1,u).concat([0]);r.push(Mn(l,c)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i){if(a==null){const l=o.shape,u=l.length,c=l[u-1],d=[c].concat(l.slice(0,l.length-1));o=Ie(Mn(Ie(o,[-1,c]),[1,0]),d)}else if(a>1){const l=[a-1].concat(zl(0,a-1));o=Mn(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let s=1;s<e.length;++s){const i=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let r=[];for(const s of e)s!=null&&s[0]!==null&&r.push(s[0]);return r=yh(r),r.length===1?n=r.concat(n):n=[null].concat(n),n}computeMask(e,n){return ke(()=>{if(n==null)return null;if(!Array.isArray(n))throw new $e("`mask` should be an Array");if(!Array.isArray(e))throw new $e("`inputs` should be an Array");if(n.length!==e.length)throw new $e(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:os(s,0));let r=n[0];for(let s=1;s<n.length-1;++s)r=ka(r,n[s]);return r})}}class ZN extends kp{constructor(e){super(e)}mergeFunction(e){return ke(()=>{let n=e[0].clone();for(let r=1;r<e.length;++r)n=tt(n,e[r]);return n})}}ZN.className="Add";it(ZN);class eA extends kp{constructor(e){super(e)}mergeFunction(e){return ke(()=>{let n=e[0].clone();for(let r=1;r<e.length;++r)n=be(n,e[r]);return n})}}eA.className="Multiply";it(eA);class tA extends kp{constructor(e){super(e)}mergeFunction(e){return ke(()=>{let n=e[0].clone();for(let r=1;r<e.length;++r)n=tt(n,e[r]);return be(1/e.length,n)})}}tA.className="Average";it(tA);class nA extends kp{constructor(e){super(e)}mergeFunction(e){return ke(()=>{let n=e[0];for(let r=1;r<e.length;++r)n=Gl(n,e[r]);return n})}}nA.className="Maximum";it(nA);class rA extends kp{constructor(e){super(e)}mergeFunction(e){return ke(()=>{let n=e[0];for(let r=1;r<e.length;++r)n=uc(n,e[r]);return n})}}rA.className="Minimum";it(rA);class sA extends kp{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new $e("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(const s of e)if(s!=null){n=!1;break}if(n)return;const r=[];for(let s=0;s<e.length;++s){const i=e[s].slice();i.splice(this.axis,1);let o=!1;for(const a of r)if(zn(a,i)){o=!0;break}o||r.push(i)}if(r.length>1)throw new $e("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ke(()=>aN(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new $e("A `Concatenate` layer should be called on a list of inputs.");const n=e,r=n[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const i of n.slice(1)){if(r[s]==null||i[s]==null){r[s]=null;break}r[s]+=i[s]}return r}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new $e("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new $e("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new $e(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return ke(()=>{let r=!0;if(n.forEach(o=>{if(o!=null){r=!1;return}}),r)return null;const s=[];for(let o=0;o<e.length;++o)n[o]==null?s.push(gt(Ro(e[o]),"bool")):n[o].rank<e[o].rank?s.push(os(n[o],-1)):s.push(n[o]);const i=Gr(s,this.axis);return fw(i,-1,!1)})}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}sA.className="Concatenate";it(sA);function S2(t,e){for(;t<0;)t+=e;return t}function hge(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new Nn("batchDot is not implemented for tensors of 4D or higher rank yet");if(J(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),J(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new Nn("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=e.shape.length;n==null&&(n=[r-1,s-2]);const i=n;return ke(()=>{let o;if(r>s){o=r-s;const l=[];for(let u=0;u<o;++u)l.push(1);e=Ie(e,e.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let u=0;u<o;++u)l.push(1);t=Ie(t,t.shape.concat(l))}else o=0;let a;if(t.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=Ot(be(t,e),i[0]):a=Ot(be(Mn(t,[1,0]),e),i[1]);else{const l=i[0]!==t.shape.length-1,u=i[1]===e.shape.length-1;a=An(t,e,l,u)}if(o>0){let l;r>s?l=r+s-3:l=r-1;const u=[];for(let c=l;c<l+o;++c)u.push(c);a=Vr(a,u)}return a.shape.length===1&&(a=os(a,1)),a})}class iA extends kp{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){J(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0],r=e[1];if(n.length>3||r.length>3)throw new Nn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);if(n[s[0]]!==r[s[1]])throw new $e(`Dimension incompatibility: ${n[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new $e(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],r=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,o)=>S2(i,e[o].shape.length)):s=[S2(this.axes,n.shape.length),S2(this.axes,r.shape.length)],this.normalize&&(n=Ub(n,s[0]),r=Ub(r,s[1])),hge(n,r,s)}interpretAxes(e,n){let r;return Array.isArray(this.axes)?r=this.axes:r=[S2(this.axes,e.length),S2(this.axes,n.length)],r}computeOutputShape(e){J(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0].slice(),r=e[1].slice();if(n.length>3||r.length>3)throw new Nn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);n.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const i=n.concat(r);return i.length===1&&i.push(1),i}computeMask(e,n){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}iA.className="Dot";it(iA);class oA extends Pn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return ke(()=>{this.invokeCallHook(e,n);const r=dn(e);return Gw(()=>tt(i4(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}}oA.className="GaussianNoise";it(oA);class aA extends Pn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return ke(()=>{this.invokeCallHook(e,n);const r=dn(e);return this.rate>0&&this.rate<1?Gw(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return be(r,i4(r.shape,1,i))},()=>r,n.training||!1):r})}}aA.className="GaussianDropout";it(aA);class lA extends Pn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||dn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return ke(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return Gw(()=>{const i=dn(e),a=-1.6732632423543772*1.0507009873554805;let l=$u(xc(r),this.rate);l=yu(l,"float32");const u=((1-this.rate)*(1+this.rate*a**2))**-.5,c=-u*a*this.rate,d=tt(be(i,l),be(tt(l,-1),a));return tt(be(d,u),c)},()=>dn(e),n.training||!1)}return e})}}lA.className="AlphaDropout";it(lA);function Fy(t,e,n,r,s,i=.001){let o;if(t.rank===2)o=Kx(t,e,n,r,s,i);else if(t.rank===3)o=Xx(t,e,n,r,s,i);else if(t.rank===4)o=Yx(t,e,n,r,s,i);else throw new Nn(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return o}function dge(t,e,n,r,s=.001){return ke(()=>{const i=w1(t,r),o=i.mean,a=i.variance;return[Fy(t,o,a,n,e,s),o,a]})}function fge(t,e,n,r,s=.001){return ke(()=>{const i=w1(t,r),o=i.mean,a=i.variance,l=[];for(const g of zl(0,t.rank))r.indexOf(g)!==-1?l.push(1):l.push(t.shape[g]);const u=Ie(o,l),c=Ie(a,l),d=e==null?null:Ie(e,l),f=n==null?null:Ie(n,l);return[Fy(t,u,c,f,d,s),o,a]})}function pge(t,e,n,r,s=.001){return zn(r.slice().sort(),zl(0,t.rank-1))?dge(t,e,n,r,s):fge(t,e,n,r,s)}class uA extends Pn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=jr(e.betaInitializer||"zeros"),this.gammaInitializer=jr(e.gammaInitializer||"ones"),this.movingMeanInitializer=jr(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=jr(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ws(e.betaConstraint),this.gammaConstraint=Ws(e.gammaConstraint),this.betaRegularizer=Hr(e.betaRegularizer),this.gammaRegularizer=Hr(e.gammaRegularizer)}build(e){e=sr(e);const n=this.axis>=0?this.axis:this.axis+e.length,r=e[n];if(r==null)throw new $e(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ss({ndim:e.length,axes:{[n]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return ke(()=>{const r=n.training==null?!1:n.training,s=dn(e),i=s.shape,o=i.length,a=zl(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const u=of(1,o);u[l]=i[l];const c=a.slice();c.sort();const d=!zn(c,zl(0,o).slice(0,o-1)),f=()=>{if(d){const x=Ie(this.movingMean.read(),u),$=Ie(this.movingVariance.read(),u),S=this.center?Ie(this.beta.read(),u):null,E=this.scale?Ie(this.gamma.read(),u):null;return Fy(s,x,$,S,E,this.epsilon)}else return Fy(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return f();const[m,g,y]=pge(s,this.gamma.read(),this.beta.read(),a,this.epsilon),v=(x,$,S)=>{ke(()=>{const E=1-S,L=x.read(),R=be($t(L,$),E);x.write($t(L,R))})};return(()=>{v(this.movingMean,g,this.momentum),v(this.movingVariance,y,this.momentum)})(),m})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:es(this.betaInitializer),gammaInitializer:es(this.gammaInitializer),movingMeanInitializer:es(this.movingMeanInitializer),movingVarianceInitializer:es(this.movingVarianceInitializer),betaRegularizer:Sr(this.betaRegularizer),gammaRegularizer:Sr(this.gammaRegularizer),betaConstraint:Us(this.betaConstraint),gammaConstraint:Us(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}uA.className="BatchNormalization";it(uA);class cA extends Pn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=jr(e.betaInitializer||"zeros"),this.gammaInitializer=jr(e.gammaInitializer||"ones"),this.betaRegularizer=Hr(e.betaRegularizer),this.gammaRegularizer=Hr(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=sr(e);const n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=n);for(const i of this.axis)if(i<0||i>=n)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==yh(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,n){const r=dn(e),s=r.shape,i=s.length;return ke(()=>{let{mean:a,variance:l}=w1(r,this.axis,!0);const u=of(1,i);for(const y of this.axis)u[y]=s[y];const c=y=>y!=null&&y.shape.length!==i?Ie(y,u):y;let d=this.scale?c(this.gamma.read()):null,f=this.center?c(this.beta.read()):null;const m=[],g=[];for(let y=0;y<i;++y)this.axis.indexOf(y)!==-1?(m.push(s[y]),g.push(1)):(m.push(1),g.push(s[y]));return a=na(a,m),l=na(l,m),d!=null&&(d=na(d,g)),f!=null&&(f=na(f,g)),Fy(r,a,l,f,d,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:es(this.betaInitializer),gammaInitializer:es(this.gammaInitializer),betaRegularizer:Sr(this.betaRegularizer),gammaRegularizer:Sr(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}cA.className="LayerNormalization";it(cA);function mge(t,e,n){return ke(()=>{if(t.rank!==4)throw new $e(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new $e("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Vl()),n!=="channelsLast"&&n!=="channelsFirst")throw new $e(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],Cu(t,r)})}class hA extends Pn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Vl():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new $e(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,r;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new $e(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new $e(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[n,r]}this.inputSpec=[new Ss({ndim:4})]}computeOutputShape(e){e=sr(e);let n,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],n,r]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],n,r,e[3]])}call(e,n){return ke(()=>mge(dn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}hA.className="ZeroPadding2D";it(hA);function I4(t,e,n,r,s,i){return ke(()=>{ws(s),BB(i),Na(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=Vl()),i==null&&(i="max"),t=DN(t,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=y1(t,e,n,a):o=u1(t,e,n,a),s==="channelsFirst"&&(o=Mn(o,[0,3,1,2])),o})}function PU(t,e,n,r,s,i){return ke(()=>{ws(s),BB(i),Na(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Vl()),i==null&&(i="max"),t=NU(t,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=w_(t,e,n,a):o=qx(t,e,n,a),s==="channelsFirst"&&(o=Mn(o,[0,4,1,2,3])),o})}class FU extends Pn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new $e(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(ni(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new $e(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);ni(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Na(this.padding),this.inputSpec=[new Ss({ndim:3})]}computeOutputShape(e){e=sr(e);const n=Ol(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return ke(()=>{this.invokeCallHook(e,n),e=Ww(dn(e),2);const r=this.poolingFunction(dn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Vr(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}}class dA extends FU{constructor(e){super(e)}poolingFunction(e,n,r,s,i){return ws(i),Na(s),I4(e,n,r,s,i,"max")}}dA.className="MaxPooling1D";it(dA);class fA extends FU{constructor(e){super(e)}poolingFunction(e,n,r,s,i){return ws(i),Na(s),I4(e,n,r,s,i,"avg")}}fA.className="AveragePooling1D";it(fA);class LU extends Pn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new $e(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];ni(this.poolSize,"poolSize"),ni(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),Na(this.padding),this.inputSpec=[new Ss({ndim:4})]}computeOutputShape(e){e=sr(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=Ol(n,this.poolSize[0],this.padding,this.strides[0]),r=Ol(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,r]:[e[0],n,r,e[3]]}call(e,n){return ke(()=>(this.invokeCallHook(e,n),this.poolingFunction(dn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class pA extends LU{constructor(e){super(e)}poolingFunction(e,n,r,s,i){return ws(i),Na(s),I4(e,n,r,s,i,"max")}}pA.className="MaxPooling2D";it(pA);class mA extends LU{constructor(e){super(e)}poolingFunction(e,n,r,s,i){return ws(i),Na(s),I4(e,n,r,s,i,"avg")}}mA.className="AveragePooling2D";it(mA);class MU extends Pn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new $e(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];ni(this.poolSize,"poolSize"),ni(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),Na(this.padding),this.inputSpec=[new Ss({ndim:5})]}computeOutputShape(e){e=sr(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=Ol(n,this.poolSize[0],this.padding,this.strides[0]),r=Ol(r,this.poolSize[1],this.padding,this.strides[1]),s=Ol(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,r,s]:[e[0],n,r,s,e[4]]}call(e,n){return ke(()=>(this.invokeCallHook(e,n),this.poolingFunction(dn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class gA extends MU{constructor(e){super(e)}poolingFunction(e,n,r,s,i){return ws(i),Na(s),PU(e,n,r,s,i,"max")}}gA.className="MaxPooling3D";it(gA);class yA extends MU{constructor(e){super(e)}poolingFunction(e,n,r,s,i){return ws(i),Na(s),PU(e,n,r,s,i,"avg")}}yA.className="AveragePooling3D";it(yA);class zU extends Pn{constructor(e){super(e),this.inputSpec=[new Ss({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,n){throw new Nn}}class wA extends zU{constructor(e){super(e||{})}call(e,n){return ke(()=>{const r=dn(e);return Wr(r,1)})}}wA.className="GlobalAveragePooling1D";it(wA);class vA extends zU{constructor(e){super(e||{})}call(e,n){return ke(()=>{const r=dn(e);return ra(r,1)})}}vA.className="GlobalMaxPooling1D";it(vA);class VU extends Pn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),this.inputSpec=[new Ss({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new Nn}getConfig(){const e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class bA extends VU{call(e,n){return ke(()=>{const r=dn(e);return this.dataFormat==="channelsLast"?Wr(r,[1,2]):Wr(r,[2,3])})}}bA.className="GlobalAveragePooling2D";it(bA);class xA extends VU{call(e,n){return ke(()=>{const r=dn(e);return this.dataFormat==="channelsLast"?ra(r,[1,2]):ra(r,[2,3])})}}xA.className="GlobalMaxPooling2D";it(xA);class BU extends Pn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,r={}){const s=n.layer,i=Dl(s,r);delete n.layer;const o={layer:i};return Object.assign(o,n),new e(o)}}class _A extends BU{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=sr(e),e.length<3)throw new $e(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=sr(e);const n=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(n),s=e[1];return[r[0],s].concat(r.slice(1))}call(e,n){return ke(()=>(e=dn(e),DU((o,a)=>[dn(this.layer.call(o,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}_A.className="TimeDistributed";it(_A);function gge(t){Cp(ppe,"BidirectionalMergeMode",t)}const yge="concat";class IA extends BU{constructor(e){super(e);const n=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=n,this.forwardLayer=Dl(r),n.goBackwards=n.goBackwards!==!0;const s={};if(s.className=e.layer.getClassName(),s.config=n,this.backwardLayer=Dl(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?yge:e.mergeMode,gge(this.mergeMode),e.weights)throw new Nn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const n=e.length,r=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let r,s,i;return this.returnState&&(i=n.slice(1)),r=n[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[r].concat(i).concat(i.slice()):Co(s)}apply(e,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const i=RU(e,r,s,this.numConstants);if(e=i.inputs,r=i.initialState,s=i.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&s==null)return super.apply(e,n);const o=[],a=[];if(r!=null){const u=r.length;if(u%2>0)throw new $e("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,o.push(...r);const c=r.map(d=>new Ss({shape:d.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(s!=null)throw new Nn("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof Bl;for(const u of o)if(u instanceof Bl!==l)throw new $e("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(o),c=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=c;const f=super.apply(u,n);return this.inputSpec=d,f}else return super.apply(e,n)}call(e,n){return ke(()=>{const r=n.initialState;let s,i;if(r==null)s=this.forwardLayer.call(e,n),i=this.backwardLayer.call(e,n);else{const l=r.slice(0,r.length/2),u=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(n,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(n,{initialState:u}))}let o;this.returnState&&(Array.isArray(s)&&(o=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=ia(i,1));let a;return this.mergeMode==="concat"?a=aN([s,i]):this.mergeMode==="sum"?a=tt(s,i):this.mergeMode==="ave"?a=be(.5,tt(s,i)):this.mergeMode==="mul"?a=be(s,i):this.mergeMode==null&&(a=[s,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ld(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ld(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[n,n]:r=n:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(i).concat(i):[r].concat(i).concat(i)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){const r=Dl(n.layer);if(delete n.layer,n.numConstants!=null)throw new Nn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=n;return s.layer=r,new e(s)}}IA.className="Bidirectional";it(IA);class TA extends Pn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return ke(()=>(e=dn(e),e.dtype!=="float32"&&(e=yu(e,"float32")),tt(be(e,this.scale),this.offset)))}}TA.className="Rescaling";it(TA);const{resizeBilinear:wge,cropAndResize:vge}=Ci;class SA extends Pn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,r,s,i,o,a,l){return ke(()=>{let u,c=!1;const d=n/o,f=r/a,m=(s+n)/o,g=(i+r)/a,y=[d,f,m,g],v=[];e.rank===3?(c=!0,u=qi([e])):u=e;for(let E=0;E<u.shape[0];E++)v.push(y);const b=Eo(v,[v.length,4]),x=Dh(0,v.length,1,"int32"),S=vge(u,b,x,[s,i],"nearest");return yu(c?dn(oa(S)):S,l)})}upsize(e,n,r,s){return ke(()=>{const i=wge(e,[n,r]);return yu(i,s)})}call(e,n){return ke(()=>{const r=dn(e),s=r.dtype,i=r.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(r,l,u,this.height,this.width,o,a,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=sr(e);const n=e.length-3,r=e.length-2;return e[n]=this.height,e[r]=this.width,e}}SA.className="CenterCrop";it(SA);function bge(t,e,n,r){let s=dn(t);if(s.dtype!=="int32"&&(s=yu(s,"int32")),e==="int")return s;const i=s.shape;if(s.rank===0&&(s=os(s,-1)),e==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=os(s,-1)),s.rank>2)throw new $e(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(e),a=s;let l;if(typeof r<"u"&&e==="count"?l=Dy(a,r,n,o):l=Dy(a,[],n,o),e!=="tfIdf")return l;if(r)return be(l,r);throw new $e("When outputMode is 'tfIdf', weights must be provided.")}class $A extends Pn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=sr(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return ke(()=>{e=dn(e),e.dtype!=="int32"&&(e=yu(e,"int32"));let r;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new $e(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);r=dn(n.countWeights)}const s=ra(e),i=Jd(e),o=Ki(this.numTokens,s).bufferSync().get(0),a=$u(i,0).bufferSync().get(0);if(!(o&&a))throw new $e(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return bge(e,this.outputMode,this.numTokens,r)})}}$A.className="CategoryEncoding";it($A);const xge=["bilinear","nearest"],sP=new Set(xge);class CA extends Pn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(sP.has(e.interpolation))this.interpolation=e.interpolation;else throw new $e(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=sr(e);const n=e[2];return[this.height,this.width,n]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return ke(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return Ci.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ci.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...sP]} are supported`)})}}CA.className="Resizing";it(CA);class UU{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}UU.className="RandomSeed";class WU extends Pn{constructor(e){super(e),this.randomGenerator=new UU(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(e,n),e}}WU.className="BaseRandomLayer";const _ge=["bilinear","nearest"],iP=new Set(_ge);class EA extends WU{constructor(e){super(e);const{factor:n,interpolation:r="bilinear"}=e;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new $e(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new $e(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new $e(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(iP.has(r))this.interpolation=r;else throw new $e(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=sr(e);const n=e[2];return[this.imgHeight,-1,n]}call(e,n){return ke(()=>{const r=dn(e);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=xc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Ci.resizeBilinear(e,o);case"nearest":return Ci.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...iP]} are supported`)}})}}EA.className="RandomWidth";it(EA);function Ige(t){return new E1(t)}function Tge(t){return new NN(t)}function Sge(t){return new CN(t)}function $ge(t){return new EN(t)}function Cge(t){return new kN(t)}function Ege(t){return new RN(t)}function kge(t){return new AN(t)}function Nge(t){return new Kw(t)}function Age(t){return new A1(t)}function Rge(t){return new ON(t)}function Dge(t){return new R1(t)}function Oge(t){return new PN(t)}function Pge(t){return new FN(t)}function Fge(t){return new LN(t)}function Lge(t){return new MN(t)}function Mge(t){return new zN(t)}function zge(t){return new qN(t)}function Vge(t){return new GN(t)}function Bge(t){return new _4(t)}function Uge(t){return new jN(t)}function Wge(t){return new HN(t)}function jge(t){return new KN(t)}function Gge(t){return new XN(t)}function Hge(t){return new YN(t)}function qge(t){return new JN(t)}function Kge(t){return new ZN(t)}function Xge(t){return new tA(t)}function Yge(t){return new sA(t)}function Qge(t){return new nA(t)}function Jge(t){return new rA(t)}function Zge(t){return new eA(t)}function e1e(t){return new iA(t)}function t1e(t){return new uA(t)}function n1e(t){return new cA(t)}function r1e(t){return new hA(t)}function kA(t){return new fA(t)}function s1e(t){return kA(t)}function i1e(t){return kA(t)}function NA(t){return new mA(t)}function o1e(t){return NA(t)}function a1e(t){return NA(t)}function AA(t){return new yA(t)}function l1e(t){return AA(t)}function u1e(t){return AA(t)}function c1e(t){return new wA(t)}function h1e(t){return new bA(t)}function jU(t){return new vA(t)}function GU(t){return new xA(t)}function HU(t){return new dA(t)}function qU(t){return new pA(t)}function d1e(t){return new gA(t)}function f1e(t){return new BN(t)}function p1e(t){return new v4(t)}function m1e(t){return new UN(t)}function g1e(t){return new Yw(t)}function y1e(t){return new VN(t)}function w1e(t){return new w4(t)}function v1e(t){return new WN(t)}function b1e(t){return new x4(t)}function x1e(t){return new ql(t)}function _1e(t){return new b4(t)}function I1e(t){return new IA(t)}function T1e(t){return new _A(t)}const S1e=jU,$1e=GU,C1e=HU,E1e=qU;function k1e(t){return new oA(t)}function N1e(t){return new aA(t)}function A1e(t){return new lA(t)}function R1e(t){return new QN(t)}function D1e(t){return new TA(t)}function O1e(t){return new SA(t)}function P1e(t){return new CA(t)}function F1e(t){return new $A(t)}function L1e(t){return new EA(t)}const M1e=Object.freeze(Object.defineProperty({__proto__:null,Layer:Pn,RNN:ql,RNNCell:Xw,activation:zge,add:Kge,alphaDropout:A1e,average:Xge,averagePooling1d:kA,averagePooling2d:NA,averagePooling3d:AA,avgPool1d:s1e,avgPool2d:o1e,avgPool3d:l1e,avgPooling1d:i1e,avgPooling2d:a1e,avgPooling3d:u1e,batchNormalization:t1e,bidirectional:I1e,categoryEncoding:F1e,centerCrop:O1e,concatenate:Yge,conv1d:Nge,conv2d:Age,conv2dTranspose:Rge,conv3d:Dge,conv3dTranspose:Oge,convLstm2d:v1e,convLstm2dCell:b1e,cropping2D:Fge,dense:Vge,depthwiseConv2d:Mge,dot:e1e,dropout:Bge,elu:Tge,embedding:qge,flatten:Wge,gaussianDropout:N1e,gaussianNoise:k1e,globalAveragePooling1d:c1e,globalAveragePooling2d:h1e,globalMaxPool1d:S1e,globalMaxPool2d:$1e,globalMaxPooling1d:jU,globalMaxPooling2d:GU,gru:f1e,gruCell:p1e,input:fU,inputLayer:Ige,layerNormalization:n1e,leakyReLU:$ge,lstm:m1e,lstmCell:g1e,masking:R1e,maxPool1d:C1e,maxPool2d:E1e,maxPooling1d:HU,maxPooling2d:qU,maxPooling3d:d1e,maximum:Qge,minimum:Jge,multiply:Zge,permute:Hge,prelu:Cge,randomWidth:L1e,reLU:Sge,repeatVector:jge,rescaling:D1e,reshape:Gge,resizing:P1e,rnn:x1e,separableConv2d:Pge,simpleRNN:y1e,simpleRNNCell:w1e,softmax:Ege,spatialDropout1d:Uge,stackedRNNCells:_1e,thresholdedReLU:kge,timeDistributed:T1e,upSampling2d:Lge,zeroPadding2d:r1e},Symbol.toStringTag,{value:"Module"}));function z1e(t,e){return _N(t,e)}function V1e(t,e){return sU(t,e)}function B1e(t,e){return iU(t,e)}function U1e(t,e){return IN(t,e)}function W1e(t,e){return TN(t,e)}function j1e(t,e){return rU(t,e)}function G1e(t,e){return _me(t,e)}function H1e(t,e){return xN(t,e)}function q1e(t,e){return p4(t,e)}function K1e(t,e){return k1(t,e)}function X1e(t,e){return k1(t,e)}function Y1e(t,e){return k1(t,e)}function Q1e(t,e){return Ep(t,e)}function J1e(t,e){return Ep(t,e)}function Z1e(t,e){return Ep(t,e)}function e2e(t,e){return Ime(t,e)}const t2e=Object.freeze(Object.defineProperty({__proto__:null,MAPE:X1e,MSE:J1e,binaryAccuracy:z1e,binaryCrossentropy:V1e,categoricalAccuracy:U1e,categoricalCrossentropy:W1e,cosineProximity:H1e,mape:Y1e,meanAbsoluteError:q1e,meanAbsolutePercentageError:K1e,meanSquaredError:Q1e,mse:Z1e,precision:j1e,r2Score:e2e,recall:G1e,sparseCategoricalAccuracy:B1e},Symbol.toStringTag,{value:"Module"}));const n2e=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:Jme},Symbol.toStringTag,{value:"Module"}));function r2e(t){return new qw(t)}function s2e(t){return ige(t)}function i2e(t){return oge(t)}const o2e=Object.freeze(Object.defineProperty({__proto__:null,l1:s2e,l1l2:r2e,l2:i2e},Symbol.toStringTag,{value:"Module"}));class KU extends Gm{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof ec))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function fv(t,e){return t<e}function oP(t,e){return t>e}class XU extends KU{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Nn("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=fv:this.mode==="max"?this.monitorFunc=oP:this.monitor.indexOf("acc")!==-1?this.monitorFunc=oP:this.monitorFunc=fv,this.monitorFunc===fv&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===fv?1/0:-1/0}async onEpochEnd(e,n){await Yc(n);const r=this.getMonitorValue(n);r!=null&&(this.monitorFunc(r-this.minDelta,this.best)?(this.best=r,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const n=e[this.monitor];return n==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),n}}function a2e(t){return new XU(t)}const l2e={earlyStopping:a2e};const u2e=De();u2e.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Qo;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(Qo||(Qo={}));var aP;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(aP||(aP={}));const RA={};function YU(t,e){const n={tfOpName:t,category:"custom",inputs:[],attrs:[],customExecutor:e};RA[t]=n}function QU(t){return RA[t]}function JU(t){delete RA[t]}function B(t,e,n,r,s){const i=e.inputParams[t];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd,u=a<0?e.inputNames.length+a:a;if(i.type==="tensor")return Si(e.inputNames[u],n,r,s);if(i.type==="tensors"){const f=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((g,y)=>{var v;return((v=f[y])===null||v===void 0?void 0:v.op)!=="NoOp"}).map(g=>Si(g,n,r,s))}const c=Si(e.inputNames[u],n,r,s),d=c.dataSync();return i.type==="number"?d[0]:$a(c.shape,d)}const o=e.attrParams[t];return o&&o.value}function Si(t,e,n,r){const[s,i]=Zo(t,n);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const o=n.currentContextIds.find(a=>!!e[qb(s,a)]);return o!==void 0?e[qb(s,o)][i]:void 0}function lP(t,e,n){return e[qb(t,n.currentContextId)]}function ju(t,e){const[n,r,s]=Zo(t,e);return[qb(n,e&&e.currentContextId),r,s]}function qb(t,e){return e?`${t}-${e}`:t}function Zo(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const i=e.parseNodeNameCache.get(t);if(i!=null)return i}const r=t.split(":");let s;if(r.length===1)s=[t,0,void 0];else{const i=r[0],o=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[i,a,o]}return n&&e.parseNodeNameCache.set(t,s),s}function tb(t,e,n){let r=B("pad",t,e,n);if(r==="explicit"){r=B("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[i*2],s[i][1]=r[i*2+1];return s}return r}function Gu(t){return t.kept?t:Rl(t)}const c2e=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],h2e=Object.freeze(Object.defineProperty({__proto__:null,json:c2e},Symbol.toStringTag,{value:"Module"}));const d2e=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],f2e=Object.freeze(Object.defineProperty({__proto__:null,json:d2e},Symbol.toStringTag,{value:"Module"}));const p2e=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],m2e=Object.freeze(Object.defineProperty({__proto__:null,json:p2e},Symbol.toStringTag,{value:"Module"}));const g2e=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],y2e=Object.freeze(Object.defineProperty({__proto__:null,json:g2e},Symbol.toStringTag,{value:"Module"}));const w2e=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],v2e=Object.freeze(Object.defineProperty({__proto__:null,json:w2e},Symbol.toStringTag,{value:"Module"}));const b2e=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],x2e=Object.freeze(Object.defineProperty({__proto__:null,json:b2e},Symbol.toStringTag,{value:"Module"}));const _2e=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],I2e=Object.freeze(Object.defineProperty({__proto__:null,json:_2e},Symbol.toStringTag,{value:"Module"}));const T2e=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],S2e=Object.freeze(Object.defineProperty({__proto__:null,json:T2e},Symbol.toStringTag,{value:"Module"}));const $2e=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],C2e=Object.freeze(Object.defineProperty({__proto__:null,json:$2e},Symbol.toStringTag,{value:"Module"}));const E2e=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],k2e=Object.freeze(Object.defineProperty({__proto__:null,json:E2e},Symbol.toStringTag,{value:"Module"}));const N2e=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],A2e=Object.freeze(Object.defineProperty({__proto__:null,json:N2e},Symbol.toStringTag,{value:"Module"}));const R2e=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],D2e=Object.freeze(Object.defineProperty({__proto__:null,json:R2e},Symbol.toStringTag,{value:"Module"}));const O2e=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],P2e=Object.freeze(Object.defineProperty({__proto__:null,json:O2e},Symbol.toStringTag,{value:"Module"}));const F2e=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],L2e=Object.freeze(Object.defineProperty({__proto__:null,json:F2e},Symbol.toStringTag,{value:"Module"}));const M2e=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],z2e=Object.freeze(Object.defineProperty({__proto__:null,json:M2e},Symbol.toStringTag,{value:"Module"}));const V2e=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],B2e=Object.freeze(Object.defineProperty({__proto__:null,json:V2e},Symbol.toStringTag,{value:"Module"}));const U2e=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],W2e=Object.freeze(Object.defineProperty({__proto__:null,json:U2e},Symbol.toStringTag,{value:"Module"}));const j2e=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],G2e=Object.freeze(Object.defineProperty({__proto__:null,json:j2e},Symbol.toStringTag,{value:"Module"}));const H2e=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],q2e=Object.freeze(Object.defineProperty({__proto__:null,json:H2e},Symbol.toStringTag,{value:"Module"}));class uP{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[h2e,f2e,m2e,y2e,v2e,x2e,I2e,S2e,C2e,k2e,A2e,D2e,P2e,L2e,z2e,B2e,W2e,G2e,q2e],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],i=[],o=[],a=r.reduce((y,v)=>(y[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?s.push(y[v.name]):v.op==="Const"?i.push(y[v.name]):(v.input==null||v.input.length===0)&&o.push(y[v.name]),y),{});let l=[];const u=[];let c={},d={};n!=null&&(c=this.mapSignatureEntries(n.inputs),d=this.mapSignatureEntries(n.outputs));const f=Object.keys(a);f.forEach(y=>{const v=a[y];v.inputNames.forEach((b,x)=>{const[$,,S]=ju(b),E=a[$];if(E.outputs!=null){const L=E.outputs.indexOf(S);if(L!==-1){const R=`${$}:${L}`;v.inputNames[x]=R}}v.inputs.push(E),E.children.push(v)})}),Object.keys(d).length===0?f.forEach(y=>{const v=a[y];v.children.length===0&&u.push(v)}):Object.keys(d).forEach(y=>{const[v]=ju(y),b=a[v];b!=null&&(b.signatureKey=d[y],u.push(b))}),Object.keys(c).length>0?Object.keys(c).forEach(y=>{const[v]=ju(y),b=a[v];b&&(b.signatureKey=c[y],l.push(b))}):l=s;let m={};e.library!=null&&e.library.function!=null&&(m=e.library.function.reduce((y,v)=>(y[v.signature.name]=this.mapFunction(v),y),{}));const g={nodes:a,inputs:l,outputs:u,weights:i,placeholders:s,signature:n,functions:m};return o.length>0&&(g.initNodes=o),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=QU(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=L$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=L$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=j$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=j$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=z$(e.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=z$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=W$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=W$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=M$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=M$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=H$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=H$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=U$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=U$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=G$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=G$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=V$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=V$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=B$(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=B$(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=cP(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=cP(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let i={};n!=null&&(i=n.reduce((d,f)=>(d[f.name]=this.mapNode(f),f.op==="Const"&&s.push(d[f.name]),d),{}));const o=[],a=[];e.signature.inputArg.forEach(d=>{const[f]=ju(d.name),m={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:DA(d.type),type:"dtype"}},children:[]};m.signatureKey=d.name,o.push(m),i[f]=m}),Object.keys(i).forEach(d=>{const f=i[d];f.inputNames.forEach((m,g)=>{const[y,,v]=ju(m),b=i[y];if(b.outputs!=null){const x=b.outputs.indexOf(v);if(x!==-1){const $=`${y}:${x}`;f.inputNames[g]=$}}f.inputs.push(b),b.children.push(f)})});const u=e.ret;e.signature.outputArg.forEach(d=>{const[f,m]=ju(u[d.name]),g=i[f];g!=null&&(g.defaultOutput=m,a.push(g))});const c=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:r,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function K2e(t){const e=De().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ZU(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):K2e(t);return e?n:n.toLowerCase()}function L$(t,e,n,r=!1){const s=t[e];return s!=null?ZU(s.s,r):n}function M$(t,e,n){const r=t[e];return r?r.b:n}function z$(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function DA(t){switch(typeof t=="string"&&(t=Qo[t]),t){case Qo.DT_FLOAT:case Qo.DT_HALF:return"float32";case Qo.DT_INT32:case Qo.DT_INT64:case Qo.DT_INT8:case Qo.DT_UINT8:return"int32";case Qo.DT_BOOL:return"bool";case Qo.DT_DOUBLE:return"float32";case Qo.DT_STRING:return"string";case Qo.DT_COMPLEX64:case Qo.DT_COMPLEX128:return"complex64";default:return null}}function cP(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function V$(t,e,n){const r=t[e];return r&&r.type?DA(r.type):n}function B$(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>DA(s)):n}function eW(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function U$(t,e,n){const r=t[e];return r&&r.shape?eW(r.shape):n}function W$(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function j$(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(i=>ZU(i,r)):n}function G$(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>eW(s)):n}function H$(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}class X2e{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(e){return Si(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Si(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return z$(this.node.rawAttrs,e,n);if(r.s!=null)return L$(this.node.rawAttrs,e,n);if(r.b!=null)return M$(this.node.rawAttrs,e,n);if(r.shape!=null)return U$(this.node.rawAttrs,e,n);if(r.type!=null)return V$(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return W$(this.node.rawAttrs,e,n);if(r.list.s!=null)return j$(this.node.rawAttrs,e,n);if(r.list.shape!=null)return G$(this.node.rawAttrs,e,n);if(r.list.b!=null)return H$(this.node.rawAttrs,e,n);if(r.list.type!=null)return B$(this.node.rawAttrs,e,n)}return n}}const Di=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Px,abs:fs,acos:zx,acosh:Vx,add:tt,addN:SE,all:fw,any:Um,argMax:Nh,argMin:Bx,asin:Ux,asinh:Wx,atan:jx,atan2:Gx,atanh:Hx,avgPool:u1,avgPool3d:qx,basicLSTMCell:CE,batchNorm:bp,batchNorm2d:Kx,batchNorm3d:Xx,batchNorm4d:Yx,batchToSpaceND:c1,bincount:Qx,bitwiseAnd:EE,booleanMaskAsync:fk,broadcastArgs:kE,broadcastTo:gh,buffer:En,cast:gt,ceil:Jx,clipByValue:Hi,clone:Rl,complex:Iu,concat:Gr,concat1d:Zx,concat2d:e_,concat3d:t_,concat4d:n_,conv1d:mw,conv2d:Tu,conv2dTranspose:gw,conv3d:r_,conv3dTranspose:s_,cos:h1,cosh:yw,cosineWindow:Lw,cumprod:Wm,cumsum:ww,denseBincount:Dy,depthToSpace:i_,depthwiseConv2d:xp,diag:AE,dilation2d:o_,div:St,divNoNan:a_,dot:l_,dropout:O_,einsum:rh,elu:_p,enclosingPowerOfTwo:P_,ensureShape:RE,equal:No,erf:vw,euclideanNorm:u_,exp:ki,expandDims:os,expm1:c_,eye:bw,fft:S1,fill:Hh,floor:Tp,floorDiv:dw,fused:bk,gather:Sp,gatherND:yk,greater:Ki,greaterEqual:$u,ifft:rf,imag:d1,image:Ci,inTopKAsync:wk,irfft:Dw,isFinite:h_,isInf:d_,isNaN:f_,leakyRelu:f1,less:Zd,lessEqual:bc,linalg:W_,linspace:OE,localResponseNormalization:p_,log:Ao,log1p:p1,logSigmoid:g_,logSoftmax:xw,logSumExp:m1,logicalAnd:ka,logicalNot:g1,logicalOr:_w,logicalXor:y_,losses:Tk,lowerBound:FE,matMul:An,max:ra,maxPool:y1,maxPool3d:w_,maxPoolWithArgmax:LE,maximum:Gl,mean:Wr,meshgrid:ME,min:Jd,minimum:uc,mirrorPad:v_,mod:b_,moments:w1,movingAverage:pk,mul:be,multiRNNCell:zE,multinomial:VE,neg:$r,norm:Ip,notEqual:Rh,oneHot:ef,ones:fo,onesLike:Ro,op:ve,outerProduct:BE,pad:Cu,pad1d:UE,pad2d:WE,pad3d:jE,pad4d:GE,pool:x_,pow:Ll,prelu:b1,print:Mx,prod:__,raggedGather:HE,raggedRange:qE,raggedTensorToTensor:KE,rand:XE,randomGamma:ZE,randomNormal:Tw,randomStandardNormal:ek,randomUniform:xc,randomUniformInt:tk,range:Dh,real:tf,reciprocal:I_,relu:ol,relu6:Sw,reshape:Ie,reverse:ia,reverse1d:nk,reverse2d:rk,reverse3d:sk,reverse4d:ik,rfft:$1,round:$w,rsqrt:Cw,scalar:Xt,scatterND:mk,searchSorted:Iw,selu:Ew,separableConv2d:kw,setdiff1dAsync:ok,sigmoid:Ca,sign:T_,signal:Ik,sin:Nw,sinh:Aw,slice:cn,slice1d:_1,slice2d:Rw,slice3d:I1,slice4d:nf,softmax:T1,softplus:Kh,spaceToBatchND:v1,sparse:Sk,sparseToDense:gk,spectral:_k,split:po,sqrt:js,square:wr,squaredDifference:Ow,squeeze:Vr,stack:qi,step:Xh,stridedSlice:S_,string:$k,sub:$t,sum:Ot,tan:$_,tanh:lc,tensor:Eo,tensor1d:Zr,tensor2d:rl,tensor3d:C_,tensor4d:ak,tensor5d:lk,tensor6d:uk,tensorScatterUpdate:hk,tile:na,topk:k_,transpose:Mn,truncatedNormal:Pw,unique:N_,unsortedSegmentSum:Fw,unstack:oa,upperBound:dk,variable:A_,where:Bs,whereAsync:D_,zeros:ps,zerosLike:jn},Symbol.toStringTag,{value:"Module"}));const Y2e=(t,e,n,r=Di)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(B("a",t,e,n),B("b",t,e,n))];case"AddN":return[r.addN(B("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(B("a",t,e,n),B("b",t,e,n))];case"Mul":return[r.mul(B("a",t,e,n),B("b",t,e,n))];case"RealDiv":case"Div":return[r.div(B("a",t,e,n),B("b",t,e,n))];case"DivNoNan":return[r.divNoNan(B("a",t,e,n),B("b",t,e,n))];case"FloorDiv":return[r.floorDiv(B("a",t,e,n),B("b",t,e,n))];case"Sub":return[r.sub(B("a",t,e,n),B("b",t,e,n))];case"Minimum":return[r.minimum(B("a",t,e,n),B("b",t,e,n))];case"Maximum":return[r.maximum(B("a",t,e,n),B("b",t,e,n))];case"Pow":return[r.pow(B("a",t,e,n),B("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(B("a",t,e,n),B("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const Q2e=(t,e,n,r=Di)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(B("x",t,e,n))];case"Acos":return[r.acos(B("x",t,e,n))];case"Acosh":return[r.acosh(B("x",t,e,n))];case"Asin":return[r.asin(B("x",t,e,n))];case"Asinh":return[r.asinh(B("x",t,e,n))];case"Atan":return[r.atan(B("x",t,e,n))];case"Atan2":return[r.atan2(B("x",t,e,n),B("y",t,e,n))];case"Atanh":return[r.atanh(B("x",t,e,n))];case"Ceil":return[r.ceil(B("x",t,e,n))];case"Complex":return[r.complex(B("real",t,e,n),B("imag",t,e,n))];case"Cos":return[r.cos(B("x",t,e,n))];case"Cosh":return[r.cosh(B("x",t,e,n))];case"Elu":return[r.elu(B("x",t,e,n))];case"Erf":return[r.erf(B("x",t,e,n))];case"Exp":return[r.exp(B("x",t,e,n))];case"Expm1":return[r.expm1(B("x",t,e,n))];case"Floor":return[r.floor(B("x",t,e,n))];case"Log":return[r.log(B("x",t,e,n))];case"Log1p":return[r.log1p(B("x",t,e,n))];case"Imag":return[r.imag(B("x",t,e,n))];case"Neg":return[r.neg(B("x",t,e,n))];case"Reciprocal":return[r.reciprocal(B("x",t,e,n))];case"Real":return[r.real(B("x",t,e,n))];case"Relu":return[r.relu(B("x",t,e,n))];case"Round":return[r.round(B("x",t,e,n))];case"Selu":return[r.selu(B("x",t,e,n))];case"Sigmoid":return[r.sigmoid(B("x",t,e,n))];case"Sin":return[r.sin(B("x",t,e,n))];case"Sign":return[r.sign(B("x",t,e,n))];case"Sinh":return[r.sinh(B("x",t,e,n))];case"Softplus":return[r.softplus(B("x",t,e,n))];case"Sqrt":return[r.sqrt(B("x",t,e,n))];case"Square":return[r.square(B("x",t,e,n))];case"Tanh":return[r.tanh(B("x",t,e,n))];case"Tan":return[r.tan(B("x",t,e,n))];case"ClipByValue":return[r.clipByValue(B("x",t,e,n),B("clipValueMin",t,e,n),B("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(B("x",t,e,n))];case"Rsqrt":return[r.rsqrt(Si(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(B("x",t,e,n),B("alpha",t,e,n))];case"Prelu":return[r.prelu(B("x",t,e,n),B("alpha",t,e,n))];case"IsNan":return[r.isNaN(Si(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(Si(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(Si(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function Qa(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){J(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],i=e[r];J(s<0||i<0||s===i,()=>n+` Shapes ${t} and ${e} must match`)}}}function hP(t){return!(typeof t=="number"||t.some(e=>e<0))}function $2(t,e,n){let r=q$(t,n);const s=!hP(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(i=>{r=q$(i.shape,r)}),!hP(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function q$(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],i=e[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:i}return n}class J2e{constructor(e,n,r,s,i,o,a){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Xt(0),Ts(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),Qa(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,Ts(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Eo([],[0].concat(this.elementShape));const r=this.readMany(e);return Qa(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),qi(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Eo([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return Qa(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Gr(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,oa(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=r===0?0:n.size/r,o=[];ke(()=>{n=Ie(n,[1,r,i]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:s[l-1],0],d=[1,e[l],i];o[l]=Ie(cn(n,c,d),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}class lf{get id(){return this.idTensor.id}constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e?.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);Qa(n,i.shape,"TensorList shape mismatch: "),Ts(i)}),this.idTensor=Xt(0),this.maxNumElements=s,Ts(this.idTensor)}copy(){return new lf([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Qa(e,this.elementShape,"TensorList shape mismatch: ");const s=$2(this.elementShape,this.tensors,e);return ke(()=>{const i=this.tensors.map(o=>Ie(o,s));return qi(i,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=$2(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,Qa(s.shape,e,"TensorList shape mismatch: "),Ie(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Qa(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ts(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new lf([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Qa(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=$2(this.elementShape,this.tensors,n);return Ie(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Qa(this.elementShape,n.shape,"TensorList shape mismatch: "),Ts(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Qa(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=$2(this.elementShape,this.tensors,r);return e.length===0?Eo([],[0].concat(s)):ke(()=>{const i=e.map(o=>Ie(this.tensors[o],s));return qi(i,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Qa(this.elementShape,n,"TensorList shape mismatch: ");const r=$2(this.elementShape,this.tensors,n);return this.size()===0?Eo([],[0].concat(r)):ke(()=>{const s=this.tensors.map(i=>Ie(i,r));return Gr(s,0)})}}function Z2e(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);Qa(s,e,"TensorList shape mismatch: ");const i=oa(t);return new lf(i,e,r)}function eye(t,e,n,r){return new lf([],t,e,r)}function tye(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new lf([],n,t.dtype,r),o=oa(t,0);return e.forEach((a,l)=>{i.setItem(a,o[l])}),i}function nye(t,e,n){let r=0;const s=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const i=t.shape.slice(1),o=q$(i,n),a=r===0?0:t.size/r,l=ke(()=>{const c=[];t=Ie(t,[1,r,a]);for(let d=0;d<e.length;++d){const m=[0,d===0?0:s[d-1],0],g=[1,e[d],a];c[d]=Ie(cn(t,m,g),o)}return t.dispose(),c}),u=new lf([],n,t.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}const rye=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=B("thenBranch",t,e,n),s=B("elseBranch",t,e,n),i=B("cond",t,e,n),o=B("args",t,e,n);return(await i.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=B("body",t,e,n),s=B("cond",t,e,n),i=B("args",t,e,n),o=await n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),a=i.map(c=>c.id);let l=await o[0].data();o.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=i;for(;l[0];){const c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const d=u.map(m=>m.id);c.forEach(m=>{!m.kept&&a.indexOf(m.id)===-1&&d.indexOf(m.id)===-1&&m.dispose()});const f=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await f[0].data(),f.forEach(m=>{!m.kept&&a.indexOf(m.id)===-1&&d.indexOf(m.id)===-1&&m.dispose()})}return u}case"LoopCond":{const r=B("pred",t,e,n);return[Gu(r)]}case"Switch":{const r=B("pred",t,e,n);let s=B("data",t,e,n);return s.kept||(s=Gu(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>Si(s,e,n)!==void 0);if(r){const s=Si(r,e,n);return[Gu(s)]}return}case"Enter":{const r=B("frameName",t,e,n),s=B("tensor",t,e,n);return n.enterFrame(r),[Gu(s)]}case"Exit":{const r=B("tensor",t,e,n);return n.exitFrame(),[Gu(r)]}case"NextIteration":{const r=B("tensor",t,e,n);return n.nextIteration(),[Gu(r)]}case"TensorArrayV3":{const r=B("size",t,e,n),s=B("dtype",t,e,n),i=B("elementShape",t,e,n),o=B("dynamicSize",t,e,n),a=B("clearAfterRead",t,e,n),l=B("identicalElementShapes",t,e,n),u=B("name",t,e,n),c=new J2e(u,s,r,i,l,o,a);return n.addTensorArray(c),[c.idTensor,Xt(1)]}case"TensorArrayWriteV3":{const r=B("tensorArrayId",t,e,n),s=B("index",t,e,n),i=B("tensor",t,e,n),o=n.getTensorArray(r.id);return o.write(s,i),[o.idTensor]}case"TensorArrayReadV3":{const r=B("tensorArrayId",t,e,n),s=B("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=B("tensorArrayId",t,e,n),s=B("indices",t,e,n),i=B("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,i)]}case"TensorArrayScatterV3":{const r=B("tensorArrayId",t,e,n),s=B("indices",t,e,n),i=B("tensor",t,e,n),o=n.getTensorArray(r.id);return o.scatter(s,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=B("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),i=B("dtype",t,e,n);return[s.concat(i)]}case"TensorArraySplitV3":{const r=B("tensorArrayId",t,e,n),s=B("tensor",t,e,n),i=B("lengths",t,e,n),o=n.getTensorArray(r.id);return o.split(i,s),[o.idTensor]}case"TensorArraySizeV3":{const r=B("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[Xt(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=B("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=B("tensorListId",t,e,n),s=B("index",t,e,n),i=B("tensor",t,e,n),o=n.getTensorList(r.id);return o.setItem(s,i),[o.idTensor]}case"TensorListGetItem":{const r=B("tensorListId",t,e,n),s=B("index",t,e,n),i=B("elementShape",t,e,n),o=B("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=B("indices",t,e,n),s=B("tensor",t,e,n),i=B("elementShape",t,e,n),o=B("numElements",t,e,n),a=tye(s,r,i,o);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=B("elementShape",t,e,n),s=B("elementDType",t,e,n);let i;t.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=B(i,t,e,n),a=t.op==="TensorListReserve"?-1:o,l=eye(r,s,o,a);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=B("tensorListId",t,e,n),s=B("indices",t,e,n),i=B("elementShape",t,e,n),o=B("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,o,i)]}case"TensorListStack":{const r=B("tensorListId",t,e,n),s=B("elementShape",t,e,n),i=B("elementDType",t,e,n),o=B("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,i,o)]}case"TensorListFromTensor":{const r=B("tensor",t,e,n),s=B("elementShape",t,e,n),i=B("elementDType",t,e,n),o=Z2e(r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=B("tensorListId",t,e,n),s=n.getTensorList(r.id),i=B("dtype",t,e,n),o=B("elementShape",t,e,n);return[s.concat(i,o)]}case"TensorListPushBack":{const r=B("tensorListId",t,e,n),s=B("tensor",t,e,n),i=n.getTensorList(r.id);return i.pushBack(s),[i.idTensor]}case"TensorListPopBack":{const r=B("tensorListId",t,e,n),s=B("elementShape",t,e,n),i=B("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,i)]}case"TensorListSplit":{const r=B("tensor",t,e,n),s=B("elementShape",t,e,n),i=B("lengths",t,e,n),o=nye(r,i,s);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=B("tensorListId",t,e,n),s=n.getTensorList(r.id);return[Xt(s.size(),"int32")]}case"TensorListResize":{const r=B("tensorListId",t,e,n),s=B("size",t,e,n),o=n.getTensorList(r.id).resize(s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function dP(t,e,n){const[r,s]=B("fusedOps",t,e,n),i=r==="biasadd",o=!i,a=s==="prelu",l=r==="fusedbatchnorm",u=B("numArgs",t,e,n);if(i){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=B("strides",t,e,n),d=tb(t,e,n),f=B("dataFormat",t,e,n).toUpperCase(),m=B("dilations",t,e,n);let[g,y]=B("args",t,e,n);o&&(y=g,g=void 0);const v=B("leakyreluAlpha",t,e,n);return{stride:c,pad:d,dataFormat:f,dilations:m,biasArg:g,preluArg:y,activationFunc:s,leakyreluAlpha:v}}const sye=(t,e,n,r=Di)=>{switch(t.op){case"Conv1D":{const s=B("stride",t,e,n),i=B("pad",t,e,n),o=B("dataFormat",t,e,n).toUpperCase(),a=B("dilation",t,e,n);return[r.conv1d(B("x",t,e,n),B("filter",t,e,n),s,i,o,a)]}case"Conv2D":{const s=B("strides",t,e,n),i=tb(t,e,n),o=B("dataFormat",t,e,n).toUpperCase(),a=B("dilations",t,e,n);return[r.conv2d(B("x",t,e,n),B("filter",t,e,n),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=dP(t,e,n);return[r.fused.conv2d({x:B("x",t,e,n),filter:B("filter",t,e,n),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=dP(t,e,n);return[r.fused.depthwiseConv2d({x:B("x",t,e,n),filter:B("filter",t,e,n),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=B("outputShape",t,e,n),i=B("strides",t,e,n),o=tb(t,e,n);return[r.conv2dTranspose(B("x",t,e,n),B("filter",t,e,n),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=B("strides",t,e,n),i=tb(t,e,n),o=B("dilations",t,e,n),a=B("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(B("input",t,e,n),B("filter",t,e,n),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=B("strides",t,e,n),i=B("pad",t,e,n),o=B("dataFormat",t,e,n).toUpperCase(),a=B("dilations",t,e,n);return[r.conv3d(B("x",t,e,n),B("filter",t,e,n),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=B("strides",t,e,n),i=B("pad",t,e,n),o=B("kernelSize",t,e,n);return[r.avgPool(B("x",t,e,n),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=B("strides",t,e,n),i=B("pad",t,e,n),o=B("kernelSize",t,e,n);return[r.maxPool(B("x",t,e,n),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=B("strides",t,e,n),i=B("pad",t,e,n),o=B("kernelSize",t,e,n),a=B("includeBatchInIndex",t,e,n),{result:l,indexes:u}=r.maxPoolWithArgmax(B("x",t,e,n),[o[1],o[2]],[s[1],s[2]],i,a);return[l,u]}case"AvgPool3D":{const s=B("strides",t,e,n),i=B("pad",t,e,n),o=B("kernelSize",t,e,n);return[r.avgPool3d(B("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=B("strides",t,e,n),i=B("pad",t,e,n),o=B("kernelSize",t,e,n);return[r.maxPool3d(B("x",t,e,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=B("strides",t,e,n),i=B("pad",t,e,n),o=B("dilations",t,e,n),a=s[1],l=s[2],u=o[1],c=o[2];return[r.dilation2d(B("x",t,e,n),B("filter",t,e,n),[a,l],i,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const iye=(t,e,n,r=Di)=>{switch(t.op){case"Fill":{const s=B("shape",t,e,n),i=B("dtype",t,e,n),o=B("value",t,e,n);return[r.fill(s,o,i)]}case"LinSpace":{const s=B("start",t,e,n),i=B("stop",t,e,n),o=B("num",t,e,n);return[r.linspace(s,i,o)]}case"Multinomial":{const s=B("logits",t,e,n),i=B("numSamples",t,e,n),o=B("seed",t,e,n);return[r.multinomial(s,i,o)]}case"OneHot":{const s=B("indices",t,e,n),i=B("depth",t,e,n),o=B("onValue",t,e,n),a=B("offValue",t,e,n),l=B("dtype",t,e,n);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(B("shape",t,e,n),B("dtype",t,e,n))];case"OnesLike":return[r.onesLike(B("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(B("shape",t,e,n),B("dtype",t,e,n),B("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(B("shape",t,e,n),B("minval",t,e,n),B("maxval",t,e,n),B("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(B("shape",t,e,n),B("minval",t,e,n),B("maxval",t,e,n),B("seed",t,e,n))];case"Range":{const s=B("start",t,e,n),i=B("stop",t,e,n),o=B("step",t,e,n);return[r.range(s,i,o,B("dtype",t,e,n))]}case"TruncatedNormal":{const s=B("shape",t,e,n),i=B("mean",t,e,n),o=B("stdDev",t,e,n),a=B("seed",t,e,n);return[r.truncatedNormal(s,i,o,B("dtype",t,e,n),a)]}case"Zeros":return[r.zeros(B("shape",t,e,n),B("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(B("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function CT(t,e,n){const r=B("boxes",t,e,n),s=B("scores",t,e,n),i=B("maxOutputSize",t,e,n),o=B("iouThreshold",t,e,n),a=B("scoreThreshold",t,e,n),l=B("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const oye=async(t,e,n,r,s=Di)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=CT(t,e,n),d=await s.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=CT(t,e,n),c=B("padToMaxOutputSize",t,e,n),d=await s.image.nonMaxSuppressionPaddedAsync(i,o,a,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=CT(t,e,n);return[await s.image.nonMaxSuppressionAsync(i,o,a,l,u)]}case"Where":{const i=s.cast(B("condition",t,e,n),"bool"),o=[await s.whereAsync(i)];return i.dispose(),o}case"ListDiff":return s.setdiff1dAsync(B("x",t,e,n),B("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};const aye=(t,e,n,r=Di)=>{switch(t.op){case"LowerBound":{const s=B("sortedSequence",t,e,n),i=B("values",t,e,n);return[r.lowerBound(s,i)]}case"TopKV2":{const s=B("x",t,e,n),i=B("k",t,e,n),o=B("sorted",t,e,n),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=B("sortedSequence",t,e,n),i=B("values",t,e,n);return[r.upperBound(s,i)]}case"Unique":{const s=B("x",t,e,n),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=B("x",t,e,n),i=B("axis",t,e,n),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const lye=(t,e,n,r=Di)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=B("default",t,e,n);return[Si(t.name,e,n)||s];case"Placeholder":return[Si(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=B("x",t,e,n);return[Gu(c)]}case"IdentityN":return B("x",t,e,n).map(c=>Gu(c));case"Snapshot":const i=B("x",t,e,n);return[Gu(i)];case"Shape":return[r.tensor1d(B("x",t,e,n).shape,"int32")];case"ShapeN":return B("x",t,e,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(B("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(B("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=B("x",t,e,n),a=B("data",t,e,n),l=B("message",t,e,n),u=B("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}};class uye{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=Xt(0),this.tensorMap=new Map,Ts(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Xt(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),ke(()=>{const s=oa(n),i=r.length,o=s.length;J(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=r[a],u=s[a];Ts(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return ke(()=>{const s=[];for(let i=0;i<r.length;i++){const o=r[i],a=this.findWithDefault(o,n);s.push(a)}return qi(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}const cye=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(t.name);if(s!=null)return[s];{const i=B("keyDType",t,e,n),o=B("valueDType",t,e,n),a=new uye(i,o);return r.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=B("tableHandle",t,e,n,r),i=B("keys",t,e,n),o=B("values",t,e,n);return[await r.getHashTableById(s.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=B("tableHandle",t,e,n,r),i=B("keys",t,e,n),o=B("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=B("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const hye=(t,e,n,r=Di)=>{switch(t.op){case"ResizeBilinear":{const s=B("images",t,e,n),i=B("size",t,e,n),o=B("alignCorners",t,e,n),a=B("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=B("images",t,e,n),i=B("size",t,e,n),o=B("alignCorners",t,e,n),a=B("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=B("image",t,e,n),i=B("boxes",t,e,n),o=B("boxInd",t,e,n),a=B("cropSize",t,e,n),l=B("method",t,e,n),u=B("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,i,o,a,l,u)]}case"ImageProjectiveTransformV3":{const s=B("images",t,e,n),i=B("transforms",t,e,n),o=B("outputShape",t,e,n),a=B("fillValue",t,e,n),l=B("interpolation",t,e,n),u=B("fillMode",t,e,n);return[r.image.transform(s,i,l.toLowerCase(),u.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const dye=(t,e,n,r=Di)=>{switch(t.op){case"Equal":return[r.equal(B("a",t,e,n),B("b",t,e,n))];case"NotEqual":return[r.notEqual(B("a",t,e,n),B("b",t,e,n))];case"Greater":return[r.greater(B("a",t,e,n),B("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(B("a",t,e,n),B("b",t,e,n))];case"Less":return[r.less(B("a",t,e,n),B("b",t,e,n))];case"LessEqual":return[r.lessEqual(B("a",t,e,n),B("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(B("a",t,e,n),B("b",t,e,n))];case"LogicalNot":return[r.logicalNot(B("a",t,e,n))];case"LogicalOr":return[r.logicalOr(B("a",t,e,n),B("b",t,e,n))];case"Select":case"SelectV2":return[r.where(B("condition",t,e,n),B("a",t,e,n),B("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(B("a",t,e,n),B("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const fye=(t,e,n,r=Di)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(B("a",t,e,n),B("b",t,e,n),B("transposeA",t,e,n),B("transposeB",t,e,n))];case"Einsum":return[r.einsum(B("equation",t,e,n),...B("tensors",t,e,n))];case"Transpose":return[r.transpose(B("x",t,e,n),B("perm",t,e,n))];case"_FusedMatMul":const[s,i]=B("fusedOps",t,e,n),o=s==="biasadd",a=i==="prelu",l=B("numArgs",t,e,n),u=B("leakyreluAlpha",t,e,n);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=B("args",t,e,n);return[r.fused.matMul({a:B("a",t,e,n),b:B("b",t,e,n),transposeA:B("transposeA",t,e,n),transposeB:B("transposeB",t,e,n),bias:c,activation:i,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(B("a",t,e,n),B("numLower",t,e,n),B("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const pye=(t,e,n,r=Di)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(B("x",t,e,n),B("axis",t,e,n),B("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(B("x",t,e,n),B("mean",t,e,n),B("variance",t,e,n),B("offset",t,e,n),B("scale",t,e,n),B("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(B("x",t,e,n),B("mean",t,e,n),B("variance",t,e,n),B("offset",t,e,n),B("scale",t,e,n),B("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(B("x",t,e,n),B("radius",t,e,n),B("bias",t,e,n),B("alpha",t,e,n),B("beta",t,e,n))];case"Softmax":return[r.softmax(B("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(B("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const mye=(t,e,n,r=Di)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(B("paramsNestedSplits",t,e,n),B("paramsDenseValues",t,e,n),B("indices",t,e,n),B("outputRaggedRank",t,e,n));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(B("starts",t,e,n),B("limits",t,e,n),B("splits",t,e,n));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(B("shape",t,e,n),B("values",t,e,n),B("defaultValue",t,e,n),B("rowPartitionTensors",t,e,n),B("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const gye=(t,e,n,r=Di)=>{switch(t.op){case"Max":{const a=B("axis",t,e,n),l=B("keepDims",t,e,n);return[r.max(B("x",t,e,n),a,l)]}case"Mean":{const a=B("axis",t,e,n),l=B("keepDims",t,e,n);return[r.mean(B("x",t,e,n),a,l)]}case"Min":{const a=B("axis",t,e,n),l=B("keepDims",t,e,n);return[r.min(B("x",t,e,n),a,l)]}case"Sum":{const a=B("axis",t,e,n),l=B("keepDims",t,e,n);return[r.sum(B("x",t,e,n),a,l)]}case"All":{const a=B("axis",t,e,n),l=B("keepDims",t,e,n);return[r.all(B("x",t,e,n),a,l)]}case"Any":{const a=B("axis",t,e,n),l=B("keepDims",t,e,n);return[r.any(B("x",t,e,n),a,l)]}case"ArgMax":{const a=B("axis",t,e,n);return[r.argMax(B("x",t,e,n),a)]}case"ArgMin":{const a=B("axis",t,e,n);return[r.argMin(B("x",t,e,n),a)]}case"Prod":{const a=B("axis",t,e,n),l=B("keepDims",t,e,n);return[r.prod(B("x",t,e,n),a,l)]}case"Cumprod":{const a=B("axis",t,e,n),l=B("exclusive",t,e,n),u=B("reverse",t,e,n);return[r.cumprod(B("x",t,e,n),a,l,u)]}case"Cumsum":{const a=B("axis",t,e,n),l=B("exclusive",t,e,n),u=B("reverse",t,e,n);return[r.cumsum(B("x",t,e,n),a,l,u)]}case"Bincount":const s=B("x",t,e,n),i=B("weights",t,e,n),o=B("size",t,e,n);return[r.bincount(s,i,o)];case"DenseBincount":{const a=B("x",t,e,n),l=B("weights",t,e,n),u=B("size",t,e,n),c=B("binaryOutput",t,e,n);return[r.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const yye=(t,e,n,r=Di)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=B("n",t,e,n),i=B("axis",t,e,n);let o=B("tensors",t,e,n);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=B("x",t,e,n),i=B("indices",t,e,n);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=B("axis",t,e,n),i=B("batchDims",t,e,n),o=B("x",t,e,n),a=B("indices",t,e,n);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=B("dims",t,e,n),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=B("x",t,e,n);return[r.reverse(o,i)]}case"ReverseV2":{const s=B("axis",t,e,n),i=B("x",t,e,n);return[r.reverse(i,s)]}case"Slice":{const s=B("begin",t,e,n),i=B("size",t,e,n);return[r.slice(B("x",t,e,n),s,i)]}case"StridedSlice":{const s=B("begin",t,e,n),i=B("end",t,e,n),o=B("strides",t,e,n),a=B("beginMask",t,e,n),l=B("endMask",t,e,n),u=B("ellipsisMask",t,e,n),c=B("newAxisMask",t,e,n),d=B("shrinkAxisMask",t,e,n),f=B("x",t,e,n);return[r.stridedSlice(f,s,i,o,a,l,u,c,d)]}case"Pack":return ke(()=>{const s=B("axis",t,e,n),i=B("tensors",t,e,n),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(u=>{const c=zn(u.shape,o);if(!c&&!zn(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,o)});return[r.stack(l,s)]});case"Unpack":{const s=B("axis",t,e,n),i=B("tensor",t,e,n);return r.unstack(i,s)}case"Tile":{const s=B("reps",t,e,n);return[r.tile(B("x",t,e,n),s)]}case"Split":case"SplitV":{const s=B("axis",t,e,n),i=B("numOrSizeSplits",t,e,n),o=B("x",t,e,n);return r.split(o,i,s)}case"ScatterNd":{const s=B("indices",t,e,n),i=B("values",t,e,n),o=B("shape",t,e,n);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=B("x",t,e,n),i=B("indices",t,e,n);return[r.gatherND(s,i)]}case"SparseToDense":{const s=B("sparseIndices",t,e,n),i=B("outputShape",t,e,n),o=B("sparseValues",t,e,n),a=B("defaultValue",t,e,n);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}case"TensorScatterUpdate":{const s=B("indices",t,e,n),i=B("values",t,e,n),o=B("tensor",t,e,n);return[r.tensorScatterUpdate(o,s,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const wye=(t,e,n,r=Di)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(B("indices",t,e,n),B("values",t,e,n),B("denseShape",t,e,n),B("defaultValue",t,e,n));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(B("inputIndices",t,e,n),B("inputShape",t,e,n),B("newShape",t,e,n));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(B("data",t,e,n),B("indices",t,e,n),B("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(B("data",t,e,n),B("indices",t,e,n),B("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const vye=(t,e,n,r=Di)=>{switch(t.op){case"FFT":return[r.fft(B("x",t,e,n))];case"IFFT":return[r.ifft(B("x",t,e,n))];case"RFFT":return[r.rfft(B("x",t,e,n))];case"IRFFT":return[r.irfft(B("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const bye=(t,e,n,r=Di)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(B("input",t,e,n),B("pattern",t,e,n),B("rewrite",t,e,n),B("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(B("data",t,e,n),B("dataSplits",t,e,n),B("separator",t,e,n),B("nGramWidths",t,e,n),B("leftPad",t,e,n),B("rightPad",t,e,n),B("padWidth",t,e,n),B("preserveShortSequences",t,e,n));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(B("input",t,e,n),B("delimiter",t,e,n),B("skipEmpty",t,e,n));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(B("input",t,e,n),B("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const xye=(t,e,n,r=Di)=>{switch(t.op){case"Cast":return[r.cast(B("x",t,e,n),B("dtype",t,e,n))];case"ExpandDims":{const s=B("axis",t,e,n);return[r.expandDims(B("x",t,e,n),s)]}case"Squeeze":{const s=B("axis",t,e,n);return[r.squeeze(B("x",t,e,n),s)]}case"Reshape":return[r.reshape(B("x",t,e,n),B("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(B("x",t,e,n),B("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(B("x",t,e,n),B("padding",t,e,n),B("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(B("x",t,e,n),B("padding",t,e,n),B("constantValue",t,e,n))];case"SpaceToBatchND":{const s=B("blockShape",t,e,n),i=B("paddings",t,e,n);return[r.spaceToBatchND(B("x",t,e,n),s,i)]}case"BatchToSpaceND":{const s=B("blockShape",t,e,n),i=B("crops",t,e,n);return[r.batchToSpaceND(B("x",t,e,n),s,i)]}case"DepthToSpace":{const s=B("blockSize",t,e,n),i=B("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(B("x",t,e,n),s,i)]}case"BroadcastTo":return[r.broadcastTo(B("x",t,e,n),B("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(B("s0",t,e,n),B("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function fP(t,e,n,r,s=ke){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>Y2e(o,a,l));case"basic_math":return s(()=>Q2e(o,a,l));case"control":return rye(o,a,l);case"convolution":return s(()=>sye(o,a,l));case"creation":return s(()=>iye(o,a,l));case"dynamic":return oye(o,a,l);case"evaluation":return s(()=>aye(o,a,l));case"image":return s(()=>hye(o,a,l));case"graph":return s(()=>lye(o,a,l));case"logical":return s(()=>dye(o,a,l));case"matrices":return s(()=>fye(o,a,l));case"normalization":return s(()=>pye(o,a,l));case"ragged":return s(()=>mye(o,a,l));case"reduction":return s(()=>gye(o,a,l));case"slice_join":return s(()=>yye(o,a,l));case"sparse":return s(()=>wye(o,a,l));case"spectral":return s(()=>vye(o,a,l));case"string":return s(()=>bye(o,a,l));case"transformation":return s(()=>xye(o,a,l));case"hash_table":return cye(o,a,l,r);case"custom":const u=QU(o.op);if(u&&u.customExecutor)return u.customExecutor(new X2e(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return ic(i)?i.then(o=>[].concat(o)):[].concat(i)}class pP{constructor(e={},n={},r={},s={},i){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}function mP(t,e,n,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,u=new Set(Object.keys(t).map(f=>Zo(f)[0]));r=r||[];const c=new Set(r.map(f=>Zo(f.name)[0])),d=[...e];for(;d.length>0;){const f=d.pop();if((Td(f)||kye(f)||Nye(f))&&o==null&&(o=f,a=o.children.map(m=>m.name).filter(m=>s.has(m))),s.add(f.name),n[f.name]==null&&!u.has(f.name)&&!c.has(f.name)){if(f.inputs.length===0){i.push(f.name);continue}f.inputs.forEach(m=>{l.has(m.name)||(l.add(m.name),d.push(m))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}function _ye(t,e){const{usedNodes:n,inputs:r}=e,s=Object.keys(r).map(v=>Zo(v)[0]).map(v=>t.nodes[v]),i=t.initNodes||[],o=v=>n.has(typeof v=="string"?v:v.name);function a(v){return[...new Map(v.map(b=>[b.name,b])).values()]}const l=a([...s,...t.weights,...i]).filter(o),u=a([...l,...Object.values(t.nodes)]).filter(o),c=new Map(u.map(v=>[v.name,v])),d={};for(const v of u){d[v.name]=d[v.name]||0;for(const b of v.children)o(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}const f=Object.entries(d).filter(([,v])=>v===0).map(([v])=>v),m=[...f];for(;f.length>0;){const v=f.pop(),b=c.get(v);for(const x of b.children.filter(o))--d[x.name]===0&&(m.push(x.name),f.push(x.name))}const g=m.map(v=>c.get(v)),y=Iye(g,l);return Tye(y,l),y}function Iye(t,e){const n=new Map(t.map(o=>[o.name,o])),r=e.map(o=>o.name),s=new Set(r);for(;r.length>0;){const o=r.pop(),a=n.get(o);for(const l of a.children)!n.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return t.filter(o=>s.has(o.name))}class pv extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Tye(t,e){const n=new Map(t.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),i=new Set(t.map(a=>a.name)),o=a=>i.has(typeof a=="string"?a:a.name);for(const a of t){for(const l of a.children.filter(o)){if(!n.has(l.name))throw new pv(`Child ${l.name} of node ${a.name} is unreachable.`);if(n.get(a.name)>n.get(l.name))throw new pv(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!n.has(l.name))throw new pv(`Input ${l.name} of node ${a.name} is unreachable.`);if(n.get(l.name)>n.get(a.name))throw new pv(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function Sye(t){const e=new Map(t.map((a,l)=>[a.name,l])),n=Number.MAX_SAFE_INTEGER,r=t.map((a,l)=>Td(a)?n:l),s=a=>{const l=r[e.get(a.name)];return l??-1},i=t.map((a,l)=>a.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),o=new Map;for(let a=0;a<t.length;++a){const l=i[a];if(l===n)continue;const u=t[a],c=t[l];o.has(c.name)||o.set(c.name,[]),o.get(c.name).push(u)}return o}const $ye=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Cye=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Eye=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Td(t){return $ye.has(t.op)}function kye(t){return Cye.has(t.op)}function Nye(t){return Eye.has(t.op)}class Kb{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Kb(e.functions[r],this)})}getCompilationKey(e,n){const r=e.map(i=>i.name).sort(),s=n.map(i=>i.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,n){const r=mP(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const u=n.map(d=>d.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}const a=_ye(this.graph,r),l=Sye(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return Ts(n),n}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(f=>this.graph.nodes[Zo(f)[0]]),i=n.map(f=>Zo(f)[0]),o=new Set(i);let a=i.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=De().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const c={},d={};return ke(()=>{const f=new pP(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(b=>{const[x,$]=Zo(b,f),S=[];S[$]=e[b],m[x]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(S))});const g=this.getFrozenTensorIds(m),{orderedNodes:y,nodeLiveUntilMap:v}=u;for(const b of y){if(m[b.name])continue;const x=fP(b,m,f,this._resourceManager);if(ic(x))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);m[b.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,m,f,g,o,v.get(b.name))}return this.parent==null&&f.dispose(g),n.map(b=>Si(b,m,f))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,i,o,a){if(!(Td(n)||o.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+n.children.length);for(const l of n.inputs){if(Td(l))continue;const u=lP(l.name,r,s);if(u!=null)for(const c of u){if(!c||c.kept||i.has(c.id))continue;const d=a[c.id];d===1?(c.dispose(),delete a[c.id]):d!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,s,i,o){function a(l){return Td(l)||i.has(l.name)}if(!(Td(e)||o==null))for(const l of o){if(a(l))continue;const u=lP(l.name,n,r);for(const c of u)!c||c.kept||s.has(c.id)||c.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,r=!1,s={},i={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=De().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new pP(this.weightMap,s,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,n,r),l=n.map(f=>Si(f,a,o)),u=l.map(f=>f.id),c=Object.keys(e).map(f=>e[f].id),d=new Set([...u,...c,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(m=>{m&&!m.isDisposed&&!d.has(m.id)&&m.dispose()})}),this.parent==null&&o.dispose(d),l}async executeFunctionAsync(e,n,r){const s=e.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const i=Object.keys(e),o=i.map(S=>this.graph.nodes[Zo(S)[0]]),a=r.map(S=>Zo(S)[0]),l=new Set(a);let u=a.map(S=>this.graph.nodes[S]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:d,dynamicNode:f,syncInputs:m}=mP(e,u,this.weightMap,this._initNodes),g=[...o,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:n.currentContext})),y=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[E,L]=Zo(S),R=[];R[L]=e[S],y[E]=R});const v={},b=this.getFrozenTensorIds(y),x={};for(;g.length>0;){const S=this.processStack(o,g,n,y,x,b,l,v,c);await Promise.all(S)}f==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=u.filter(S=>!Td(S)&&!Si(S.name,y,n)).map(S=>S.name);if($.length>0){let S="";throw f!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${i}]. Consider providing the following inputs: [${d}]. ${S}`)}return y}processStack(e,n,r,s,i,o,a,l,u){const c=[];for(;n.length>0;){const d=n.pop();r.currentContext=d.contexts;let f="";if(d.node.op==="Enter"&&B("isConstant",d.node,s,r)&&([f]=ju(d.node.name,r)),s[d.node.name]==null){const m=fP(d.node,s,r,this._resourceManager);f||([f]=ju(d.node.name,r));const g=r.currentContext;ic(m)?c.push(m.then(y=>(s[f]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(y)),r.currentContext=g,this.checkTensorForDisposal(f,d.node,s,r,o,a,l),this.processChildNodes(d.node,n,r,s,i,u),y))):(s[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),this.checkTensorForDisposal(f,d.node,s,r,o,a,l),this.processChildNodes(d.node,n,r,s,i,u))}else this.processChildNodes(d.node,n,r,s,i,u)}return c}processChildNodes(e,n,r,s,i,o){e.children.forEach(a=>{const[l]=ju(a.name,r);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!Si(u,s,r))&&(i[l]=!0,n.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!Si(u,s,r))&&(i[l]=!0,n.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=Zo(n),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===r.shape.length&&r.shape.every((l,u)=>o[u]===-1||o[u]===l);J(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&J(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var n,r;const s={};for(const i in e){const o=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[i];o!=null?s[o.name]=e[i]:s[i]=e[i]}return s}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=Zo(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var r,s;const i=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return i!=null?i.name:n},{})}checkOutputs(e){e.forEach(n=>{const[r]=Zo(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class Aye{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Rye="?tfjs-format=file",Dye="model.json";class T4{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},r=Y_){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new Aye}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return ic(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await fV(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(s=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Kb(uP.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=uP.Instance.transformGraph(e.modelInitializer);this.initializer=new Kb(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof Rn?[e]:e,r={};return n.forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return e}predict(e,n){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,n){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var n;if(!(e instanceof Rn)&&!Array.isArray(e)){const i=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(i!=null)for(const o in i){const a=i[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,u;const c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||u===void 0?void 0:u.resourceId;return c!=null?i[o]=this.resourceIdToCapturedInput[c]:i[o]=e[s++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let s=0;s<r.length;s++){const i=r[s],o=n[i];this.resourceIdToCapturedInput[o.resourceId]=e[s]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&en(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function S4(t,e={},n=Y_){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=Oye(t));const r=new T4(t,e,n);return await r.load(),r}function tW(t){if(t==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(t instanceof Array){const[r,s]=t;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");const i=Fb(r.weightsManifest),o=IE(r,i,s);e=Lb(o)}else if("load"in t)e=t;else if("modelTopology"in t&&"weightSpecs"in t&&"weightData"in t)e=Lb(t);else throw new Error("Unknown model format");const n=new T4(e);return n.load(),n}function Oye(t){return t.endsWith("/")||(t=t+"/"),`${t}${Dye}${Rye}`}const OA="4.22.0";const Pye=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:T4,deregisterOp:JU,loadGraphModel:S4,loadGraphModelSync:tW,registerOp:YU,version_converter:OA},Symbol.toStringTag,{value:"Module"}));function Fye(t,e){return Xb(t,e)}function Xb(t,e,n=new Map,r=new Set){if(t==null)return null;if(typeof Blob=="function"&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const s=e(t);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Hm(t)){const i=Array.isArray(t)?[]:{};r.add(t);for(const o in t){const a=t[o],l=Xb(a,e,n,r);i[o]=l}return r.delete(t),t.__proto__&&(i.__proto__=t.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${t}`);else return n.set(t,s.value),s.value}function Lye(t,e=rW){return nW(t,e)}function nW(t,e,n=new Set){const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=e(t);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Hm(r)){const i=Array.isArray(r)?[]:{};n.add(r);for(const o in r){const a=t.map(u=>u[o]),l=nW(a,e,n);i[o]=l}return n.delete(r),i}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function rW(t){return t===null?null:Hm(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function sW(t,e){const n=new Map;Xb(t,e,n);for(const s of Array.from(n.keys())){const i=n.get(s);if(ic(i)){const o=await i;n.set(s,o)}}return Xb(t,e,n)}function Hm(t){let e=!1;if(De().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:n}=require("string_decoder");e=t instanceof n}return t!=null&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||typeof t=="object"&&!(t instanceof Rn)&&!(t instanceof Promise)&&!e)}function Mye(t){return t==null||zye(t)||Array.isArray(t)||typeof t=="object"&&t instanceof Rn||Ms(t)}function zye(t){return t===null||typeof t!="object"&&typeof t!="function"}function Vye(t){return Fye(t,Bye)}function Bye(t){return t instanceof Rn?{value:t.clone(),recurse:!1}:Hm(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class iW{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,n){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=n}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const n of e)this.push(n)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const n=this.wrap(this.begin+e),r=this.get(n);return this.set(n,this.pop()),r}}class $4 extends iW{constructor(){super($4.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,n=new Array(e),r=this.length();for(let s=0;s<r;s++)n[s]=this.get(this.wrap(this.begin+s));this.data=n,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}$4.INITIAL_CAPACITY=32;function oW(t){return new jye(t)}function PA(t){return new Gye(t)}function Uye(t,e){return new aW(t,e)}function Wye(t,e=ah.FAIL){return new e0e(t,e)}class oi{async toArray(){const e=[];let n=await this.next();for(;!n.done;)e.push(n.value),n=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),n=[];let r=await e.next();for(;!r.done;)n.push(r.value),r=await e.next();return n}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let n=await this.next(),r=e(n.value);for(;!n.done&&r;)n=await this.next(),r=e(n.value)}handleErrors(e){return new Jye(this,e)}filter(e){return new Yye(this,e)}map(e){return new Qye(this,e)}mapAsync(e){return new gP(this,e)}serialMapAsync(e){return new gP(this,e).serial()}flatmap(e){return new Zye(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(n=>n===!0)}rowMajorBatch(e,n=!0){return new Xye(this,e,n)}columnMajorBatch(e,n=!0,r=rW){return this.rowMajorBatch(e,n).map(i=>Lye(i,r))}concatenate(e,n){return new aW(oW([this,e]),n)}take(e){return e<0||e==null?this:new Kye(this,e)}skip(e){return e<0||e==null?this:new qye(this,e)}prefetch(e){return new lW(this,e)}shuffle(e,n){return new t0e(this,e,n)}serial(){return new Hye(this)}}class jye extends oi{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Vye(e),done:!1}}}class Gye extends oi{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class Hye extends oi{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class qye extends oi{constructor(e,n){super(),this.upstream=e,this.maxCount=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;en(e.value)}return this.upstream.next()}}class Kye extends oi{constructor(e,n){super(),this.upstream=e,this.maxCount=n,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class Xye extends oi{constructor(e,n,r=!0){super(),this.upstream=e,this.batchSize=n,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(n.value)}return{value:e,done:!1}}}class Yye extends oi{constructor(e,n){super(),this.upstream=e,this.predicate=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;en(e.value)}}}class Qye extends oi{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const n=ac(e.value),r=this.transform(e.value),s=ac(r);for(const i of n)Ox(i,s)||i.dispose();return{value:r,done:!1}}}class Jye extends oi{constructor(e,n){super(),this.upstream=e,this.handler=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class gP extends oi{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const n=ac(e.value),r=await this.transform(e.value),s=ac(r);for(const i of n)Ox(i,s)||i.dispose();return{value:r,done:!1}}}class FA extends oi{constructor(){super(),this.outputQueue=new $4,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Zye extends FA{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const n=ac(e.value),r=this.transform(e.value),s=ac(r);this.outputQueue.pushAll(r);for(const i of n)Ox(i,s)||i.dispose();return!0}}class aW extends oi{constructor(e,n){super(),this.baseErrorHandler=n,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(e)):n}}var ah;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(ah||(ah={}));class e0e extends oi{constructor(e,n=ah.FAIL){super(),this.iterators=e,this.mismatchMode=n,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let n=0,r=0;function s(o){return o instanceof oi?{value:o.next().then(l=>(n++,l.done&&r++,l.value)),recurse:!1}:{value:null,recurse:!0}}const i=await sW(this.iterators,s);if(n===r)return{value:null,done:!0};if(r>0)switch(this.mismatchMode){case ah.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case ah.SHORTEST:return{value:null,done:!0};case ah.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class lW extends oi{constructor(e,n){super(),this.upstream=e,this.bufferSize=n,this.buffer=new iW(n)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class t0e extends lW{constructor(e,n,r){super(e,n),this.upstream=e,this.windowSize=n,this.upstreamExhausted=!1,this.random=x1.alea(r||Ti().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),n=await this.buffer.shuffleExcise(e);if(n.done)this.upstreamExhausted=!0;else return this.refill(),n}return{value:null,done:!0}}}class D1{constructor(){this.size=null}batch(e,n=!0){const r=this;J(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let s;return this.size===1/0||this.size==null?s=this.size:n?s=Math.ceil(this.size/e):s=Math.floor(this.size/e),Jo(async()=>(await r.iterator()).columnMajorBatch(e,n,s0e),s)}concatenate(e){const n=this;let r;return this.size===1/0||e.size===1/0?r=1/0:this.size!=null&&e.size!=null?r=this.size+e.size:r=null,Jo(async()=>(await n.iterator()).concatenate(await e.iterator()),r)}filter(e){const n=this;let r;return this.size===1/0?r=1/0:r=null,Jo(async()=>(await n.iterator()).filter(s=>ke(()=>e(s))),r)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const n=this;return Jo(async()=>(await n.iterator()).map(r=>ke(()=>e(r))),this.size)}mapAsync(e){const n=this;return Jo(async()=>(await n.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const n=this;return Jo(async()=>(await n.iterator()).prefetch(e),this.size)}repeat(e){const n=this;let r;return this.size!=null&&e>0?r=this.size*e:e===0?r=0:this.size!=null&&(e===void 0||e<0)?r=1/0:r=null,Jo(async()=>{const s=PA(async()=>({value:await n.iterator(),done:!1}));return Uye(s.take(e))},r)}skip(e){const n=this;let r;return this.size!=null&&e>=0&&this.size>=e?r=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?r=0:r=null,Jo(async()=>(await n.iterator()).skip(e),r)}shuffle(e,n,r=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,i=x1.alea(n||Ti().toString());return Jo(async()=>{let o=i.int32();return r&&(o+=i.int32()),(await s.iterator()).shuffle(e,o.toString())},this.size)}take(e){const n=this;let r;return this.size!=null&&this.size>e?r=e:this.size!=null&&this.size<=e?r=this.size:r=null,Jo(async()=>(await n.iterator()).take(e),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}D1.MAX_BUFFER_SIZE=1e4;function Jo(t,e=null){return new class extends D1{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function n0e(t){return Jo(async()=>oW(t),t.length)}function r0e(t){if(!Hm(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let n=0;n<t.length;n++)e=e==null?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(const n in t)e=e==null?t[n].size:Math.min(e,t[n].size);return Jo(async()=>{const n=await sW(t,r=>{if(r instanceof D1)return{value:r.iterator(),recurse:!1};if(Hm(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Wye(n,ah.SHORTEST)},e)}function s0e(t){if(t===null)return null;const e=t[0];return Mye(e)?{value:i0e(t),recurse:!1}:{value:null,recurse:!0}}function i0e(t){if(t.length===0)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Rn?qi(t):Eo(t)}class uW extends D1{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(s=>(s.endsWith("\r")&&(s=s.slice(0,-1)),s))}}const mv='"',C2=Symbol("out"),yP=Symbol("field"),gv=Symbol("quote"),ET=Symbol("quoteafterquote"),wP=Symbol("quoteinquote");class cW extends D1{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&J(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const n=this.fullColumnNames.reduce((s,i)=>(s[i]=s[i]+1||1,s),{}),r=Object.keys(n).filter(s=>n[s]>1);if(J(r.length===0,()=>"Duplicate column names found: "+r.toString()),this.columnConfigs){for(const s of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(s)===-1)throw new Error('The key "'+s+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const n=await(await this.base.iterator()).next();if(n.done)throw new Error("No data was found for CSV parsing.");const r=n.value;return this.parseRow(r,!1)}else return null}constructor(e,n){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new uW(e),n||(n={}),this.hasHeader=n.hasHeader!==!1,this.fullColumnNames=n.columnNames,this.columnConfigs=n.columnConfigs,this.configuredColumnsOnly=n.configuredColumnsOnly,n.delimWhitespace?(J(n.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=n.delimiter?n.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(n=>this.makeDataElement(n))}makeDataElement(e){const n=this.parseRow(e),r={},s={};for(let i=0;i<this.fullColumnNames.length;i++){const o=this.fullColumnNames[i],a=this.columnConfigs?this.columnConfigs[o]:null;if(!(this.configuredColumnsOnly&&!a)){const l=n[i];let u=null;if(l==="")if(a&&a.default!==void 0)u=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${o} is empty in this line: ${e}`);u=void 0}else{const c=Number(l);if(isNaN(c))a&&a.dtype==="bool"?u=this.getBoolean(l):u=l;else if(!a||!a.dtype)u=c;else switch(a.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(l);break;default:u=c}}a&&a.isLabel?s[o]=u:r[o]=u}}return Object.keys(s).length===0?r:{xs:r,ys:s}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,n=!0){const r=[];let s=0;const i=e.length;let o=C2;for(let a=0;a<i;a++)switch(o){case C2:switch(e.charAt(a)){case mv:s=a+1,o=gv;break;case this.delimiter:if(s=a+1,this.delimiter===" "&&this.delimWhitespace)break;r.push(""),o=C2;break;default:o=yP,s=a;break}break;case yP:switch(e.charAt(a)){case this.delimiter:r.push(e.substring(s,a)),o=C2,s=a+1;break}break;case gv:switch(e.charAt(a)){case mv:o=ET;break}break;case ET:switch(e.charAt(a)){case this.delimiter:r.push(e.substring(s,a-1)),o=C2,s=a+1;break;case mv:o=gv;break;default:o=wP;break}break;case wP:switch(e.charAt(a)){case mv:o=gv;break}break}if(o===ET?r.push(e.substring(s,i-1)):r.push(e.substring(s)),n&&r.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${r}`);return r}}class LA extends oi{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!De().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const n=new LA(e);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,n;const r=await this.getAudioData();if(this.includeSpectrogram){const s=this.flattenQueue(r.freqDataQueue);e=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const s=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],n=[];let r=0;return new Promise(s=>{const i=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&s({freqDataQueue:e,timeDataQueue:n}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(i),s({freqDataQueue:e,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const n=e[0].length,r=new Float32Array(e.length*n);return e.forEach((s,i)=>r.set(s,i*n)),r}getTensorFromAudioDataArray(e,n){const r=new Float32Array(Ue(n));return r.set(e,r.length-e.length),Eo(r,n)}}class MA extends oi{constructor(e,n){if(super(),this.webcamVideoElement=e,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Zr([0],"int32"),this.webcamConfig.centerCrop){const r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,i=(1-r)/2,o=(1-s)/2,a=i+r,l=s+o;this.cropBox=rl([o,i,l,a],[1,4])}else this.cropBox=rl([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,n={}){if(!De().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=n.resizeWidth,e.height=n.resizeHeight}const r=new MA(e,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&J(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Q_(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return ke(()=>{const n=os(gt(e,"float32"),0);let r;r=Ci.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const s=r.shape;return Ie(r,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(n=>n.stop());try{this.webcamVideoElement.srcObject=null}catch(n){console.log(n),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class hW{}class dW extends oi{split(e){return new o0e(this,e)}}class o0e extends dW{constructor(e,n){super(),this.upstream=e,this.impl=new a0e(e,n)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class a0e extends FA{constructor(e,n){super(),this.upstream=e,this.separator=n,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const n=e.value.split(this.separator);n[0]=this.carryover+n[0];for(const r of n.slice(0,-1))this.outputQueue.push(r);return this.carryover=n[n.length-1],!0}}class l0e extends oi{decodeUTF8(){return new u0e(this)}}class u0e extends dW{constructor(e){super(),this.upstream=e,this.impl=new c0e(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class c0e extends FA{constructor(e){if(super(),this.upstream=e,De().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:n}=require("string_decoder");this.decoder=new n("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let n;if(e.done)return!1;n=e.value;let r;return De().get("IS_BROWSER")?r=this.decoder.decode(n,{stream:!0}):r=this.decoder.write(Buffer.from(n.buffer)),this.outputQueue.push(r),!0}}class fW extends l0e{constructor(e,n={}){super(),this.file=e,this.options=n,J(e instanceof Uint8Array||(De().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=n.offset||0,this.chunkSize=n.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((n,r)=>{const s=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)n(new Uint8Array(this.file.slice(this.offset,s)));else{const i=new FileReader;i.onload=a=>{let l=i.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return r(new TypeError("FileReader returned unknown type."));n(l)},i.onabort=a=>r(new Error("Aborted")),i.onerror=a=>r(new Error(a.type));const o=this.file.slice(this.offset,s);i.readAsArrayBuffer(o)}this.offset=s}),done:!1}}}async function h0e(t,e={},n){let r,s;typeof t=="string"?r=t:(r=t.url,s=d0e(t));const i=await Uz(r,s);if(i.ok){const o=new Uint8Array(await i.arrayBuffer());return new fW(o,e)}else throw new Error(i.statusText)}const d0e=t=>({method:t.method,headers:t.headers,body:t.body,mode:t.mode,credentials:t.credentials,cache:t.cache,redirect:t.redirect,referrer:t.referrer,integrity:t.integrity});function pW(t){return typeof t=="string"&&t.slice(0,7)==="file://"}class mW extends hW{constructor(e,n={}){super(),this.input=e,this.options=n}async iterator(){if(pW(this.input)&&De().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new fW(this.input,this.options)}}class gW extends hW{constructor(e,n={}){super(),this.url=e,this.fileOptions=n}async iterator(){return pW(this.url)?new mW(this.url,this.fileOptions).iterator():h0e(this.url,this.fileOptions)}}function f0e(t,e={}){return new cW(new gW(t),e)}function p0e(t){const e=PA(t);return Jo(async()=>e)}function m0e(t){return Jo(async()=>{const e=await t();return PA(()=>e.next())})}async function g0e(t,e){return MA.create(t,e)}async function y0e(t){return LA.create(t)}const yW="4.22.0";const w0e=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:cW,Dataset:D1,FileDataSource:mW,TextLineDataset:uW,URLDataSource:gW,array:n0e,csv:f0e,func:p0e,generator:m0e,microphone:y0e,version_data:yW,webcam:g0e,zip:r0e},Symbol.toStringTag,{value:"Module"}));function zt(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&J(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const v0e=R_;class Qw extends n0{nextDataId(){return Qw.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Nx(this,Ya())}write(e,n,r){this.firstUse&&(this.firstUse=!1,De().get("IS_NODE")&&_a(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&ou(r[0])){const i=r.map(o=>mu(o));s=this.write(i,e,n)}else s=this.write(r,e,n);return{dataId:s,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,r,s,i){this.data.set(e,{values:n,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:r}=this.data.get(e);if(n==="complex64"){const s=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return cc(s,i)}return $z(this.data.get(e).values,n)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>oc(s));return En(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return En(e.shape,e.dtype,n)}makeOutput(e,n,r){return Ya().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=Ti();return e(),{kernelMs:Ti()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){zt([e],"where");const n=this.readSync(e.dataId);return v0e(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Qw.nextDataId=0;function wW(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const b0e=t=>{const{x:e}=t.inputs,n=t.backend;zt(e,"abs");let r=new Float32Array(Ue(e.shape));const s=n.data.get(e.dataId).values;return r=wW(s),n.makeOutput(r,e.shape,e.dtype)},x0e={kernelName:og,backendName:"cpu",kernelFunc:b0e};function vs(t){return(e,n,r,s,i)=>{const o=_n(e,n),a=o.length,l=Qt(o),u=Ue(o),c=ii(i,u),d=e.length,f=n.length,m=Qt(e),g=Qt(n),y=Qd(e,o),v=Qd(n,o);if(y.length+v.length===0)for(let b=0;b<c.length;++b)c[b]=t(r[b%r.length],s[b%s.length]);else for(let b=0;b<c.length;++b){const x=Tf(b,a,l),$=x.slice(-d);y.forEach(R=>$[R]=0);const S=Al($,d,m),E=x.slice(-f);v.forEach(R=>E[R]=0);const L=Al(E,f,g);c[b]=t(r[S],s[L])}return[c,o]}}function ta(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,a=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(a.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",i),imag:n.makeTensorInfo(s.shape,"float32",o)},a}const _0e={kernelName:u0,backendName:"cpu",kernelFunc:ta};function Yb(t,e,n="float32"){if(n==="complex64"){const s=Yb(t,e,"float32"),i=Yb(t,e,"float32");return ta({inputs:{real:s,imag:i},backend:t})}const r=Ei(Ue(e),n);return t.makeTensorInfo(e,n,r)}function Su(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const I0e={kernelName:Gf,backendName:"cpu",kernelFunc:Su};function uf(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.real,i=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,i)}const T0e={kernelName:U0,backendName:"cpu",kernelFunc:uf};function vW(t,e,n,r){if(r==="int32"){const s=Int32Array.from(t);return[e,"int32",s]}if(r==="bool"){const s=Wh([0],n),[i,o]=vs((a,l)=>a!==l?1:0)(e,[],t,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Mh(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Su({inputs:{x:s},backend:n});const c=Yb(n,s.shape,s.dtype),d=Mh({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),f=ta({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),f}if(s.dtype==="complex64"){const c=uf({inputs:{input:s},backend:n}),d=Mh({inputs:{x:c},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(c),d}if(!cE(s.dtype,i)){const c=Su({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:i}}const o=n.data.get(s.dataId).values,[a,l,u]=vW(o,s.shape,s.dtype,i);return n.makeTensorInfo(a,l,u)}const S0e={kernelName:Rf,backendName:"cpu",kernelFunc:Mh};function Gs(t,e,n,r){return n==null?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;zt([o,a],t);const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,d=o.dtype==="string"?hc(u):u,f=o.dtype==="string"?hc(c):c,m=r||o.dtype,[g,y]=e(o.shape,a.shape,d,f,m);return l.makeTensorInfo(y,m,g)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const u=Mh({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,f=c.complexTensorInfos.imag,m=l.data.get(d.dataId).values,g=l.data.get(f.dataId).values,y=Mh({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),v=l.data.get(y.dataId),b=v.complexTensorInfos.real,x=v.complexTensorInfos.imag,$=l.data.get(b.dataId).values,S=l.data.get(x.dataId).values,[E,L,R]=n(o.shape,a.shape,m,g,$,S),D=l.makeTensorInfo(R,"float32",E),A=l.makeTensorInfo(R,"float32",L),F=ta({inputs:{real:D,imag:A},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(y),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(A),F}else{const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,d=r||o.dtype,[f,m]=e(o.shape,a.shape,u,c,d);return l.makeTensorInfo(m,d,f)}}}function zA(t){return(e,n,r,s,i,o)=>{const a=_n(e,n),l=Ue(a),u=a.length,c=Qt(a),d=ii("float32",l),f=ii("float32",l),m=Qd(e,a),g=Qd(n,a),y=cc(r,s),v=cc(i,o),b=e.length,x=Qt(e),$=n.length,S=Qt(n);if(m.length+g.length===0)for(let E=0;E<d.length;E++){const L=E%y.length,R=E%v.length,D=t(y[L*2],y[L*2+1],v[R*2],v[R*2+1]);d[E]=D.real,f[E]=D.imag}else for(let E=0;E<d.length;E++){const L=Tf(E,u,c),R=L.slice(-b);m.forEach(K=>R[K]=0);const D=Al(R,b,x),A=L.slice(-$);g.forEach(K=>A[K]=0);const F=Al(A,$,S),P=t(y[D*2],y[D*2+1],v[F*2],v[F*2+1]);d[E]=P.real,f[E]=P.imag}return[d,f,a]}}const bW=vs(((t,e)=>t+e)),$0e=zA(((t,e,n,r)=>({real:t+n,imag:e+r}))),qm=Gs(Uh,bW,$0e),C0e={kernelName:Uh,backendName:"cpu",kernelFunc:qm};function VA(t,e,n,r,s){const i=Ue(r),o=Ei(s,n);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function xW(t,e,n,r=!1){const s=t.shape[0],i=t.shape[1],o=En([s,n],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const u=t.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?o.set(1,a,u):e.size>0?o.set(o.get(a,u)+e.get(a,l),a,u):o.set(o.get(a,u)+1,a,u))}return o}const _W=vs(((t,e)=>t&e)),E0e=Gs(pg,_W),k0e={kernelName:pg,backendName:"cpu",kernelFunc:E0e};function ku(t){return(e,n,r)=>{const s=as(n,e.length);for(let i=0;i<e.length;++i)s[i]=t(e[i],r);return s}}function br(t,e,n){const r=ku(e);return Qh(t,r,n)}function Qh(t,e,n){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;zt(o,t);const a=i,l=a.data.get(o.dataId).values;let u;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=hc(l)}else u=l;const c=n||o.dtype,d=e(u,c,s);return a.makeTensorInfo(o.shape,c,d)}}const IW=ku(t=>Math.ceil(t)),N0e=Qh(Df,IW),A0e={kernelName:Df,backendName:"cpu",kernelFunc:N0e};function TW(t,e,n,r){const s=as(n,Ue(e));if(r&&n!=="string"){let i=0;t.forEach(o=>{const a=Ue(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;t.forEach(o=>{const a=n==="string"?hc(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*e[1]+i;for(let d=0;d<o.shape[1];++d)s[c+d]=a[l++]}i+=o.shape[1]})}return s}const SW=vs((t,e)=>t===e?1:0),$W=Gs(Ig,SW,null,"bool"),R0e={kernelName:Ig,backendName:"cpu",kernelFunc:$W};const CW=ku(t=>Math.exp(t)),EW=Qh(Vf,CW,"float32"),D0e={kernelName:Vf,backendName:"cpu",kernelFunc:EW};const kW=ku(t=>Math.expm1(t)),O0e=Qh(Bf,kW),P0e={kernelName:Bf,backendName:"cpu",kernelFunc:O0e};const NW=ku(t=>Math.floor(t)),F0e=Qh(Uf,NW),L0e={kernelName:Uf,backendName:"cpu",kernelFunc:F0e};const AW=vs((t,e)=>Math.floor(t/e)),M0e=Gs(Wf,AW,null,"int32"),z0e={kernelName:Wf,backendName:"cpu",kernelFunc:M0e};function RW(t,e,n,r,s,i,o,a,l){const u=En([r,i],n);for(let c=0;c<r;c++){const d=[];let f=0;for(let m=0;m<s;m++){const g=t[c*s+m];f+=g*o[m],d.push(g)}if(f<0||f>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let m=0;m<i;m++)u.values[c*i+m]=e.get(...e.indexToLoc(f*i+m))}return u}function DW(t,e,n){const r=En(n,t.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),a=o[0],l=o[2],u=e.locToIndex([a,l]);o[2]=e.values[u];const c=t.locToIndex(o);0<=c&&c<t.values.length&&(r.values[s]=t.values[c])}return r}const OW=vs((t,e)=>t>e?1:0),V0e=Gs(Cg,OW,null,"bool"),B0e={kernelName:Cg,backendName:"cpu",kernelFunc:V0e};const PW=vs((t,e)=>t>=e?1:0),U0e=Gs(jf,PW,null,"bool"),W0e={kernelName:jf,backendName:"cpu",kernelFunc:U0e};const FW=vs((t,e)=>t<e?1:0),j0e=Gs(kg,FW,null,"bool"),G0e={kernelName:kg,backendName:"cpu",kernelFunc:j0e};const LW=vs((t,e)=>t<=e?1:0),H0e=Gs(Ng,LW,null,"bool"),q0e={kernelName:Ng,backendName:"cpu",kernelFunc:H0e};function MW(t,e,n){const r=(e-t)/(n-1),s=Ei(n,"float32");s[0]=t;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const zW=ku(t=>Math.log(t)),K0e=Qh(Xf,zW),X0e={kernelName:Xf,backendName:"cpu",kernelFunc:K0e};function VW(t,e,n,r){const s=ii(r,Ue(n));for(let i=0;i<s.length;++i){const o=i*e;let a=t[o];for(let l=0;l<e;++l){const u=t[o+l];(Number.isNaN(u)||u>a)&&(a=u)}s[i]=a}return s}const BW=vs(((t,e)=>Math.max(t,e))),Y0e=Gs(Qf,BW),Q0e={kernelName:Qf,backendName:"cpu",kernelFunc:Y0e};const UW=vs(((t,e)=>Math.min(t,e))),J0e=Gs(Jf,UW),Z0e={kernelName:Jf,backendName:"cpu",kernelFunc:J0e};const BA=vs(((t,e)=>t*e)),ewe=zA(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),C4=Gs(ep,BA,ewe),twe={kernelName:ep,backendName:"cpu",kernelFunc:C4};function WW(t,e,n){const r=yc(-1,n);return BA([],e,r,t,n)}function nwe(t){const{inputs:e,backend:n}=t,{x:r}=e;zt(r,"neg");const s=n.data.get(r.dataId).values,[i,o]=WW(s,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}const rwe={kernelName:Bg,backendName:"cpu",kernelFunc:nwe};const jW=vs(((t,e)=>t!==e?1:0)),swe=Gs(Ug,jW,null,"bool"),iwe={kernelName:Ug,backendName:"cpu",kernelFunc:swe};function UA(t,e,n,r,s){const i=e.length,o=Ue(e),a=Qt(e),l=Qt(s),u=ii(n,Ue(s));for(let c=0;c<o;++c){const d=Tf(c,i,a),f=new Array(d.length);for(let g=0;g<f.length;g++)f[g]=d[r[g]];const m=Al(f,i,l);u[m]=t[c]}return u}function Oo(t){const{inputs:e,attrs:n,backend:r}=t,{x:s}=e,{perm:i}=n;zt(s,"transpose");const o=s.shape.length,a=new Array(o);for(let d=0;d<a.length;d++)a[d]=s.shape[i[d]];const l=r.data.get(s.dataId).values,u=UA(l,s.shape,s.dtype,i,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const owe={kernelName:ph,backendName:"cpu",kernelFunc:Oo};function GW(t,e,n,r){const[s,i]=li(t,r),o=go(e,"int32"),a=Ei(Ue(s),o),l=Ue(i);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let f=0;f<l;++f)d*=n[c+f];a[u]=d}return{outVals:a,outShape:s,outDtype:o}}function awe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r;zt(s,"prod");const a=s.shape.length,l=On(i,s.shape),u=ns(l,a);let c=l,d=s;const f=[];u!=null&&(d=Oo({inputs:{x:s},backend:n,attrs:{perm:u}}),f.push(d),c=ys(c.length,a));const m=n.data.get(d.dataId).values,{outVals:g,outShape:y,outDtype:v}=GW(d.shape,d.dtype,m,c);let b=y;return o&&(b=gs(y,l)),f.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(b,v,g)}const lwe={kernelName:Kg,backendName:"cpu",kernelFunc:awe};function uwe(t,e,n){t.forEach((r,s)=>{if(r<0||r>=n){const i=Tf(s,e.length,Qt(e)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${n})`)}})}function cwe(t,e){for(let n=0;n<t.length;++n){const r=t[n],s=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}function hwe(t,e,n,r){const s=[];let i=0;const o=e.length-1+n.length,a=new Array(o).fill(null).map(()=>[0]);cwe(n,r);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let d=1;d<l+1;++d)a[u].push(d*c)}for(let u=0;u<t.length;++u){let c=t[u],d=t[u]+1;for(let f=0;f<n.length;++f){const m=n[f],g=f+e.length-1;if(g>=0){const y=a[g],v=y[y.length-1]-m[c];for(let b=c;b<d;++b)a[g].push(m[b+1]+v)}c=m[c],d=m[d]}d!==c&&(s.push([c,d]),i+=d-c)}return{outSplits:a,valueSlices:s,numValues:i}}function dwe(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,s=as("int32",r);e.push(s),t[n].forEach((i,o)=>s[o]=i)}return e}function vP(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function fwe(t,e,n,r,s,i){const o=vP(e,2)[1],a=vP(i,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*a+d]=t[c*o+d];++l}}function pwe(t,e,n,r,s){const i=e.slice();i[0]=s;const o=as(n,Ue(i)),a=t.length,l=a===0?0:a/e[0];return fwe(t,e,r,l,o,i),[o,i]}function HW(t,e,n,r,s,i,o,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(uwe(i,o,l),r.length===0)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:f}=hwe(i,o,t,u),m=dwe(c),g=pwe(n,r,s,d,f);return[m,g[0],g[1]]}const bP=2147483647;function qW(t,e,n,r,s,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,u=o.length===0,c=[];a||c.push(e[0]),l||c.push(s[0]),u||c.push(o[0]);for(let v=1;v<c.length;++v)if(c[v]!==c[v-1])throw new Error("starts, limits, and deltas must have the same shape");const d=c.length===0?1:c[0],f=as("int32",d+1);f[0]=0;for(let v=0;v<d;++v){const b=a?t[0]:t[v],x=l?r[0]:r[v],$=u?i[0]:i[v];if($===0)throw new Error("Requires delta != 0");let S;if($>0&&x<b||$<0&&x>b)S=0;else if(S=Math.ceil(Math.abs((x-b)/$)),S>bP)throw new Error(`Requires ((limit - start) / delta) <= ${bP}`);f[v+1]=f[v]+S}const m=f[d],g=as(n,m);let y=0;for(let v=0;v<d;++v){const b=f[v+1]-f[v];let x=a?t[0]:t[v];const $=u?i[0]:i[v];for(let S=0;S<b;++S)g[y++]=x,x+=$}return[f,g]}var Ka=Cl;class Qb{constructor(e,n,r,s,i,o,a,l,u,c){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=hB(c),this.raggedRank=dB(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ka.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ka.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ka.VALUE_ROWIDS:return Qb.getMaxWidthValueRowID(n);case Ka.ROW_SPLITS:return Qb.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Ka[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const i=e[s+1]-e[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,s=e[0],i=0;for(let o=1;o<n;++o){const a=e[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(n-r,i)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return _P(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;fB(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=cB(this.raggedRank,s,n);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,n,r){const s=Math.min(e,r),i=[];let o=0;for(let a=0;a<s;++a,o+=n)i.push(o);for(let a=s;a<e;++a)i.push(-1);return J(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,n,r,s){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let u=Math.min(s,l),c=n[a];c===-1&&(u=0);for(let d=0;d<u;++d)o.push(c),c+=r;for(let d=0;d<l-u;++d)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,n,r,s){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];o.push(u);for(let c=1;c<i;++c){const d=e[c];if(d===l)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}o.push(u)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,n,r,s){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Ka.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,n,r,s);case Ka.ROW_SPLITS:if(i.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(i,n,r,s);default:throw new Error(`Unsupported partition type: ${Ka[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Ka.FIRST_DIM_SIZE:return e[0];case Ka.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ka.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ka[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=_P(r,!1),o=as(this.valuesDType,Ue(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,n,r,s){if(r.length===0)return;const i=this.values,o=r;let a=s.slice();a=a.slice(e+1);const l=Ue(a),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const g=this.defaultValueShape;ke(()=>{const y=Ie(c,g);c=gh(y,a).dataSync()})}let d=0,f=0,m=0;for(let g=0;g<=u;++g){let y=g<u?n[g]:-1;if(y===m){++m;continue}if(f<m){const v=i.subarray(d*l),b=o.subarray(f*l),x=(m-f)*l;xP(b,v,x)}if(g>=u){const v=r.length;y=Math.floor(v/l)}if(y>m)if(this.defaultValue.length===1)o.subarray(m*l,y*l).fill(this.defaultValue[0]),m=y;else for(;y>m;){const v=o.slice(m*l);xP(v,c,l),++m}y<0?(d=g+1,f=m):(d=g,f=m,m=f+1)}}}function xP(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function _P(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function KW(t,e,n,r,s,i,o,a,l,u){return new Qb(t,e,n,r,s,i,o,a,l,u).compute()}function XW(t,e,n,r){const s=t===e,i=t<e&&n<0,o=e<t&&n>1;if(s||i||o)return Ei(0,r);const a=Math.abs(Math.ceil((e-t)/n)),l=Ei(a,r);e<t&&n===1&&(n=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}const YW=ku(t=>1/Math.sqrt(t)),mwe=Qh(op,YW),gwe={kernelName:op,backendName:"cpu",kernelFunc:mwe};function Ad(t,e,n,r,s,i,o,a,l,u){const c=[r/s,s],d=t.values,f=e.values;if(r===0)return En(n,e.dtype);const m=l instanceof ms?l:En(c,e.dtype);typeof l=="string"||typeof l=="number"?m.values.fill(l):typeof l=="boolean"&&m.values.fill(+l);for(let g=0;g<i;g++){const y=[];let v=0;for(let b=0;b<o;b++){const x=d[g*o+b];y.push(x),v+=x*a[b]}if(v<0||v>=r/s)throw new Error(`Invalid indices: ${y} does not index into ${n}`);for(let b=0;b<s;b++)u?m.values[v*s+b]+=f[g*s+b]:m.values[v*s+b]=e.rank===0?f[0]:f[g*s+b]}return m}const ywe=ku(t=>1/(1+Math.exp(-t))),QW=br(hp,t=>1/(1+Math.exp(-t))),wwe={kernelName:hp,backendName:"cpu",kernelFunc:QW};function JW(t,e,n,r,s){const i=Rk(r,e,n),o=Ue(n),a=Qt(r);if(i){const d=Dk(e,a);return s==="string"?t.slice(d,d+o):t.subarray(d,d+o)}const l=s==="string"?hc(t):t,u=En(r,s,l),c=En(n,s);for(let d=0;d<c.size;++d){const f=c.indexToLoc(d),m=f.map((g,y)=>g+e[y]);c.set(u.get(...m),...f)}return s==="string"?DB(c.values):c.values}function cf(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,size:o}=r;zt(s,"slice");const[a,l]=Z_(s,i,o);Nk(s,a,l);const u=n.data.get(s.dataId).values,c=JW(u,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}const vwe={kernelName:e1,backendName:"cpu",kernelFunc:cf};function ZW(t,e,n,r,s,i,o){const a=e[0],l=i[0],u=new Array(l),c=new Array(a),d=e[1];if(l===0){if(a!==0)throw new Error(bB(a));const v=as(n,0),b=as(s,0);return[v,[0,d],b,u,c]}let f=!0,m=0;const g=new Array(l).fill(0);for(let v=0;v<a;++v){const b=t[v*d];if(b<0)throw new Error(xB(v,b));if(b>=l)throw new Error(_B(v,b,l));++g[b],f=f&&b>=m,m=b}let y=!0;for(let v=0;v<l;++v){const b=g[v]===0;u[v]=b,y=y&&!b,g[v]=Math.max(g[v],1),v>0&&(g[v]+=g[v-1])}if(y&&f){const v=t,b=r;for(let x=0;x<a;++x)c[x]=x;return[v,[a,d],b,u,c]}else{const v=g[l-1],b=as(n,v*d),x=as(s,v),$=new Array(l).fill(0);for(let S=0;S<a;++S){const E=t[S*d],L=$[E],R=(E===0?0:g[E-1])+L;$[E]++;for(let D=0;D<d;++D)b[R*d+D]=t[S*d+D];x[R]=r[S],c[S]=R}for(let S=0;S<l;++S)if($[S]===0){const L=S===0?0:g[S-1];b[L*d+0]=S;for(let R=1;R<d;++R)b[L*d+R]=0;x[L]=o}return[b,[v,d],x,u,c]}}function ej(t,e,n,r,s){const i=Ue(r),o=e[0],a=s.length,l=[];let u=1,c=-1;for(let v=0;v<a;++v){const b=s[v];if(b===-1){if(c!==-1)throw new Error(IB(c,v));c=v,l.push(1)}else{if(b<0)throw new Error(TB(v,b));u*=b,l.push(b)}}if(c!==-1){if(u<=0)throw new Error(SB());const v=Math.trunc(i/u);if(u*v!==i)throw new Error($B(r,l));l[c]=v}if(Ue(l)!==i)throw new Error(CB(r,l));const f=r.length,m=[];if(f>0){m[f-1]=1;for(let v=f-2;v>=0;--v)m[v]=m[v+1]*r[v+1]}const g=[];if(a>0){g[a-1]=1;for(let v=a-2;v>=0;--v)g[v]=g[v+1]*l[v+1]}const y=as(n,o*a);for(let v=0;v<o;++v){let b=0;for(let x=0;x<f;++x)b+=t[v*f+x]*m[x];for(let x=0;x<a;++x)y[v*a+x]=Math.trunc(b/g[x]),b%=g[x]}return[y,[o,a],l]}function WA(t,e,n,r,s,i=!1,o=0){const a=r.length,l=[e[0],t.length/e[0]],u=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error(C$());const f=e.slice();f[0]=d;const m=f.reduce(($,S)=>$*S,1),g=as(n,m);if(a===0)return d>0&&g.fill(o),[g,f];if(d<=0)throw new Error(C$());let y=0,v=1,b=0,x=s[y];for(;;){let $=0;if(v<a){if($=s[v],x===$){++v;continue}if(x>=$)throw new Error(EB())}if(x<0||x>=d)throw new Error(kB(x,d));x>b&&g.fill(o,b*u,x*u);for(let S=y;S<v;++S){const E=r[S];if(E<0||E>=l[0])throw new Error(NB(S,r[S],l[0]));for(let L=0;L<u;L++)g[x*u+L]+=t[E*u+L]}if(i)for(let S=0;S<u;S++)g[x*u+S]/=v-y;if(y=v,++v,b=x+1,x=$,v>a)break}return b<d&&g.fill(o,b*u,d*u),[g,f]}const bwe=ku(t=>Math.sqrt(t)),xwe=br(fp,t=>Math.sqrt(t)),_we={kernelName:fp,backendName:"cpu",kernelFunc:xwe};const tj=vs(((t,e)=>{const n=t-e;return n*n})),Iwe=Gs(pp,tj),Twe={kernelName:pp,backendName:"cpu",kernelFunc:Iwe};const nj=ku((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=e;return t.replace(new RegExp(n,r?"g":""),s)}),Swe=Qh(i1,nj),$we={kernelName:i1,backendName:"cpu",kernelFunc:Swe};function rj(t,e,n,r){const s=En(t,e.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*n[l]+r[l];s.set(e.get(...a),...o)}return s}class Cwe{constructor(e,n,r,s,i,o){this.separator=mu(e),this.nGramWidths=n,this.leftPad=mu(r),this.rightPad=mu(s),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),u=Math.max(0,l-a),c=Math.max(0,l-(i-(a+1))),d=o-(u+c),f=n+(u>0?0:a-l);let m=0;m+=u*this.leftPad.length;for(let x=0;x<d;++x)m+=e[f+x].length;m+=c*this.rightPad.length;const g=u+c+d-1;m+=g*this.separator.length,r[s+a]=new Uint8Array(m);const y=r[s+a];let v=0;const b=x=>x.forEach($=>y[v++]=$);for(let x=0;x<u;++x)b(this.leftPad),b(this.separator);for(let x=0;x<d-1;++x)b(e[f+x]),b(this.separator);if(d>0){b(e[f+d-1]);for(let x=0;x<c;++x)b(this.separator),b(this.rightPad)}else{for(let x=0;x<c-1;++x)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,n){const r=e.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=n[u]>=l;if(c=c&&n[u]<=r,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${r}]`);l=n[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=as("int32",s);if(r===0||s===0){const l=new Array(r);for(let u=0;u<=i;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&c===0&&(c=1),o[l]=o[l-1]+c}const a=new Array(o[i]);for(let l=0;l<i;++l){const u=n[l];let c=o[l];if(this.nGramWidths.forEach(d=>{const f=n[l+1]-n[l],m=this.getNumNGrams(f,d);this.createNGrams(e,u,a,c,m,d),c+=m}),this.preserveShort&&c===o[l]){const d=n[l+1]-n[l];if(d===0)continue;const f=d+2*this.padWidth;this.createNGrams(e,u,a,c,1,f)}}return[a,o]}}function sj(t,e,n,r,s,i,o,a){return new Cwe(n,r,s,i,o,a).compute(t,e)}function Ewe(t,e,n,r){if(!t.length)return;if(e.length===0){for(let i=0;i<t.length;++i)r.push(t.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=t.indexOf(i);for(;o!==-1;){const a=t.subarray(0,o);(!n||a.length!==0)&&r.push(a),t=t.subarray(o+1),o=t.indexOf(i)}(!n||t.length!==0)&&r.push(t);return}let s=0;for(let i=0;i<t.length+1;i++)if(i===t.length||e.indexOf(t[i])!==-1){const o=t.subarray(s,i);(!n||o.length!==0)&&r.push(o),s=i+1}}function ij(t,e,n){const r=t.length,s=[];let i=0,o=0;const a=new Array(r);for(let f=0;f<r;++f){const m=s.length;Ewe(t[f],e,n,s);const g=s.length-m;a[f]=g,i+=g,o=Math.max(o,g)}const l=as("int32",i*2),u=new Array(i),c=[r,o];let d=0;for(let f=0;f<r;++f)for(let m=0;m<a[f];++m)l[d*2]=f,l[d*2+1]=m,u[d]=s[d],++d;return[l,u,c]}function oj(t,e){const n=as("int32",t.length);for(let r=0;r<t.length;++r)n[r]=Bz(t[r]).modulo(e).getLowBitsUnsigned();return n}const aj=vs(((t,e)=>t-e)),kwe=zA(((t,e,n,r)=>({real:t-n,imag:e-r}))),jA=Gs(mp,aj,kwe),Nwe={kernelName:mp,backendName:"cpu",kernelFunc:jA};function lj(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=En(n,t.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(t.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%t.shape[l];const a=t.locToIndex(o);r.values[s]=t.values[a]}return r}const X2=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function uj(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,l=e-n+1,u=Math.log(a),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),f=Math.max(n,Math.floor(e-l*c/a+d)),m=Math.min(r,Math.floor(e+(a-l)*c/a+d));uj(t,e,f,m)}const s=t[e];let i=n,o=r;for(Hu(t,n,e),X2(t[r],s)>0&&Hu(t,n,r);i<o;){for(Hu(t,i,o),i++,o--;X2(t[i],s)<0;)i=i+1;for(;X2(t[o],s)>0;)o=o-1}X2(t[n],s)===0?Hu(t,n,o):(o=o+1,Hu(t,o,r)),o<=e&&(n=o+1),e<=o&&(r=o-1)}}function cj(t,e,n,r,s){const i=e[e.length-1],[o,a]=[t.length/i,i],l=ii(n,o*r),u=ii("int32",o*r);for(let d=0;d<o;d++){const f=d*a,m=t.subarray(f,f+a);let g=new Array(m.length);m.forEach((x,$)=>g[$]={value:x,index:$}),r<g.length&&(uj(g,r),g=g.slice(0,r)),s&&g.sort(X2);const y=d*r,v=l.subarray(y,y+r),b=u.subarray(y,y+r);for(let x=0;x<r;x++)v[x]=g[x].value,b[x]=g[x].index}const c=e.slice();return c[c.length-1]=r,[En(c,n,l),En(c,"int32",u)]}function hj(t,e,n,r){const s=On(e,n)[0],i=[1,n[0],1];for(let g=0;g<s;g++)i[0]*=n[g];i[1]=n[s];for(let g=s+1;g<n.length;g++)i[2]*=n[g];const o=new Map,a=new Int32Array(n[s]),l=new ms(i,r,t),u=[],c=i[0]===1&&i[2]===1;for(let g=0;g<n[s];g++){let y;if(c)y=t[g].toString();else{const b=[];for(let x=0;x<i[0];x++)for(let $=0;$<i[2];$++)b.push(l.get(x,g,$));y=b.join(",")}const v=o.get(y);if(v!=null)a[g]=v;else{const b=o.size;o.set(y,b),a[g]=b,u.push(g)}}const d=i.slice();d[1]=o.size;const f=new ms(d,r);u.forEach((g,y)=>{for(let v=0;v<i[0];v++)for(let b=0;b<i[2];b++)f.set(l.get(v,g,b),v,y,b)});const m=n.slice();return m[s]=d[1],{outputValues:f.values,outputShape:m,indices:a}}const dj=Object.freeze(Object.defineProperty({__proto__:null,addImpl:bW,bincountImpl:VA,bincountReduceImpl:xW,bitwiseAndImpl:_W,castImpl:vW,ceilImpl:IW,concatImpl:TW,equalImpl:SW,expImpl:CW,expm1Impl:kW,floorDivImpl:AW,floorImpl:NW,gatherNdImpl:RW,gatherV2Impl:DW,greaterEqualImpl:PW,greaterImpl:OW,lessEqualImpl:LW,lessImpl:FW,linSpaceImpl:MW,logImpl:zW,maxImpl:VW,maximumImpl:BW,minimumImpl:UW,multiplyImpl:BA,negImpl:WW,notEqualImpl:jW,prodImpl:GW,raggedGatherImpl:HW,raggedRangeImpl:qW,raggedTensorToTensorImpl:KW,rangeImpl:XW,rsqrtImpl:YW,scatterImpl:Ad,sigmoidImpl:ywe,simpleAbsImpl:wW,sliceImpl:JW,sparseFillEmptyRowsImpl:ZW,sparseReshapeImpl:ej,sparseSegmentReductionImpl:WA,sqrtImpl:bwe,squaredDifferenceImpl:tj,staticRegexReplaceImpl:nj,stridedSliceImpl:rj,stringNGramsImpl:sj,stringSplitImpl:ij,stringToHashBucketFastImpl:oj,subImpl:aj,tileImpl:lj,topKImpl:cj,transposeImpl:UA,uniqueImpl:hj},Symbol.toStringTag,{value:"Module"}));const fj="4.22.0";Fx("cpu",()=>new Qw,1);const pj=br(Mf,t=>t>=0?t:Math.exp(t)-1),Awe={kernelName:Mf,backendName:"cpu",kernelFunc:pj};function mj(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:i}=r;zt([s],"leakyRelu");const o=Ue(s.shape),a=n.data.get(s.dataId).values,l=ii("float32",o);for(let u=0;u<a.length;u++)l[u]=a[u]<0?i*a[u]:a[u];return n.makeTensorInfo(s.shape,"float32",l)}const Rwe={kernelName:Eg,backendName:"cpu",kernelFunc:mj};const Dwe=vs((t,e)=>t<0?e*t:t);function gj(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e;zt([r,s],"prelu");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,[a,l]=Dwe(r.shape,s.shape,i,o,"float32");return n.makeTensorInfo(l,"float32",a)}const Owe={kernelName:qg,backendName:"cpu",kernelFunc:gj};const yj=br(rp,t=>Math.max(0,t)),Pwe={kernelName:rp,backendName:"cpu",kernelFunc:yj};const wj=br(sp,t=>Math.min(Math.max(0,t),6)),Fwe={kernelName:sp,backendName:"cpu",kernelFunc:wj};function Jb(t,e,n,r,s){if(n==="linear")return Su({inputs:{x:e},backend:t});if(n==="relu")return yj({inputs:{x:e},backend:t});if(n==="elu")return pj({inputs:{x:e},backend:t});if(n==="relu6")return wj({inputs:{x:e},backend:t});if(n==="prelu")return gj({inputs:{x:e,alpha:r},backend:t});if(n==="leakyrelu")return mj({inputs:{x:e},backend:t,attrs:{alpha:s}});if(n==="sigmoid")return QW({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Nr(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:i}=r,o=Ue(s.shape),a=uE(i,o),l=Ue(a);J(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Lwe={kernelName:Xg,backendName:"cpu",kernelFunc:Nr};function vj(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;zt([s,i],"matMul");const l=s.shape.length,u=i.shape.length,c=o?s.shape[l-2]:s.shape[l-1],d=a?i.shape[u-1]:i.shape[u-2],f=o?s.shape[l-1]:s.shape[l-2],m=a?i.shape[u-2]:i.shape[u-1],g=s.shape.slice(0,-2),y=i.shape.slice(0,-2),v=Ue(g),b=Ue(y),$=_n(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([f,m]);J(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const S=o?[v,c,f]:[v,f,c],E=a?[b,m,d]:[b,d,m],L=Nr({inputs:{x:s},backend:n,attrs:{shape:S}}),R=Nr({inputs:{x:i},backend:n,attrs:{shape:E}}),D=o?L.shape[1]:L.shape[2],A=o?L.shape[2]:L.shape[1],F=a?R.shape[1]:R.shape[2],P=Math.max(v,b),K=n.data.get(L.dataId).values,j=n.data.get(R.dataId).values,se=Qt(L.shape),fe=Qt(R.shape),[me,ye,oe]=o?[se[0],1,se[1]]:[se[0],se[1],1],[ue,_e,Y]=a?[1,fe[1],fe[0]]:[fe[1],1,fe[0]],re=A*F,Te=En([P,A,F],L.dtype),Pe=Te.values,de=n.blockSize;for(let ge=0;ge<P;ge++){const Re=ge%v,Oe=ge%b;for(let Ve=0;Ve<A;Ve+=de){const We=Math.min(Ve+de,A);for(let nt=0;nt<F;nt+=de){const ct=Math.min(nt+de,F);for(let Ct=0;Ct<D;Ct+=de){const Wt=Math.min(Ct+de,D);for(let Et=Ve;Et<We;Et++)for(let vt=nt;vt<ct;vt++){let Ht=0;for(let Tt=Ct;Tt<Wt;Tt++){const Pt=K[Re*me+Et*ye+Tt*oe],Rt=j[Tt*ue+vt*_e+Oe*Y];Ht+=Pt*Rt}Pe[ge*re+(Et*F+vt)]+=Ht}}}}}return n.disposeIntermediateTensorInfo(L),n.disposeIntermediateTensorInfo(R),n.makeTensorInfo($,Te.dtype,Te.values)}const Mwe={kernelName:dg,backendName:"cpu",kernelFunc:vj};function zwe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let f,m,g;const y=[];f=vj({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),o&&(m=qm({inputs:{a:f,b:o},backend:n}),y.push(f),f=m),c&&(g=Jb(n,f,c,a,d),y.push(f),f=g);for(const b of y)n.disposeIntermediateTensorInfo(b);return f}const Vwe={kernelName:Pm,backendName:"cpu",kernelFunc:zwe};const Bwe=br(Sf,t=>Math.acos(t)),Uwe={kernelName:Sf,backendName:"cpu",kernelFunc:Bwe};const Wwe=br($f,t=>Math.acosh(t)),jwe={kernelName:$f,backendName:"cpu",kernelFunc:Wwe};function Gwe(t){const{inputs:e,backend:n}=t,r=e;zt(e,"addN");const s=r.map(a=>n.data.get(a.dataId).values),i=En(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<o.length;u++)o[u]+=l[u]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}const Hwe={kernelName:ag,backendName:"cpu",kernelFunc:Gwe};function qwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r;zt(s,"all");const a=On(i,s.shape);let l=a;const u=ns(l,s.shape.length);let c=s;u!=null&&(c=Oo({inputs:{x:s},backend:n,attrs:{perm:u}}),l=ys(l.length,s.shape.length)),Ri("all",l,c.shape.length);const[d,f]=li(c.shape,l),m=Ue(f),g=Ei(Ue(d),c.dtype),y=n.data.get(c.dataId).values;for(let b=0;b<g.length;++b){const x=b*m;let $=y[x];for(let S=0;S<m;++S){const E=y[x+S];$=$&&E}g[b]=$}u!=null&&n.disposeIntermediateTensorInfo(c);const v=n.makeTensorInfo(d,c.dtype,g);if(o){const b=gs(d,a),x=Nr({inputs:{x:v},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(v),x}return v}const Kwe={kernelName:r0,backendName:"cpu",kernelFunc:qwe};function Xwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r;zt(s,"any");const a=On(i,s.shape);let l=a;const u=ns(l,s.shape.length);let c=s;u!=null&&(c=Oo({inputs:{x:s},backend:n,attrs:{perm:u}}),l=ys(l.length,s.shape.length)),Ri("any",l,c.shape.length);const[d,f]=li(c.shape,l),m=Ue(f),g=Ei(Ue(d),c.dtype),y=n.data.get(c.dataId).values;for(let b=0;b<g.length;++b){const x=b*m;let $=y[x];for(let S=0;S<m;++S){const E=y[x+S];$=$||E}g[b]=$}u!=null&&n.disposeIntermediateTensorInfo(c);const v=n.makeTensorInfo(d,c.dtype,g);if(o){const b=gs(d,a),x=Nr({inputs:{x:v},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(v),x}return v}const Ywe={kernelName:s0,backendName:"cpu",kernelFunc:Xwe};function Qwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;zt(s,"argMax");let o=On(i,s.shape);const a=ns(o,s.shape.length);let l=s;const u=[];a!=null&&(l=Oo({inputs:{x:s},backend:n,attrs:{perm:a}}),u.push(l),o=ys(o.length,l.shape.length)),o=[o[0]],Ri("argMax",o,l.shape.length);const[c,d]=li(l.shape,o),f=Ue(c),m=Ei(f,"int32"),g=Ue(d),y=n.data.get(l.dataId).values;for(let v=0;v<m.length;++v){const b=v*g;let x=y[b],$=0;for(let S=0;S<g;++S){const E=y[b+S];E>x&&(x=E,$=S)}m[v]=$}return u.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(c,"int32",m)}const Jwe={kernelName:lg,backendName:"cpu",kernelFunc:Qwe};function Zwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;zt(s,"argMin");let o=On(i,s.shape);const a=ns(o,s.shape.length);let l=s;const u=[];a!=null&&(l=Oo({inputs:{x:s},backend:n,attrs:{perm:a}}),u.push(l),o=ys(o.length,l.shape.length)),o=[o[0]],Ri("argMin",o,l.shape.length);const[c,d]=li(l.shape,o),f=Ue(c),m=Ei(f,"int32"),g=Ue(d),y=n.data.get(l.dataId).values;for(let v=0;v<m.length;++v){const b=v*g;let x=y[b],$=0;for(let S=0;S<g;++S){const E=y[b+S];E<x&&(x=E,$=S)}m[v]=$}return u.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(c,"int32",m)}const e3e={kernelName:ug,backendName:"cpu",kernelFunc:Zwe};const t3e=br(Cf,t=>Math.asin(t)),n3e={kernelName:Cf,backendName:"cpu",kernelFunc:t3e};const r3e=br(Ef,t=>Math.asinh(t)),s3e={kernelName:Ef,backendName:"cpu",kernelFunc:r3e};const i3e=br(kf,t=>Math.atan(t)),o3e={kernelName:kf,backendName:"cpu",kernelFunc:i3e};const a3e=vs((t,e)=>Math.atan2(t,e)),l3e=Gs(Af,a3e),u3e={kernelName:Af,backendName:"cpu",kernelFunc:l3e};const c3e=br(Nf,t=>Math.atanh(t)),h3e={kernelName:Nf,backendName:"cpu",kernelFunc:c3e};function GA(t,e,n,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,g=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=En(s.outShape,n),v=y.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],x=s.outShape[2]*s.outShape[3],$=s.outShape[3];for(let S=0;S<s.batchSize;++S){const E=S*b,L=S*r[0];for(let R=0;R<s.inChannels;++R)for(let D=0;D<s.outHeight;++D){const A=D*o-f,F=Math.max(0,A),P=Math.min(s.inHeight,c+A),K=E+D*x;for(let j=0;j<s.outWidth;++j){const se=j*a-m,fe=Math.max(0,se),me=Math.min(s.inWidth,d+se);let ye=g,oe=0,ue=0;for(let Y=F;Y<P;Y+=l){const re=L+Y*r[1];for(let Te=fe;Te<me;Te+=u){const Pe=re+Te*r[2],de=t[Pe+R];i==="max"&&de>ye?ye=de:i==="avg"&&(oe+=de,ue++)}if(isNaN(ye))break}const _e=K+j*$+R;v[_e]=i==="avg"?oe/ue:ye}}}return y}function bj(t,e,n,r,s=!1,i=!1){const o=En(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.top,g=r.padInfo.left,y=En(e,n,t);for(let v=0;v<r.batchSize;++v)for(let b=0;b<r.inChannels;++b)for(let x=0;x<r.outHeight;++x){const $=x*a-m;let S=$;for(;S<0;)S+=u;const E=Math.min(r.inHeight,d+$);for(let L=0;L<r.outWidth;++L){const R=L*l-g;let D=R;for(;D<0;)D+=c;const A=Math.min(r.inWidth,f+R);let F=Number.NEGATIVE_INFINITY,P=-1;for(let K=S;K<E;K+=u){const j=K-$;for(let se=D;se<A;se+=c){const fe=se-R,me=y.get(v,K,se,b);me>F&&(F=me,s?P=i?((v*r.inHeight+K)*r.inWidth+se)*r.inChannels+b:(K*r.inWidth+se)*r.inChannels+b:P=j*f+fe)}}o.set(P,v,x,L,b)}}return o}function xj(t,e,n,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,f=s.effectiveFilterDepth,m=s.effectiveFilterHeight,g=s.effectiveFilterWidth,y=s.padInfo.front,v=s.padInfo.top,b=s.padInfo.left,x=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,$=En(s.outShape,n),S=$.values,E=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],L=s.outShape[2]*s.outShape[3]*s.outShape[4],R=s.outShape[3]*s.outShape[4],D=s.outShape[4];for(let A=0;A<s.batchSize;++A){const F=A*E,P=A*r[0];for(let K=0;K<s.inChannels;++K)for(let j=0;j<s.outDepth;++j){const se=j*o-y;let fe=se;for(;fe<0;)fe+=u;const me=Math.min(s.inDepth,f+se),ye=F+j*L;for(let oe=0;oe<s.outHeight;++oe){const ue=oe*a-v;let _e=ue;for(;_e<0;)_e+=c;const Y=Math.min(s.inHeight,m+ue),re=ye+oe*R;for(let Te=0;Te<s.outWidth;++Te){const Pe=Te*l-b;let de=Pe;for(;de<0;)de+=d;const ge=Math.min(s.inWidth,g+Pe),Re=re+Te*D;let Oe=x,Ve=0,We=0;for(let ct=fe;ct<me;ct+=u){const Ct=P+ct*r[1];for(let Wt=_e;Wt<Y;Wt+=c){const Et=Ct+Wt*r[2];for(let vt=de;vt<ge;vt+=d){const Ht=Et+vt*r[3],Tt=t[Ht+K];if(i==="max"&&Tt>Oe?Oe=Tt:i==="avg"&&(Ve+=Tt,We++),isNaN(Oe))break}if(isNaN(Oe))break}if(isNaN(Oe))break}const nt=Re+K;S[nt]=i==="avg"?Ve/Math.max(We,1):Oe}}}}return $}function d3e(t,e){const n=En(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.front,m=e.padInfo.top,g=e.padInfo.left;for(let y=0;y<e.batchSize;++y)for(let v=0;v<e.inChannels;++v)for(let b=0;b<e.outDepth;++b){const x=b*r-f;let $=x;for(;$<0;)$+=o;const S=Math.min(e.inDepth,u+x);for(let E=0;E<e.outHeight;++E){const L=E*s-m;let R=L;for(;R<0;)R+=a;const D=Math.min(e.inHeight,c+L);for(let A=0;A<e.outWidth;++A){const F=A*i-g;let P=F;for(;P<0;)P+=l;const K=Math.min(e.inWidth,d+F);let j=Number.NEGATIVE_INFINITY,se=-1;for(let fe=$;fe<S;fe+=o){const me=fe-x;for(let ye=R;ye<D;ye+=a){const oe=ye-L;for(let ue=P;ue<K;ue+=l){const _e=ue-F,Y=t.get(y,fe,ye,ue,v);Y>=j&&(j=Y,se=me*c*d+oe*c+_e)}}}n.set(se,y,b,E,A,v)}}}return n}function f3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;zt(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;J(Ai(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=il(s.shape,i,o,u,a,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&zn(c.inShape,c.outShape))d=Su({inputs:{x:s},backend:n});else{const f=n.data.get(s.dataId).values,m=Qt(s.shape),g=GA(f,s.shape,s.dtype,m,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,g.values)}return d}const p3e={kernelName:cg,backendName:"cpu",kernelFunc:f3e};function m3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=r;zt(s,"avgPool3d");const c=wc(s.shape,i,o,1,a,l,u),d=n.data.get(s.dataId).values,f=xj(d,s.shape,s.dtype,Qt(s.shape),c,"avg");return n.makeTensorInfo(f.shape,"float32",f.values)}const g3e={kernelName:hg,backendName:"cpu",kernelFunc:m3e};function y3e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=r;zt([s,i],"avgPool3DGrad");const c=wc(i.shape,o,a,1,l,u),d=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.filterDepth,y=c.filterHeight,v=c.filterWidth,b=c.dilationDepth,x=c.dilationHeight,$=c.dilationWidth,S=c.effectiveFilterDepth,E=c.effectiveFilterHeight,L=c.effectiveFilterWidth,R=S-1-c.padInfo.front,D=L-1-c.padInfo.left,A=E-1-c.padInfo.top,F=En(i.shape,"float32"),P=1/(g*y*v),K=n.bufferSync(s);for(let j=0;j<c.batchSize;++j)for(let se=0;se<c.inChannels;++se)for(let fe=0;fe<c.inDepth;++fe)for(let me=0;me<c.inHeight;++me)for(let ye=0;ye<c.inWidth;++ye){const oe=fe-R,ue=me-A,_e=ye-D;let Y=0;for(let re=0;re<S;re+=b){const Te=(oe+re)/d;if(!(Te<0||Te>=c.outDepth||Math.floor(Te)!==Te))for(let Pe=0;Pe<E;Pe+=x){const de=(ue+Pe)/f;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let ge=0;ge<L;ge+=$){const Re=(_e+ge)/m;if(Re<0||Re>=c.outWidth||Math.floor(Re)!==Re)continue;const Oe=K.get(j,Te,de,Re,se);Y+=Oe}}}F.set(Y*P,j,fe,me,ye,se)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}const w3e={kernelName:o0,backendName:"cpu",kernelFunc:y3e};function v3e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,o=i;zt([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=il(o.shape,a,l,1,u),d=c.strideHeight,f=c.strideWidth,m=c.filterHeight,g=c.filterWidth,y=c.dilationHeight,v=c.dilationWidth,b=c.effectiveFilterHeight,x=c.effectiveFilterWidth,$=x-1-c.padInfo.left,S=b-1-c.padInfo.top,E=En(o.shape,"float32"),L=1/(m*g),R=n.data.get(s.dataId).values,D=En(s.shape,"float32",R);for(let A=0;A<c.batchSize;++A)for(let F=0;F<c.inChannels;++F)for(let P=0;P<c.inHeight;++P)for(let K=0;K<c.inWidth;++K){const j=P-S,se=K-$;let fe=0;for(let me=0;me<b;me+=y){const ye=(j+me)/d;if(!(ye<0||ye>=c.outHeight||Math.floor(ye)!==ye))for(let oe=0;oe<x;oe+=v){const ue=(se+oe)/f;if(ue<0||ue>=c.outWidth||Math.floor(ue)!==ue)continue;const _e=D.get(A,ye,ue,F);fe+=_e}}E.set(fe*L,A,P,K,F)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const b3e={kernelName:i0,backendName:"cpu",kernelFunc:v3e};function x3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,scale:i,offset:o,mean:a,variance:l}=e;J(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),zt([s,a,l,i,o],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,f=n.data.get(l.dataId).values,m=i?n.data.get(i.dataId).values:new Float32Array([1]),g=o?n.data.get(o.dataId).values:new Float32Array([0]),y=new Float32Array(c.length),v=g.length,b=m.length,x=f.length,$=d.length;let S=0,E=0,L=0,R=0;for(let D=0;D<c.length;++D)y[D]=g[S++]+(c[D]-d[E++])*m[L++]/Math.sqrt(f[R++]+u),S>=v&&(S=0),E>=$&&(E=0),L>=b&&(L=0),R>=x&&(R=0);return n.makeTensorInfo(s.shape,s.dtype,y)}const _3e={kernelName:Sg,backendName:"cpu",kernelFunc:x3e};function I3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,crops:o}=r;zt([s],"batchToSpaceND");const a=i.reduce((b,x)=>b*x),l=zw(s.shape,i,a),u=Vw(l.length,i.length),c=Bw(s.shape,i,a),d=Bk(o,i.length),f=Uk(c,o,i.length),m=Nr({inputs:{x:s},backend:n,attrs:{shape:l}}),g=Oo({inputs:{x:m},backend:n,attrs:{perm:u}}),y=Nr({inputs:{x:g},backend:n,attrs:{shape:c}}),v=cf({inputs:{x:y},backend:n,attrs:{begin:d,size:f}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),v}const T3e={kernelName:fg,backendName:"cpu",kernelFunc:I3e};function S3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:o}=r,a=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,u=VA(a,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,u)}const $3e={kernelName:a0,backendName:"cpu",kernelFunc:S3e};function C3e(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,a=_n(Array.from(i),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const E3e={kernelName:l0,backendName:"cpu",kernelFunc:C3e};const k3e=br(Of,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),N3e={kernelName:Of,backendName:"cpu",kernelFunc:k3e};const A3e=t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(Ue(e.shape)),s=n.data.get(e.dataId),i=s.complexTensorInfos.real,o=s.complexTensorInfos.imag,a=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,e.shape,"float32")},R3e={kernelName:mg,backendName:"cpu",kernelFunc:A3e};function Km(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.imag,i=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,i)}const D3e={kernelName:E0,backendName:"cpu",kernelFunc:Km};function Xm(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,i=On(s,e[0].shape)[0],o=e.map(y=>y.shape);Mk(o,i);let a=gu(e.map(y=>y.shape),i);if(Ue(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(y=>Ue(y.shape)>0);if(l.length===1)return Su({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const y=l.map(S=>uf({inputs:{input:S},backend:n})),v=l.map(S=>Km({inputs:{input:S},backend:n})),b=Xm({inputs:y,backend:n,attrs:{axis:i}}),x=Xm({inputs:v,backend:n,attrs:{axis:i}}),$=ta({inputs:{real:b,imag:x},backend:n});return y.forEach(S=>n.disposeIntermediateTensorInfo(S)),v.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),$}const u=l.map(y=>{const b=[-1,Ue(y.shape.slice(i))];return Nr({inputs:{x:y},backend:n,attrs:{shape:b}})}),c=u.map(y=>({vals:n.data.get(y.dataId).values,shape:y.shape}));a=gu(u.map(y=>y.shape),1);const d=u[0].shape[0]===1,f=TW(c,a,e[0].dtype,d),m=gu(l.map(y=>y.shape),i),g=n.makeTensorInfo(m,e[0].dtype,f);return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const O3e={kernelName:gg,backendName:"cpu",kernelFunc:Xm};function _j(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;zt([s,i],"conv2d");const d=vc(l),f=ai(s.shape,i.shape,o,u,a,c,!1,d),m=f.filterHeight,g=f.filterWidth,y=f.dilationHeight,v=f.dilationWidth,b=f.padInfo.left,x=f.padInfo.top,$=f.dataFormat==="channelsLast",S=new ms(f.outShape,s.dtype),E=Qt(s.shape),L=Qt(i.shape),R=E[0],D=$?E[1]:E[2],A=$?E[2]:1,F=$?1:E[1],P=S.strides[0],K=$?S.strides[1]:S.strides[2],j=$?S.strides[2]:1,se=$?1:S.strides[1],fe=n.data.get(s.dataId).values,me=n.data.get(i.dataId).values,ye=S.values;for(let oe=0;oe<f.batchSize;++oe){const ue=oe*R,_e=oe*P;for(let Y=0;Y<f.outHeight;++Y){const re=_e+Y*K,Te=Y*f.strideHeight-x;for(let Pe=0;Pe<m;++Pe){const de=Te+Pe*y;if(de<0||de>=f.inHeight)continue;const ge=Pe*L[0],Re=ue+de*D;for(let Oe=0;Oe<f.outWidth;++Oe){const Ve=re+Oe*j,We=Oe*f.strideWidth-b;for(let nt=0;nt<g;++nt){const ct=We+nt*v;if(ct<0||ct>=f.inWidth)continue;const Ct=ge+nt*L[1],Wt=Re+ct*A;let Et=Ct;for(let vt=0;vt<f.inChannels;++vt){const Ht=fe[Wt+vt*F];for(let Tt=0;Tt<f.outChannels;++Tt)ye[Ve+Tt*se]+=Ht*me[Et+Tt];Et+=f.outChannels}}}}}}return n.makeTensorInfo(S.shape,S.dtype,ye)}const P3e={kernelName:yg,backendName:"cpu",kernelFunc:_j};function F3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;zt([s,i],"conv2dBackpropFilter");const d=vc(l),f=ai(s.shape,c,o,1,a,u,!1,d),{strideHeight:m,strideWidth:g,filterHeight:y,filterWidth:v}=f,b=f.dataFormat==="channelsLast",x=new ms(f.filterShape,"float32"),$=f.padInfo.left,S=f.padInfo.top,E=n.data.get(s.dataId).values,L=n.data.get(i.dataId).values,R=new ms(s.shape,s.dtype,E),D=new ms(i.shape,i.dtype,L);for(let A=0;A<y;++A){const F=Math.max(0,Math.ceil((S-A)/m)),P=Math.min(f.outHeight,(f.inHeight+S-A)/m);for(let K=0;K<v;++K){const j=Math.max(0,Math.ceil(($-K)/g)),se=Math.min(f.outWidth,(f.inWidth+$-K)/g);for(let fe=0;fe<f.inChannels;++fe)for(let me=0;me<f.outChannels;++me){let ye=0;for(let oe=0;oe<f.batchSize;++oe)for(let ue=F;ue<P;++ue){const _e=A+ue*m-S;for(let Y=j;Y<se;++Y){const re=K+Y*g-$;b?ye+=R.get(oe,_e,re,fe)*D.get(oe,ue,Y,me):ye+=R.get(oe,fe,_e,re)*D.get(oe,me,ue,Y)}}x.set(ye,A,K,fe,me)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const L3e={kernelName:c0,backendName:"cpu",kernelFunc:F3e};function M3e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;zt([s,i],"conv2dBackpropInput");const d=Qt(i.shape),f=Qt(s.shape);let m=vc(u);const g=ai(o,i.shape,a,1,l,c,!1,m),y=new ms(g.inShape,"float32"),v=y.values,b=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,[$,S,E]=d,{batchSize:L,filterHeight:R,filterWidth:D,inChannels:A,inHeight:F,inWidth:P,outChannels:K,outHeight:j,outWidth:se,strideHeight:fe,strideWidth:me}=g;m=g.dataFormat;const ye=R-1-g.padInfo.top,oe=D-1-g.padInfo.left,ue=m==="channelsLast",_e=y.strides[0],Y=ue?y.strides[1]:y.strides[2],re=ue?y.strides[2]:1,Te=ue?1:y.strides[1],Pe=f[0],de=ue?f[1]:f[2],ge=ue?f[2]:1,Re=ue?1:f[1];for(let Oe=0;Oe<L;++Oe)for(let Ve=0;Ve<A;++Ve)for(let We=0;We<F;++We){const nt=We-ye,ct=Math.max(0,Math.ceil(nt/fe)),Ct=Math.min(j,(R+nt)/fe);for(let Wt=0;Wt<P;++Wt){const Et=Wt-oe,vt=Math.max(0,Math.ceil(Et/me)),Ht=Math.min(se,(D+Et)/me);let Tt=0;for(let Rt=ct;Rt<Ct;++Rt){const Yt=Rt*fe-nt;for(let mn=vt;mn<Ht;++mn){const jt=mn*me-Et,Fn=Pe*Oe+de*Rt+ge*mn,Vn=$*(R-1-Yt)+S*(D-1-jt)+E*Ve;for(let Bn=0;Bn<K;++Bn){const Ln=b[Fn+Re*Bn],Tn=x[Vn+Bn];Tt+=Ln*Tn}}}const Pt=_e*Oe+Y*We+re*Wt+Te*Ve;v[Pt]=Tt}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const z3e={kernelName:wg,backendName:"cpu",kernelFunc:M3e};function V3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r;zt([s,i],"conv3d");const u=Gh(s.shape,i.shape,o,l,a),{filterDepth:c,filterHeight:d,filterWidth:f,dilationDepth:m,dilationHeight:g,dilationWidth:y,padInfo:v}=u,b=v.front,x=v.left,$=v.top,S=new ms(u.outShape,s.dtype),E=n.data.get(s.dataId).values,L=n.data.get(i.dataId).values,R=S.values,D=Qt(s.shape),A=Qt(i.shape);for(let F=0;F<u.batchSize;++F){const P=F*D[0],K=F*S.strides[0];for(let j=0;j<u.outDepth;++j){const se=K+j*S.strides[1],fe=j*u.strideDepth-b;for(let me=0;me<c;++me){const ye=fe+me*m;if(ye<0||ye>=u.inDepth)continue;const oe=me*A[0],ue=P+ye*D[1];for(let _e=0;_e<u.outHeight;++_e){const Y=se+_e*S.strides[2],re=_e*u.strideHeight-$;for(let Te=0;Te<d;++Te){const Pe=re+Te*g;if(Pe<0||Pe>=u.inHeight)continue;const de=oe+Te*A[1],ge=ue+Pe*D[2];for(let Re=0;Re<u.outWidth;++Re){const Oe=Y+Re*u.outChannels,Ve=Re*u.strideWidth-x;for(let We=0;We<f;++We){const nt=Ve+We*y;if(nt<0||nt>=u.inWidth)continue;const ct=de+We*A[2],Ct=ge+nt*u.inChannels;let Wt=ct;for(let Et=0;Et<u.inChannels;++Et){const vt=E[Ct+Et];for(let Ht=0;Ht<u.outChannels;++Ht)R[Oe+Ht]+=vt*L[Wt+Ht];Wt+=u.outChannels}}}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const B3e={kernelName:vg,backendName:"cpu",kernelFunc:V3e};function U3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r;zt([s,i],"conv3dBackpropFilterV2");const u=Qt(s.shape),c=Qt(i.shape),d=Gh(s.shape,l,o,1,a),f=d.strideDepth,m=d.strideHeight,g=d.strideWidth,y=d.filterDepth,v=d.filterHeight,b=d.filterWidth,x=new ms(d.filterShape,"float32"),$=x.values,[S,E,L,R]=x.strides,D=n.data.get(i.dataId).values,[A,F,P,K]=c,j=n.data.get(s.dataId).values,[se,fe,me,ye]=u,oe=d.padInfo.front,ue=d.padInfo.left,_e=d.padInfo.top;for(let Y=0;Y<y;++Y){const re=Math.max(0,Math.ceil((oe-Y)/f)),Te=Math.min(d.outDepth,(d.inDepth+oe-Y)/f),Pe=Y*S;for(let de=0;de<v;++de){const ge=Math.max(0,Math.ceil((_e-de)/m)),Re=Math.min(d.outHeight,(d.inHeight+_e-de)/m),Oe=de*E+Pe;for(let Ve=0;Ve<b;++Ve){const We=Math.max(0,Math.ceil((ue-Ve)/g)),nt=Math.min(d.outWidth,(d.inWidth+ue-Ve)/g),ct=Ve*L+Oe;for(let Ct=0;Ct<d.inChannels;++Ct){const Wt=Ct*R+ct;for(let Et=0;Et<d.outChannels;++Et){let vt=0;for(let Ht=0;Ht<d.batchSize;++Ht){const Tt=Ht*se,Pt=Ht*A;for(let Rt=re;Rt<Te;++Rt){const mn=(Y+Rt*f-oe)*fe+Tt,jt=Rt*F+Pt;for(let Fn=ge;Fn<Re;++Fn){const Bn=(de+Fn*m-_e)*me+mn,Ln=Fn*P+jt;for(let Tn=We;Tn<nt;++Tn){const fr=(Ve+Tn*g-ue)*ye+Bn,Ar=Tn*K+Ln;vt+=j[fr+Ct]*D[Ar+Et]}}}}$[Wt+Et]=vt}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const W3e={kernelName:h0,backendName:"cpu",kernelFunc:U3e};function j3e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r;zt([s],"conv3dBackpropInputV2");const u=Qt(s.shape),c=Qt(i.shape),d=Gh(l,i.shape,a,1,o),f=new ms(d.inShape,"float32"),m=f.values,[g,y,v,b]=f.strides,x=n.data.get(s.dataId).values,[$,S,E,L]=u,R=n.data.get(i.dataId).values,[D,A,F,P]=c,{batchSize:K,filterDepth:j,filterHeight:se,filterWidth:fe,inChannels:me,inDepth:ye,inHeight:oe,inWidth:ue,outChannels:_e,outDepth:Y,outHeight:re,outWidth:Te,strideDepth:Pe,strideHeight:de,strideWidth:ge}=d,Re=j-1-d.padInfo.front,Oe=se-1-d.padInfo.top,Ve=fe-1-d.padInfo.left;for(let We=0;We<K;++We)for(let nt=0;nt<me;++nt)for(let ct=0;ct<ye;++ct){const Ct=ct-Re,Wt=Math.max(0,Math.ceil(Ct/Pe)),Et=Math.min(Y,(j+Ct)/Pe);for(let vt=0;vt<oe;++vt){const Ht=vt-Oe,Tt=Math.max(0,Math.ceil(Ht/de)),Pt=Math.min(re,(se+Ht)/de);for(let Rt=0;Rt<ue;++Rt){const Yt=Rt-Ve,mn=Math.max(0,Math.ceil(Yt/ge)),jt=Math.min(Te,(fe+Yt)/ge);let Fn=0;for(let Vn=Wt;Vn<Et;++Vn){const Bn=Vn*Pe-Ct;for(let Ln=Tt;Ln<Pt;++Ln){const Tn=Ln*de-Ht;for(let xr=mn;xr<jt;++xr){const fr=xr*ge-Yt,Ar=$*We+S*Vn+E*Ln+L*xr,Hs=D*(j-1-Bn)+A*(se-1-Tn)+F*(fe-1-fr)+P*nt;for(let qr=0;qr<_e;++qr){const gr=x[Ar+qr],ir=R[Hs+qr];Fn+=gr*ir}}}}m[g*We+y*ct+v*vt+b*Rt+nt]=Fn}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const G3e={kernelName:d0,backendName:"cpu",kernelFunc:j3e};const H3e=br(Pf,t=>Math.cos(t)),q3e={kernelName:Pf,backendName:"cpu",kernelFunc:H3e};const K3e=br(Ff,t=>Math.cosh(t)),X3e={kernelName:Ff,backendName:"cpu",kernelFunc:K3e};function Y3e(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,f,m]=s.shape,g=i.shape[0],[y,v]=a,b=En([g,y,v,m],"float32"),x=n.data.get(i.dataId).values,$=n.data.get(o.dataId).values,S=n.data.get(s.dataId).values,E=Qt(s.shape),L=Qt(b.shape);for(let R=0;R<g;R++){const D=R*4,A=x[D],F=x[D+1],P=x[D+2],K=x[D+3],j=$[R];if(j>=c)continue;const se=y>1?(P-A)*(d-1)/(y-1):0,fe=v>1?(K-F)*(f-1)/(v-1):0;for(let me=0;me<y;me++){const ye=y>1?A*(d-1)+me*se:.5*(A+P)*(d-1);if(ye<0||ye>d-1){for(let oe=0;oe<v;oe++)for(let ue=0;ue<m;ue++){const _e=ue+oe*L[2]+me*L[1]+R*L[0];b.values[_e]=u}continue}if(l==="bilinear"){const oe=Math.floor(ye),ue=Math.ceil(ye),_e=ye-oe;for(let Y=0;Y<v;Y++){const re=v>1?F*(f-1)+Y*fe:.5*(F+K)*(f-1);if(re<0||re>f-1){for(let ge=0;ge<m;ge++){const Re=ge+Y*L[2]+me*L[1]+R*L[0];b.values[Re]=u}continue}const Te=Math.floor(re),Pe=Math.ceil(re),de=re-Te;for(let ge=0;ge<m;ge++){let Re=ge+Te*E[2]+oe*E[1]+j*E[0];const Oe=S[Re];Re=ge+Pe*E[2]+oe*E[1]+j*E[0];const Ve=S[Re];Re=ge+Te*E[2]+ue*E[1]+j*E[0];const We=S[Re];Re=ge+Pe*E[2]+ue*E[1]+j*E[0];const nt=S[Re],ct=Oe+(Ve-Oe)*de,Ct=We+(nt-We)*de;Re=ge+Y*L[2]+me*L[1]+R*L[0],b.values[Re]=ct+(Ct-ct)*_e}}}else for(let oe=0;oe<v;++oe){const ue=v>1?F*(f-1)+oe*fe:.5*(F+K)*(f-1);if(ue<0||ue>f-1){for(let re=0;re<m;re++){const Te=re+oe*L[2]+me*L[1]+R*L[0];b.values[Te]=u}continue}const _e=Math.round(ue),Y=Math.round(ye);for(let re=0;re<m;re++){const Te=re+_e*E[2]+Y*E[1]+j*E[0],Pe=re+oe*L[2]+me*L[1]+R*L[0];b.values[Pe]=S[Te]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const Q3e={kernelName:p0,backendName:"cpu",kernelFunc:Y3e};function J3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;zt(s,"cumprod");const l=ns([i],s.shape.length);let u=s;l!=null&&(u=Oo({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=ys(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=go(u.dtype,"int32"),f=Rx(Ue(u.shape),d),m=n.data.get(u.dataId).values,g=u.shape[u.shape.length-1],y=a?(b,x)=>b+g-x-1:(b,x)=>b+x;for(let b=0;b<m.length;b+=g)for(let x=0;x<g;x++){const $=y(b,x);if(x===0)f[$]=o?1:m[$];else{const S=y(b,x-1);f[$]=o?m[S]*f[S]:m[$]*f[S]}}const v=n.makeTensorInfo(u.shape,d,f);if(l!=null){const b=qh(l),x=Oo({inputs:{x:v},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(u),x}return v}const Z3e={kernelName:f0,backendName:"cpu",kernelFunc:J3e};function eve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;zt(s,"cumsum");const l=ns([i],s.shape.length);let u=s;l!=null&&(u=Oo({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=ys(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=go(u.dtype,"int32"),f=Ei(Ue(u.shape),d),m=n.data.get(u.dataId).values,g=u.shape[u.shape.length-1],y=a?(b,x)=>b+g-x-1:(b,x)=>b+x;for(let b=0;b<m.length;b+=g)for(let x=0;x<g;x++){const $=y(b,x);if(x===0)f[$]=o?0:m[$];else{const S=y(b,x-1);f[$]=o?m[S]+f[S]:m[$]+f[S]}}const v=n.makeTensorInfo(u.shape,d,f);if(l!=null){const b=qh(l),x=Oo({inputs:{x:v},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(u),x}return v}const tve={kernelName:bg,backendName:"cpu",kernelFunc:eve};function nve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,c=VA(l,u,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(i),c=xW(l,u,o,a);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const rve={kernelName:m0,backendName:"cpu",kernelFunc:nve};function sve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:i,dataFormat:o}=r;J(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*i,f=u*i,m=c/(i*i),g=n.data.get(s.dataId).values,y=new Float32Array(a*d*f*m);let v=0;for(let b=0;b<a;++b)for(let x=0;x<d;++x){const $=Math.floor(x/i),S=x%i;for(let E=0;E<f;++E){const L=Math.floor(E/i),R=E%i,D=(S*i+R)*m;for(let A=0;A<m;++A){const P=A+D+c*(L+u*($+l*b));y[v++]=g[P]}}}return n.makeTensorInfo([a,d,f,m],s.dtype,y)}const ive={kernelName:g0,backendName:"cpu",kernelFunc:sve};function Ij(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=r;zt([s,i],"depthwiseConv2DNative");const c=Qt(s.shape),d=Qt(i.shape);let f=l;f==null&&(f=[1,1]),J(Ai(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const m=ai(s.shape,i.shape,o,f,a,u,!0),{filterHeight:g,filterWidth:y,dilationHeight:v,dilationWidth:b,padInfo:x}=m,$=x.left,S=x.top,E=m.outChannels/m.inChannels,L=new ms(m.outShape,s.dtype),R=n.data.get(s.dataId).values,D=n.data.get(i.dataId).values,A=L.values;for(let F=0;F<m.batchSize;++F){const P=F*c[0],K=F*L.strides[0];for(let j=0;j<m.outHeight;++j){const se=K+j*L.strides[1],fe=j*m.strideHeight-S;for(let me=0;me<g;++me){const ye=fe+me*v;if(ye<0||ye>=m.inHeight)continue;const oe=me*d[0],ue=P+ye*c[1];for(let _e=0;_e<m.outWidth;++_e){const Y=se+_e*L.strides[2],re=_e*m.strideWidth-$;for(let Te=0;Te<y;++Te){const Pe=re+Te*b;if(Pe<0||Pe>=m.inWidth)continue;const de=oe+Te*d[1],ge=ue+Pe*m.inChannels;let Re=Y,Oe=de;for(let Ve=0;Ve<m.inChannels;++Ve){const We=R[ge+Ve];for(let nt=0;nt<E;++nt)A[Re+nt]+=We*D[Oe+nt];Re+=E,Oe+=E}}}}}}return n.makeTensorInfo(L.shape,L.dtype,L.values)}const ove={kernelName:xg,backendName:"cpu",kernelFunc:Ij};function ave(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;zt([s,i],"depthwiseConv2dNativeBackpropFilter");const d=ai(s.shape,c,o,a,l,u,!0),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:y}=d,v=new ms(d.filterShape,"float32"),b=d.padInfo.left,x=d.padInfo.top,$=d.outChannels/d.inChannels,S=n.data.get(s.dataId).values,E=new ms(s.shape,s.dtype,S),L=n.data.get(i.dataId).values,R=new ms(i.shape,i.dtype,L);for(let D=0;D<g;++D){const A=Math.max(0,Math.ceil((x-D)/f)),F=Math.min(d.outHeight,(d.inHeight+x-D)/f);for(let P=0;P<y;++P){const K=Math.max(0,Math.ceil((b-P)/m)),j=Math.min(d.outWidth,(d.inWidth+b-P)/m);for(let se=0;se<d.outChannels;++se){const fe=Math.trunc(se/$),me=se%$;let ye=0;for(let oe=0;oe<d.batchSize;++oe)for(let ue=A;ue<F;++ue){const _e=D+ue*f-x;for(let Y=K;Y<j;++Y){const re=P+Y*m-b;ye+=E.get(oe,_e,re,fe)*R.get(oe,ue,Y,se)}}v.set(ye,D,P,fe,me)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const lve={kernelName:y0,backendName:"cpu",kernelFunc:ave};function uve(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;zt([s,i],"depthwiseConv2DNativeBackpropInput");const d=Qt(s.shape),f=Qt(i.shape),m=ai(c,i.shape,o,a,l,u,!0),g=new ms(m.inShape,"float32"),y=g.values,[v,b,x]=g.strides,$=n.data.get(s.dataId).values,[S,E,L]=d,R=n.data.get(i.dataId).values,[D,A,F]=f,{batchSize:P,filterHeight:K,filterWidth:j,inChannels:se,inHeight:fe,inWidth:me,outChannels:ye,outHeight:oe,outWidth:ue,strideHeight:_e,strideWidth:Y}=m,re=K-1-m.padInfo.top,Te=j-1-m.padInfo.left,Pe=ye/se;for(let de=0;de<P;++de)for(let ge=0;ge<se;++ge)for(let Re=0;Re<fe;++Re){const Oe=Re-re,Ve=Math.max(0,Math.ceil(Oe/_e)),We=Math.min(oe,(K+Oe)/_e);for(let nt=0;nt<me;++nt){const ct=nt-Te,Ct=Math.max(0,Math.ceil(ct/Y)),Wt=Math.min(ue,(j+ct)/Y);let Et=0;for(let vt=Ve;vt<We;++vt){const Ht=vt*_e-Oe;for(let Tt=Ct;Tt<Wt;++Tt){const Pt=Tt*Y-ct,Rt=S*de+E*vt+L*Tt,Yt=D*(K-1-Ht)+A*(j-1-Pt)+F*ge;for(let mn=0;mn<Pe;++mn){const jt=ge*Pe+mn,Fn=$[Rt+jt],Vn=R[Yt+mn];Et+=Fn*Vn}}}y[v*de+b*Re+x*nt+ge]=Et}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const cve={kernelName:w0,backendName:"cpu",kernelFunc:uve};function hve(t){const{inputs:e,backend:n}=t,{x:r}=e,s=Ue(r.shape),i=n.data.get(r.dataId).values,o=En([s,s],r.dtype),a=o.values;for(let u=0;u<i.length;u++)a[u*s+u]=i[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,o.dtype,o.values)}const dve={kernelName:v0,backendName:"cpu",kernelFunc:hve};const fve={kernelName:_g,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s}=t,{strides:i,pad:o,dilations:a}=n,l=e,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,f=s.shape.length,{batchSize:m,inHeight:g,inWidth:y,inChannels:v,outHeight:b,outWidth:x,padInfo:$,strideHeight:S,strideWidth:E,filterHeight:L,filterWidth:R,dilationHeight:D,dilationWidth:A,outShape:F}=pw(r.shape,s.shape,i,o,"NHWC",a),P=Ue(F),K=F.length,j=as(r.dtype,P);for(let fe=0;fe<m;++fe)for(let me=0;me<b;++me){const ye=me*S-$.top;for(let oe=0;oe<x;++oe){const ue=oe*E-$.left;for(let _e=0;_e<v;++_e){let Y=Number.MIN_SAFE_INTEGER;for(let Te=0;Te<L;++Te){const Pe=ye+Te*D;if(Pe>=0&&Pe<g)for(let de=0;de<R;++de){const ge=ue+de*A;if(ge>=0&&ge<y){const Re=Al([fe,Pe,ge,_e],c,Qt(r.shape)),Oe=Al([Te,de,_e],f,Qt(s.shape)),Ve=u[Re]+d[Oe];Ve>Y&&(Y=Ve)}}}const re=Al([fe,me,oe,_e],K,Qt(F));j[re]=Y}}}return{dataId:l.write(Wh(j,r.dtype),F,r.dtype),shape:F,dtype:r.dtype}}};const pve={kernelName:$y,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:i}=t,{strides:o,pad:a,dilations:l}=n,u=e,c=$a(r.shape,u.data.get(r.dataId).values),d=$a(s.shape,u.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:v,outWidth:b,padInfo:x,strideHeight:$,strideWidth:S,filterHeight:E,filterWidth:L,dilationHeight:R,dilationWidth:D,outShape:A}=pw(r.shape,s.shape,o,a,"NHWC",l);J(i.rank===A.length,()=>`Error in ${$y}, dy must have the same rank as output ${A.length}, but got ${i.rank}`);const F=$a(A,u.data.get(i.dataId).values),P=hE(s.shape,s.dtype);for(let j=0;j<f;++j)for(let se=0;se<v;++se){const fe=se*$-x.top;for(let me=0;me<b;++me){const ye=me*S-x.left;for(let oe=0;oe<y;++oe){let ue=Number.MIN_SAFE_INTEGER,_e=0,Y=0;for(let re=0;re<E;++re){const Te=fe+re*R;if(Te>=0&&Te<m)for(let Pe=0;Pe<L;++Pe){const de=ye+Pe*D;if(de>=0&&de<g){const ge=c[j][Te][de][oe]+d[re][Pe][oe];ge>ue&&(ue=ge,_e=re,Y=Pe)}}}P[_e][Y][oe]+=F[j][se][me][oe]}}}return{dataId:u.write(Wh(P,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const mve={kernelName:Sy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:i}=t,{strides:o,pad:a,dilations:l}=n,u=e,c=$a(r.shape,u.data.get(r.dataId).values),d=$a(s.shape,u.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:v,outWidth:b,padInfo:x,strideHeight:$,strideWidth:S,filterHeight:E,filterWidth:L,dilationHeight:R,dilationWidth:D,outShape:A}=pw(r.shape,s.shape,o,a,"NHWC",l);J(i.rank===A.length,()=>`Error in ${Sy}, dy must have the same rank as output ${A.length}, but got ${i.rank}`);const F=$a(A,u.data.get(i.dataId).values),P=hE(r.shape,r.dtype);for(let j=0;j<f;++j)for(let se=0;se<v;++se){const fe=se*$-x.top;for(let me=0;me<b;++me){const ye=me*S-x.left;for(let oe=0;oe<y;++oe){let ue=Number.MIN_SAFE_INTEGER,_e=fe<0?0:fe,Y=ye<0?0:ye;for(let re=0;re<E;++re){const Te=fe+re*R;if(Te>=0&&Te<m)for(let Pe=0;Pe<L;++Pe){const de=ye+Pe*D;if(de>=0&&de<g){const ge=c[j][Te][de][oe]+d[re][Pe][oe];ge>ue&&(ue=ge,_e=Te,Y=de)}}}P[j][_e][Y][oe]+=F[j][se][me][oe]}}}return{dataId:u.write(Wh(P,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function gve(t){const{inputs:e,backend:n,attrs:r}=t,{image:s}=e,{canvas:i,options:o}=r,{contextOptions:a,imageOptions:l}=o||{},u=l?.alpha||1,c=a?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const d=i.getContext(c,a?.contextAttributes||{});if(d==null)throw new Error(`Could not get the context with ${c} type.`);const[f,m]=s.shape.slice(0,2),g=s.shape.length===2?1:s.shape[2],y=n.data.get(s.dataId).values,v=s.dtype==="float32"?255:1,b=new Uint8ClampedArray(m*f*4);for(let $=0;$<f*m;++$){const S=[0,0,0,255*u];for(let L=0;L<g;L++){const R=y[$*g+L];if(s.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(s.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);g===1?(S[0]=R*v,S[1]=R*v,S[2]=R*v):S[L]=R*v}const E=$*4;b[E+0]=Math.round(S[0]),b[E+1]=Math.round(S[1]),b[E+2]=Math.round(S[2]),b[E+3]=Math.round(S[3])}i.width=m,i.height=f;const x=new ImageData(b,m,f);return d.putImageData(x,0,0),s}const yve={kernelName:b0,backendName:"cpu",kernelFunc:gve};function Jw(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r;zt(s,"sum");let a;s.dtype==="bool"?a=Mh({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):a=Su({inputs:{x:s},backend:n});const l=a.shape.length,u=On(i,a.shape),c=ns(u,l);let d=u,f=a;c!=null&&(f=Oo({inputs:{x:a},backend:n,attrs:{perm:c}}),d=ys(d.length,l)),Ri("sum",d,f.shape.length);const[m,g]=li(f.shape,d),y=go(f.dtype,"int32");let v=Yb(n,m,y);const b=Ue(g),x=n.data.get(v.dataId).values,$=n.data.get(f.dataId).values;for(let S=0;S<x.length;++S){const E=S*b;let L=0;for(let R=0;R<b;++R)L+=$[E+R];x[S]=L}if(o){const S=gs(v.shape,u),E=v;v=Nr({inputs:{x:v},backend:n,attrs:{shape:S}}),n.disposeIntermediateTensorInfo(E)}return n.disposeIntermediateTensorInfo(a),c!=null&&n.disposeIntermediateTensorInfo(f),v}const wve={kernelName:t1,backendName:"cpu",kernelFunc:Jw};function vve(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=Yk(s,i.length);Jk(o.length,l,i);const{path:u,steps:c}=Zk(a,l),d=c.length;let f=null,m=o.length;const g=[];for(let y=0;y<d;++y){for(const v of c[y]){const{permutationIndices:b,expandDims:x}=Qk(m,l[v]);let $;eN(b)?$=i[v]:($=Oo({inputs:{x:i[v]},backend:n,attrs:{perm:b}}),g.push($));const S=$.shape.slice();for(let E=0;E<x.length;++E)S.splice(x[E],0,1);zn($.shape,S)||($=Nr({inputs:{x:$},backend:n,attrs:{shape:S}}),g.push($)),f===null?f=$:(f=C4({inputs:{a:$,b:f},backend:n}),g.push(f))}y<d-1&&(u[y]>=0&&(f=Jw({inputs:{x:f},backend:n,attrs:{axis:u[y]-(o.length-m),keepDims:!1}}),g.push(f)),m--)}for(const y of g)y!==f&&n.disposeIntermediateTensorInfo(y);return f}const bve={kernelName:x0,backendName:"cpu",kernelFunc:vve};function xve(t){const{inputs:e,backend:n}=t,{dy:r,y:s}=e;zt([r,s],"eluGrad");const i=new Float32Array(Ue(s.shape)),o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const u=o[l];u>=0?i[l]=a[l]:i[l]=a[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",i)}const _ve={kernelName:_0,backendName:"cpu",kernelFunc:xve};const Ive=Wk,Tve=jk,Sve=Gk,$ve=Hk,Cve=qk,Eve=Kk,kve=br(zf,t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+Ive*n);return e*(1-((((Eve*r+Cve)*r+$ve)*r+Sve)*r+Tve)*r*Math.exp(-n*n))}),Nve={kernelName:zf,backendName:"cpu",kernelFunc:kve};function Zb(t){const{inputs:e,backend:n,attrs:r}=t,{input:s}=e,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(J(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Nr({inputs:{x:s},backend:n,attrs:{shape:a}})}const Ave={kernelName:Tg,backendName:"cpu",kernelFunc:Zb};const Rve=vs((t,e)=>t/e),HA=Gs(Lf,Rve),K$={kernelName:Lf,backendName:"cpu",kernelFunc:HA};function Tj(t,e,n){const r=t.shape,s=r[0],i=r[1],o=n.data.get(t.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[s,i],c=Ue(u),d=ii("float32",c),f=ii("float32",c);for(let v=0;v<s;v++){const b=cf({inputs:{x:a},backend:n,attrs:{begin:[v,0],size:[1,i]}}),x=cf({inputs:{x:l},backend:n,attrs:{begin:[v,0],size:[1,i]}}),$=ta({inputs:{real:b,imag:x},backend:n}),{real:S,imag:E}=Dve($,e,n),L=cc(S,E);for(let R=0;R<i;R++){const D=Xk(L,R);d[v*i+R]=D.real,f[v*i+R]=D.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo($)}const m=n.makeTensorInfo(u,"float32",d),g=n.makeTensorInfo(u,"float32",f),y=ta({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}function Dve(t,e,n){const r=Ue(t.shape),s=n.data.get(t.dataId),i=n.data.get(s.complexTensorInfos.real.dataId).values,o=n.data.get(s.complexTensorInfos.imag.dataId).values;if(Ove(r)){const a=X$(i,o,r,e,n),l=[t.shape[0],t.shape[1]];if(e){const u=n.makeTensorInfo(l,"float32",a.real),c=n.makeTensorInfo(l,"float32",a.imag),d=n.makeTensorInfo([],"float32",yc(r,"float32")),f=Su({inputs:{x:d},backend:n}),m=K$.kernelFunc({inputs:{a:u,b:d},backend:n}),g=K$.kernelFunc({inputs:{a:c,b:f},backend:n}),y=n.data.get(m.dataId).values,v=n.data.get(g.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),{real:y,imag:v}}return a}else{const a=cc(i,o),l=Pve(a,r,e);return pB(l)}}function Ove(t){return(t&t-1)===0}function X$(t,e,n,r,s){if(n===1)return{real:t,imag:e};const i=cc(t,e),o=n/2,a=mB(i),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),f=s.makeTensorInfo(c,"float32",u),m=ta({inputs:{real:d,imag:f},backend:s}),g=gB(i),y=g.real,v=g.imag,b=[y.length],x=s.makeTensorInfo(b,"float32",y),$=s.makeTensorInfo(b,"float32",v),S=ta({inputs:{real:x,imag:$},backend:s}),E=X$(l,u,o,r,s),L=E.real,R=E.imag,D=[L.length],A=s.makeTensorInfo(D,"float32",L),F=s.makeTensorInfo(D,"float32",R),P=ta({inputs:{real:A,imag:F},backend:s}),K=X$(y,v,o,r,s),j=K.real,se=K.imag,fe=[j.length],me=s.makeTensorInfo(fe,"float32",j),ye=s.makeTensorInfo(fe,"float32",se),oe=ta({inputs:{real:me,imag:ye},backend:s}),ue=wB(n,r),_e=[ue.real.length],Y=s.makeTensorInfo(_e,"float32",ue.real),re=s.makeTensorInfo(_e,"float32",ue.imag),Te=ta({inputs:{real:Y,imag:re},backend:s}),Pe=C4({inputs:{a:Te,b:oe},backend:s}),de=qm({inputs:{a:P,b:Pe},backend:s}),ge=jA({inputs:{a:P,b:Pe},backend:s}),Re=uf({inputs:{input:de},backend:s}),Oe=uf({inputs:{input:ge},backend:s}),Ve=Km({inputs:{input:de},backend:s}),We=Km({inputs:{input:ge},backend:s}),nt=Xm({inputs:[Re,Oe],backend:s,attrs:{axis:0}}),ct=Xm({inputs:[Ve,We],backend:s,attrs:{axis:0}}),Ct=s.data.get(nt.dataId).values,Wt=s.data.get(ct.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(me),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(oe),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(Te),s.disposeIntermediateTensorInfo(Pe),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(Re),s.disposeIntermediateTensorInfo(Ve),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(We),s.disposeIntermediateTensorInfo(nt),s.disposeIntermediateTensorInfo(ct),{real:Ct,imag:Wt}}function Pve(t,e,n){const r=new Float32Array(e*2);for(let s=0;s<e;s++){let i=0,o=0;for(let a=0;a<e;a++){const l=vB(s*a,e,n),u=Xk(t,a);i+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}n&&(i/=e,o/=e),yB(r,i,o,s)}return r}function Fve(t){const{inputs:e,backend:n}=t,{input:r}=e,s=Ue(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=Nr({inputs:{x:r},backend:n,attrs:{shape:[o,i]}}),l=Tj(a,!1,n),u=Nr({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}const Lve={kernelName:I0,backendName:"cpu",kernelFunc:Fve};function qA(t){const{backend:e,attrs:n}=t,{shape:r,value:s,dtype:i}=n,o=i||If(s),a=as(o,Ue(r));return zve(a,s,o),e.makeTensorInfo(r,o,a)}const Mve={kernelName:T0,backendName:"cpu",kernelFunc:qA};function zve(t,e,n){t.fill(e)}const Vve={kernelName:S0,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,s=n,i=ii(r.dtype,Ue(r.shape)),[o,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let f=0;f<o;f++){const m=f*l*a*u;for(let g=0;g<a;g++){const y=g*(l*u);for(let v=0;v<l;v++){const b=v*u;for(let x=0;x<u;x++){const $=Math.round(l-v-1),S=m+y+b+x;let E=c[S];if($>=0&&$<l){const L=$*u,R=m+y+L+x;E=c[R]}i[S]=E}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Bve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=r;let y=_j({inputs:{x:s,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f}});if(o){const v=y;if(c==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const b=Nr({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});y=qm({inputs:{a:y,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else y=qm({inputs:{a:y,b:o},backend:n});n.disposeIntermediateTensorInfo(v)}if(m){const v=y;if(c==="NCHW"&&m==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const b=Nr({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});y=Jb(n,y,m,b,g),n.disposeIntermediateTensorInfo(b)}else y=Jb(n,y,m,a,g);n.disposeIntermediateTensorInfo(v)}return y}const Uve={kernelName:Fm,backendName:"cpu",kernelFunc:Bve};function Wve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=r;let y=Ij({inputs:{x:s,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f}});if(o){const v=y;y=qm({inputs:{a:y,b:o},backend:n}),n.disposeIntermediateTensorInfo(v)}if(m){const v=y;y=Jb(n,y,m,a,g),n.disposeIntermediateTensorInfo(v)}return y}const jve={kernelName:Lm,backendName:"cpu",kernelFunc:Wve};function Gve(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,i=Ue(r.shape),o=s.shape,a=o[o.length-1],[l,u,c,d]=J_(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);const f=n.data.get(s.dataId).values,m=n.bufferSync(r),g=RW(f,m,r.dtype,u,a,c,d,r.shape,i);return n.makeTensorInfo(l,r.dtype,g.values)}const Hve={kernelName:$0,backendName:"cpu",kernelFunc:Gve};function qve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:i}=e,{axis:o,batchDims:a}=r;zt([s,i],"gatherV2");const l=On(o,s.shape)[0],u=n.data.get(i.dataId).values,c=s.shape[l];for(let S=0;S<u.length;++S){const E=u[S];J(E<=c-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${c-1}]`)}let d=a;a==null&&(d=0);const f=Ue(i.shape),m=nN(s,i,l,d),g=Nr({inputs:{x:s},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),y=Nr({inputs:{x:i},backend:n,attrs:{shape:[m.batchSize,f/m.batchSize]}}),v=[m.batchSize,m.outerSize,f/m.batchSize,m.sliceSize],b=n.bufferSync(y),x=n.bufferSync(g),$=DW(x,b,v);return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.makeTensorInfo(m.outputShape,$.dtype,$.values)}const Kve={kernelName:$g,backendName:"cpu",kernelFunc:qve};function Xve(t){const{inputs:e,backend:n}=t,{input:r}=e,s=Ue(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=Nr({inputs:{x:r},backend:n,attrs:{shape:[o,i]}}),l=Tj(a,!0,n),u=Nr({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}const Yve={kernelName:C0,backendName:"cpu",kernelFunc:Xve};const Qve=br(Hf,t=>Number.isFinite(t)?1:0,"bool"),Jve={kernelName:Hf,backendName:"cpu",kernelFunc:Qve};const Zve=br(qf,t=>Math.abs(t)===1/0?1:0,"bool"),ebe={kernelName:qf,backendName:"cpu",kernelFunc:Zve};const tbe=br(Kf,t=>Number.isNaN(t)?1:0,"bool"),nbe={kernelName:Kf,backendName:"cpu",kernelFunc:tbe};function rbe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:i}=n,o=MW(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const sbe={kernelName:k0,backendName:"cpu",kernelFunc:rbe};const ibe=br(Yf,t=>Math.log1p(t)),obe={kernelName:Yf,backendName:"cpu",kernelFunc:ibe};const abe=vs((t,e)=>t&&e),lbe=Gs(Ag,abe,null,"bool"),ube={kernelName:Ag,backendName:"cpu",kernelFunc:lbe};const cbe=br(Rg,t=>t?0:1,"bool"),hbe={kernelName:Rg,backendName:"cpu",kernelFunc:cbe};const dbe=vs((t,e)=>t||e),fbe=Gs(Dg,dbe,null,"bool"),pbe={kernelName:Dg,backendName:"cpu",kernelFunc:fbe};function mbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;zt(s,"LRN");const u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,f=Ue(s.shape),m=new Float32Array(f);function g(y){const v=y%u;let b=y-v+Math.max(0,v-i);const x=y-v+Math.min(v+i,c);let $=0;for(;b<=x;b++){const S=d[b];$+=S*S}return $}for(let y=0;y<f;y++){const v=g(y),b=d[y]*Math.pow(o+a*v,-l);m[y]=b}return n.makeTensorInfo(s.shape,s.dtype,m)}const gbe={kernelName:Og,backendName:"cpu",kernelFunc:mbe};function ybe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=r;zt(o,"LRNGrad");const d=Ue(o.shape),f=o.shape[3],m=n.data.get(o.dataId).values,g=n.data.get(s.dataId).values,y=n.data.get(i.dataId).values,v=new Float32Array(d),b=d;for(let x=0;x<b;x++){const $=x%f,S=x-$+Math.max(0,$-a),E=x-$+Math.min(f,$+a+1);let L=0;for(let R=S;R<E;R++)L+=Math.pow(g[R],2);L=u*L+l;for(let R=S;R<E;R++){let D=-2*u*c*g[R]*y[x]/L;x===R&&(D+=Math.pow(L,-c)),D*=m[x],v[R]+=D}}return n.makeTensorInfo(o.shape,s.dtype,v)}const wbe={kernelName:N0,backendName:"cpu",kernelFunc:ybe};function Sj(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=n;let l=s.shape;const u=l.length,c=On(i,l);let d=c;const f=ns(d,u);let m=a.data.get(s.dataId).values;if(f!=null){const S=new Array(u);for(let E=0;E<S.length;E++)S[E]=l[f[E]];m=UA(m,l,s.dtype,f,S),d=ys(d.length,u),l=S}zt(s,"max"),Ri("max",d,u);const[g,y]=li(l,d),v=Ue(y),b=VW(m,v,g,s.dtype),x=a.write(b,g,s.dtype);let $=g;return o&&($=gs(g,c)),{dataId:x,shape:$,dtype:s.dtype}}const vbe={kernelName:Pg,backendName:"cpu",kernelFunc:Sj};function bbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;zt(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;J(Ai(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=il(s.shape,i,o,u,a,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&zn(c.inShape,c.outShape))d=Su({inputs:{x:s},backend:n});else{const f=n.data.get(s.dataId).values,m=Qt(s.shape),g=GA(f,s.shape,s.dtype,m,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,g.values)}return d}const xbe={kernelName:Fg,backendName:"cpu",kernelFunc:bbe};function _be(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=r;zt(s,"maxPool3d");const c=wc(s.shape,i,o,1,a,l,u),d=n.data.get(s.dataId).values,f=xj(d,s.shape,s.dtype,Qt(s.shape),c,"max");return n.makeTensorInfo(f.shape,"float32",f.values)}const Ibe={kernelName:Lg,backendName:"cpu",kernelFunc:_be};function Tbe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=r;zt([s,i],"maxPool3DGrad");const c=wc(i.shape,o,a,1,l,u),d=n.bufferSync(i),f=d3e(d,c),m=c.strideDepth,g=c.strideHeight,y=c.strideWidth,v=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,$=c.effectiveFilterDepth,S=c.effectiveFilterHeight,E=c.effectiveFilterWidth,L=$-1-c.padInfo.front,R=E-1-c.padInfo.left,D=S-1-c.padInfo.top,A=En(i.shape,"float32"),F=n.bufferSync(s);for(let P=0;P<c.batchSize;++P)for(let K=0;K<c.inChannels;++K)for(let j=0;j<c.inDepth;++j)for(let se=0;se<c.inHeight;++se)for(let fe=0;fe<c.inWidth;++fe){const me=j-L,ye=se-D,oe=fe-R;let ue=0;for(let _e=0;_e<$;_e+=v){const Y=(me+_e)/m;if(!(Y<0||Y>=c.outDepth||Math.floor(Y)!==Y))for(let re=0;re<S;re+=b){const Te=(ye+re)/g;if(!(Te<0||Te>=c.outHeight||Math.floor(Te)!==Te))for(let Pe=0;Pe<E;Pe+=x){const de=(oe+Pe)/y;if(de<0||de>=c.outWidth||Math.floor(de)!==de)continue;const ge=$*S*E-1-f.get(P,Y,Te,de,K),Re=_e*S*E+re*E+Pe,Oe=ge===Re?1:0;if(Oe===0)continue;const Ve=F.get(P,Y,Te,de,K);ue+=Ve*Oe}}}A.set(ue,P,j,se,fe,K)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}const Sbe={kernelName:R0,backendName:"cpu",kernelFunc:Tbe};function $be(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i,output:o}=e,a=i;zt([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,f=il(a.shape,l,u,1,c,d),m=n.data.get(a.dataId).values,g=En(f.outShape,a.dtype,bj(m,a.shape,a.dtype,f).values),y=f.strideHeight,v=f.strideWidth,b=f.dilationHeight,x=f.dilationWidth,$=f.effectiveFilterHeight,S=f.effectiveFilterWidth,E=S-1-f.padInfo.left,L=$-1-f.padInfo.top,R=En(a.shape,"float32"),D=n.data.get(s.dataId).values,A=En(s.shape,"float32",D);for(let F=0;F<f.batchSize;++F)for(let P=0;P<f.inChannels;++P)for(let K=0;K<f.inHeight;++K)for(let j=0;j<f.inWidth;++j){const se=K-L,fe=j-E;let me=0;for(let ye=0;ye<$;ye+=b){const oe=(se+ye)/y;if(!(oe<0||oe>=f.outHeight||Math.floor(oe)!==oe))for(let ue=0;ue<S;ue+=x){const _e=(fe+ue)/v;if(_e<0||_e>=f.outWidth||Math.floor(_e)!==_e)continue;const Y=$*S-1-g.get(F,oe,_e,P),re=ye*S+ue,Te=Y===re?1:0;if(Te===0)continue;const Pe=A.get(F,oe,_e,P);me+=Pe*Te}}R.set(me,F,K,j,P)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}const Cbe={kernelName:A0,backendName:"cpu",kernelFunc:$be};function Ebe(t,e,n,r,s){const i=Qt(e),o=GA(t,e,n,i,s,"max"),a=bj(t,e,n,s,!0,r);return[o.values,a.values]}const kbe={kernelName:D0,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=n;zt(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=il(r.shape,s,i,[1,1],o),[d,f]=Ebe(u,r.shape,r.dtype,a,c),m=l.write(d,c.outShape,r.dtype),g=l.write(f,c.outShape,r.dtype);return[{dataId:m,shape:c.outShape,dtype:r.dtype},{dataId:g,shape:c.outShape,dtype:"int32"}]}};function Nbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r,a=On(i,s.shape),u=li(s.shape,a)[1],c=Ue(u),d=[],f=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(f);const m=Mh({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(m);const g=HA({inputs:{a:m,b:f},backend:n});d.push(g);const y=Jw({inputs:{x:g},backend:n,attrs:{axis:i,keepDims:o}});return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),y}const Abe={kernelName:Mg,backendName:"cpu",kernelFunc:Nbe};function Rbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r;zt(s,"min");const a=On(i,s.shape);let l=a;const u=ns(l,s.shape.length);let c=s;u!=null&&(c=Oo({inputs:{x:s},backend:n,attrs:{perm:u}}),l=ys(l.length,s.shape.length)),Ri("min",l,c.shape.length);const[d,f]=li(c.shape,l),m=Ue(f),g=Ei(Ue(d),c.dtype),y=n.data.get(c.dataId).values;for(let b=0;b<g.length;++b){const x=b*m;let $=y[x];for(let S=0;S<m;++S){const E=y[x+S];(Number.isNaN(E)||E<$)&&($=E)}g[b]=$}u!=null&&n.disposeIntermediateTensorInfo(c);const v=n.makeTensorInfo(d,c.dtype,g);if(o){const b=gs(d,a),x=Nr({inputs:{x:v},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(v),x}return v}const Dbe={kernelName:zg,backendName:"cpu",kernelFunc:Rbe};function Obe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:i,mode:o}=r;zt(s,"mirrorPad");const a=i.map(($,S)=>$[0]+s.shape[S]+$[1]),l=i.map($=>$[0]),u=i.map(($,S)=>$[0]+s.shape[S]),c=o==="reflect"?0:1,d=n.data.get(s.dataId).values,f=s.shape.length,m=Qt(s.shape),g=Ue(a),y=a.length,v=Qt(a),b=ii(s.dtype,g);for(let $=0;$<g;$++){let S=Tf($,y,v);for(let L=0;L<y;L++)S[L]<l[L]?S[L]=l[L]*2-S[L]-c:S[L]>=u[L]&&(S[L]=(u[L]-1)*2-S[L]+c);S=S.map((L,R)=>L-l[R]);const E=Al(S,f,m);b[$]=d[E]}return{dataId:n.write(b,a,s.dtype),shape:a,dtype:s.dtype}}const Pbe={kernelName:Vg,backendName:"cpu",kernelFunc:Obe};const Fbe=vs(((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})),Lbe=Gs(Zf,Fbe),Mbe={kernelName:Zf,backendName:"cpu",kernelFunc:Lbe};function $j(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:i}=r,o=s.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=On([a],s.shape),u=Sj({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=gs(u.shape,l),d=Nr({inputs:{x:u},backend:n,attrs:{shape:c}}),f=jA({inputs:{a:s,b:d},backend:n}),m=EW({inputs:{x:f},backend:n}),g=Jw({inputs:{x:m},backend:n,attrs:{axis:l,keepDims:!1}}),y=Nr({inputs:{x:g},backend:n,attrs:{shape:c}}),v=HA({inputs:{a:m,b:y},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),v}const zbe={kernelName:s1,backendName:"cpu",kernelFunc:$j};function Vbe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r;zt(s,"multinomial");const l=a?s:$j({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,f=[u,i],m=Ei(Ue(f),"int32");for(let g=0;g<u;++g){const y=g*c,v=new Float32Array(c-1);v[0]=d[y];for(let $=1;$<v.length;++$)v[$]=v[$-1]+d[y+$];const b=x1.alea(o.toString()),x=g*i;for(let $=0;$<i;++$){const S=b();m[x+$]=v.length;for(let E=0;E<v.length;E++)if(S<v[E]){m[x+$]=E;break}}}return a||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(f,"int32",m)}const Bbe={kernelName:O0,backendName:"cpu",kernelFunc:Vbe};const Ube=V_;function Wbe(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;zt(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:d}=Ube(u,c,o,a,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const jbe={kernelName:P0,backendName:"cpu",kernelFunc:Wbe};const Gbe=B_;function Hbe(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;zt(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,{selectedIndices:f,validOutputs:m}=Gbe(c,d,o,a,l,u);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([m]))]}const qbe={kernelName:F0,backendName:"cpu",kernelFunc:Hbe};const Kbe=U_;function Xbe(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;zt(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,f=o,m=a,g=l,y=u,{selectedIndices:v,selectedScores:b}=Kbe(c,d,f,m,g,y);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const Ybe={kernelName:L0,backendName:"cpu",kernelFunc:Xbe};function Qbe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r;zt(s,"oneHot");const u=Ue(s.shape),c=new Float32Array(u*o);c.fill(l);const d=n.data.get(s.dataId).values;for(let f=0;f<u;++f)d[f]>=0&&d[f]<o&&(c[f*o+d[f]]=a);return n.makeTensorInfo([...s.shape,o],i,c)}const Jbe={kernelName:jg,backendName:"cpu",kernelFunc:Qbe};function ex(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=uf({inputs:{input:r},backend:n}),i=ex({inputs:{x:s},backend:n}),o=Km({inputs:{input:r},backend:n}),a=ex({inputs:{x:o},backend:n}),l=ta({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return qA({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Zbe={kernelName:l1,backendName:"cpu",kernelFunc:ex};function Cj(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=uf({inputs:{input:r},backend:n}),i=Cj({inputs:{x:s},backend:n}),o=Km({inputs:{input:r},backend:n}),a=ex({inputs:{x:o},backend:n}),l=ta({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return qA({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const exe={kernelName:Wg,backendName:"cpu",kernelFunc:Cj};function Ej(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Zb({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{Ni(i,c.shape,"All tensors passed to stack must have matching shapes"),J(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const d=Zb({inputs:{input:c},backend:n,attrs:{dim:s}});return a.push(d),d}),u=Xm({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const txe={kernelName:Gg,backendName:"cpu",kernelFunc:Ej};function nxe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:i,constantValue:o}=r;zt(s,"pad");const a=i.map((x,$)=>x[0]+s.shape[$]+x[1]),l=i.map(x=>x[0]),u=n.data.get(s.dataId).values,c=Ue(s.shape),d=s.shape.length,f=Qt(s.shape),m=Ue(a),g=a.length,y=Qt(a),v=ii(s.dtype,m);o!==0&&v.fill(o);for(let x=0;x<c;x++){const S=Tf(x,d,f).map((L,R)=>L+l[R]),E=Al(S,g,y);v[E]=u[x]}return{dataId:n.write(v,a,s.dtype),shape:a,dtype:s.dtype}}const kj={kernelName:Hg,backendName:"cpu",kernelFunc:nxe};const rxe=vs((t,e)=>Math.pow(t,e)),sxe=Gs(tp,rxe),ixe={kernelName:tp,backendName:"cpu",kernelFunc:sxe};function oxe(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=r,l=s.map(b=>n.data.get(b.dataId).values),u=s.map(b=>b.shape),c=n.data.get(i.dataId).values,d=n.data.get(o.dataId).values,[f,m,g]=HW(l,u,c,i.shape,i.dtype,d,o.shape),y=f.map(b=>n.makeTensorInfo([b.length],"int32",b)),v=n.makeTensorInfo(g,i.dtype,m);return y.concat([v])}const axe={kernelName:M0,backendName:"cpu",kernelFunc:oxe};function lxe(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:i}=e,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,[u,c]=qW(o,r.shape,r.dtype,a,s.shape,l,i.shape),d=n.makeTensorInfo([u.length],"int32",u),f=n.makeTensorInfo([c.length],r.dtype,c);return[d,f]}const uxe={kernelName:z0,backendName:"cpu",kernelFunc:lxe};function cxe(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,d=n.data.get(o.dataId).values,f=a.map(v=>n.data.get(v.dataId).values),m=a.map(v=>v.shape),[g,y]=KW(u,s.shape,c,i.shape,i.dtype,d,o.shape,f,m,l);return n.makeTensorInfo(g,i.dtype,y)}const hxe={kernelName:V0,backendName:"cpu",kernelFunc:cxe};function dxe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,dtype:i,step:o}=n,a=XW(r,s,o,i);return e.makeTensorInfo([a.length],i,a)}const fxe={kernelName:B0,backendName:"cpu",kernelFunc:dxe};const pxe=br(np,t=>1/t),mxe={kernelName:np,backendName:"cpu",kernelFunc:pxe};function gxe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;zt(s,"resizeBilinear");const l=Qt(s.shape),[u,c]=a,[d,f,m,g]=s.shape,y=n.data.get(s.dataId).values,v=new Float32Array(Ue([d,u,c,g])),b=[i&&u>1?f-1:f,i&&c>1?m-1:m],x=[i&&u>1?u-1:u,i&&c>1?c-1:c];let $=0;const S=b[0]/x[0],E=b[1]/x[1];for(let L=0;L<d;L++)for(let R=0;R<u;R++){let D;o?D=S*(R+.5)-.5:D=S*R;const A=Math.max(0,Math.floor(D)),F=D-A,P=Math.min(f-1,Math.ceil(D)),K=L*l[0]+A*l[1],j=L*l[0]+P*l[1];for(let se=0;se<c;se++){let fe;o?fe=E*(se+.5)-.5:fe=E*se;const me=Math.max(0,Math.floor(fe)),ye=fe-me,oe=Math.min(m-1,Math.ceil(fe)),ue=K+me*l[2],_e=j+me*l[2],Y=K+oe*l[2],re=j+oe*l[2];for(let Te=0;Te<g;Te++){const Pe=y[ue+Te],de=y[_e+Te],ge=y[Y+Te],Re=y[re+Te],Oe=Pe+(ge-Pe)*ye,Ve=de+(Re-de)*ye,We=Oe+(Ve-Oe)*F;v[$++]=We}}}return n.makeTensorInfo([d,u,c,g],"float32",v)}const yxe={kernelName:Qg,backendName:"cpu",kernelFunc:gxe};function wxe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:o}=r;zt([i,s],"resizeBilinearGrad");const a=Qt(s.shape),[l,u,c,d]=s.shape,[,f,m]=i.shape,g=new Float32Array(l*u*c*d),y=[o&&f>1?u-1:u,o&&m>1?c-1:c],v=[o&&f>1?f-1:f,o&&m>1?m-1:m],b=y[0]/v[0],x=y[1]/v[1],$=n.data.get(i.dataId).values;let S=0;for(let E=0;E<l;E++){const L=E*a[0];for(let R=0;R<f;R++){const D=R*b,A=Math.floor(D),F=Math.min(Math.ceil(D),u-1),P=L+A*a[1],K=L+F*a[1],j=D-A,se=1-j;for(let fe=0;fe<m;fe++){const me=fe*x,ye=Math.floor(me),oe=Math.min(Math.ceil(me),c-1),ue=me-ye,_e=1-ue,Y=P+ye*a[2],re=P+oe*a[2],Te=K+ye*a[2],Pe=K+oe*a[2],de=se*_e,ge=se*ue,Re=j*_e,Oe=j*ue;for(let Ve=0;Ve<d;Ve++){const We=$[S++];g[Y+Ve]+=We*de,g[re+Ve]+=We*ge,g[Te+Ve]+=We*Re,g[Pe+Ve]+=We*Oe}}}}return n.makeTensorInfo([l,c,u,d],"float32",g)}const vxe={kernelName:j0,backendName:"cpu",kernelFunc:wxe};function bxe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;zt(s,"resizeNearestNeighbor");const l=Qt(s.shape),[u,c]=a,[d,f,m,g]=s.shape,y=n.data.get(s.dataId).values,v=new Float32Array(d*u*c*g),b=[i&&u>1?f-1:f,i&&c>1?m-1:m],x=[i&&u>1?u-1:u,i&&c>1?c-1:c],$=b[0]/x[0],S=b[1]/x[1];let E=0;for(let L=0;L<d;L++){const R=L*l[0];for(let D=0;D<u;D++){const A=o?$*(D+.5):$*D;let F=Math.min(f-1,i?Math.round(A):Math.floor(A));o&&(F=Math.max(0,F));const P=R+F*l[1];for(let K=0;K<c;K++){const j=o?S*(K+.5):S*K;let se=Math.min(m-1,i?Math.round(j):Math.floor(j));o&&(se=Math.max(0,se));const fe=P+se*l[2];for(let me=0;me<g;me++){const ye=y[fe+me];v[E++]=ye}}}}return n.makeTensorInfo([d,u,c,g],s.dtype,v)}const xxe={kernelName:Yg,backendName:"cpu",kernelFunc:bxe};function _xe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:o}=r;zt([i,s],"resizeNearestNeighborGrad");const a=Qt(s.shape),l=Qt(i.shape),[u,c,d,f]=s.shape,[,m,g]=i.shape,y=new Float32Array(u*c*d*f),v=n.data.get(i.dataId).values,b=[o&&m>1?c-1:c,o&&g>1?d-1:d],x=[o&&m>1?m-1:m,o&&g>1?g-1:g],$=b[0]/x[0],S=b[1]/x[1],E=1/$,L=1/S,R=Math.ceil(E)*2+2,D=Math.ceil(L)*2+2;for(let A=0;A<u;A++){const F=A*a[0];for(let P=0;P<c;P++){const K=F+P*a[1],j=Math.floor(P*E),se=Math.floor(j-R/2);for(let fe=0;fe<d;fe++){const me=K+fe*a[2],ye=Math.floor(fe*L),oe=Math.floor(ye-D/2);for(let ue=0;ue<f;ue++){let _e=0;for(let Y=0;Y<R;Y++){const re=Y+se;if(re<0||re>=m)continue;const Te=F+re*l[1],Pe=re*$,de=Math.min(c-1,o?Math.round(Pe):Math.floor(Pe));if(P===de)for(let ge=0;ge<D;ge++){const Re=ge+oe;if(Re<0||Re>=g)continue;const Oe=Te+Re*l[2],Ve=Re*S,We=Math.min(d-1,o?Math.round(Ve):Math.floor(Ve));fe===We&&(_e+=v[Oe+ue])}}y[me+ue]=_e}}}}return n.makeTensorInfo(s.shape,s.dtype,y)}const Ixe={kernelName:W0,backendName:"cpu",kernelFunc:_xe};function Txe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:i}=r;zt(s,"reverse");const o=s.shape.length,a=On(i,s.shape);if(o===0)return Su({inputs:{x:s},backend:n});const l=new ms(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),f=d.slice();a.forEach(m=>f[m]=s.shape[m]-1-f[m]),l.set(u.get(...f),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const Sxe={kernelName:Jg,backendName:"cpu",kernelFunc:Txe};const $xe={kernelName:aw,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:i,center:o}=e,a=n,l=ii(r.dtype,Ue(r.shape)),[u,c,d,f]=r.shape,[m,g]=Vk(o,c,d),y=255,v=Math.sin(s),b=Math.cos(s),x=a.data.get(r.dataId).values;for(let S=0;S<u;S++){const E=S*d*c*f;for(let L=0;L<c;L++){const R=L*(d*f);for(let D=0;D<d;D++){const A=D*f;for(let F=0;F<f;F++){const P=[u,L,D,F],K=P[2],j=P[1];let se=(K-m)*b-(j-g)*v,fe=(K-m)*v+(j-g)*b;se=Math.round(se+m),fe=Math.round(fe+g);let me=i;if(typeof i!="number"&&(F===3?me=y:me=i[F]),se>=0&&se<d&&fe>=0&&fe<c){const oe=fe*(d*f),ue=se*f,_e=E+oe+ue+F;me=x[_e]}const ye=E+R+A+F;l[ye]=me}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const Cxe=br(ip,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),Exe={kernelName:ip,backendName:"cpu",kernelFunc:Cxe};function kxe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Yh(i,s,o),f=!0,m=n.bufferSync(s),g=n.bufferSync(i),y=Ad(m,g,o,d,u,l,a,c,0,f);return n.makeTensorInfo(o,y.dtype,y.values)}const Nxe={kernelName:G0,backendName:"cpu",kernelFunc:kxe};function Axe(t,e){let n=0,r=t.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),t[s]<e?n=s+1:r=s;return r}function Rxe(t,e){let n=0,r=t.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),t[s]<=e?n=s+1:r=s;return r}function Dxe(t,e,n,r,s,i){const o=as("int32",n*s);for(let a=0;a<n;++a){const l=t.slice(a*r,(a+1)*r),u=a*s;for(let c=0;c<s;++c)o[u+c]=i==="left"?Axe(l,e[c+u]):Rxe(l,e[c+u])}return o}function Oxe(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:i}=e,{side:o}=r,a=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,u=Dxe(a,l,s.shape[0],s.shape[1],i.shape[1],o);return n.makeTensorInfo(i.shape,"int32",u)}const Pxe={kernelName:q0,backendName:"cpu",kernelFunc:Oxe};function Fxe(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:i}=e;zt([r,s,i],"select");const o=r.shape.length,a=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,c=go(s.dtype,i.dtype),d=Ei(Ue(s.shape),c);let f=0;const m=o===0||o>1||s.shape.length===1?1:Ue(s.shape.slice(1));for(let g=0;g<a.length;g++)for(let y=0;y<m;y++)a[g]===1?d[f++]=l[g]:d[f++]=u[g];return n.makeTensorInfo(s.shape,c,d)}const Lxe={kernelName:Zg,backendName:"cpu",kernelFunc:Fxe};const Mxe=n4,zxe=r4,Vxe=br(ap,t=>t>=0?zxe*t:Mxe*(Math.exp(t)-1)),Bxe={kernelName:ap,backendName:"cpu",kernelFunc:Vxe};const Uxe=br(cp,t=>t<0?-1:t>0?1:0),Wxe={kernelName:cp,backendName:"cpu",kernelFunc:Uxe};const jxe=br(lp,t=>Math.sin(t)),Gxe={kernelName:lp,backendName:"cpu",kernelFunc:jxe};const Hxe=br(up,t=>Math.sinh(t)),qxe={kernelName:up,backendName:"cpu",kernelFunc:Hxe};const Kxe=11920928955078125e-23,IP=Math.log(Kxe)+2,Xxe=br(dp,t=>{const e=t>-IP,n=t<IP,r=Math.exp(t);let s;return n?s=r:e?s=t:s=Math.log(1+r),s}),Yxe={kernelName:dp,backendName:"cpu",kernelFunc:Xxe};function Qxe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,paddings:o}=r;zt([s],"spaceToBatchND");const a=Ue(i),l=[[0,0]];l.push(...o);for(let L=1+i.length;L<s.shape.length;++L)l.push([0,0]);const u=kj.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=zw(u.shape,i,a,!1),d=Vw(c.length,i.length,!1),f=Bw(u.shape,i,a,!1),y=Nr({inputs:{x:u},backend:n,attrs:{shape:c}}),x=Oo({inputs:{x:y},backend:n,attrs:{perm:d}}),E=Nr({inputs:{x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),E}const Jxe={kernelName:n1,backendName:"cpu",kernelFunc:Qxe};function Zxe(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(o.dataId).values[0],[d,f,m,g,y]=ZW(a,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([f[0]],s.dtype,m),n.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(v=>Number(v)))),n.makeTensorInfo([y.length],r.dtype,new Int32Array(y))]}const e_e={kernelName:K0,backendName:"cpu",kernelFunc:Zxe};function t_e(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.data.get(s.dataId).values),a=n.data.get(r.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,c,d]=ej(a,r.shape,r.dtype,o,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}const n_e={kernelName:X0,backendName:"cpu",kernelFunc:t_e};function r_e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,[u,c]=WA(o,r.shape,r.dtype,a,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const s_e={kernelName:Y0,backendName:"cpu",kernelFunc:r_e};function i_e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,[u,c]=WA(o,r.shape,r.dtype,a,l);return n.makeTensorInfo(c,r.dtype,u)}const o_e={kernelName:Q0,backendName:"cpu",kernelFunc:i_e};function a_e(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:f}=Yh(i,s,a),m=!1,g=n.bufferSync(s);let y;switch(i.dtype){case"bool":{const v=n.bufferSync(i),b=!!n.data.get(o.dataId).values[0];y=Ad(g,v,a,f,c,u,l,d,b,m);break}case"float32":{const v=n.bufferSync(i),b=n.data.get(o.dataId).values[0];y=Ad(g,v,a,f,c,u,l,d,b,m);break}case"int32":{const v=n.bufferSync(i),b=n.data.get(o.dataId).values[0];y=Ad(g,v,a,f,c,u,l,d,b,m);break}case"string":{const v=n.bufferSync(i),b=oc(n.data.get(o.dataId).values[0]);y=Ad(g,v,a,f,c,u,l,d,b,m);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(a,y.dtype,y.values)}const l_e={kernelName:J0,backendName:"cpu",kernelFunc:a_e};function u_e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=On(o,s.shape)[0],l=tN(s,i,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const f=[...c];f[a]=d;const m=cf({inputs:{x:s},backend:n,attrs:{begin:u,size:f}});return u[a]+=d,m})}const c_e={kernelName:r1,backendName:"cpu",kernelFunc:u_e};const h_e={kernelName:Z0,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;zt(n,"square");const s=r.data.get(n.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};const d_e=br(vp,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),f_e={kernelName:vp,backendName:"cpu",kernelFunc:d_e};function p_e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:f}=r;zt(s,"stridedSlice");const{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:v,isSimpleSlice:b,begin:x,end:$,strides:S}=Ok(s.shape,i,o,a,l,u,c,d,f);let E;if(y)E=Nr({inputs:{x:s},backend:n,attrs:{shape:g}});else if(v||b){J(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const L=Ak(x,$,S),R=cf({inputs:{x:s},backend:n,attrs:{begin:x,size:L}});E=Nr({inputs:{x:R},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(R)}else{const L=n.bufferSync(s),R=rj(m,L,S,x);E=n.makeTensorInfo(g,R.dtype,R.values)}return E}const m_e={kernelName:ew,backendName:"cpu",kernelFunc:p_e};function g_e(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=e,f=n.data.get(c.dataId).values,m=n.data.get(d.dataId).values,[g,y]=sj(f,m,s,i,o,a,l,u);return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(d.shape,"int32",y)]}const y_e={kernelName:tw,backendName:"cpu",kernelFunc:g_e};function w_e(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values[0],[u,c,d]=ij(a,l,s),f=c.length;return[n.makeTensorInfo([f,2],"int32",u),n.makeTensorInfo([f],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const v_e={kernelName:nw,backendName:"cpu",kernelFunc:w_e};function b_e(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=n.data.get(i.dataId).values,a=oj(o,s);return n.makeTensorInfo(i.shape,"int32",a)}const x_e={kernelName:rw,backendName:"cpu",kernelFunc:b_e};const __e=br(gp,t=>Math.tan(t)),I_e={kernelName:gp,backendName:"cpu",kernelFunc:__e};const T_e=br(yp,t=>Math.tanh(t)),S_e={kernelName:yp,backendName:"cpu",kernelFunc:T_e};function $_e(t){const{inputs:e,backend:n}=t,{tensor:r,indices:s,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=Yh(i,s,r.shape),d=!1,f=n.bufferSync(s),m=n.bufferSync(i),g=n.bufferSync(r),y=Ad(f,m,r.shape,c,l,a,o,u,g,d);return n.makeTensorInfo(r.shape,y.dtype,y.values)}const C_e={kernelName:H0,backendName:"cpu",kernelFunc:$_e};function E_e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:i}=r;zt(s,"tile");const o=lj(n.bufferSync(s),i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const k_e={kernelName:wp,backendName:"cpu",kernelFunc:E_e};function N_e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:i,sorted:o}=r;zt(s,"topk");const a=n.data.get(s.dataId).values,[l,u]=cj(a,s.shape,s.dtype,i,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const A_e={kernelName:sw,backendName:"cpu",kernelFunc:N_e};function R_e(t){const{inputs:e,attrs:n,backend:r}=t,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=n,[c,d,f,m]=s.shape,[g,y]=u??[d,f],v=[c,g,y,m],b=Qt(s.shape),x=b[0],$=b[1],S=b[2],E=Qt(v),L=E[0],R=E[1],D=E[2],A=ii(s.dtype,Ue(v));A.fill(l);const F=r.data.get(s.dataId).values,P=r.data.get(i.dataId).values;for(let j=0;j<c;++j){const se=i.shape[0]===1?P:P.subarray(j*8,j*8+8);for(let fe=0;fe<g;++fe)for(let me=0;me<y;++me)for(let ye=0;ye<m;++ye){let oe;const ue=se[6]*me+se[7]*fe+1;if(ue===0)continue;const _e=(se[0]*me+se[1]*fe+se[2])/ue,Y=(se[3]*me+se[4]*fe+se[5])/ue,re=TP(_e,f,a),Te=TP(Y,d,a);switch(o){case"nearest":oe=M_e(F,d,f,x,$,S,j,Te,re,ye,l);break;case"bilinear":oe=z_e(F,d,f,x,$,S,j,Te,re,ye,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const Pe=j*L+fe*R+me*D+ye;A[Pe]=oe}return r.makeTensorInfo(v,s.dtype,A)}return{dataId:r.write(A,v,s.dtype),shape:s.shape,dtype:s.dtype}}const D_e={kernelName:iw,backendName:"cpu",kernelFunc:R_e};function TP(t,e,n){switch(n){case"reflect":return O_e(t,e);case"wrap":return P_e(t,e);case"nearest":return L_e(t,e);case"constant":default:return F_e(t)}}function O_e(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const r=2*e;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-e?n+r:-n-1}else if(n>e-1)if(e<=1)n=0;else{const r=2*e;n-=r*Math.trunc(n/r),n>=e&&(n=r-n-1)}return Ch(0,n,e-1)}function P_e(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const r=e-1;n+=e*(Math.trunc(-n/r)+1)}else if(n>e-1)if(e<=1)n=0;else{const r=e-1;n-=e*Math.trunc(n/r)}return Ch(0,n,e-1)}function F_e(t,e){return t}function L_e(t,e){return Ch(0,t,e-1)}function Y2(t,e,n,r,s,i,o,a,l,u,c){const d=o*r+a*s+l*i+u;return 0<=a&&a<e&&0<=l&&l<n?t[d]:c}function M_e(t,e,n,r,s,i,o,a,l,u,c){const d=Math.round(a),f=Math.round(l);return Y2(t,e,n,r,s,i,o,d,f,u,c)}function z_e(t,e,n,r,s,i,o,a,l,u,c){const d=Math.floor(a),f=Math.floor(l),m=d+1,g=f+1,y=(g-l)*Y2(t,e,n,r,s,i,o,d,f,u,c)+(l-f)*Y2(t,e,n,r,s,i,o,d,g,u,c),v=(g-l)*Y2(t,e,n,r,s,i,o,m,f,u,c)+(l-f)*Y2(t,e,n,r,s,i,o,m,g,u,c);return(m-a)*y+(a-d)*v}function V_e(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:i}=e;zt(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:u}=hj(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}const B_e={kernelName:ow,backendName:"cpu",kernelFunc:V_e};function U_e(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let u=0;for(let m=0;m<o;m++)m!==i&&(l[u++]=s.shape[m]);const c=new Array(o).fill(0),d=s.shape.slice();d[i]=1;const f=new Array(a);for(let m=0;m<f.length;m++){c[i]=m;const g=cf({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});f[m]=Nr({inputs:{x:g},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(g)}return f}const W_e={kernelName:o1,backendName:"cpu",kernelFunc:U_e};function j_e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:i}=e,{numSegments:o}=r;zt(s,"unsortedSegmentSum");const a=s.shape.length,l=i.shape.length,u=[],c=[],d=a-l;let f=i;for(let g=0;g<d;++g){const y=Zb({inputs:{input:f},backend:n,attrs:{dim:g+1}});f=y,c.push(y)}for(let g=0;g<o;++g){const y=yc(g,"int32"),v=n.makeTensorInfo([],"int32",y),b=$W({inputs:{a:v,b:f},backend:n}),x=Mh({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),$=C4({inputs:{a:x,b:s},backend:n}),S=Jw({inputs:{x:$},backend:n,attrs:{axis:0,keepDims:!1}});u.push(S),c.push(v),c.push(b),c.push(x),c.push($),c.push(S)}const m=Ej({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const G_e={kernelName:a1,backendName:"cpu",kernelFunc:j_e};const H_e=[Vwe,x0e,Uwe,jwe,C0e,Hwe,Kwe,Ywe,Jwe,e3e,n3e,s3e,o3e,u3e,h3e,p3e,g3e,w3e,b3e,Mwe,_3e,T3e,$3e,k0e,E3e,S0e,A0e,N3e,_0e,R3e,O3e,P3e,L3e,z3e,B3e,W3e,G3e,q3e,X3e,Q3e,Z3e,tve,rve,ive,ove,lve,cve,dve,fve,pve,mve,yve,bve,Awe,_ve,R0e,Nve,D0e,Ave,P0e,Lve,Mve,Vve,L0e,z0e,Uve,jve,Hve,Kve,B0e,W0e,I0e,Yve,D3e,Jve,ebe,nbe,Rwe,G0e,q0e,sbe,X0e,obe,ube,hbe,pbe,gbe,wbe,vbe,Q0e,xbe,Ibe,Sbe,Cbe,kbe,Abe,Dbe,Z0e,Pbe,Mbe,Bbe,twe,rwe,jbe,qbe,Ybe,iwe,Jbe,exe,txe,kj,ixe,Owe,lwe,axe,uxe,hxe,fxe,T0e,K$,mxe,Pwe,Fwe,Lwe,yxe,vxe,xxe,Ixe,Sxe,$xe,Exe,gwe,Nxe,Pxe,Lxe,Bxe,wwe,Wxe,Gxe,qxe,vwe,zbe,Yxe,Jxe,e_e,n_e,s_e,o_e,l_e,c_e,_we,h_e,Twe,$we,f_e,m_e,y_e,v_e,x_e,Nwe,wve,I_e,S_e,C_e,k_e,A_e,D_e,owe,B_e,W_e,G_e,Zbe];for(const t of H_e)lw(t);const Sd={},yv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Nj(t,e){Sd[t]=e}function Ul(t,e){if(!(t in Sd)||e!=null){const r=K_e(t,e);if(r!==null)Sd[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=Sd[t];return n==null||n.isContextLost()?(delete Sd[t],Ul(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Sd[t])}function q_e(t){if(!De().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function K_e(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??q_e(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Sd[t]},!1),De().getBool("SOFTWARE_WEBGL_ENABLED")&&(yv.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",yv)||n.getContext("experimental-webgl",yv):n.getContext("webgl2",yv)}var Ly;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(Ly||(Ly={}));var Ta;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(Ta||(Ta={}));var $i;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})($i||($i={}));function Zw(t,e){return[e,t]}function X_e(t,e){return t*e}function wv(t){const e=Ue(t),n=Math.ceil(e/4);return Nb(n)}function O1(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Y_e(t,e){const[n,r]=O1(t,e);return n*r*4}function KA(t,e){const n=t;let r,s,i,o,a,l,u,c,d,f;return De().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,i=n.RGBA16F,o=n.RGBA32F,a=n.RED,u=4,c=1,d=n.HALF_FLOAT,f=n.FLOAT,l=n.RGBA8):(r=t.RGBA,s=t.RGBA,i=t.RGBA,o=n.RGBA,a=t.RGBA,u=4,c=4,d=e!=null?e.HALF_FLOAT_OES:null,f=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:f}}function It(t,e){const n=e();return De().getBool("DEBUG")&&Q_e(t),n}function Q_e(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+Rj(t,e))}const J_e=596e-10,Z_e=65504;function Aj(t){return!!(De().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||J_e<Math.abs(t)&&Math.abs(t)<Z_e)}function Rj(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Q2(t,e){return Ic(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Dj(t,e){const n=Ic(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(It(t,()=>t.shaderSource(n,e)),It(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function Oj(t,e){const n=Ic(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(It(t,()=>t.shaderSource(n,e)),It(t,()=>t.compileShader(n)),De().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw XA(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const e4e=/ERROR: [0-9]+:([0-9]+):/g;function XA(t,e){const n=e4e.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],s=t.split(`
`),i=s.length.toString().length+2,o=s.map((d,f)=>Fd((f+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,r-1),u=o.slice(r-1,r),c=o.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Fd(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function Pj(t){return Ic(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function Fj(t,e){if(It(t,()=>t.linkProgram(e)),!De().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function nb(t,e){if(It(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Lj(t,e){const n=Ic(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return It(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),It(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Mj(t,e){const n=Ic(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return It(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),It(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function t4e(){return De().getNumber("WEBGL_VERSION")===2?1:4}function zj(t){return Ic(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function Vj(t,e){const n=De().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function Bj(t){return Ic(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Y$(t,e,n,r,s,i,o){const a=t.getAttribLocation(e,n);return a===-1?!1:(It(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),It(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,i,o)),It(t,()=>t.enableVertexAttribArray(a)),!0)}function Uj(t,e,n){qj(t,n),It(t,()=>t.activeTexture(t.TEXTURE0+n)),It(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function n4e(t,e){qj(t,e),It(t,()=>t.activeTexture(t.TEXTURE0+e)),It(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function Wj(t,e,n){return Ic(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function jj(t,e,n){return t.getUniformLocation(e,n)}function Gj(t,e,n,r){It(t,()=>Uj(t,e,r)),It(t,()=>t.uniform1i(n,r))}function r4e(t){It(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),It(t,()=>t.viewport(0,0,t.canvas.width,t.canvas.height)),It(t,()=>t.scissor(0,0,t.canvas.width,t.canvas.height))}function rb(t,e,n){It(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),It(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function Q$(t,e){It(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),It(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function J2(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Hj(t,e))}function Hj(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Ic(t,e,n){const r=It(t,()=>e());if(r==null)throw new Error(n);return r}function qj(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function hf(t,e=2){return Ue(t.slice(0,t.length-e))}function df(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Z2(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[hf(t),...df(t)]),e}function Kj(t,e=!1){let n=De().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=De().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&De().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((a,l)=>l>=t.length-2?Ax(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=gc(t).newShape);let s=Ue(t),i=null;t.length<=1&&s<=n?i=[1,s]:t.length===2&&t[0]<=n&&t[1]<=n?i=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?i=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?i=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?i=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(i=[t[0],t[1]*t[2]*t[3]]);const o=i!=null&&Math.max(...i)>r&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=hf(t);let l=2,u=2;t.length&&([l,u]=df(t)),s=a*(l/2)*(u/2),i=Nb(s).map(c=>c*2)}else i=Nb(s);return i}function vv(t){return t%2===0}function My(t,e){if(t=t.slice(-2),e=e.slice(-2),zn(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r||vv(n)&&vv(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&vv(t[0])&&vv(e[0])}let sb,ib;function Xj(t){if(sb==null){const e=Ul(t);sb=e.getParameter(e.MAX_TEXTURE_SIZE)}return sb}function s4e(){sb=null}function i4e(){ib=null}function Yj(t){if(ib==null){const e=Ul(t);ib=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ib)}function Qj(t){if(t===0)return 0;let e;const n=Ul(t);return Sa(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:Sa(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function Sa(t,e){return t.getExtension(e)!=null}function J$(t){try{if(Ul(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Jj(t){if(t===0)return!1;const e=Ul(t);if(t===1){if(!Sa(e,"OES_texture_float"))return!1}else if(!Sa(e,"EXT_color_buffer_float"))return!1;return Z$(e)}function Zj(t){if(t===0)return!1;const e=Ul(t);if(t===1){if(!Sa(e,"OES_texture_float")||!Sa(e,"WEBGL_color_buffer_float"))return!1}else{if(Sa(e,"EXT_color_buffer_float"))return Z$(e);const r="EXT_color_buffer_half_float";if(Sa(e,r)){const s=e.getExtension(r);return o4e(e,s)}return!1}return Z$(e)}function Z$(t){const e=KA(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(i),o}function o4e(t,e){const n=KA(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),a}function eG(t){return t!==2?!1:Ul(t).fenceSync!=null}function P1(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&J(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const a4e=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:P1,bindCanvasToFramebuffer:r4e,bindColorTextureToFramebuffer:rb,bindTextureToProgramUniformSampler:Gj,bindTextureUnit:Uj,bindVertexBufferToProgramAttribute:Y$,callAndCheck:It,canBeRepresented:Aj,createFragmentShader:Oj,createFramebuffer:Bj,createProgram:Pj,createStaticIndexBuffer:Mj,createStaticVertexBuffer:Lj,createTexture:zj,createVertexShader:Dj,getBatchDim:hf,getExtensionOrThrow:Q2,getFramebufferErrorMessage:Hj,getMaxTexturesInShader:Yj,getNumChannels:t4e,getProgramUniformLocation:jj,getProgramUniformLocationOrThrow:Wj,getRowsCols:df,getShapeAs3D:Z2,getTextureShapeFromLogicalShape:Kj,getWebGLDisjointQueryTimerVersion:Qj,getWebGLErrorMessage:Rj,getWebGLMaxTextureSize:Xj,hasExtension:Sa,isCapableOfRenderingToFloatTexture:Jj,isDownloadFloatTextureEnabled:Zj,isReshapeFree:My,isWebGLFenceEnabled:eG,isWebGLVersionEnabled:J$,linkProgram:Fj,logShaderSourceAndInfoLog:XA,resetMaxTextureSize:s4e,resetMaxTexturesInShader:i4e,unbindColorTextureFromFramebuffer:Q$,unbindTextureUnit:n4e,validateFramebuffer:J2,validateProgram:nb,validateTextureSize:Vj},Symbol.toStringTag,{value:"Module"}));const Bt=De();Bt.registerFlag("HAS_WEBGL",()=>Bt.getNumber("WEBGL_VERSION")>0);Bt.registerFlag("WEBGL_VERSION",()=>J$(2)?2:J$(1)?1:0);Bt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Bt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Bt.get("WEBGL_VERSION")===2);Bt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Bt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Bt.registerFlag("WEBGL_PACK",()=>Bt.getBool("HAS_WEBGL"));Bt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_CLIP",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_REDUCE",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_CONV_IM2COL",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Bt.getBool("WEBGL_PACK"));Bt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Xj(Bt.getNumber("WEBGL_VERSION")));Bt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Yj(Bt.getNumber("WEBGL_VERSION")));Bt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Bt.getNumber("WEBGL_VERSION");return t===0?0:Qj(t)});Bt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Bt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!wE());Bt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Jj(Bt.getNumber("WEBGL_VERSION")));Bt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Bt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Bt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Bt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Zj(Bt.getNumber("WEBGL_VERSION")));Bt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>eG(Bt.getNumber("WEBGL_VERSION")));Bt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Bt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Bt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Bt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>wE()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Bt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Bt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Bt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Bt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Bt.registerFlag("WEBGL_EXP_CONV",()=>!1);Bt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Bt.getBool("IS_TEST"));Bt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Bt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Bt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Bt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function vo(){let t,e,n,r,s,i,o,a,l,u;return De().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=De().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function Np(t,e,n="index"){const r=Qt(e);return r.map((s,i)=>{const o=`int ${t[i]} = ${n} / ${s}`,a=i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${s}`:`index -= ${t[i]} * ${s}`;return`${o}; ${a};`}).join("")}function E4(t,e,n="index"){const r=Qt(e);return r.map((s,i)=>{const o=`int ${t[i]} = ${n} / outShapeStrides[${i}]`,a=i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * outShapeStrides[${i}]`:`index -= ${t[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function l4e(t,e){const n=t.length,r=t.map(i=>`${e}[${i}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let i=n-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}function u4e(t,e,n="index"){const r=t.map((i,o)=>o),s=l4e(r,e);return s.map((i,o)=>{const a=`int ${t[o]} = ${n} / ${s[o]}`,l=o===s.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${s[o]}`:`index -= ${t[o]} * ${s[o]}`;return`${a}; ${l};`}).join("")}function YA(t){const e=Qt(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function QA(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const tG=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:nG}=rN;function c4e(t,e,n){const r=[];if(t.forEach(m=>{const g=Ue(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?r.push(`uniform float ${m.name}${g>1?`[${g}]`:""};`):(r.push(`uniform sampler2D ${m.name};`),r.push(`uniform int offset${m.name};`)),n.enableShapeUniforms){const{uniformShape:y}=JA(n.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(y.length){case 1:r.push(`uniform int ${m.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${m.name}Shape;`);break}r.push(`uniform ivec2 ${m.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(m=>{r.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});const s=r.join(`
`),i=t.map(m=>h4e(m,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=e.texShape,a=vo(),l=p4e(a);let u,c,d=y4e(a);return e.isPacked?(u=d4e(e.logicalShape,o,n.enableShapeUniforms),c=g4e(a)):(u=f4e(e.logicalShape,o,n.enableShapeUniforms),c=m4e(a)),n.packedInputs&&(d+=x4e),[d,l,c,s,u,i,n.userCode].join(`
`)}function F1(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return D4e(t,e);case 1:return P4e(t,e);case 2:return L4e(t,e);case 3:return z4e(t,e);case 4:return B4e(t,e);case 5:return U4e(t);case 6:return W4e(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function rG(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return R4e(t);case 1:return O4e(t,e);case 2:return F4e(t,e);case 3:return M4e(t,e);default:return V4e(t,e)}}function h4e(t,e,n=!1,r){let s="";n?s+=rG(t,r):s+=F1(t,r);const i=t.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(n?s+=j4e(t,e):s+=G4e(t,e)),s}function d4e(t,e,n){switch(t.length){case 0:return sG();case 1:return _4e(t,e,n);case 2:return N4e(t,e,n);case 3:return T4e(t,e,n);default:return $4e(t,e,n)}}function f4e(t,e,n){switch(t.length){case 0:return sG();case 1:return I4e(t,e,n);case 2:return A4e(t,e,n);case 3:return S4e(t,e,n);case 4:return C4e(t,e,n);case 5:return E4e(t,e);case 6:return k4e(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function p4e(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function m4e(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function g4e(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function y4e(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${w4e}
    ${v4e}
    ${b4e}
  `}const w4e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,v4e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,b4e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,x4e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function sG(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function _4e(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function I4e(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function T4e(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),i=s*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function S4e(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${E4(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Np(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function $4e(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),i=s*Math.ceil(t[t.length-2]/2);let o=i,a="",l="b, r, c";for(let u=2;u<t.length-1;u++)o*=t[t.length-u-1],a=`
      int b${u} = index / ${o};
      index -= b${u} * ${o};
    `+a,l=`b${u}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${t.length}(${l});
    }
  `}function C4e(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${E4(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Np(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function E4e(t,e){const n=Np(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function k4e(t,e){const n=Np(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function N4e(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(zn(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function A4e(t,e,n){return zn(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Ap(t){return`offset${t}`}function R4e(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=vo();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function D4e(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,i]=t.shapeInfo.texShape;if(s===1&&i===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Ap(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;const[a,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function O4e(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,i=vo();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${n}, uv);
    }
  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }
  `}function P4e(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${L1(t)}
      }
    `;const s=t.shapeInfo.texShape,i=s[0],o=s[1];if(o===1&&i===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=Ap(n);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${n}, uv);
      }
    `:i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function F4e(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,o=i[0],a=i[1],l=vo();if(i!=null&&zn(n,i))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function L4e(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape;if(i!=null&&zn(n,i)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=i[0],m=i[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:a}=gc(n),l=o;if(l.length<n.length){const f=M1(t,l),m=["row","col"];return`
      ${F1(f,e)}
      float ${s}(int row, int col) {
        return ${s}(${z1(m,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${L1(t)}
      }
    `;const u=i[0],c=i[1],d=Ap(r);return c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function M4e(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(n[0]===1){const f=n.slice(1),m=[1,2],g=M1(t,f),y=["b","row","col"];return`
        ${rG(g,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${z1(y,m)});
        }
      `}const a=vo();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=o[0],u=o[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function z4e(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],o=n[2],{newShape:a,keptDims:l}=gc(n),u=a;if(u.length<n.length){const y=M1(t,u),v=["row","col","depth"];return`
        ${F1(y,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${z1(v,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${L1(t)}
      }
    `;const c=t.shapeInfo.texShape,d=c[0],f=c[1],m=t.shapeInfo.flatOffset;if(f===i&&m==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&m==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const g=Ap(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${g};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${g};
        vec2 uv = uvFromFlat(${d}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function V4e(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=vo();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const i=t.shapeInfo.logicalShape,o=i.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],d=Math.ceil(i[o-1]/2);let f=d*Math.ceil(i[o-2]/2),m="int b, int row, int col",g=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let y=2;y<o-1;y++)m=`int b${y}, `+m,f*=i[o-y-1],g=`b${y} * ${f} + `+g;return`
    vec4 ${r}(${m}) {
      int index = ${g};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function B4e(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],o=n[2]*i,a=n[1]*o,{newShape:l,keptDims:u}=gc(n);if(l.length<n.length){const x=M1(t,l),$=["row","col","depth","depth2"];return`
      ${F1(x,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${z1($,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${L1(t)}
      }
    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],m=d[1],g=`int stride2 = ${r}Shape[3];`,y=`int stride1 = ${r}Shape[2] * stride2;`,v=`int stride0 = ${r}Shape[1] * stride1;`;if(m===a&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${g}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(m===i&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const b=Ap(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${g}
      ${y}
      ${v}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${f}, ${m}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `}function U4e(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],i=e[3]*s,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:u}=gc(e);if(l.length<e.length){const y=M1(t,l),v=["row","col","depth","depth2","depth3"];return`
      ${F1(y)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${z1(v,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${s})) +
          depth3;
        ${L1(t)}
      }
    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],m=d[1];if(m===a&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const g=Ap(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${s} + depth3 + ${g};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function W4e(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:i}=gc(e);if(s.length<e.length){const v=M1(t,s),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${F1(v)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${z1(b,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${L1(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,m=f[0],g=f[1];if(g===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===o&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=Ap(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${y};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function L1(t){const e=t.name,n=Ue(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function j4e(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=nG(t.shapeInfo.logicalShape,e.logicalShape),l=_r(o),u=o-i;let c;const d=["x","y","z","w","u","v"];i===0?c="":o<2&&a.length>=1?c="coords = 0;":c=a.map(x=>`coords.${d[x+u]} = 0;`).join(`
`);let f="";o<2&&i>0?f="coords":f=t.shapeInfo.logicalShape.map((x,$)=>`coords.${d[$+u]}`).join(", ");let m="return outputValue;";const y=Ue(t.shapeInfo.logicalShape)===1,b=Ue(e.logicalShape)===1;if(i===1&&!y&&!b)m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(y&&!b)o===1?m=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:m=`
        return vec4(outputValue.x);
      `;else if(a.length){const x=i-2,$=i-1;a.indexOf(x)>-1&&a.indexOf($)>-1?m="return vec4(outputValue.x);":a.indexOf(x)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf($)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${f});
      ${m}
    }
  `}function G4e(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=e.texShape,o=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&zn(o,i))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=_r(l),c=nG(t.shapeInfo.logicalShape,e.logicalShape),d=l-a;let f;const m=["x","y","z","w","u","v"];a===0?f="":l<2&&c.length>=1?f="coords = 0;":f=c.map(y=>`coords.${m[y+d]} = 0;`).join(`
`);let g="";return l<2&&a>0?g="coords":g=t.shapeInfo.logicalShape.map((y,v)=>`coords.${m[v+d]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${f}
      return get${r}(${g});
    }
  `}function _r(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function JA(t,e,n){const{newShape:r,keptDims:s}=gc(e),i=e.length,o=t&&i===3&&e[0]===1,a=o?e.slice(1):r,l=!t&&i>1&&!zn(e,n)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function M1(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function z1(t,e){return e.map(n=>t[n]).join(", ")}function H4e(t,e,n,r){const s=n.map((c,d)=>{const f={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(f.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:f}}),i=s.map(c=>c.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=c4e(s,o,e),l=Oj(t.gl,a),u=t.createProgram(l);return De().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(u),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o},iG(t,e,u)))}function iG(t,e,n){const r=[],s=[];let i,o,a,l=null,u=null;u=t.getUniformLocation(n,"NAN",!1),De().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of e.variableNames){const f={name:d,uniform:t.getUniformLocation(n,d,c),offset:t.getUniformLocation(n,`offset${d}`,c)};e.enableShapeUniforms&&(f.shape=t.getUniformLocation(n,`${d}Shape`,c),f.texShape=t.getUniformLocation(n,`${d}TexShape`,c)),r.push(f)}if(e.enableShapeUniforms&&(i=t.getUniformLocation(n,"outShape",c),a=t.getUniformLocation(n,"outShapeStrides",c),o=t.getUniformLocation(n,"outTexShape",c)),e.customUniforms)for(const d of e.customUniforms)s.push(t.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function SP(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const s=n.logicalShape,i=e[r],o=i.shape;if(!zn(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(n.isUniform&&i.isUniform)return;const a=n.texShape,l=i.isUniform?null:i.texData.texShape;if(!zn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function q4e(t,e,n,r,s){e.program.enableShapeUniforms||(SP(e.inShapeInfos,n),SP([e.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):t.setOutputMatrixTexture(i.texture,o[0],o[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),De().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const u=n[l],{uniform:c,offset:d,shape:f,texShape:m}=e.variablesLocations[l];if(f){const{uniformShape:g}=JA(e.program.packedInputs,u.shape,u.texData.texShape);switch(g.length){case 1:t.gl.uniform1iv(f,new Int32Array(g));break;case 2:t.gl.uniform2iv(f,new Int32Array(g));break;case 3:t.gl.uniform3iv(f,new Int32Array(g));break;case 4:t.gl.uniform4iv(f,new Int32Array(g));break}}if(m&&t.gl.uniform2i(m,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(Ue(u.shape)<2)t.gl.uniform1f(c,u.uniformValues[0]);else{let g=u.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),t.gl.uniform1fv(c,g)}continue}u.texData.slice!=null&&d!=null&&t.gl.uniform1i(d,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Qt(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],d=s[l];if(u.type==="float")t.gl.uniform1fv(c,d);else if(u.type==="vec2")t.gl.uniform2fv(c,d);else if(u.type==="vec3")t.gl.uniform3fv(c,d);else if(u.type==="vec4")t.gl.uniform4fv(c,d);else if(u.type==="int")t.gl.uniform1iv(c,d);else if(u.type==="ivec2")t.gl.uniform2iv(c,d);else if(u.type==="ivec3")t.gl.uniform3iv(c,d);else if(u.type==="ivec4")t.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}t.executeProgram()}function K4e(t,e,n){let r="";e.concat(n).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=JA(t.packedInputs,o.shape,l);let f="",m="",g="";if(c.length===1&&t.packedInputs){const E=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${E[0]>1}_${E[1]>1}`}else if(c.length===2&&!t.packedInputs)m=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){const E=Qt(c);g=`${E[0]===l[1]}_${E[E.length-1]===l[1]}`}const y=o.shape.length,v=c.length===2&&zn(o.shape,l),b=Ue(o.shape)===1,x=Qd(o.shape,n.shape),$=!t.packedInputs&&y===n.shape.length&&zn(l,n.texData.texShape),S=t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${y}_${$}_${u?d:""}_${c.length}_${b}_${x}_${v}_${f}_${m}_${g}_${S}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${l}_${a}`}});const s=t.userCode;let i=t.constructor.name;return i+="_"+r+"_"+s+`${De().getNumber("WEBGL_VERSION")}`,i}function Yi(t){return De().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class X4e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ly.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=vo();this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?E4(["r","c","d"],e):Np(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}class Y4e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ly.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=vo();this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?E4(["r","c","d"],e):Np(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}class Q4e{constructor(e){this.variableNames=["A"],this.outTexUsage=Ta.DOWNLOAD;const n=vo();this.outputShape=e,this.userCode=`
      ${tG}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}class J4e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Ta.DOWNLOAD;const n=vo();this.outputShape=e,this.userCode=`
      ${tG}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}const Z4e={R:0,G:1,B:2,A:3};class $P{constructor(e,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=vo();this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length);let i="result";n&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++){const l=r[a];o+=`
          if(offset == ${a}) {
            result = values[${Z4e[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?QA():YA(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${o}
        }
        ${s.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class eIe{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=vo();this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length);let s="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?QA():YA(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${i};
        }
    `}}function oG(t){const e=vo(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Dj(t,n)}function aG(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Lj(t,e)}function lG(t){const e=new Uint16Array([0,1,2,2,1,3]);return Mj(t,e)}function e3(t,e,n,r,s,i){Vj(e,n);const o=zj(t),a=t.TEXTURE_2D;return It(t,()=>t.bindTexture(a,o)),It(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),It(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),It(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),It(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),De().getNumber("WEBGL_VERSION")===1?It(t,()=>t.texImage2D(a,0,r,e,n,0,s,i,null)):It(t,()=>t.texStorage2D(a,1,r,e,n)),It(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:o,texShape:[n,e]}}function ZA(t){return t.internalFormatFloat}function uG(t,e,n,r){const[s,i]=Zw(e,n);return e3(t,s,i,ZA(r),r.textureFormatFloat,t.FLOAT)}function eR(t){return t.internalFormatHalfFloat}function cG(t,e,n,r){const[s,i]=Zw(e,n);return e3(t,s,i,eR(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function tR(t){return t.downloadTextureFormat}function hG(t,e,n,r){const[s,i]=Zw(e,n);return e3(t,s,i,tR(r),t.RGBA,t.UNSIGNED_BYTE)}function nR(t){return t.internalFormatPackedFloat}function dG(t,e,n,r){const[s,i]=O1(e,n);return e3(t,s,i,nR(r),t.RGBA,t.FLOAT)}function rR(t){return t.internalFormatPackedHalfFloat}function fG(t,e,n,r){const[s,i]=O1(e,n);return e3(t,s,i,rR(r),t.RGBA,r.textureTypeHalfFloat)}function pG(t,e,n){return It(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Y$(t,e,"clipSpacePos",n,3,20,0)&&Y$(t,e,"uv",n,2,20,12)}function mG(t,e,n,r,s,i){It(t,()=>t.bindTexture(t.TEXTURE_2D,e));let o,a,l;s instanceof Uint8Array?(o=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),a=t.FLOAT,l=i.internalFormatPackedFloat),o.set(s),De().getNumber("WEBGL_VERSION")===2?It(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,a,o)):It(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,a,o)),It(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function gG(t,e,n){It(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?De().getNumber("WEBGL_VERSION")===2?It(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):It(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):De().getNumber("WEBGL_VERSION")===2?It(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):It(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),It(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function yG(t,e,n,r){const s=t.createBuffer();It(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=4*4*e*n;return It(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),It(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),It(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}function wG(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function vG(t,e,n,r){const[s,i]=Zw(e,n),o=4,a=new Uint8Array(X_e(e*n,o));return It(t,()=>t.readPixels(0,0,s,i,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function bG(t,e,n,r,s,i,o,a){const l=t,u=new Float32Array(Y_e(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function xG(t,e,n){const r=new Float32Array(e*n*4);return It(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}const tIe=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:pG,createBufferFromOutputTexture:yG,createFloat16MatrixTexture:cG,createFloat16PackedMatrixTexture:fG,createFloat32MatrixTexture:uG,createIndexBuffer:lG,createPackedMatrixTexture:dG,createUnsignedBytesMatrixTexture:hG,createVertexBuffer:aG,createVertexShader:oG,downloadByteEncodedFloatMatrixFromOutputTexture:vG,downloadFloat32MatrixFromBuffer:wG,downloadMatrixFromPackedOutputTexture:xG,downloadPackedMatrixFromBuffer:bG,getInternalFormatForFloat16MatrixTexture:eR,getInternalFormatForFloat16PackedMatrixTexture:rR,getInternalFormatForFloat32MatrixTexture:ZA,getInternalFormatForPackedMatrixTexture:nR,getInternalFormatForUnsignedBytesMatrixTexture:tR,uploadDenseMatrixToTexture:mG,uploadPixelDataToTexture:gG},Symbol.toStringTag,{value:"Module"}));class ob{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=De().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Nj(n,e)):this.gl=Ul(n),e=this.gl,De().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>It(i,()=>i.createVertexArray()),this.bindVertexArray=o=>It(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>It(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>It(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>It(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>It(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>It(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>It(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),De().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Q2(this.gl,i),Sa(this.gl,o))this.textureHalfFloatExtension=Q2(this.gl,o);else if(De().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Sa(this.gl,s))this.colorBufferHalfFloatExtension=Q2(this.gl,s);else if(De().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Sa(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Sa(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=aG(this.gl),this.indexBuffer=lG(this.gl),this.framebuffer=Bj(this.gl),this.textureConfig=KA(this.gl,this.textureHalfFloatExtension)}get debug(){return De().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;It(e,()=>e.finish()),It(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),It(e,()=>e.deleteFramebuffer(this.framebuffer)),It(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),It(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),It(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),uG(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),cG(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),hG(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),gG(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,s){this.throwIfDisposed(),mG(this.gl,e,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),fG(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),dG(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Q$(this.gl,this.framebuffer),this.outputTexture=null),It(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>vG(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,s,i,o){return bG(this.gl,e,n,r,s,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return wG(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const s=yG(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(De().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},n=i}else De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>xG(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=oG(n));const r=Pj(n);It(n,()=>n.attachShader(r,this.vertexShader)),It(n,()=>n.attachShader(r,e)),Fj(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&nb(n,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;It(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),pG(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(It(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&nb(this.gl,this.program),It(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?Wj(this.gl,e,n):jj(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),It(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),Gj(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[s,i]=O1(n,r);this.setOutputMatrixTextureDriver(e,s,i)}setOutputMatrixWriteRegion(e,n,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,n)}setOutputPackedMatrixWriteRegion(e,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&nb(this.gl,this.program),J2(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}It(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),It(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Q2(this.gl,De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await c$(()=>this.disposed||this.isQueryAvailable(e,De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=nIe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in De().platform&&(r=De().platform.setTimeoutCustom.bind(De().platform)),c$(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),rb(this.gl,e,this.framebuffer),this.debug&&J2(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(rb(this.gl,this.outputTexture,this.framebuffer),this.debug&&J2(this.gl)):Q$(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const s=this.gl;rb(s,e,this.framebuffer),this.debug&&J2(s),this.outputTexture=e,It(s,()=>s.viewport(0,0,n,r)),It(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,s){this.throwIfDisposed(),It(this.gl,()=>this.gl.scissor(e,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function nIe(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}const{addImpl:rIe,bincountImpl:_G,bincountReduceImpl:sIe,bitwiseAndImpl:iIe,castImpl:oIe,ceilImpl:aIe,concatImpl:lIe,equalImpl:uIe,expImpl:cIe,expm1Impl:hIe,floorImpl:dIe,gatherNdImpl:fIe,gatherV2Impl:pIe,greaterImpl:mIe,greaterEqualImpl:gIe,lessImpl:yIe,lessEqualImpl:wIe,linSpaceImpl:vIe,logImpl:bIe,maxImpl:xIe,maximumImpl:_Ie,minimumImpl:IIe,multiplyImpl:TIe,negImpl:SIe,notEqualImpl:$Ie,prodImpl:CIe,raggedGatherImpl:EIe,raggedRangeImpl:kIe,raggedTensorToTensorImpl:NIe,rangeImpl:AIe,rsqrtImpl:RIe,scatterImpl:DIe,sigmoidImpl:OIe,simpleAbsImpl:IG,sliceImpl:PIe,sparseFillEmptyRowsImpl:FIe,sparseReshapeImpl:LIe,sparseSegmentReductionImpl:TG,sqrtImpl:MIe,staticRegexReplaceImpl:zIe,stridedSliceImpl:VIe,stringNGramsImpl:BIe,stringSplitImpl:UIe,stringToHashBucketFastImpl:WIe,subImpl:jIe,tileImpl:GIe,topKImpl:HIe,transposeImpl:sR,uniqueImpl:qIe}=dj;function SG(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function ho(t,e){return e===1?[t]:SG(t,e)}function KIe(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}class XIe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Yi(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=ho("rc",this.rank),r=_r(this.rank),s=this.getOutOfBoundsCondition(n),i=this.getSetup(n),o=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;n.push(i)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}class $G{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2===1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`
        ${i}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${YIe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?QA():YA(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function YIe(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?u4e(["r","c","d"],"inputShape"):Np(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}class QIe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,r){const s=EP(n,r),i=kP(e,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=CP(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return s===$i.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===$i.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===$i.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===$i.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===$i.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,n,r,s){if(this.freeTextures==null)return;const i=EP(r,s),o=kP(n,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=CP(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=De().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[o],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function JIe(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function CP(t,e,n,r,s){const i=ZIe(e,r);let o;if(s){const[l,u]=O1(t[0],t[1]);o=l*u}else{const[l,u]=Zw(t[0],t[1]);o=l*u}const a=JIe(n,i);return o*a}function ZIe(t,e){switch(t){case $i.PACKED_2X2_FLOAT32:return nR(e);case $i.PACKED_2X2_FLOAT16:return rR(e);case $i.UNPACKED_FLOAT32:return ZA(e);case $i.UNPACKED_FLOAT16:return eR(e);case $i.PACKED_4X1_UNSIGNED_BYTE:return tR(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function eTe(t){return De().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?$i.PACKED_2X2_FLOAT32:$i.UNPACKED_FLOAT32:t?$i.PACKED_2X2_FLOAT16:$i.UNPACKED_FLOAT16}function EP(t,e){if(t===Ta.UPLOAD)return $i.PACKED_2X2_FLOAT32;if(t===Ta.RENDER||t==null)return eTe(e);if(t===Ta.DOWNLOAD||t===Ta.PIXELS)return $i.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function kP(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class au{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const ll="if (isnan(x)) return x;",tTe="return x;",NP="return abs(x);",nTe="return (x >= 0.0) ? x : (exp(x) - 1.0);",rTe=ll+`
  return (x < 0.0) ? 0.0 : x;
`,sTe=ll+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Jc="return x;",iTe="return 1.0 / (1.0 + exp(-1.0 * x));";const oTe="return x;",aTe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,lTe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uTe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cTe="return 1.0 / (1.0 + exp(-1.0 * x));";class lh{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class hTe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length);const n=e.length,r=ho("rc",n),s=_r(n),i=KIe(n,r),o=r.slice(-2),a=n<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}const dTe=R_,fTe=1e-7,pTe=1e-4,bv={};function mTe(t){return t in bv||(bv[t]={}),bv[t]}const gTe=De().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),yTe=600;function wTe(){return De().global.screen==null?1024:De().global.screen.height*De().global.screen.width*window.devicePixelRatio*yTe/1024/1024}class t3 extends n0{nextDataId(){return t3.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!De().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof ob)n=e;else{const r=Ul(De().getNumber("WEBGL_VERSION"),e);n=new ob(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Ul(De().getNumber("WEBGL_VERSION"));n=new ob(r),this.binaryCache=mTe(De().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new QIe(this.gpgpu),this.numMBBeforeWarning=wTe(),this.texData=new Nx(this,Ya())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,s,i,o){const a=this.makeTensorInfo(n,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,i]},l.texShape=[s,i];const u=Z2(n),c=new $P(u,!1,o),d=this.runWebGLProgram(c,[a],r,[[s,i]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(a),d.dataId}write(e,n,r){if((De().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||De().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:e,usage:Ta.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,s,i){if(De().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:n,usage:Ta.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=n;if(o!=null){let f;l?f=new lh(a,Jc):f=new au(a,Jc);const m=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:s}],s),g=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const u=this.activeTimers!=null;let c;u&&(c=Ti());let d;if(s==="complex64"){const f=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId);d=cc(f,m)}else d=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Ti()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const g=this.pendingRead.get(e);return new Promise(y=>g.push(y))}const n=this.texData.get(e),{values:r,shape:s,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=n;if(i!=null){let g;l?g=new lh(s,Jc):g=new au(s,Jc);const y=this.runWebGLProgram(g,[{dataId:e,shape:s,dtype:o}],o),v=this.read(y.dataId);return this.disposeIntermediateTensorInfo(y),v}if(r!=null)return this.convertAndCacheOnCPU(e);if(De().getBool("DEBUG")&&!De().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&De().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(o!=="complex64"&&De().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const g=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(g.texture.texture,...wv(s))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const g=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),y=g[0],v=g[1];d=cc(y,v)}else if(u==null)d=this.getValuesFromTexture(e);else{const g=Ue(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,g)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const g=this.gpgpu.gl;It(g,()=>g.deleteBuffer(u))}const f=this.convertAndCacheOnCPU(e,d),m=this.pendingRead.get(e);return this.pendingRead.delete(e),m.forEach(g=>g(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ya().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,n={}){const r=this.texData.get(e),{values:s,shape:i,slice:o,dtype:a,isPacked:l,texture:u}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let m;l?m=new lh(i,Jc):m=new au(i,Jc);const g=this.runWebGLProgram(m,[{dataId:e,shape:i,dtype:a}],a),y=this.readToGPU(g,n);return this.disposeIntermediateTensorInfo(g),y}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,n.customTexShape),d=Ya().makeTensorFromTensorInfo(c),f=this.texData.get(c.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>oc(s));return En(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return En(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!Aj(r))throw De().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:s}=this.texData.get(e),i=Ue(n);if(De().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),m=this.texData.get(f.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...wv(n)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),g}const o=De().getBool("WEBGL_PACK")&&s===!0,a=o?Z2(n):n,l=o?new J4e(a):new Q4e(a),u=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=xu(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=xu(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=vz(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:o[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ti(),endMs:null}}endTimer(e){return De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ti(),e)}async getQueryTime(e){if(De().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:s,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,i,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=gTe){return De().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Ue(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){_a("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return dTe(e.shape,n)}packedUnaryOp(e,n,r){const s=new lh(e.shape,n),i=this.compileAndRun(s,[e],r);return Ya().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=IG(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(De().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,NP,e.dtype);const n=new au(e.shape,NP),r=this.compileAndRun(n,[e]);return Ya().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&ou(r[0])){const i=r.map(o=>mu(o));s=this.write(i,e,n)}else s=this.write(r,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,r){return Ya().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new hTe(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new XIe(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[hf(e.shape),...df(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},i=[hf(n),...df(n)],o=new $G(i,r),a=!0,l=[r],u=this.runWebGLProgram(o,[s],e.dtype,l,a);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:s,shape:i,dtype:o}=r;if(n!=null){const f=Ue(i),m=n[0]*n[1]*4;J(f<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Z2(i);let l;s?l=new Y4e(a):l=new X4e(a);const u=!0,c=[n??wv(a)],d=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,c,u,n);return{dtype:o,shape:i,dataId:d.dataId}}runWebGLProgram(e,n,r,s,i=!1,o){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Ly.DENSE){const b=o??wv(e.outputShape);l.texShape=b.map(x=>x*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Ue(a.shape)===0)return l.values=ii(a.dtype,0),a;const u=[],c=n.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(b.dataId);if(x.texture==null){if(!e.packedInputs&&Ue(b.shape)<=De().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!x.isPacked!=!!e.packedInputs)b=x.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),x=this.texData.get(b.dataId);else if(x.isPacked&&!My(x.shape,b.shape)){const $=b,S=b.shape;b.shape=x.shape,b=this.packedReshape(b,S),u.push(b),x=this.texData.get(b.dataId),$.shape=S}return{shape:b.shape,texData:x,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:l,isUniform:!1},f=K4e(e,c,d),m=this.getAndSaveBinary(f,()=>H4e(this.gpgpu,e,c,d)),g=this.activeTimers!=null;let y;g&&(y=this.startTimer()),De().get("ENGINE_COMPILE_ONLY")||q4e(this.gpgpu,m,c,d,s),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),g&&(y=this.endTimer(y),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(y)}));const v=De().getNumber("WEBGL_FLUSH_THRESHOLD");if(v>0){const b=Ti();b-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!De().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const b=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),b}return a}compileAndRun(e,n,r,s,i=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,s,i)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(De().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ke(()=>{if(!De().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=De().getBool("DEBUG");De().set("DEBUG",!1);const n=this.abs(Xt(1e-8)).dataSync()[0];if(De().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?fTe:pTe}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:s,values:i,texture:o,usage:a,isPacked:l}=n;if(o!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Ti());let d=n.texShape;if(d==null&&(d=Kj(r,l),n.texShape=d),i!=null){const f=Z2(r);let m,g=d[1],y=d[0];const v=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!v)&&([g,y]=O1(d[0],d[1])),l?m=new eIe(f,v):m=new $P(f,v);const b=v?[y,g]:d,x=this.makeTensorInfo(b,s),$=this.texData.get(x.dataId);v?$.usage=Ta.PIXELS:$.usage=Ta.UPLOAD,$.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),g,y,i);const S=[[y,g]],L=this.runWebGLProgram(m,[x],s,S,!0),R=this.texData.get(L.dataId);n.texShape=R.texShape,n.isPacked=R.isPacked,n.usage=R.usage,De().get("ENGINE_COMPILE_ONLY")?this.disposeData(L.dataId):(n.texture=R.texture,n.values=null,this.texData.delete(L.dataId)),this.disposeIntermediateTensorInfo(x),u&&(this.uploadWaitMs+=Ti()-c)}else{const f=this.acquireTexture(d,a,s,l);n.texture=f}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:s}=r;return n!=null&&(r.values=vTe(n,s)),r.values}acquireTexture(e,n,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*Ty(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(i){throw i}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await e4(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(XA(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=iG(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";const{texture:s,height:i,width:o,channels:a}=e,l=Ya().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(s,n,r,i,o,a);return Ya().makeTensorFromDataId(u,n,r,l)}}t3.nextDataId=0;function vTe(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}const CG="4.22.0";function EG(){De().set("WEBGL_FORCE_F16_TEXTURES",!0)}vE()&&Fx("webgl",()=>new t3,2);const bTe={forceHalfFloat:EG};const iR=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class ff{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=_n(n,r),this.enableShapeUniforms=Yi(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Rp=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class V1{constructor(e,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_n(n,r);const i=this.outputShape.length;this.enableShapeUniforms=Yi(i);let o="";if(s)if(i===0||Ue(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${_r(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=ho("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function aa(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const xTe={kernelName:Gf,backendName:"webgl",kernelFunc:aa};function Jh(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,i=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(i.dataId),a=aa({inputs:{x:r},backend:n}),l=aa({inputs:{x:s},backend:n});return o.complexTensorInfos={real:a,imag:l},i}const _Te={kernelName:u0,backendName:"webgl",kernelFunc:Jh};const kG="return (a < 0.) ? b * a : a;",NG=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ITe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:i}=r,o=n.makeTensorInfo([],"float32",yc(i,"float32")),a=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new V1(NG,s.shape,o.shape):new ff(kG,s.shape,o.shape),l=n.runWebGLProgram(a,[s,o],"float32");return n.disposeIntermediateTensorInfo(o),l}const TTe={kernelName:Eg,backendName:"webgl",kernelFunc:ITe};const AG="return (a < 0.) ? b * a : a;",RG=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function STe(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,i=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new V1(RG,r.shape,s.shape):new ff(AG,r.shape,s.shape);return n.runWebGLProgram(i,[r,s],"float32")}const $Te={kernelName:qg,backendName:"webgl",kernelFunc:STe};const B1="if (isnan(x)) return x;";function tr({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&n!=null){const d=a.texData.get(o.dataId),f=n(d.values,l);return a.makeTensorInfo(o.shape,l,f)}const u=De().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new lh(o.shape,e):c=new au(o.shape,t),a.runWebGLProgram(c,[o],l)}}function Oi({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:u}=o,c=a;if(r&&l.dtype==="complex64"){const g=c.texData.get(l.dataId),y=c.texData.get(u.dataId),[v,b]=[[g.complexTensorInfos.real,y.complexTensorInfos.real],[g.complexTensorInfos.imag,y.complexTensorInfos.imag]].map($=>{const[S,E]=$,L={dataId:S.dataId,dtype:S.dtype,shape:l.shape},R={dataId:E.dataId,dtype:E.dtype,shape:u.shape},D=new ff(t,l.shape,u.shape);return c.runWebGLProgram(D,[L,R],go(S.dtype,E.dtype))}),x=Jh({inputs:{real:v,imag:b},backend:c});return c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(b),x}const d=i||go(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){const g=c.texData.get(l.dataId).values,y=c.texData.get(u.dataId).values,v=l.dtype==="string"?hc(g):g,b=l.dtype==="string"?hc(y):y,[x,$]=s(l.shape,u.shape,v,b,d),S=c.makeTensorInfo($,d),E=c.texData.get(S.dataId);return E.values=x,S}const f=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let m;return f?m=new V1(e,l.shape,u.shape,n):m=new ff(t,l.shape,u.shape),c.runWebGLProgram(m,[l,u],d)}}function zy(t,e=!1){if(t==="linear")return e?oTe:tTe;if(t==="relu")return e?lTe:rTe;if(t==="elu")return e?aTe:nTe;if(t==="relu6")return e?uTe:sTe;if(t==="prelu")return e?RG:AG;if(t==="leakyrelu")return e?NG:kG;if(t==="sigmoid")return e?cTe:iTe;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class DG{constructor(e,n,r,s=!1,i=!1,o=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Yi(this.outputShape.length);const c=s?e[1]:e[2],d=Math.ceil(c/2),f=s?"i * 2, rc.y":"rc.y, i * 2",m=i?"rc.z, i * 2":"i * 2, rc.z",g=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],y=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",b="";a&&(l?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:v=`vec4 activation(vec4 x) {
          ${a}
        }`,b="result = activation(result);");const x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let $="rc.x",S="rc.x";e[0]<n[0]?$=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(S=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${$};
        int batchB = ${S};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${y[0]});
          result += (${g[1]} * ${y[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${b}

        setOutput(result);
      }
    `}}const AP={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class RP{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=_n(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const DP="return a * b;";function oR(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,i=go(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new RP(AP.REAL,r.shape,s.shape),c=new RP(AP.IMAG,r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],f=n.runWebGLProgram(u,d,"float32"),m=n.runWebGLProgram(c,d,"float32"),g=Jh({inputs:{real:f,imag:m},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}if(n.shouldExecuteOnCPU([r,s])){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=TIe(r.shape,s.shape,a.values,l.values,i),d=n.makeTensorInfo(c,i),f=n.texData.get(d.dataId);return f.values=u,d}let o;return De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new V1(DP,r.shape,s.shape):o=new ff(DP,r.shape,s.shape),n.runWebGLProgram(o,[r,s],i)}const CTe={kernelName:ep,backendName:"webgl",kernelFunc:oR};function ETe(t,e,n){const r=[hf(t.shape),...df(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},i=[hf(e),...df(e)],o=new $G(i,r),a=!0,l=[r],u=n.runWebGLProgram(o,[s],t.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}function _t(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:i}=r,o=n,a=Ue(s.shape),l=uE(i,a),u=Ue(l);J(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(s.dataId);return c.isPacked&&!My(s.shape,l)&&!(c.texture!==null&&My(c.shape,l))?ETe(s,l,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const kTe={kernelName:Xg,backendName:"webgl",kernelFunc:_t};class OP{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];const a=Math.floor(r/4)*4,l=r%4;let u="sumValue += dot(values, ones);";if(n!=null){const d=1/n;u=`sumValue += dot(values * ${Hd(d)?d.toPrecision(2):d}, ones);`}let c="";i%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}class NTe{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];let a="0.0",l="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",l="min"):n==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");const c=Math.floor(r/4)*4,d=r%4;let f=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";n==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):n==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let g="";i%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `}}function ATe(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=t4(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function Dp(t,e,n,r){const s=ATe(t.shape);let i=t;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:u}=s[o];let c,d;n==="mean"?c=o===0?new OP({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new OP({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):c=new NTe({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},n),d=i,i=r.runWebGLProgram(c,[i],e),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return i}class RTe{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[n[o]];this.outputShape=r,this.rank=r.length;const s=_r(this.rank),i=DTe(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function DTe(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}class OTe{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let c=0;c<r.length;c++)r[c]=e[n[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=_r(this.rank),i=SG("rc",this.rank),o=new Array(this.rank);for(let c=0;c<n.length;c++)o[n[c]]=i[c];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}function k4(t,e,n){const r=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new OTe(t.shape,e):new RTe(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}function PTe(t,e,n,r){const s=e,i=t.shape.length,o=On(s,t.shape);let a=o;const l=ns(a,i),u=l!=null;let c=t;u&&(c=k4(t,l,r),a=ys(a.length,i)),Ri("sum",a,i);const[d,f]=li(c.shape,a);let m=d;n&&(m=gs(d,o));const g=Ue(f),v=Ue(t.shape)/g,b=_t({inputs:{x:c},attrs:{shape:[v,g]},backend:r}),x=cw(t.dtype),$=Dp(b,x,"sum",r),S=_t({inputs:{x:$},attrs:{shape:m},backend:r});return r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo($),u&&r.disposeIntermediateTensorInfo(c),S}function N4(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r;return PTe(s,i,o,n)}const FTe={kernelName:t1,backendName:"webgl",kernelFunc:N4};function yo(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:i}=r,o=n,a=s.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=s.shape[i[c]];let u;if(o.shouldExecuteOnCPU([s])){const d=o.texData.get(s.dataId).values,f=sR(d,s.shape,s.dtype,i,l);u=o.makeTensorInfo(l,s.dtype);const m=o.texData.get(u.dataId);m.values=f}else u=k4(s,i,o);return u}const LTe={kernelName:ph,backendName:"webgl",kernelFunc:yo};const OG=1e3;function tx({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,d=n?t.shape[u-2]:t.shape[u-1],f=r?e.shape[c-1]:e.shape[c-2],m=n?t.shape[u-1]:t.shape[u-2],g=r?e.shape[c-2]:e.shape[c-1],y=t.shape.slice(0,-2),v=e.shape.slice(0,-2),b=Ue(y),x=Ue(v),S=_n(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([m,g]);J(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const E=n?[b,d,m]:[b,m,d],L=r?[x,g,f]:[x,f,g],R=_t({inputs:{x:t},backend:s,attrs:{shape:E}}),D=_t({inputs:{x:e},backend:s,attrs:{shape:L}}),A=[R,D],F=Math.max(b,x),P=n?R.shape[1]:R.shape[2],K=i!=null,j=o!=null,se=l==="leakyrelu",fe=l!=null?zy(l,!0):null,me=K||j||se||fe!=null;let ye;if((m===1||g===1)&&P>OG&&me===!1){let ue=R,_e=D;n&&(ue=yo({inputs:{x:R},backend:s,attrs:{perm:[0,2,1]}}),A.push(ue)),r&&(_e=yo({inputs:{x:D},backend:s,attrs:{perm:[0,2,1]}}),A.push(_e));const Y=g!==1,re=g===1;let Te=ue;Y&&(Te=_t({inputs:{x:ue},backend:s,attrs:{shape:[F,P,1]}}),A.push(Te));const Pe=g===1?2:1;let de=_e;re&&(de=_t({inputs:{x:_e},backend:s,attrs:{shape:[F,1,P]}}),A.push(de));const ge=oR({inputs:{a:Te,b:de},backend:s});ye=N4({inputs:{x:ge},backend:s,attrs:{axis:Pe,keepDims:!0}}),A.push(ge)}else{const ue=go(t.dtype,e.dtype),_e=new DG(E,L,[F,m,g],n,r,K,fe,j,se),Y=[R,D];if(i!=null&&Y.push(i),j&&Y.push(o),se){const re=s.makeTensorInfo([],"float32",yc(a,"float32"));Y.push(re),A.push(re)}ye=s.runWebGLProgram(_e,Y,ue)}const oe=_t({inputs:{x:ye},backend:s,attrs:{shape:S}});A.push(ye);for(const ue of A)s.disposeIntermediateTensorInfo(ue);return oe}function MTe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return tx({a:s,b:i,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}const zTe={kernelName:Pm,backendName:"webgl",kernelFunc:MTe};const PP="return abs(x);";function VTe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const i=n.texData.get(r.dataId),o=IG(i.values);return n.makeTensorInfo(r.shape,r.dtype,o)}let s;return De().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new lh(r.shape,PP):s=new au(r.shape,PP),n.runWebGLProgram(s,[r],r.dtype)}const BTe={kernelName:og,backendName:"webgl",kernelFunc:VTe};const UTe=ll+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,WTe=tr({opSnippet:UTe}),jTe={kernelName:Sf,backendName:"webgl",kernelFunc:WTe};const GTe=ll+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,HTe=tr({opSnippet:GTe}),qTe={kernelName:$f,backendName:"webgl",kernelFunc:HTe};const FP="return a + b;",KTe=Oi({opSnippet:FP,packedOpSnippet:FP,supportsComplex:!0,cpuKernelImpl:rIe}),XTe={kernelName:Uh,backendName:"webgl",kernelFunc:KTe};class YTe{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}class QTe{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}function ab(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return aa({inputs:{x:r[0]},backend:n});if(r.length>De().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=ab({inputs:r.slice(0,l),backend:n}),c=ab({inputs:r.slice(l),backend:n});return ab({inputs:[u,c],backend:n})}const s=r.map(l=>l.dtype).reduce((l,u)=>go(l,u)),i=r.map(l=>l.shape),a=De().getBool("WEBGL_PACK")?new QTe(r[0].shape,i):new YTe(r[0].shape,i);return n.runWebGLProgram(a,r,s)}const JTe={kernelName:ag,backendName:"webgl",kernelFunc:ab};function ZTe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=On(i,s.shape);let u=l;const c=ns(u,a);let d=s;c!=null&&(d=yo({inputs:{x:s},backend:n,attrs:{perm:c}}),u=ys(u.length,a)),Ri("all",u,a);const[f,m]=li(d.shape,u),g=Ue(m),y=_t({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),v=Dp(y,y.dtype,"all",n);let b;if(o){const x=gs(f,l);b=_t({inputs:{x:v},backend:n,attrs:{shape:x}})}else b=_t({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),c!=null&&n.disposeIntermediateTensorInfo(d),b}const eSe={kernelName:r0,backendName:"webgl",kernelFunc:ZTe};function tSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=On(i,s.shape);let u=l;const c=ns(u,a);let d=s;c!=null&&(d=yo({inputs:{x:s},backend:n,attrs:{perm:c}}),u=ys(u.length,a)),Ri("any",u,a);const[f,m]=li(d.shape,u),g=Ue(m),y=_t({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),v=Dp(y,y.dtype,"any",n);let b;if(o){const x=gs(f,l);b=_t({inputs:{x:v},backend:n,attrs:{shape:x}})}else b=_t({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),c!=null&&n.disposeIntermediateTensorInfo(d),b}const nSe={kernelName:s0,backendName:"webgl",kernelFunc:tSe};class rSe{constructor(e,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class sSe{constructor(e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,J(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/n);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=_r(l),c=ho("coords",l);let d,f;if(o===1){f=l+1;const D=_r(f);d=`
        ${D} sourceLocR = ${D}(${c.join()}, 0);
        ++${c[l-1]};
        ${D} sourceLocG = ${D}(${c.join()}, 0);
        ++${c[l-2]};
        ${D} sourceLocA = ${D}(${c.join()}, 0);
        --${c[l-1]};
        ${D} sourceLocB = ${D}(${c.join()}, 0);
        --${c[l-2]};`}else f=l,d=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const m=["x","y","z","w","u","v"].slice(0,f),g="."+m[f-1],y=m.map(D=>"int "+D),v=ho("sourceLocR",f-1).concat("inIdx.r"),b=ho("sourceLocG",f-1).concat("inIdx.g"),x=ho("sourceLocB",f-1).concat("inIdx.b"),$=ho("sourceLocA",f-1).concat("inIdx.a"),S=r==="max"?"greaterThan":"lessThan",E=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${$.join()})));`,L=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,R=s?"":`
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${y.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${L};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${L};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${S}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function PG(t,e,n,r=null){let s=e.shape[0],i=e.shape[1];r!=null&&(s=r.shape[0],i=r.shape[1]);const o=t4(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new rSe(a,n,r==null),u=[e];r!=null&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const d=PG(t,e,n,c);return t.disposeIntermediateTensorInfo(c),d}function FG(t,e,n,r=null){const s=r!=null?r.shape:e.shape,i=s[s.length-1],o=t4(i),a=new sSe(s,o,n,r==null),l=r==null?[e]:[e,r],u=t.runWebGLProgram(a,l,"int32");if(u.shape.length===e.shape.length){const c=FG(t,e,n,u);return t.disposeIntermediateTensorInfo(u),c}return u}function LG(t,e,n,r){const s=[n];if(Ri("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!De().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=t.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=t.unpackTensor(e),i.push(l));const[u,c]=li(l.shape,s),d=Ue(c),f=_t({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});i.push(f);const m=PG(t,f,r);i.push(m);const g=_t({inputs:{x:m},backend:t,attrs:{shape:u}});return i.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}return FG(t,e,r)}function iSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;let o=On(i,s.shape);const a=ns(o,s.shape.length);let l=s;const u=[];a!=null&&(l=yo({inputs:{x:s},backend:n,attrs:{perm:a}}),u.push(l),o=ys(o.length,l.shape.length)),Ri("argMax",[o[0]],l.shape.length);const c=LG(n,l,o[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const oSe={kernelName:lg,backendName:"webgl",kernelFunc:iSe};function aSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;let o=On(i,s.shape);const a=ns(o,s.shape.length);let l=s;const u=[];a!=null&&(l=yo({inputs:{x:s},backend:n,attrs:{perm:a}}),u.push(l),o=ys(o.length,l.shape.length)),Ri("argMin",[o[0]],l.shape.length);const c=LG(n,l,o[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const lSe={kernelName:ug,backendName:"webgl",kernelFunc:aSe};const uSe=ll+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,cSe=tr({opSnippet:uSe}),hSe={kernelName:Cf,backendName:"webgl",kernelFunc:cSe};const dSe=ll+"return log(x + sqrt(x * x + 1.0));",fSe=tr({opSnippet:dSe}),pSe={kernelName:Ef,backendName:"webgl",kernelFunc:fSe};const mSe=ll+`
  return atan(x);
`,gSe=tr({opSnippet:mSe}),ySe={kernelName:kf,backendName:"webgl",kernelFunc:gSe};const wSe=iR+`
  return atan(a, b);
`,vSe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Rp+`
  return result;
`,bSe=Oi({opSnippet:wSe,packedOpSnippet:vSe}),xSe={kernelName:Af,backendName:"webgl",kernelFunc:bSe};const _Se=ll+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,ISe=tr({opSnippet:_Se}),TSe={kernelName:Nf,backendName:"webgl",kernelFunc:ISe};class Vy{constructor(e,n,r,s=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const y=n==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(y||(x="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${m}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?i?v:b:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let S=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(S="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,L=o%4,R=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${m}, ${g});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${E};
          if (${L===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${L===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${L===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${S});
      }
    `}}class aR{constructor(e,n,r,s=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,d=e.dilationHeight,f=e.dilationWidth,m=e.effectiveFilterDepth,g=e.effectiveFilterHeight,y=e.effectiveFilterWidth,v=e.padInfo.front,b=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const $=n==="avg";let S="0.0";if($||(S="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${v}, ${b}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${y};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${y} +
                      wR * ${y} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let L=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(L="avgValue / max(count, 1.0)");const R=Math.floor(o/4)*4,D=o%4,A=`
      if (${$}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${v}, ${b}, ${x});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${R};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${A}
            }
          }
        }
        setOutput(${L});
      }
    `}}function SSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;P1(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;J(Ai(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=il(s.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&zn(c.inShape,c.outShape))return aa({inputs:{x:s},backend:n});const d=new Vy(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}const $Se={kernelName:cg,backendName:"webgl",kernelFunc:SSe};function CSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=wc(s.shape,i,o,c,a,l,u),f=new aR(d,"avg",!1);return n.runWebGLProgram(f,[s],"float32")}const ESe={kernelName:hg,backendName:"webgl",kernelFunc:CSe};class kSe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,d=u-1-e.padInfo.left,f=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class NSe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=d-1-e.padInfo.front,y=f-1-e.padInfo.top,v=m-1-e.padInfo.left,b=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${y}, ${v});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function ASe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],f=wc(o.shape,a,l,d,u,c),m=new NSe(f);return n.runWebGLProgram(m,[s],o.dtype)}const RSe={kernelName:o0,backendName:"webgl",kernelFunc:ASe};function DSe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,o=i;P1([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=il(o.shape,a,l,1,u),d=new kSe(c);return n.runWebGLProgram(d,[s],o.dtype)}const OSe={kernelName:i0,backendName:"webgl",kernelFunc:DSe};function PSe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return tx({a:s,b:i,transposeA:o,transposeB:a,backend:n})}const FSe={kernelName:dg,backendName:"webgl",kernelFunc:PSe};class LSe{constructor(e,n,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],_n(e,n),_n(e,r);let a="0.0";s!=null&&(_n(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(_n(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class MSe{constructor(e,n,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],_n(e,n),_n(e,r);let a="vec4(0.0)";s!=null&&(_n(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(_n(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const zSe=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=t;J(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[r,s,i];let c=null;o!=null&&(c=o.shape,u.push(o));let d=null;a!=null&&(d=a.shape,u.push(a));const f=De().getBool("WEBGL_PACK_NORMALIZATION")?new MSe(r.shape,s.shape,i.shape,c,d,l):new LSe(r.shape,s.shape,i.shape,c,d,l);return e.runWebGLProgram(f,u,u[0].dtype)},VSe={kernelName:Sg,backendName:"webgl",kernelFunc:zSe};class BSe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=_r(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=USe(this.rank);let s;const i=e.map((o,a)=>`sourceLoc.${eC[a]} = start[${a}] + coords.${eC[a]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const eC=["x","y","z","w","u","v"];function USe(t){if(t===1)return"sourceLoc";if(t<=6)return eC.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}class WSe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=_r(this.rank),r=ho("coords",this.rank),s=ho("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${o};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${o};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((c,d)=>`start[${d}]`).join()});`:e.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}function jSe(t,e,n,r){const s=r.texData.get(t.dataId),i=r.makeTensorInfo(n,t.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=n,o.dtype=t.dtype;let a=Dk(e,Qt(t.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}function U1(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,size:o}=r,[a,l]=Z_(s,i,o);if(Nk(s,a,l),Ue(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const d=n.texData.get(s.dataId),f=PIe(d.values,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,f)}const{isPacked:u}=n.texData.get(s.dataId),c=Rk(s.shape,a,l);if(u||!c){const d=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WSe(l):new BSe(l),f=[a];return n.runWebGLProgram(d,[s],s.dtype,f)}return n.uploadToGPU(s.dataId),jSe(s,a,l,n)}const GSe={kernelName:e1,backendName:"webgl",kernelFunc:U1};const HSe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,crops:o}=r;J(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((x,$)=>x*$),l=zw(s.shape,i,a),u=Vw(l.length,i.length),c=Bw(s.shape,i,a),d=Bk(o,i.length),f=Uk(c,o,i.length),m=[],g=_t({inputs:{x:s},backend:n,attrs:{shape:l}}),y=yo({inputs:{x:g},backend:n,attrs:{perm:u}}),v=_t({inputs:{x:y},backend:n,attrs:{shape:c}}),b=U1({inputs:{x:v},backend:n,attrs:{begin:d,size:f}});return m.push(g),m.push(y),m.push(v),m.forEach(x=>n.disposeIntermediateTensorInfo(x)),b},qSe={kernelName:fg,backendName:"webgl",kernelFunc:HSe};function KSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:o}=r,a=n.readSync(s.dataId),l=n.readSync(i.dataId),u=_G(a,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,u)}const XSe={kernelName:a0,backendName:"webgl",kernelFunc:KSe};const YSe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,QSe=`
  return float(int(a.r) & int(b.r));
`;function JSe(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,i=De().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=De().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||o===1){const l=n.texData.get(r.dataId).values,u=n.texData.get(s.dataId).values,[c,d]=iIe(r.shape,s.shape,l,u,r.dtype),f=n.makeTensorInfo(d,r.dtype),m=n.texData.get(f.dataId);return m.values=c,f}let a;return i?a=new V1(YSe,r.shape,s.shape,!1):a=new ff(QSe,r.shape,s.shape),n.runWebGLProgram(a,[r,s],r.dtype)}const ZSe={kernelName:pg,backendName:"webgl",kernelFunc:JSe};function e$e(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,i=n.readSync(r.dataId),o=n.readSync(s.dataId),a=_n(Array.from(i),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const t$e={kernelName:l0,backendName:"webgl",kernelFunc:e$e};const n$e="return float(a != b);",MG=Oi({opSnippet:n$e,cpuKernelImpl:$Ie,dtype:"bool"}),r$e={kernelName:Ug,backendName:"webgl",kernelFunc:MG};function n3(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return aa({inputs:{x:s.complexTensorInfos.real},backend:n})}const s$e={kernelName:U0,backendName:"webgl",kernelFunc:n3};const i$e="return float(int(x));";function o$e(t,e){const n=new au(t.shape,i$e),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function tC(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return aa({inputs:{x:s},backend:n});const o=ps(s.shape),a=tC({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Jh({inputs:{real:a,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const o=n3({inputs:{input:s},backend:n}),a=tC({inputs:{x:o},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(o),a}if(!cE(s.dtype,i)){const o=aa({inputs:{x:s},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(n.shouldExecuteOnCPU([s])){const o=n.texData.get(s.dataId).values,[a,l,u]=oIe(o,s.shape,s.dtype,i);return n.makeTensorInfo(a,l,u)}if(i==="int32")return o$e(s,n);if(i==="bool"){const o=n.makeTensorInfo([],"bool",ii("bool",1)),l=MG({inputs:{a:s,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const a$e={kernelName:Rf,backendName:"webgl",kernelFunc:tC};const LP="return ceil(x);",l$e=tr({opSnippet:LP,packedOpSnippet:LP,cpuKernelImpl:aIe}),u$e={kernelName:Df,backendName:"webgl",kernelFunc:l$e};class c$e{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class h$e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function d$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;De().getBool("WEBGL_PACK_CLIP")?a=new h$e(s.shape):a=new c$e(s.shape);const l=[[i],[o]];return n.runWebGLProgram(a,[s],s.dtype,l)}const f$e={kernelName:Of,backendName:"webgl",kernelFunc:d$e};class p$e{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function MP(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function m$e(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),i=new p$e(r.shape),o=[MP(r,s.complexTensorInfos.real),MP(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(i,o,o[0].dtype)}const g$e={kernelName:mg,backendName:"webgl",kernelFunc:m$e};class y$e{constructor(e){this.outputShape=[],this.outputShape=gu(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let o=1;o<n.length;o++)n[o]=n[o-1]+e[o][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<n.length;o++){const a=n[o-1];r.push(`else if (yC < ${n[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const s=n.length,i=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}class w$e{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=gu(e,n);const r=this.outputShape,s=r.length,i=_r(s),o=ho("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((y,v)=>`T${v}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let y=1;y<l.length;y++)l[y]=l[y-1]+e[y][n];const u=a[n],c=a.slice(-2),d=a.join();let f=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let y=1;y<l.length;y++){const v=l[y-1];f+=`
        if (${u} < ${l[y]}  && ${u} >= ${l[y-1]}) {
          return getChannel(
            getT${y}(${xv(a,u,v)}),
            vec2(${xv(c,u,v)}));
        }`}const m=l.length,g=l[l.length-1];f+=`
        return getChannel(
          getT${m}(${xv(a,u,g)}),
          vec2(${xv(c,u,g)}));`,this.userCode=`
      float getValue(${a.map(y=>"int "+y)}) {
        ${f}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[s-1]} = ${o[s-1]} + 1;
        if (${o[s-1]} < ${r[s-1]}) {
          result.g = getValue(${o});
        }

        ${o[s-2]} = ${o[s-2]} + 1;
        if (${o[s-2]} < ${r[s-2]}) {
          result.a = getValue(${o});
        }

        ${o[s-1]} = ${o[s-1]} - 1;
        if (${o[s-2]} < ${r[s-2]} &&
            ${o[s-1]} < ${r[s-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function xv(t,e,n){const r=t.indexOf(e);return t.map((i,o)=>o===r?`${i} - ${n}`:i).join()}function A4(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return aa({inputs:{x:s.complexTensorInfos.imag},backend:n})}const v$e={kernelName:E0,backendName:"webgl",kernelFunc:A4};function ey(t,e,n){const r=t[0].dtype;if(r==="complex64"){const m=t.map(x=>n3({inputs:{input:x},backend:n})),g=t.map(x=>A4({inputs:{input:x},backend:n})),y=ey(m,e,n),v=ey(g,e,n),b=Jh({inputs:{real:y,imag:v},backend:n});return m.forEach(x=>n.disposeIntermediateTensorInfo(x)),g.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),b}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const m=t.map(S=>{const L=[-1,Ue(S.shape.slice(e))];return _t({inputs:{x:S},backend:n,attrs:{shape:L}})}),g=m.map(S=>({vals:n.readSync(S.dataId),shape:S.shape})),y=gu(m.map(S=>S.shape),1),v=m[0].shape[0]===1,b=lIe(g,y,r,v),x=gu(t.map(S=>S.shape),e),$=n.makeTensorInfo(x,r,b);return m.forEach(S=>n.disposeIntermediateTensorInfo(S)),$}const i=t.filter(m=>Ue(m.shape)>0),o=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const m=o?new au(t[0].shape,Jc):new lh(t[0].shape,Jc);return n.runWebGLProgram(m,t,r)}const a=De().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const m=[];for(let y=0;y<i.length;y+=a){const v=i.slice(y,y+a);m.push(ey(v,e,n))}const g=ey(m,e,n);for(const y of m)n.disposeIntermediateTensorInfo(y);return g}if(o){const m=new w$e(i.map(g=>g.shape),e);return n.runWebGLProgram(m,i,r)}const{tensors2D:l,outShape:u}=b$e(i,e,n),c=new y$e(l.map(m=>m.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(m=>n.disposeIntermediateTensorInfo(m));const f=_t({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),f}function b$e(t,e,n){const r=gu(t.map(i=>i.shape),e);return{tensors2D:t.map(i=>_t({inputs:{x:i},attrs:{shape:[-1,Ue(i.shape.slice(e))]},backend:n})),outShape:r}}function zG(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,i=On(s,e[0].shape)[0],o=e.map(u=>u.shape);Mk(o,i);const a=gu(e.map(u=>u.shape),i);if(Ue(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>Ue(u.shape)>0);return l.length===1?aa({inputs:{x:l[0]},backend:n}):ey(l,i,n)}const x$e={kernelName:gg,backendName:"webgl",kernelFunc:zG};class VG{constructor(e,n=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,y=e.inChannels%4,v=e.dataFormat==="channelsLast",b=v?1:2,x=v?2:3,$=v?3:1;let S="",E="";r&&(s?S=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?S=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:S=`
          float activation(float x) {
            ${r}
          }
        `,E="result = activation(result);");const L=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${S}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${$}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${y===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${y===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${y===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${L}
        ${E}
        setOutput(result);
      }
    `}}class _$e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterDepth,f=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,y=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${y===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${y===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${y===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class BG{constructor(e,n=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Yi(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<c;v++)f+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;f+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<c;v++)f+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(d+1)/2;v++){const b=v*2;if(f+=`
           xC = xCCorner + ${b*l};
           `,a===1){if(b<c&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,l===1&&b>0?f+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<c)){const x=o%2===0?Ax(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:f+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):x===1?f+=`
                     xC${b+1} = xTexelC${b};
                     `:f+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<c&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<c&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<c&&(f+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<c&&(f+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<c&&(f+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let m="",g="";r&&(s?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:i?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:m=`vec4 activation(vec4 x) {
           ${r}
         }`,g="result = activation(result);");const y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${y}
         ${g}
         setOutput(result);
       }
     `}}class I$e{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Yi(this.outputShape.length);const{dataFormat:r}=n,s=vo(),i=r==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}}function nx(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function UG({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.shape,u=r.texData.get(t.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],f=n.outChannels,m=n.dataFormat==="channelsLast",g=!1,y=!1;let v;const b=[];if(i!=null){const S=nx(i.shape,m);S!=null&&(i=_t({inputs:{x:i},backend:r,attrs:{shape:S}}),b.push(i))}if(s!=null){const S=nx(s.shape,m);S!=null&&(s=_t({inputs:{x:s},backend:r,attrs:{shape:S}}),b.push(s))}if(!((d===1||f===1)&&c>OG)&&u.isPacked&&m&&u.texture!=null&&l[2]%2!==0&&zn(u.shape.slice(-3),l.slice(-3))){const S=l[0]*l[1]*(l[2]+1),E={dataId:t.dataId,shape:[1,S,n.inChannels],dtype:t.dtype},L=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,J(My(u.shape,E.shape),()=>`packed reshape ${u.shape} to ${E.shape} isn't free`);const R=_t({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(R);const D=tx({a:E,b:R,backend:r,transposeA:g,transposeB:y,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),A=r.texData.get(D.dataId);J(A.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=L,A.shape=n.outShape,v=aa({inputs:{x:D},backend:r}),v.shape=n.outShape,b.push(D)}else{const S=n.outHeight*n.outWidth,E=_t({inputs:{x:t},backend:r,attrs:{shape:m?[n.batchSize,S,n.inChannels]:[n.batchSize,n.inChannels,S]}}),L=_t({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),R=tx({a:m?E:L,b:m?L:E,transposeA:!m,transposeB:y,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});v=_t({inputs:{x:R},backend:r,attrs:{shape:n.outShape}}),b.push(E),b.push(L),b.push(R)}for(const S of b)r.disposeIntermediateTensorInfo(S);return v}function WG({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:f,dataFormat:m}=n,g=m==="channelsLast",y=l*u*c,v=f*d,b=[n.batchSize,y,v],x=!0,$=!1,S=[];if(i!=null){const oe=nx(i.shape,g);oe!=null&&(i=_t({inputs:{x:i},backend:r,attrs:{shape:oe}}),S.push(i))}if(s!=null){const oe=nx(s.shape,g);oe!=null&&(s=_t({inputs:{x:s},backend:r,attrs:{shape:oe}}),S.push(s))}const E=_t({inputs:{x:e},backend:r,attrs:{shape:[1,y,Ue(e.shape)/y]}});S.push(E);const L=new I$e(b,n),R=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],D=r.runWebGLProgram(L,[t],"float32",R),A=_t({inputs:{x:D},backend:r,attrs:{shape:b}});S.push(D),S.push(A);const F=s!=null,P=i!=null,K=a==="leakyrelu",j=a?zy(a,!0):null,se=new DG(g?A.shape:E.shape,g?E.shape:A.shape,g?[n.batchSize,v,n.outChannels]:[n.batchSize,n.outChannels,v],x,$,F,j,P,K),fe=g?[A,E]:[E,A];if(s&&fe.push(s),P&&fe.push(i),K){const oe=r.makeTensorInfo([],"float32",yc(o,"float32"));fe.push(oe),S.push(oe)}const me=r.runWebGLProgram(se,fe,"float32"),ye=_t({inputs:{x:me},backend:r,attrs:{shape:n.outShape}});S.push(me);for(const oe of S)r.disposeIntermediateTensorInfo(oe);return ye}function T$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=vc(l),f=ai(s.shape,i.shape,o,u,a,c,!1,d);let m;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))m=UG({x:s,filter:i,convInfo:f,backend:n});else if(f.strideWidth<=2&&d==="channelsLast"&&De().getBool("WEBGL_EXP_CONV")){const y=new BG(f),v=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];m=n.runWebGLProgram(y,[s,i],"float32",v)}else if(De().getBool("WEBGL_CONV_IM2COL"))m=WG({x:s,filter:i,convInfo:f,backend:n});else{const y=new VG(f);m=n.runWebGLProgram(y,[s,i],"float32")}const g=_t({inputs:{x:m},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(m),g}const S$e={kernelName:yg,backendName:"webgl",kernelFunc:T$e};class $$e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class C$e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,l=r-1-e.padInfo.left,u=o?1:2,c=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class E$e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class k$e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=n-1-e.padInfo.front,u=r-1-e.padInfo.top,c=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function N$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=vc(l),f=ai(s.shape,c,o,1,a,u,!1,d),m=new $$e(f);return n.runWebGLProgram(m,[s,i],"float32")}const A$e={kernelName:c0,backendName:"webgl",kernelFunc:N$e};class R$e{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Yi(this.outputShape.length);const n=e.filterHeight,r=e.filterWidth,s=n-1-e.padInfo.top,i=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function D$e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=vc(u),f=ai(o,i.shape,a,1,l,c,!1,d);if(De().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const m=[[f.strideHeight,f.strideWidth]],g=new R$e(f);return n.runWebGLProgram(g,[s,i],"float32",m)}else{const m=new C$e(f);return n.runWebGLProgram(m,[s,i],"float32")}}const O$e={kernelName:wg,backendName:"webgl",kernelFunc:D$e};function P$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,u=Gh(s.shape,i.shape,o,l,a),c=new _$e(u);return n.runWebGLProgram(c,[s,i],"float32")}const F$e={kernelName:vg,backendName:"webgl",kernelFunc:P$e};function L$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,u=Gh(s.shape,l,o,1,a),c=new E$e(u);return n.runWebGLProgram(c,[s,i],"float32")}const M$e={kernelName:h0,backendName:"webgl",kernelFunc:L$e};function z$e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r,u=Gh(l,i.shape,a,1,o),c=new k$e(u);return n.runWebGLProgram(c,[s,i],"float32")}const V$e={kernelName:d0,backendName:"webgl",kernelFunc:z$e};const B$e=B1+`
  return cos(x);
`,U$e=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Rp}
  return result;
`,W$e=tr({opSnippet:B$e,packedOpSnippet:U$e}),j$e={kernelName:Pf,backendName:"webgl",kernelFunc:W$e};const G$e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,H$e=tr({opSnippet:G$e}),q$e={kernelName:Ff,backendName:"webgl",kernelFunc:H$e};class K$e{constructor(e,n,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,u]=e,[c]=n,[d,f]=r;this.outputShape=[c,d,f,u];const m=s==="bilinear"?1:0,[g,y]=[`${a-1}.0`,`${l-1}.0`],[v,b,x]=d>1?[`${(a-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[$,S,E]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${y} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${y}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${$});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${S};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const X$e=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=r,c=new K$e(s.shape,i.shape,a,l,u);return n.runWebGLProgram(c,[s,i,o],"float32")},Y$e={kernelName:p0,backendName:"webgl",kernelFunc:X$e};var By;(function(t){t.Prod="*",t.Sum="+"})(By||(By={}));class zP{constructor(e,n,r,s){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===By.Prod?"1.0":"0.0",a=r?o:`getX(${VP(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?`end != ${l-1}`:"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${_r(i)} coords = getOutputCoords();
        int end = ${BP(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${BP(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${VP(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function VP(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function BP(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function jG(t,e,n,r,s,i){const o=e.shape.length,a=ns([r],o);let l=e;a!=null&&(l=yo({inputs:{x:e},backend:n,attrs:{perm:a}}));const u=ys(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=aa({inputs:{x:l},backend:n});for(let f=0;f<=Math.ceil(Math.log2(c))-1;f++){const m=new zP(t,l.shape,!1,i),g=[[f]],y=d;d=n.runWebGLProgram(m,[d],d.dtype,g),n.disposeIntermediateTensorInfo(y)}if(s){const f=new zP(t,l.shape,s,i),m=d;d=n.runWebGLProgram(f,[d],d.dtype),n.disposeIntermediateTensorInfo(m)}if(a!=null){const f=qh(a),m=yo({inputs:{x:d},backend:n,attrs:{perm:f}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),m}return d}function Q$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return jG(By.Prod,s,n,i,o,a)}const J$e={kernelName:f0,backendName:"webgl",kernelFunc:Q$e};function Z$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return jG(By.Sum,s,n,i,o,a)}const eCe={kernelName:bg,backendName:"webgl",kernelFunc:Z$e};function tCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),u=n.readSync(i.dataId),c=_G(l,u,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(i),c=sIe(l,u,o,a);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const nCe={kernelName:m0,backendName:"webgl",kernelFunc:tCe};class rCe{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function sCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],u=o==="NHWC"?s.shape[2]:s.shape[3],c=o==="NHWC"?s.shape[3]:s.shape[1],d=l*i,f=u*i,m=c/(i*i),g=o==="NHWC"?[a,d,f,m]:[a,m,d,f],y=new rCe(g,i,o);return n.runWebGLProgram(y,[s],s.dtype)}const iCe={kernelName:g0,backendName:"webgl",kernelFunc:sCe};class GG{constructor(e,n=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Yi(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";r&&(s?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}class HG{constructor(e,n=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Yi(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=d;let m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<d;b++)m+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;m+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let b=0;b<d;b++)m+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(f+1)/2;b++){const x=b*2;if(m+=`
          xC = xCCorner + ${x*u};
          `,l===1){if(x<d&&(a%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,u===1&&x>0?m+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<d)){const $=a%2===0?Ax(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${$};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,u>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:m+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):$===1?m+=`
                    xC${x+1} = xTexelC${x};
                    `:m+=`
                    xCOffset = xC + ${$};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<d&&(a%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<d&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<d&&(m+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<d&&(m+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<d&&(m+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let g="",y="";r&&(s?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:g=`vec4 activation(vec4 x) {
          ${r}
        }`,y="result = activation(result);");const v=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${y}
        setOutput(result);
      }
    `}}function oCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;c==null&&(c=[1,1]),J(Ai(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=ai(s.shape,i.shape,o,c,a,u,!0);let f;De().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?f=new HG(d):f=new GG(d);const m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(f,[s,i],"float32",m)}const aCe={kernelName:xg,backendName:"webgl",kernelFunc:oCe};class lCe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class uCe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=n-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function cCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=ai(s.shape,c,o,a,l,u,!0),f=new lCe(d);return n.runWebGLProgram(f,[s,i],"float32")}const hCe={kernelName:y0,backendName:"webgl",kernelFunc:cCe};function dCe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=ai(c,i.shape,o,a,l,u,!0),f=new uCe(d);return n.runWebGLProgram(f,[s,i],"float32")}const fCe={kernelName:w0,backendName:"webgl",kernelFunc:dCe};class pCe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function mCe(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],i=Ue(r.shape),o=_t({inputs:{x:r},backend:n,attrs:{shape:[i]}}),a=new pCe(i),l=n.runWebGLProgram(a,[o],o.dtype),u=_t({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const gCe={kernelName:v0,backendName:"webgl",kernelFunc:mCe};class yCe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:d,left:f}=s;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function wCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,u=pw(s.shape,i.shape,o,a,"NHWC",l);let c;const d=new yCe(u);c=n.runWebGLProgram(d,[s,i],"float32");const f=_t({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),f}const vCe={kernelName:_g,backendName:"webgl",kernelFunc:wCe};function bCe(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=Yk(s,i.length);Jk(o.length,l,i);const{path:u,steps:c}=Zk(a,l),d=c.length;let f=null,m=o.length;const g=[];for(let y=0;y<d;++y){for(const v of c[y]){const{permutationIndices:b,expandDims:x}=Qk(m,l[v]);let $;eN(b)?$=i[v]:($=yo({inputs:{x:i[v]},backend:n,attrs:{perm:b}}),g.push($));const S=$.shape.slice();for(let E=0;E<x.length;++E)S.splice(x[E],0,1);zn($.shape,S)||($=_t({inputs:{x:$},backend:n,attrs:{shape:S}}),g.push($)),f===null?f=$:(f=oR({inputs:{a:$,b:f},backend:n}),g.push(f))}y<d-1&&(u[y]>=0&&(f=N4({inputs:{x:f},backend:n,attrs:{axis:u[y]-(o.length-m),keepDims:!1}}),g.push(f)),m--)}for(const y of g)y!==f&&n.disposeIntermediateTensorInfo(y);return f}const xCe={kernelName:x0,backendName:"webgl",kernelFunc:bCe};const _Ce="return (x >= 0.0) ? x : (exp(x) - 1.0);",ICe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,TCe=tr({opSnippet:_Ce,packedOpSnippet:ICe}),SCe={kernelName:Mf,backendName:"webgl",kernelFunc:TCe};const $Ce="return (b >= 0.0) ? a : a * (b + 1.0);",CCe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,ECe=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,i=De().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new V1(CCe,r.shape,s.shape):new ff($Ce,r.shape,s.shape);return n.runWebGLProgram(i,[r,s],r.dtype)},kCe={kernelName:_0,backendName:"webgl",kernelFunc:ECe};const NCe=`
  return vec4(equal(a, b));
`,ACe="return float(a == b);",RCe=Oi({opSnippet:ACe,packedOpSnippet:NCe,dtype:"bool",cpuKernelImpl:uIe}),DCe={kernelName:Ig,backendName:"webgl",kernelFunc:RCe};const OCe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Wk};
  float a1 = ${jk};
  float a2 = ${Gk};
  float a3 = ${Hk};
  float a4 = ${qk};
  float a5 = ${Kk};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,PCe=tr({opSnippet:OCe}),FCe={kernelName:zf,backendName:"webgl",kernelFunc:PCe};const LCe=B1+`
  return exp(x);
`,MCe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qG=tr({opSnippet:LCe,packedOpSnippet:MCe,cpuKernelImpl:cIe,dtype:"float32"}),zCe={kernelName:Vf,backendName:"webgl",kernelFunc:qG};function nC(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(J(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),_t({inputs:{x:i},backend:r,attrs:{shape:a}})}const VCe={kernelName:Tg,backendName:"webgl",kernelFunc:nC};const UP="return exp(x) - 1.0;",BCe=tr({opSnippet:UP,packedOpSnippet:UP,cpuKernelImpl:hIe}),UCe={kernelName:Bf,backendName:"webgl",kernelFunc:BCe};class WP{constructor(e,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function KG(t,e,n){const r=n.texData.get(t.dataId),s=Ue(t.shape),i=t.shape[t.shape.length-1],o=s/i,a=_t({inputs:{x:t},backend:n,attrs:{shape:[o,i]}}),l=a.shape,u=new WP("real",l,e),c=new WP("imag",l,e),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=n.runWebGLProgram(u,d,"float32"),m=n.runWebGLProgram(c,d,"float32"),g=Jh({inputs:{real:f,imag:m},backend:n});n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m);const y=_t({inputs:{x:g},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(g),y}function WCe(t){const{inputs:e,backend:n}=t,{input:r}=e;return KG(r,!1,n)}const jCe={kernelName:I0,backendName:"webgl",kernelFunc:WCe};class GCe{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function r3(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:i}=n;if(i=i||If(s),i==="string"){const o=as(i,Ue(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new GCe(r,s),a=[[s]];return e.runWebGLProgram(o,[],i,a)}}const HCe={kernelName:T0,backendName:"webgl",kernelFunc:r3};class qCe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const KCe={kernelName:S0,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new qCe(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};const jP="return floor(x);",XCe=tr({opSnippet:jP,packedOpSnippet:jP,cpuKernelImpl:dIe}),YCe={kernelName:Uf,backendName:"webgl",kernelFunc:XCe};const QCe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,JCe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,ZCe=Oi({opSnippet:QCe,packedOpSnippet:JCe,dtype:"int32"}),eEe={kernelName:Wf,backendName:"webgl",kernelFunc:ZCe};class tEe{constructor(e){this.variableNames=["A"];const n=vo(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class nEe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=vo(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}const rEe={kernelName:Cy,backendName:"webgl",kernelFunc:sEe};let um,kT=De().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function sEe(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,i];if(a||o){const y=De().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(um==null||y!==kT)&&(kT=y,um=document.createElement("canvas").getContext("2d",{willReadFrequently:kT})),um.canvas.width=l,um.canvas.height=u,um.drawImage(s,0,0,l,u),s=um.canvas}const f=n.makeTensorInfo(c,"int32");n.texData.get(f.dataId).usage=Ta.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),s);const m=De().getBool("WEBGL_PACK")?new nEe(d):new tEe(d),g=n.runWebGLProgram(m,[f],"int32");return n.disposeData(f.dataId),g}function iEe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=r,y=vc(c),v=ai(s.shape,i.shape,l,d,u,f,!1,y);let b;const x=[],$=o!=null,S=a!=null,E=m==="leakyrelu",L=()=>{const D=[s,i],A=(F,P)=>{if(P==="NCHW"&&F.shape.length===1&&F.shape[0]!==1){const K=_t({inputs:{x:F},backend:n,attrs:{shape:[F.shape[0],1,1]}});return x.push(K),K}return F};if($&&D.push(A(o,c)),S&&D.push(A(a,c)),E){const F=n.makeTensorInfo([],"float32",yc(g,"float32"));D.push(F),x.push(F)}return D};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))b=UG({x:s,filter:i,convInfo:v,backend:n,bias:o,activation:m,preluActivationWeights:a,leakyreluAlpha:g});else if(v.strideWidth<=2&&y==="channelsLast"&&De().getBool("WEBGL_EXP_CONV")){const D=m?zy(m,!0):null,A=new BG(v,$,D,S,E),F=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],P=L();b=n.runWebGLProgram(A,P,"float32",F)}else if(De().getBool("WEBGL_CONV_IM2COL"))b=WG({x:s,filter:i,convInfo:v,backend:n,bias:o,activation:m,preluActivationWeights:a,leakyreluAlpha:g});else{const D=m?zy(m,!1):null,A=new VG(v,$,D,S,E),F=L();b=n.runWebGLProgram(A,F,"float32")}const R=_t({inputs:{x:b},backend:n,attrs:{shape:v.outShape}});return x.push(b),x.forEach(D=>n.disposeIntermediateTensorInfo(D)),R}const oEe={kernelName:Fm,backendName:"webgl",kernelFunc:iEe};function aEe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,g=[];let y=c;y==null&&(y=[1,1]),J(Ai(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const v=ai(s.shape,i.shape,l,y,u,d,!0),b=De().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,x=f?zy(f,b):null,$=[s,i],S=o!=null,E=a!=null,L=f==="leakyrelu";if(S&&$.push(o),E&&$.push(a),L){const F=n.makeTensorInfo([],"float32",yc(m,"float32"));$.push(F),g.push(F)}let R;b?R=new HG(v,S,x,E,L):R=new GG(v,S,x,E,L);const D=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],A=n.runWebGLProgram(R,$,"float32",D);return g.forEach(F=>n.disposeIntermediateTensorInfo(F)),A}const lEe={kernelName:Lm,backendName:"webgl",kernelFunc:aEe};class uEe{constructor(e,n,r,s){this.sliceDim=e,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=_r(r.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function cEe(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Ue(r.shape),[l,u,c,d]=J_(r,s),f=_t({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),m=_t({inputs:{x:r},backend:n,attrs:{shape:[Ue(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const b=n.readSync(s.dataId),x=n.bufferSync(r),$=fIe(b,x,r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,$.values)}const g=new uEe(o,d,[u,c],r.shape),y=n.runWebGLProgram(g,[m,f],m.dtype),v=_t({inputs:{x:y},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),v}const hEe={kernelName:$0,backendName:"webgl",kernelFunc:cEe};class dEe{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=_r(this.rank),s=fEe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function fEe(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}function XG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=On(o,s.shape)[0];if(De().get("DEBUG")){const x=n.readSync(i.dataId),$=s.shape[l];for(let S=0;S<x.length;++S){const E=x[S];J(E<=$-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${$-1}]`)}}const u=nN(s,i,l,a),c=Ue(i.shape),d=[],f=_t({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),m=_t({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(f),d.push(m);const g=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const x=n.bufferSync(m),$=n.bufferSync(f),S=pIe($,x,g);return d.forEach(E=>n.disposeIntermediateTensorInfo(E)),n.makeTensorInfo(u.outputShape,S.dtype,S.values)}const y=new dEe(f.shape,g),v=n.runWebGLProgram(y,[f,m],f.dtype);d.push(v);const b=_t({inputs:{x:v},backend:n,attrs:{shape:u.outputShape}});return d.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}const pEe={kernelName:$g,backendName:"webgl",kernelFunc:XG};const mEe="return float(a > b);",gEe=`
  return vec4(greaterThan(a, b));
`,yEe=Oi({opSnippet:mEe,packedOpSnippet:gEe,cpuKernelImpl:mIe,dtype:"bool"}),wEe={kernelName:Cg,backendName:"webgl",kernelFunc:yEe};const vEe="return float(a >= b);",bEe=`
  return vec4(greaterThanEqual(a, b));
`,xEe=Oi({opSnippet:vEe,packedOpSnippet:bEe,dtype:"bool",cpuKernelImpl:gIe}),_Ee={kernelName:jf,backendName:"webgl",kernelFunc:xEe};function IEe(t){const{inputs:e,backend:n}=t,{input:r}=e;return KG(r,!0,n)}const TEe={kernelName:C0,backendName:"webgl",kernelFunc:IEe};const SEe="return float(!isnan(x) && !isinf(x));",$Ee=tr({opSnippet:SEe,dtype:"bool"}),CEe={kernelName:Hf,backendName:"webgl",kernelFunc:$Ee};const EEe="return float(isinf(x));",kEe=tr({opSnippet:EEe,dtype:"bool"}),NEe={kernelName:qf,backendName:"webgl",kernelFunc:kEe};const AEe="return float(isnan(x));",REe=tr({opSnippet:AEe,dtype:"bool"}),DEe={kernelName:Kf,backendName:"webgl",kernelFunc:REe};const OEe="return float(a < b);",PEe=`
  return vec4(lessThan(a, b));
`,FEe=Oi({opSnippet:OEe,packedOpSnippet:PEe,cpuKernelImpl:yIe,dtype:"bool"}),LEe={kernelName:kg,backendName:"webgl",kernelFunc:FEe};const MEe="return float(a <= b);",zEe=`
  return vec4(lessThanEqual(a, b));
`,VEe=Oi({opSnippet:MEe,packedOpSnippet:zEe,cpuKernelImpl:wIe,dtype:"bool"}),BEe={kernelName:Ng,backendName:"webgl",kernelFunc:VEe};function UEe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:i}=n,o=vIe(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const WEe={kernelName:k0,backendName:"webgl",kernelFunc:UEe};const jEe=B1+`
  return x < 0.0 ? 0./0. : log(x);
`,GEe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,HEe=tr({opSnippet:jEe,packedOpSnippet:GEe,cpuKernelImpl:bIe}),qEe={kernelName:Xf,backendName:"webgl",kernelFunc:HEe};const KEe=B1+`
  return log(1.0 + x);
`,XEe=tr({opSnippet:KEe}),YEe={kernelName:Yf,backendName:"webgl",kernelFunc:XEe};const QEe="return float(a >= 1.0 && b >= 1.0);",JEe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,ZEe=Oi({opSnippet:QEe,packedOpSnippet:JEe,dtype:"bool"}),eke={kernelName:Ag,backendName:"webgl",kernelFunc:ZEe};const tke="return float(!(x >= 1.0));",nke=tr({opSnippet:tke}),rke={kernelName:Rg,backendName:"webgl",kernelFunc:nke};const ske="return float(a >= 1.0 || b >= 1.0);",ike=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,oke=Oi({opSnippet:ske,packedOpSnippet:ike,dtype:"bool"}),ake={kernelName:Dg,backendName:"webgl",kernelFunc:oke};class lke{constructor(e,n,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=n,a=e[3]-1;this.outputShape=e;let l;const u=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class uke{constructor(e,n,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=n,a=e[3]-1;this.outputShape=e;let l;const u=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const cke=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r,u=De().getBool("WEBGL_PACK_NORMALIZATION")?new uke(s.shape,i,o,a,l):new lke(s.shape,i,o,a,l);return n.runWebGLProgram(u,[s],s.dtype)},hke={kernelName:Og,backendName:"webgl",kernelFunc:cke};class dke{constructor(e,n,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const fke=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new dke(s.shape,a,l,u,c);return n.runWebGLProgram(d,[s,i,o],s.dtype)},pke={kernelName:N0,backendName:"webgl",kernelFunc:fke};function mke(t,e,n,r){const s=Ue(e),o=Ue(t.shape)/s,a=_t({inputs:{x:t},attrs:{shape:[o,s]},backend:r}),l=Dp(a,t.dtype,"max",r),u=_t({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}function YG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=On(i,s.shape);let u=l;const c=ns(u,a),d=c!=null,f=n.shouldExecuteOnCPU([s]);let m=s;if(d){if(f){const $=n.texData.get(m.dataId).values,S=new Array(a);for(let R=0;R<S.length;R++)S[R]=s.shape[c[R]];const E=sR($,s.shape,s.dtype,c,S);m=n.makeTensorInfo(S,s.dtype);const L=n.texData.get(m.dataId);L.values=E}else m=k4(s,c,n);u=ys(u.length,a)}Ri("max",u,a);const[g,y]=li(m.shape,u);let v=g;o&&(v=gs(g,l));let b;if(f){const $=n.texData.get(m.dataId).values,S=xIe($,Ue(y),v,s.dtype);b=n.makeTensorInfo(v,s.dtype);const E=n.texData.get(b.dataId);E.values=S}else b=mke(m,y,v,n);return d&&n.disposeIntermediateTensorInfo(m),b}const gke={kernelName:Pg,backendName:"webgl",kernelFunc:YG};const yke=iR+`
  return max(a, b);
`,wke=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Rp+`
  return result;
`,vke=Oi({opSnippet:yke,packedOpSnippet:wke,cpuKernelImpl:_Ie}),bke={kernelName:Qf,backendName:"webgl",kernelFunc:vke};function xke(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;P1(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;J(Ai(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=il(s.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&zn(c.inShape,c.outShape))return aa({inputs:{x:s},backend:n});const d=new Vy(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}const _ke={kernelName:Fg,backendName:"webgl",kernelFunc:xke};function Ike(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=wc(s.shape,i,o,c,a,u,l),f=new aR(d,"max",!1);return n.runWebGLProgram(f,[s],s.dtype)}const Tke={kernelName:Lg,backendName:"webgl",kernelFunc:Ike};class Ske{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,u=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class $ke{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=l-1-e.padInfo.front,f=u-1-e.padInfo.top,m=c-1-e.padInfo.left,g=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${f}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Cke(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],f=wc(o.shape,a,l,d,u,c),m=new aR(f,"max",!0),g=n.runWebGLProgram(m,[o],o.dtype),y=new $ke(f),v=n.runWebGLProgram(y,[s,g],o.dtype);return n.disposeIntermediateTensorInfo(g),v}const Eke={kernelName:R0,backendName:"webgl",kernelFunc:Cke};function kke(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i,output:o}=e,a=i;P1([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,f=il(a.shape,l,u,1,c,d),m=!0,g=new Vy(f,"max",m),y=n.runWebGLProgram(g,[a],a.dtype),v=new Ske(f),b=n.runWebGLProgram(v,[s,y],a.dtype);return n.disposeIntermediateTensorInfo(y),b}const Nke={kernelName:A0,backendName:"webgl",kernelFunc:kke};function Ake(t,e,n,r){let s=new Vy(n,"max",!1);const i=r.runWebGLProgram(s,[t],"float32");s=new Vy(n,"max",!0,!0,e);const o=r.runWebGLProgram(s,[t],"float32");return[i,o]}const Rke={kernelName:D0,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=n;J(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];J(Ai(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=il(r.shape,s,i,u,o),[d,f]=Ake(r,a,c,l);return[d,f]}};function Dke(t,e,n,r){const s=Ue(e),o=Ue(t.shape)/s,a=_t({inputs:{x:t},attrs:{shape:[o,s]},backend:r}),l=Dp(a,"float32","mean",r),u=_t({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}const Oke={kernelName:Mg,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:i}=e,o=n,a=r.shape.length,l=On(i,r.shape);let u=l;const c=ns(u,a),d=c!=null,f=o.shouldExecuteOnCPU([r]),m=[];let g=r;if(d){if(f){const S=o.texData.get(g.dataId).values,E=new Array(a);for(let D=0;D<E.length;D++)E[D]=r.shape[c[D]];const L=sR(S,r.shape,r.dtype,c,E);g=o.makeTensorInfo(E,r.dtype);const R=o.texData.get(g.dataId);R.values=L}else g=k4(r,c,o);m.push(g),u=ys(u.length,a)}Ri("sum",u,a);const[y,v]=li(g.shape,u);let b=y;s&&(b=gs(y,l));const x=Dke(g,v,b,o);for(const $ of m)o.disposeIntermediateTensorInfo($);return x}};function Pke(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=On(i,s.shape);let u=l;const c=ns(u,a);let d=s;c!=null&&(d=yo({inputs:{x:s},backend:n,attrs:{perm:c}}),u=ys(u.length,s.shape.length)),Ri("min",u,a);const[f,m]=li(d.shape,u),g=Ue(m),y=_t({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),v=Dp(y,y.dtype,"min",n);let b;if(o){const x=gs(f,l);b=_t({inputs:{x:v},backend:n,attrs:{shape:x}})}else b=_t({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),c!=null&&n.disposeIntermediateTensorInfo(d),b}const Fke={kernelName:zg,backendName:"webgl",kernelFunc:Pke};const Lke=iR+`
  return min(a, b);
`,Mke=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Rp+`
  return result;
`,zke=Oi({opSnippet:Lke,packedOpSnippet:Mke,cpuKernelImpl:IIe}),Vke={kernelName:Jf,backendName:"webgl",kernelFunc:zke};class Bke{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((c,d)=>c[0]+e[d]+c[1]);const s=e.length,i=_r(s),o=n.map(c=>c[0]).join(","),a=n.map((c,d)=>c[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class Uke{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((g,y)=>g[0]+e[y]+g[1]);const s=e.length,i=_r(s),o=n.map(g=>g[0]).join(","),a=n.map((g,y)=>g[0]+e[y]).join(","),l=ho("rc",s),u=ho("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,f=r==="reflect"?0:1;let m="";if(s===1){const g=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;m=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
      `}else{const g=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;m=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${g}
          result[2] = getChannel(getX(${u.join()}), ${d});
          ${l[s-1]} += 1;
          if(${c}) {
            ${g}
            result[3] = getChannel(getX(${u.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}const Wke=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:i}=n,o=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uke(r.shape,s,i):new Bke(r.shape,s,i);return e.runWebGLProgram(o,[r],r.dtype)},jke={kernelName:Vg,backendName:"webgl",kernelFunc:Wke};const Gke=`if (b == 0.0) return NAN;
  return mod(a, b);`,Hke=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Rp+`
  return result;
`,qke=Oi({opSnippet:Gke,packedOpSnippet:Hke}),Kke={kernelName:Zf,backendName:"webgl",kernelFunc:qke};class Xke{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}const Yke=`
if (a == b) {
  return 1.0;
};
return a / b;`,Qke=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,QG=Oi({opSnippet:Yke,packedOpSnippet:Qke,checkOutOfBounds:!0}),Jke={kernelName:Lf,backendName:"webgl",kernelFunc:QG};const GP="return a - b;",JG=Oi({opSnippet:GP,packedOpSnippet:GP,supportsComplex:!0,cpuKernelImpl:jIe}),Zke={kernelName:mp,backendName:"webgl",kernelFunc:JG};function ZG(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:i}=r,o=On([i],s.shape),a=YG({inputs:{x:s},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=gs(a.shape,o),u=_t({inputs:{x:a},backend:n,attrs:{shape:l}}),c=JG({inputs:{a:s,b:u},backend:n}),d=qG({inputs:{x:c},backend:n}),f=N4({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),m=_t({inputs:{x:f},backend:n,attrs:{shape:l}}),g=QG({inputs:{a:d,b:m},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const eNe={kernelName:s1,backendName:"webgl",kernelFunc:ZG};function tNe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:ZG({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new Xke(u,c,i),f=[[o]],m=n.runWebGLProgram(d,[l],"int32",f);return a||n.disposeIntermediateTensorInfo(l),m}const nNe={kernelName:O0,backendName:"webgl",kernelFunc:tNe};const rNe=ll+`
  return -x;
`,sNe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function iNe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const i=n.texData.get(r.dataId),[o,a]=SIe(i.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,o)}let s;return De().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new lh(r.shape,sNe):s=new au(r.shape,rNe),n.runWebGLProgram(s,[r],r.dtype)}const oNe={kernelName:Bg,backendName:"webgl",kernelFunc:iNe};const aNe=V_;function lNe(t){_a("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(i.dataId),{selectedIndices:d}=aNe(u,c,o,a,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const uNe={kernelName:P0,backendName:"webgl",kernelFunc:lNe};const cNe=B_;function hNe(t){_a("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(i.dataId),{selectedIndices:f,validOutputs:m}=cNe(c,d,o,a,l,u);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([m]))]}const dNe={kernelName:F0,backendName:"webgl",kernelFunc:hNe};const fNe=U_;function pNe(t){_a("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(i.dataId),f=o,m=a,g=l,y=u,{selectedIndices:v,selectedScores:b}=fNe(c,d,f,m,g,y);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const mNe={kernelName:L0,backendName:"webgl",kernelFunc:pNe};class gNe{constructor(e,n,r,s){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}const yNe=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,u=Ue(s.shape),c=new gNe(u,o,a,l),d=_t({inputs:{x:s},backend:n,attrs:{shape:[u]}}),f=n.runWebGLProgram(c,[d],i);n.disposeIntermediateTensorInfo(d);const m=[...s.shape,o],g=_t({inputs:{x:f},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(f),g},wNe={kernelName:jg,backendName:"webgl",kernelFunc:yNe};function rx(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=n3({inputs:{input:r},backend:n}),i=rx({inputs:{x:s},backend:n}),o=A4({inputs:{input:r},backend:n}),a=rx({inputs:{x:o},backend:n}),l=Jh({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return r3({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const vNe={kernelName:l1,backendName:"webgl",kernelFunc:rx};function eH(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=n3({inputs:{input:r},backend:n}),i=eH({inputs:{x:s},backend:n}),o=A4({inputs:{input:r},backend:n}),a=rx({inputs:{x:o},backend:n}),l=Jh({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return r3({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const bNe={kernelName:Wg,backendName:"webgl",kernelFunc:eH};function xNe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return nC({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{Ni(i,c.shape,"All tensors passed to stack must have matching shapes"),J(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const d=nC({inputs:{input:c},backend:n,attrs:{dim:s}});return a.push(d),d}),u=zG({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const _Ne={kernelName:Gg,backendName:"webgl",kernelFunc:xNe};class INe{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+e[c]+u[1]);const s=e.length,i=_r(s),o=n.map(u=>u[0]).join(","),a=n.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class TNe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((y,v)=>y[0]+e[v]+y[1]);const s=e.length,i=_r(s),o=n.map(y=>y[0]).join(","),a=n.map((y,v)=>y[0]+e[v]).join(","),l=ho("rc",s),u=ho("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,f=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${c}) {`],m=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let y=0,v=s===1?2:4;y<v;y++)g+=`
        ${f[y]}
        if (${m}) {
          result[${y}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${y}] = getChannel(getX(${u.join()}), ${d});
        }
      `;g+=s===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}const tH=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:i,constantValue:o}=r;if(Ue(s.shape)===0){const u=i.map((c,d)=>c[0]+s.shape[d]+c[1]);return r3({backend:n,attrs:{shape:u,value:o,dtype:s.dtype}})}const a=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TNe(s.shape,i,o):new INe(s.shape,i,o),l=[[o]];return n.runWebGLProgram(a,[s],s.dtype,l)},SNe={kernelName:Hg,backendName:"webgl",kernelFunc:tH};const $Ne=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,CNe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Rp+`
  return result;
`,ENe=Oi({opSnippet:$Ne,packedOpSnippet:CNe}),kNe={kernelName:tp,backendName:"webgl",kernelFunc:ENe};function NNe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],u=On(i,s.shape);let c=u;const d=ns(c,a);let f=s;d!=null&&(f=yo({inputs:{x:s},backend:n,attrs:{perm:d}}),c=ys(c.length,a),l.push(f)),Ri("prod",c,a);let m;if(n.shouldExecuteOnCPU([f])){const g=n.texData.get(f.dataId).values,{outVals:y,outShape:v,outDtype:b}=CIe(f.shape,f.dtype,g,c);m=n.makeTensorInfo(v,b,y)}else{const[g,y]=li(f.shape,c),v=Ue(y),b=_t({inputs:{x:f},backend:n,attrs:{shape:[-1,v]}}),x=cw(s.dtype),$=Dp(b,x,"prod",n);m=_t({inputs:{x:$},backend:n,attrs:{shape:g}}),l.push(b),l.push($)}if(o){l.push(m);const g=gs(m.shape,u);m=_t({inputs:{x:m},backend:n,attrs:{shape:g}})}return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const ANe={kernelName:Kg,backendName:"webgl",kernelFunc:NNe};function RNe(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=r,l=s.map(b=>n.readSync(b.dataId)),u=s.map(b=>b.shape),c=n.readSync(i.dataId),d=n.readSync(o.dataId),[f,m,g]=EIe(l,u,c,i.shape,i.dtype,d,o.shape,a),y=f.map(b=>n.makeTensorInfo([b.length],"int32",b)),v=n.makeTensorInfo(g,i.dtype,m);return y.concat([v])}const DNe={kernelName:M0,backendName:"webgl",kernelFunc:RNe};function ONe(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:i}=e,o=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(i.dataId),[u,c]=kIe(o,r.shape,r.dtype,a,s.shape,l,i.shape),d=n.makeTensorInfo([u.length],"int32",u),f=n.makeTensorInfo([c.length],r.dtype,c);return[d,f]}const PNe={kernelName:z0,backendName:"webgl",kernelFunc:ONe};function FNe(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(i.dataId),d=n.readSync(o.dataId),f=a.map(v=>n.readSync(v.dataId)),m=a.map(v=>v.shape),[g,y]=NIe(u,s.shape,c,i.shape,i.dtype,d,o.shape,f,m,l);return n.makeTensorInfo(g,i.dtype,y)}const LNe={kernelName:V0,backendName:"webgl",kernelFunc:FNe};const nH=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:i,dtype:o}=n,a=AIe(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},MNe={kernelName:B0,backendName:"webgl",kernelFunc:nH};const zNe="return 1.0 / x;",VNe=tr({opSnippet:zNe}),BNe={kernelName:np,backendName:"webgl",kernelFunc:VNe};const UNe=ll+`
  return (x < 0.0) ? 0.0 : x;
`,WNe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,jNe=tr({opSnippet:UNe,packedOpSnippet:WNe}),GNe={kernelName:rp,backendName:"webgl",kernelFunc:jNe};const HNe=ll+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,qNe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,KNe=tr({opSnippet:HNe,packedOpSnippet:qNe}),XNe={kernelName:sp,backendName:"webgl",kernelFunc:KNe};class YNe{constructor(e,n,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,r,u];const c=[s&&n>1?a-1:a,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let f;i?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class QNe{constructor(e,n,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,r,u];const c=[s&&n>1?a-1:a,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let f;i?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function JNe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,u]=a,c=De().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new QNe(s.shape,l,u,i,o):new YNe(s.shape,l,u,i,o);return n.runWebGLProgram(c,[s],"float32")}const ZNe={kernelName:Qg,backendName:"webgl",kernelFunc:JNe};class eAe{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,i]=n,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],u=[r&&o>1?o-1:o,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],f=1/c,m=1/d,g=Math.ceil(f)*2+2,y=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function tAe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:o}=r,a=new eAe(i.shape,s.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}const nAe={kernelName:j0,backendName:"webgl",kernelFunc:tAe};class rAe{constructor(e,n,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,r,u];const c=[s&&n>1?a-1:a,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],f=s?"0.5":"0.0";let m;i?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class sAe{constructor(e,n,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,n,r,u];const c=[s&&n>1?a-1:a,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],f=s?"0.5":"0.0";let m;i?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function iAe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,u]=a,c=De().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sAe(s.shape,l,u,i,o):new rAe(s.shape,l,u,i,o);return n.runWebGLProgram(c,[s],s.dtype)}const oAe={kernelName:Yg,backendName:"webgl",kernelFunc:iAe};class aAe{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,i]=n,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],u=[r&&o>1?o-1:o,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],f=1/c,m=1/d,g=Math.ceil(f)*2+2,y=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function lAe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:o}=r,a=new aAe(i.shape,s.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}const uAe={kernelName:W0,backendName:"webgl",kernelFunc:lAe};class cAe{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>s(l)).join(","),o=_r(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class hAe{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=ho("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=_r(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${i}){
            result.g = ${u(s.slice())};
          }
          if(${o}) {
            result.b = ${c(s.slice())};
            if(${i}) {
              result.a = ${d(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(g){return f(g)}function u(g){return g[r-1]="("+g[r-1]+" + 1)",f(g)}function c(g){return g[r-2]="("+g[r-2]+" + 1)",f(g)}function d(g){return g[r-1]="("+g[r-1]+" + 1)",g[r-2]="("+g[r-2]+" + 1)",f(g)}function f(g){const y=e.map((x,$)=>m($,g)),v=y.join(","),b=y.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${b}))`}function m(g,y){return n.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${y[g]} - 1`:`${y[g]}`}}}function dAe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:i}=r,o=s.shape.length,a=On(i,s.shape);if(o===0)return aa({inputs:{x:s},backend:n});const l=De().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hAe(s.shape,a):new cAe(s.shape,a);return n.runWebGLProgram(l,[s],s.dtype)}const fAe={kernelName:Jg,backendName:"webgl",kernelFunc:dAe};class pAe{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let i="";typeof n=="number"?i=`float outputValue = ${n.toFixed(2)};`:i=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const mAe={kernelName:aw,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:i,center:o}=e,a=n,l=new pAe(r.shape,i),[u,c]=Vk(o,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}};const gAe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,yAe=tr({opSnippet:gAe}),wAe={kernelName:ip,backendName:"webgl",kernelFunc:yAe};const vAe="return inversesqrt(x);",bAe=tr({opSnippet:vAe,cpuKernelImpl:RIe}),xAe={kernelName:op,backendName:"webgl",kernelFunc:bAe};class lR{constructor(e,n,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const u=_r(i.length),c=_r(o.length);let d="";r===1?d="i":r===2&&(d="i, j");const f=`getIndices(${d})`;let m="";s===1?m="i":s===2&&(m="i, coords[1]");const g=`getUpdates(${m})`;let y="";l&&(y="coords[0], coords[1]");const v=`getDefaultValue(${y})`,b=n>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}}class _Ae{constructor(e,n,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const u=_r(i.length),c=_r(o.length);let d="";r===1?d="i":r===2&&(d="i, j");const f=`getIndices(${d})`;let m="";s===1?m="i":s===2&&(m="i, coords[1]");const g=`getUpdates(${m})`;let y="";l&&(y="coords[0], coords[1]");const v=`getDefaultValue(${y})`,b=n>1?"strides[j]":"strides",x=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}}function IAe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Yh(i,s,o),f=[d/u,u];if(d===0)return n.makeTensorInfo(o,s.dtype);const m=_t({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),g=_t({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),y=n.makeTensorInfo([],"float32",new Float32Array([0]));let v;De().getBool("WEBGL_PACK")?v=new _Ae(l,a,m.shape.length,g.shape.length,c,f):v=new lR(l,a,m.shape.length,g.shape.length,c,f);const b=n.runWebGLProgram(v,[g,m,y],g.dtype),x=_t({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),x}const TAe={kernelName:G0,backendName:"webgl",kernelFunc:IAe};class SAe{constructor(e,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=De().getNumber("WEBGL_VERSION")===2?i:o,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function $Ae(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:i}=e,{side:o}=r,a=new SAe(s.shape[0],s.shape[1],i.shape[1],o),l=[[s.shape[1]]];return n.runWebGLProgram(a,[s,i],"int32",l)}const CAe={kernelName:q0,backendName:"webgl",kernelFunc:$Ae};class EAe{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,i;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${a[c]}`),c<e&&l.push(`${a[c]}`);s=l.join(),i=u.join()}const o=_r(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function kAe(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:i}=e,o=new EAe(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(o,[r,s,i],go(s.dtype,i.dtype))}const NAe={kernelName:Zg,backendName:"webgl",kernelFunc:kAe};const AAe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${n4};
  float scale = ${r4};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,RAe=tr({opSnippet:AAe}),DAe={kernelName:ap,backendName:"webgl",kernelFunc:RAe};const OAe=B1+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,PAe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,FAe=tr({opSnippet:OAe,packedOpSnippet:PAe,cpuKernelImpl:OIe}),LAe={kernelName:hp,backendName:"webgl",kernelFunc:FAe};const MAe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,zAe=tr({opSnippet:MAe}),VAe={kernelName:cp,backendName:"webgl",kernelFunc:zAe};const BAe=B1+`
  return sin(x);
`,UAe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Rp}
  return result;
`,WAe=tr({opSnippet:BAe,packedOpSnippet:UAe}),jAe={kernelName:lp,backendName:"webgl",kernelFunc:WAe};const GAe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,HAe=tr({opSnippet:GAe}),qAe={kernelName:up,backendName:"webgl",kernelFunc:HAe};const KAe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,XAe=tr({opSnippet:KAe}),YAe={kernelName:dp,backendName:"webgl",kernelFunc:XAe};const QAe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,paddings:o}=r;J(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=[[0,0]];l.push(...o);for(let b=1+i.length;b<s.shape.length;++b)l.push([0,0]);const u=[],c=tH({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=zw(c.shape,i,a,!1),f=Vw(d.length,i.length,!1),m=Bw(c.shape,i,a,!1),g=_t({inputs:{x:c},backend:n,attrs:{shape:d}}),y=yo({inputs:{x:g},backend:n,attrs:{perm:f}}),v=_t({inputs:{x:y},backend:n,attrs:{shape:m}});return u.push(c),u.push(g),u.push(y),u.forEach(b=>n.disposeIntermediateTensorInfo(b)),v},JAe={kernelName:n1,backendName:"webgl",kernelFunc:QAe};function ZAe(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(i.dataId),c=n.readSync(o.dataId)[0],[d,f,m,g,y]=FIe(a,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([f[0]],s.dtype,m),n.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(v=>Number(v)))),n.makeTensorInfo([y.length],r.dtype,new Int32Array(y))]}const eRe={kernelName:K0,backendName:"webgl",kernelFunc:ZAe};function tRe(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.readSync(s.dataId)),a=n.readSync(r.dataId),l=Array.from(n.readSync(i.dataId)),[u,c,d]=LIe(a,r.shape,r.dtype,o,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}const nRe={kernelName:X0,backendName:"webgl",kernelFunc:tRe};function rRe(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(i.dataId),[u,c]=TG(o,r.shape,r.dtype,a,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const sRe={kernelName:Y0,backendName:"webgl",kernelFunc:rRe};function iRe(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(i.dataId),[u,c]=TG(o,r.shape,r.dtype,a,l);return n.makeTensorInfo(c,r.dtype,u)}const oRe={kernelName:Q0,backendName:"webgl",kernelFunc:iRe};function aRe(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:f}=Yh(i,s,a),m=!1;if(i.dtype==="string"){const b=n.bufferSync(s),x=n.bufferSync(i),$=oc(n.readSync(o.dataId)[0]),S=DIe(b,x,a,f,c,u,l,d,$,m);return n.makeTensorInfo(a,S.dtype,S.values)}const g=new lR(u,l,s.shape.length,i.shape.length,d,[f,1],m),y=n.runWebGLProgram(g,[i,s,o],i.dtype),v=_t({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(y),v}const lRe={kernelName:J0,backendName:"webgl",kernelFunc:aRe};function uRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=On(o,s.shape)[0],l=tN(s,i,a),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(f=>{const m=[...d];m[a]=f;const g=U1({inputs:{x:s},backend:n,attrs:{begin:c,size:m}});return c[a]+=f,g})}const cRe={kernelName:r1,backendName:"webgl",kernelFunc:uRe};const HP="return sqrt(x);",hRe=tr({opSnippet:HP,packedOpSnippet:HP,cpuKernelImpl:MIe}),dRe={kernelName:fp,backendName:"webgl",kernelFunc:hRe};const fRe="return x * x;",pRe=tr({opSnippet:fRe}),mRe={kernelName:Z0,backendName:"webgl",kernelFunc:pRe};const qP="return (a - b) * (a - b);",gRe=Oi({opSnippet:qP,packedOpSnippet:qP}),yRe={kernelName:pp,backendName:"webgl",kernelFunc:gRe};function wRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const i=n.readSync(s.dataId),o=hc(i),a=zIe(o,"string",r);return n.makeTensorInfo(s.shape,"string",a)}const vRe={kernelName:i1,backendName:"webgl",kernelFunc:wRe};function bRe({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=ll+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new au(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}const xRe={kernelName:vp,backendName:"webgl",kernelFunc:bRe};class _Re{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=_r(r.length),o=_r(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${n});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}function IRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:f}=r,{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:v,isSimpleSlice:b,begin:x,end:$,strides:S}=Ok(s.shape,i,o,a,l,u,c,d,f);let E;if(y)E=_t({inputs:{x:s},backend:n,attrs:{shape:g}});else if(v||b){J(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const R=Ak(x,$,S),D=U1({inputs:{x:s},backend:n,attrs:{begin:x,size:R}});E=_t({inputs:{x:D},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(D)}else if(n.shouldExecuteOnCPU([s])){const D=n.readSync(s.dataId),A=En(s.shape,s.dtype,D),F=VIe(m,A,S,x);E=n.makeTensorInfo(g,s.dtype,F.values)}else{const D=new _Re(x,S,m);E=n.runWebGLProgram(D,[s],s.dtype)}const L=_t({inputs:{x:E},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(E),L}const TRe={kernelName:ew,backendName:"webgl",kernelFunc:IRe};function SRe(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=e,f=n.readSync(c.dataId),m=n.readSync(d.dataId),[g,y]=BIe(f,m,s,i,o,a,l,u);return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(d.shape,"int32",y)]}const $Re={kernelName:tw,backendName:"webgl",kernelFunc:SRe};function CRe(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.readSync(i.dataId),l=n.readSync(o.dataId)[0],[u,c,d]=UIe(a,l,s),f=c.length;return[n.makeTensorInfo([f,2],"int32",u),n.makeTensorInfo([f],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const ERe={kernelName:nw,backendName:"webgl",kernelFunc:CRe};function kRe(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(i.dataId),a=WIe(o,s);return n.makeTensorInfo(i.shape,"int32",a)}const NRe={kernelName:rw,backendName:"webgl",kernelFunc:kRe};const ARe="return tan(x);",RRe=tr({opSnippet:ARe}),DRe={kernelName:gp,backendName:"webgl",kernelFunc:RRe};const ORe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,PRe=tr({opSnippet:ORe}),FRe={kernelName:yp,backendName:"webgl",kernelFunc:PRe};function LRe(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Yh(o,i,s.shape),f=[d/u,u];if(d===0)return n.makeTensorInfo(s.shape,i.dtype);const m=_t({inputs:{x:i},backend:n,attrs:{shape:[l,a]}}),g=_t({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),y=_t({inputs:{x:s},backend:n,attrs:{shape:f}}),v=new lR(l,a,m.shape.length,g.shape.length,c,f,!1,!0),b=n.runWebGLProgram(v,[g,m,y],y.dtype),x=_t({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}const MRe={kernelName:H0,backendName:"webgl",kernelFunc:LRe};class zRe{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*n[o];this.outputShape=r,this.rank=r.length;const s=_r(this.rank),i=VRe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function VRe(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}function rH(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:i}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),u=s.dtype==="string"?l.map(f=>oc(f)):l,c=En(s.shape,s.dtype,u),d=GIe(c,i);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new zRe(s.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}const BRe={kernelName:wp,backendName:"webgl",kernelFunc:rH};class URe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class WRe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function pd(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function KP(t){let e=1;for(;e<t;)e*=2;return e}function jRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:i,sorted:o}=r,a=De().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=De().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<a||i>l){const F=n.readSync(s.dataId),[P,K]=HIe(F,u,s.dtype,i,o);return[n.makeTensorInfo(P.shape,P.dtype,P.values),n.makeTensorInfo(K.shape,K.dtype,K.values)]}if(i===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,r3({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),f=d!==null&&d.isPacked,m=f?n.unpackTensor(s):s,y=Ue(u)/c,v=_t({inputs:{x:m},attrs:{shape:[y,c]},backend:n});f&&pd(n,m);const b=KP(i),x=KP(c);let $=null;const S=()=>$===null?[v,v]:[v,$],E=(F,P,K)=>{const j=S(),se=new URe(K),me=[[c],[$===null?1:0],[Number.NEGATIVE_INFINITY],[F],[P]],ye=$;$=n.runWebGLProgram(se,j,"int32",me),pd(n,ye)};for(let F=1;F<b;F*=2){const P=F*2;for(let K=F;K>=1;K/=2)E(P,K,[y,x])}for(let F=x;F>b;F/=2){const P=S(),K=new WRe([y,F/2]),se=[[c],[$===null?1:0],[b]],fe=$;$=n.runWebGLProgram(K,P,"int32",se),pd(n,fe);const me=b/2,ye=me*2;for(let oe=me;oe>=1;oe/=2)E(ye,oe,$.shape)}let L=$;$=U1({inputs:{x:$},backend:n,attrs:{begin:0,size:[y,i]}}),pd(n,L);let R=XG({inputs:{x:v,indices:$},backend:n,attrs:{axis:1,batchDims:1}});pd(n,v);const D=u.slice(0,-1);D.push(i),L=$,$=_t({inputs:{x:$},attrs:{shape:D},backend:n}),pd(n,L);const A=R;return R=_t({inputs:{x:R},attrs:{shape:D},backend:n}),pd(n,A),[R,$]}const GRe={kernelName:sw,backendName:"webgl",kernelFunc:jRe};class HRe{constructor(e,n,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function qRe(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,f,m]=s.shape,[g,y]=u??[d,f],v=[c,g,y,m],b=new HRe(d,f,o,a,l,v);return n.runWebGLProgram(b,[s,i],"float32")}const KRe={kernelName:iw,backendName:"webgl",kernelFunc:qRe};function XRe(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:i}=e;P1(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:u}=qIe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}const YRe={kernelName:ow,backendName:"webgl",kernelFunc:XRe};function QRe(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],u=new Array(a-1);let c=0;for(let y=0;y<a;y++)y!==i&&(u[c++]=o.shape[y]);const d=[],f=new Array(a).fill(0),m=o.shape.slice();m[i]=1;const g=new Array(l);for(let y=0;y<g.length;y++){f[i]=y;const v=U1({inputs:{x:o},backend:n,attrs:{begin:f,size:m}}),b=_t({inputs:{x:v},backend:n,attrs:{shape:u}});g[y]=b,d.push(v)}return d.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const JRe={kernelName:o1,backendName:"webgl",kernelFunc:QRe};class ZRe{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const l="0.0",u="sumValue",c=Math.floor(r/4)*4,d=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let m="";i%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let g="";i%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `}}function e6e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let u=0;const c=ns([u],a);let d=s;c!=null&&(d=yo({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=ys(1,a)[0]);const f=RB(d.shape,u,o),m=Ue([d.shape[u]]),g=_t({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}});l.push(g);const y=cw(s.dtype),v=(S,E,L,R,D)=>{const A=S.shape[0],F=S.shape[1],P=AB(F,D),K={windowSize:P,inSize:F,batchSize:A,numSegments:D},j=new ZRe(K,E),se=n.compileAndRun(j,[S,L],R);if(l.push(se),se.shape[1]===D)return se;const fe=nH({backend:n,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),me=rH({inputs:{x:fe},backend:n,attrs:{reps:[F/P]}});return l.push(fe),l.push(me),v(se,E,me,R,D)},b=v(g,"unsortedSegmentSum",i,y,o),x=_t({inputs:{x:b},backend:n,attrs:{shape:f}});let $=x;if(c!=null){l.push(x);const S=qh(c);$=yo({inputs:{x:$},backend:n,attrs:{perm:S}})}return l.forEach(S=>n.disposeIntermediateTensorInfo(S)),$}const t6e={kernelName:a1,backendName:"webgl",kernelFunc:e6e};const n6e=[zTe,BTe,jTe,qTe,XTe,JTe,eSe,nSe,oSe,lSe,hSe,pSe,ySe,xSe,TSe,$Se,ESe,RSe,OSe,FSe,VSe,qSe,XSe,ZSe,t$e,a$e,u$e,f$e,_Te,g$e,x$e,S$e,A$e,O$e,F$e,M$e,V$e,j$e,q$e,Y$e,J$e,eCe,nCe,iCe,aCe,hCe,fCe,gCe,vCe,xCe,SCe,kCe,DCe,FCe,zCe,VCe,UCe,jCe,HCe,KCe,YCe,eEe,rEe,oEe,lEe,hEe,pEe,wEe,_Ee,xTe,TEe,v$e,CEe,NEe,DEe,TTe,LEe,BEe,WEe,qEe,YEe,eke,rke,ake,hke,pke,gke,bke,_ke,Tke,Eke,Nke,Rke,Oke,Fke,Vke,jke,Kke,nNe,CTe,oNe,uNe,dNe,mNe,r$e,wNe,bNe,_Ne,SNe,kNe,$Te,ANe,DNe,PNe,LNe,MNe,s$e,Jke,BNe,GNe,XNe,kTe,ZNe,nAe,oAe,uAe,fAe,mAe,wAe,xAe,TAe,CAe,NAe,DAe,LAe,VAe,jAe,qAe,GSe,eNe,YAe,JAe,eRe,nRe,sRe,oRe,lRe,cRe,dRe,mRe,yRe,vRe,xRe,TRe,$Re,ERe,NRe,Zke,FTe,DRe,FRe,MRe,BRe,GRe,KRe,LTe,YRe,JRe,t6e,vNe];for(const t of n6e)lw(t);const r6e="4.22.0";const s6e={"tfjs-core":Fk,"tfjs-backend-cpu":fj,"tfjs-backend-webgl":CG,"tfjs-data":yW,"tfjs-layers":g4,"tfjs-converter":OA,tfjs:r6e},NT=Object.freeze(Object.defineProperty({__proto__:null,Abs:og,Acos:Sf,Acosh:$f,AdadeltaOptimizer:j_,AdagradOptimizer:G_,AdamOptimizer:H_,AdamaxOptimizer:q_,Add:Uh,AddN:ag,All:r0,Any:s0,ArgMax:lg,ArgMin:ug,Asin:Cf,Asinh:Ef,Atan:kf,Atan2:Af,Atanh:Nf,AvgPool:cg,AvgPool3D:hg,AvgPool3DGrad:o0,AvgPoolGrad:i0,BatchMatMul:dg,BatchToSpaceND:fg,Bincount:a0,BitwiseAnd:pg,BroadcastArgs:l0,BroadcastTo:pE,Callback:KU,CallbackList:QB,Cast:Rf,Ceil:Df,ClipByValue:Of,Complex:u0,ComplexAbs:mg,Concat:gg,Conv2D:yg,Conv2DBackpropFilter:c0,Conv2DBackpropInput:wg,Conv3D:vg,Conv3DBackpropFilterV2:h0,Conv3DBackpropInputV2:d0,Cos:Pf,Cosh:Ff,CropAndResize:p0,Cumprod:f0,Cumsum:bg,CustomCallback:ZB,DataStorage:Nx,DenseBincount:m0,DepthToSpace:g0,DepthwiseConv2dNative:xg,DepthwiseConv2dNativeBackpropFilter:y0,DepthwiseConv2dNativeBackpropInput:w0,Diag:v0,Dilation2D:_g,Dilation2DBackpropFilter:$y,Dilation2DBackpropInput:Sy,Draw:b0,get ENV(){return Dx},EarlyStopping:XU,Einsum:x0,Elu:Mf,EluGrad:_0,Environment:dE,Equal:Ig,Erf:zf,Exp:Vf,ExpandDims:Tg,Expm1:Bf,FFT:I0,Fill:T0,FlipLeftRight:S0,Floor:Uf,FloorDiv:Wf,FromPixels:Cy,FusedBatchNorm:Sg,FusedConv2D:Fm,FusedDepthwiseConv2D:Lm,GPGPUContext:ob,GatherNd:$0,GatherV2:$g,GraphModel:T4,Greater:Cg,GreaterEqual:jf,History:JB,IFFT:C0,Identity:Gf,Imag:E0,InputSpec:Ss,IsFinite:Hf,IsInf:qf,IsNan:Kf,KernelBackend:n0,LRN:Og,LRNGrad:N0,LayerVariable:qB,LayersModel:ec,LeakyRelu:Eg,Less:kg,LessEqual:Ng,LinSpace:k0,Log:Xf,Log1p:Yf,LogSoftmax:mE,LogicalAnd:Ag,LogicalNot:Rg,LogicalOr:Dg,LogicalXor:Ez,LowerBound:kz,MathBackendCPU:Qw,MathBackendWebGL:t3,MatrixBandPart:Nz,Max:Pg,MaxPool:Fg,MaxPool3D:Lg,MaxPool3DGrad:R0,MaxPoolGrad:A0,MaxPoolWithArgmax:D0,Maximum:Qf,Mean:Mg,Min:zg,Minimum:Jf,MirrorPad:Vg,Mod:Zf,MomentumOptimizer:K_,Multinomial:O0,Multiply:ep,Neg:Bg,NonMaxSuppressionV3:P0,NonMaxSuppressionV4:F0,NonMaxSuppressionV5:L0,NotEqual:Ug,OP_SCOPE_SUFFIX:Px,OneHot:jg,OnesLike:Wg,Optimizer:Eu,OptimizerConstructors:Lk,Pack:Gg,PadV2:Hg,Pool:Az,Pow:tp,Prelu:qg,Prod:Kg,RMSPropOptimizer:X_,RNN:ql,RaggedGather:M0,RaggedRange:z0,RaggedTensorToTensor:V0,Range:B0,get Rank(){return Ob},Real:U0,RealDiv:Lf,Reciprocal:np,get Reduction(){return ji},Relu:rp,Relu6:sp,Reshape:Xg,ResizeBilinear:Qg,ResizeBilinearGrad:j0,ResizeNearestNeighbor:Yg,ResizeNearestNeighborGrad:W0,Reverse:Jg,RotateWithOffset:aw,Round:ip,Rsqrt:op,SGDOptimizer:Mw,ScatterNd:G0,SearchSorted:q0,Select:Zg,Selu:ap,Sequential:af,Sigmoid:hp,Sign:cp,Sin:lp,Sinh:up,Slice:e1,Softmax:s1,Softplus:dp,SpaceToBatchND:n1,SparseFillEmptyRows:K0,SparseReshape:X0,SparseSegmentMean:Y0,SparseSegmentSum:Q0,SparseToDense:J0,SplitV:r1,Sqrt:fp,Square:Z0,SquaredDifference:pp,StaticRegexReplace:i1,Step:vp,StridedSlice:ew,StringNGrams:tw,StringSplit:nw,StringToHashBucketFast:rw,Sub:mp,Sum:t1,SymbolicTensor:Bl,Tan:gp,Tanh:yp,Tensor:Rn,TensorBuffer:ms,TensorScatterUpdate:H0,Tile:wp,TopK:sw,Transform:iw,Transpose:ph,Unique:ow,Unpack:o1,UnsortedSegmentSum:a1,UpperBound:Rz,Variable:Vm,ZerosLike:l1,_FusedMatMul:Pm,abs:fs,acos:zx,acosh:Vx,add:tt,addN:SE,all:fw,any:Um,argMax:Nh,argMin:Bx,asin:Ux,asinh:Wx,atan:jx,atan2:Gx,atanh:Hx,avgPool:u1,avgPool3d:qx,backend:Lx,backend_util:rN,basicLSTMCell:CE,batchNorm:bp,batchNorm2d:Kx,batchNorm3d:Xx,batchNorm4d:Yx,batchToSpaceND:c1,bincount:Qx,bitwiseAnd:EE,booleanMaskAsync:fk,broadcastArgs:kE,broadcastTo:gh,broadcast_util:$V,browser:eB,buffer:En,callbacks:l2e,cast:gt,ceil:Jx,clipByValue:Hi,clone:Rl,complex:Iu,concat:Gr,concat1d:Zx,concat2d:e_,concat3d:t_,concat4d:n_,constraints:qpe,conv1d:mw,conv2d:Tu,conv2dTranspose:gw,conv3d:r_,conv3dTranspose:s_,copyRegisteredKernels:Pz,cos:h1,cosh:yw,cosineWindow:Lw,cumprod:Wm,cumsum:ww,customGrad:Ml,data:w0e,denseBincount:Dy,deprecationWarn:nV,depthToSpace:i_,depthwiseConv2d:xp,deregisterOp:JU,device_util:Qz,diag:AE,dilation2d:o_,disableDeprecationWarnings:tV,dispose:en,disposeVariables:rV,div:St,divNoNan:a_,dot:l_,dropout:O_,einsum:rh,elu:_p,enableDebugMode:eV,enableProdMode:Zz,enclosingPowerOfTwo:P_,engine:Ya,ensureShape:RE,env:De,equal:No,erf:vw,euclideanNorm:u_,exp:ki,expandDims:os,expm1:c_,eye:bw,fft:S1,fill:Hh,findBackend:uV,findBackendFactory:cV,floor:Tp,floorDiv:dw,forceHalfFloat:EG,fused:bk,gather:Sp,gatherND:yk,gather_util:tB,getBackend:bE,getGradient:Db,getKernel:zm,getKernelsForBackend:ky,gpgpu_util:tIe,grad:kV,grads:NV,greater:Ki,greaterEqual:$u,ifft:rf,imag:d1,image:Ci,inTopKAsync:wk,initializers:ume,input:fU,io:Y_,irfft:Dw,isFinite:h_,isInf:d_,isNaN:f_,keep:Ts,kernel_impls:OB,layers:M1e,leakyRelu:f1,less:Zd,lessEqual:bc,linalg:W_,linspace:OE,loadGraphModel:S4,loadGraphModelSync:tW,loadLayersModel:Zme,localResponseNormalization:p_,log:Ao,log1p:p1,logSigmoid:g_,logSoftmax:xw,logSumExp:m1,logicalAnd:ka,logicalNot:g1,logicalOr:_w,logicalXor:y_,losses:Tk,lowerBound:FE,matMul:An,math:QV,max:ra,maxPool:y1,maxPool3d:w_,maxPoolWithArgmax:LE,maximum:Gl,mean:Wr,memory:Pb,meshgrid:ME,metrics:t2e,min:Jd,minimum:uc,mirrorPad:v_,mod:b_,model:nge,models:n2e,moments:w1,movingAverage:pk,mul:be,multiRNNCell:zE,multinomial:VE,neg:$r,nextFrame:e4,norm:Ip,notEqual:Rh,oneHot:ef,ones:fo,onesLike:Ro,op:ve,outerProduct:BE,pad:Cu,pad1d:UE,pad2d:WE,pad3d:jE,pad4d:GE,pool:x_,pow:Ll,prelu:b1,print:Mx,prod:__,profile:sV,raggedGather:HE,raggedRange:qE,raggedTensorToTensor:KE,rand:XE,randomGamma:ZE,randomNormal:Tw,randomStandardNormal:ek,randomUniform:xc,randomUniformInt:tk,range:Dh,ready:aV,real:tf,reciprocal:I_,registerBackend:Fx,registerCallbackConstructor:sge,registerGradient:gE,registerKernel:lw,registerOp:YU,regularizers:o2e,relu:ol,relu6:Sw,removeBackend:lV,reshape:Ie,reverse:ia,reverse1d:nk,reverse2d:rk,reverse3d:sk,reverse4d:ik,rfft:$1,round:$w,rsqrt:Cw,scalar:Xt,scatterND:mk,scatter_util:FV,searchSorted:Iw,selu:Ew,separableConv2d:kw,sequential:rge,serialization:jV,setBackend:oV,setPlatform:hV,setWebGLContext:Nj,setdiff1dAsync:ok,shared:dj,sigmoid:Ca,sign:T_,signal:Ik,sin:Nw,sinh:Aw,slice:cn,slice1d:_1,slice2d:Rw,slice3d:I1,slice4d:nf,slice_util:Pk,softmax:T1,softplus:Kh,spaceToBatchND:v1,sparse:Sk,sparseToDense:gk,spectral:_k,split:po,sqrt:js,square:wr,squaredDifference:Ow,squeeze:Vr,stack:qi,step:Xh,stridedSlice:S_,string:$k,sub:$t,sum:Ot,sumOutType:cw,tan:$_,tanh:lc,tensor:Eo,tensor1d:Zr,tensor2d:rl,tensor3d:C_,tensor4d:ak,tensor5d:lk,tensor6d:uk,tensorScatterUpdate:hk,tensor_util:Xz,test_util:PV,tidy:ke,tile:na,time:iV,topk:k_,train:Qc,transpose:Mn,truncatedNormal:Pw,unique:N_,unregisterGradient:Oz,unregisterKernel:Dz,unsortedSegmentSum:Fw,unstack:oa,upcastType:go,upperBound:dk,util:Wz,valueAndGrad:AV,valueAndGrads:RV,variable:A_,variableGrads:PE,version:s6e,version_converter:OA,version_core:Fk,version_cpu:fj,version_layers:g4,version_webgl:CG,webgl:bTe,webgl_util:a4e,where:Bs,whereAsync:D_,zeros:ps,zerosLike:jn},Symbol.toStringTag,{value:"Module"}));var AT={},XP;function i6e(){return XP||(XP=1,(function(){var t;function e(O){var U=0;return function(){return U<O.length?{done:!1,value:O[U++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(O,U,G){return O==Array.prototype||O==Object.prototype||(O[U]=G.value),O};function r(O){O=[typeof globalThis=="object"&&globalThis,O,typeof window=="object"&&window,typeof self=="object"&&self,typeof _D=="object"&&_D];for(var U=0;U<O.length;++U){var G=O[U];if(G&&G.Math==Math)return G}throw Error("Cannot find global object")}var s=r(this);function i(O,U){if(U)e:{var G=s;O=O.split(".");for(var ce=0;ce<O.length-1;ce++){var Ne=O[ce];if(!(Ne in G))break e;G=G[Ne]}O=O[O.length-1],ce=G[O],U=U(ce),U!=ce&&U!=null&&n(G,O,{configurable:!0,writable:!0,value:U})}}i("Symbol",function(O){function U(qe){if(this instanceof U)throw new TypeError("Symbol is not a constructor");return new G(ce+(qe||"")+"_"+Ne++,qe)}function G(qe,Ae){this.g=qe,n(this,"description",{configurable:!0,writable:!0,value:Ae})}if(O)return O;G.prototype.toString=function(){return this.g};var ce="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",Ne=0;return U}),i("Symbol.iterator",function(O){if(O)return O;O=Symbol("Symbol.iterator");for(var U="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),G=0;G<U.length;G++){var ce=s[U[G]];typeof ce=="function"&&typeof ce.prototype[O]!="function"&&n(ce.prototype,O,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return O});function o(O){return O={next:O},O[Symbol.iterator]=function(){return this},O}function a(O){var U=typeof Symbol<"u"&&Symbol.iterator&&O[Symbol.iterator];return U?U.call(O):{next:e(O)}}function l(O){if(!(O instanceof Array)){O=a(O);for(var U,G=[];!(U=O.next()).done;)G.push(U.value);O=G}return O}var u=typeof Object.create=="function"?Object.create:function(O){function U(){}return U.prototype=O,new U},c;if(typeof Object.setPrototypeOf=="function")c=Object.setPrototypeOf;else{var d;e:{var f={a:!0},m={};try{m.__proto__=f,d=m.a;break e}catch{}d=!1}c=d?function(O,U){if(O.__proto__=U,O.__proto__!==U)throw new TypeError(O+" is not extensible");return O}:null}var g=c;function y(O,U){if(O.prototype=u(U.prototype),O.prototype.constructor=O,g)g(O,U);else for(var G in U)if(G!="prototype")if(Object.defineProperties){var ce=Object.getOwnPropertyDescriptor(U,G);ce&&Object.defineProperty(O,G,ce)}else O[G]=U[G];O.ea=U.prototype}function v(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function b(O){if(O.l)throw new TypeError("Generator is already running");O.l=!0}v.prototype.o=function(O){this.h=O};function x(O,U){O.j={U,V:!0},O.g=O.m||O.s}v.prototype.return=function(O){this.j={return:O},this.g=this.s};function $(O,U,G){return O.g=G,{value:U}}function S(O){this.g=new v,this.h=O}function E(O,U){b(O.g);var G=O.g.i;return G?L(O,"return"in G?G.return:function(ce){return{value:ce,done:!0}},U,O.g.return):(O.g.return(U),R(O))}function L(O,U,G,ce){try{var Ne=U.call(O.g.i,G);if(!(Ne instanceof Object))throw new TypeError("Iterator result "+Ne+" is not an object");if(!Ne.done)return O.g.l=!1,Ne;var qe=Ne.value}catch(Ae){return O.g.i=null,x(O.g,Ae),R(O)}return O.g.i=null,ce.call(O.g,qe),R(O)}function R(O){for(;O.g.g;)try{var U=O.h(O.g);if(U)return O.g.l=!1,{value:U.value,done:!1}}catch(G){O.g.h=void 0,x(O.g,G)}if(O.g.l=!1,O.g.j){if(U=O.g.j,O.g.j=null,U.V)throw U.U;return{value:U.return,done:!0}}return{value:void 0,done:!0}}function D(O){this.next=function(U){return b(O.g),O.g.i?U=L(O,O.g.i.next,U,O.g.o):(O.g.o(U),U=R(O)),U},this.throw=function(U){return b(O.g),O.g.i?U=L(O,O.g.i.throw,U,O.g.o):(x(O.g,U),U=R(O)),U},this.return=function(U){return E(O,U)},this[Symbol.iterator]=function(){return this}}function A(O,U){return U=new D(new S(U)),g&&O.prototype&&g(U,O.prototype),U}function F(O,U){O instanceof String&&(O+="");var G=0,ce=!1,Ne={next:function(){if(!ce&&G<O.length){var qe=G++;return{value:U(qe,O[qe]),done:!1}}return ce=!0,{done:!0,value:void 0}}};return Ne[Symbol.iterator]=function(){return Ne},Ne}var P=typeof Object.assign=="function"?Object.assign:function(O,U){for(var G=1;G<arguments.length;G++){var ce=arguments[G];if(ce)for(var Ne in ce)Object.prototype.hasOwnProperty.call(ce,Ne)&&(O[Ne]=ce[Ne])}return O};i("Object.assign",function(O){return O||P}),i("Promise",function(O){function U(Ae){this.h=0,this.i=void 0,this.g=[],this.o=!1;var Ye=this.j();try{Ae(Ye.resolve,Ye.reject)}catch(ot){Ye.reject(ot)}}function G(){this.g=null}function ce(Ae){return Ae instanceof U?Ae:new U(function(Ye){Ye(Ae)})}if(O)return O;G.prototype.h=function(Ae){if(this.g==null){this.g=[];var Ye=this;this.i(function(){Ye.l()})}this.g.push(Ae)};var Ne=s.setTimeout;G.prototype.i=function(Ae){Ne(Ae,0)},G.prototype.l=function(){for(;this.g&&this.g.length;){var Ae=this.g;this.g=[];for(var Ye=0;Ye<Ae.length;++Ye){var ot=Ae[Ye];Ae[Ye]=null;try{ot()}catch(bt){this.j(bt)}}}this.g=null},G.prototype.j=function(Ae){this.i(function(){throw Ae})},U.prototype.j=function(){function Ae(bt){return function(tn){ot||(ot=!0,bt.call(Ye,tn))}}var Ye=this,ot=!1;return{resolve:Ae(this.C),reject:Ae(this.l)}},U.prototype.C=function(Ae){if(Ae===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(Ae instanceof U)this.F(Ae);else{e:switch(typeof Ae){case"object":var Ye=Ae!=null;break e;case"function":Ye=!0;break e;default:Ye=!1}Ye?this.u(Ae):this.m(Ae)}},U.prototype.u=function(Ae){var Ye=void 0;try{Ye=Ae.then}catch(ot){this.l(ot);return}typeof Ye=="function"?this.G(Ye,Ae):this.m(Ae)},U.prototype.l=function(Ae){this.s(2,Ae)},U.prototype.m=function(Ae){this.s(1,Ae)},U.prototype.s=function(Ae,Ye){if(this.h!=0)throw Error("Cannot settle("+Ae+", "+Ye+"): Promise already settled in state"+this.h);this.h=Ae,this.i=Ye,this.h===2&&this.D(),this.A()},U.prototype.D=function(){var Ae=this;Ne(function(){if(Ae.B()){var Ye=s.console;typeof Ye<"u"&&Ye.error(Ae.i)}},1)},U.prototype.B=function(){if(this.o)return!1;var Ae=s.CustomEvent,Ye=s.Event,ot=s.dispatchEvent;return typeof ot>"u"?!0:(typeof Ae=="function"?Ae=new Ae("unhandledrejection",{cancelable:!0}):typeof Ye=="function"?Ae=new Ye("unhandledrejection",{cancelable:!0}):(Ae=s.document.createEvent("CustomEvent"),Ae.initCustomEvent("unhandledrejection",!1,!0,Ae)),Ae.promise=this,Ae.reason=this.i,ot(Ae))},U.prototype.A=function(){if(this.g!=null){for(var Ae=0;Ae<this.g.length;++Ae)qe.h(this.g[Ae]);this.g=null}};var qe=new G;return U.prototype.F=function(Ae){var Ye=this.j();Ae.J(Ye.resolve,Ye.reject)},U.prototype.G=function(Ae,Ye){var ot=this.j();try{Ae.call(Ye,ot.resolve,ot.reject)}catch(bt){ot.reject(bt)}},U.prototype.then=function(Ae,Ye){function ot(Zt,an){return typeof Zt=="function"?function(kt){try{bt(Zt(kt))}catch(C){tn(C)}}:an}var bt,tn,bn=new U(function(Zt,an){bt=Zt,tn=an});return this.J(ot(Ae,bt),ot(Ye,tn)),bn},U.prototype.catch=function(Ae){return this.then(void 0,Ae)},U.prototype.J=function(Ae,Ye){function ot(){switch(bt.h){case 1:Ae(bt.i);break;case 2:Ye(bt.i);break;default:throw Error("Unexpected state: "+bt.h)}}var bt=this;this.g==null?qe.h(ot):this.g.push(ot),this.o=!0},U.resolve=ce,U.reject=function(Ae){return new U(function(Ye,ot){ot(Ae)})},U.race=function(Ae){return new U(function(Ye,ot){for(var bt=a(Ae),tn=bt.next();!tn.done;tn=bt.next())ce(tn.value).J(Ye,ot)})},U.all=function(Ae){var Ye=a(Ae),ot=Ye.next();return ot.done?ce([]):new U(function(bt,tn){function bn(kt){return function(C){Zt[kt]=C,an--,an==0&&bt(Zt)}}var Zt=[],an=0;do Zt.push(void 0),an++,ce(ot.value).J(bn(Zt.length-1),tn),ot=Ye.next();while(!ot.done)})},U}),i("Object.is",function(O){return O||function(U,G){return U===G?U!==0||1/U===1/G:U!==U&&G!==G}}),i("Array.prototype.includes",function(O){return O||function(U,G){var ce=this;ce instanceof String&&(ce=String(ce));var Ne=ce.length;for(G=G||0,0>G&&(G=Math.max(G+Ne,0));G<Ne;G++){var qe=ce[G];if(qe===U||Object.is(qe,U))return!0}return!1}}),i("String.prototype.includes",function(O){return O||function(U,G){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(U instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(U,G||0)!==-1}}),i("Array.prototype.keys",function(O){return O||function(){return F(this,function(U){return U})}});var K=this||self;function j(O,U){O=O.split(".");var G=K;O[0]in G||typeof G.execScript>"u"||G.execScript("var "+O[0]);for(var ce;O.length&&(ce=O.shift());)O.length||U===void 0?G[ce]&&G[ce]!==Object.prototype[ce]?G=G[ce]:G=G[ce]={}:G[ce]=U}function se(O,U){return U=String.fromCharCode.apply(null,U),O==null?U:O+U}var fe,me=typeof TextDecoder<"u",ye,oe=typeof TextEncoder<"u";function ue(O){if(oe)O=(ye||(ye=new TextEncoder)).encode(O);else{var U=void 0;U=U===void 0?!1:U;for(var G=0,ce=new Uint8Array(3*O.length),Ne=0;Ne<O.length;Ne++){var qe=O.charCodeAt(Ne);if(128>qe)ce[G++]=qe;else{if(2048>qe)ce[G++]=qe>>6|192;else{if(55296<=qe&&57343>=qe){if(56319>=qe&&Ne<O.length){var Ae=O.charCodeAt(++Ne);if(56320<=Ae&&57343>=Ae){qe=1024*(qe-55296)+Ae-56320+65536,ce[G++]=qe>>18|240,ce[G++]=qe>>12&63|128,ce[G++]=qe>>6&63|128,ce[G++]=qe&63|128;continue}else Ne--}if(U)throw Error("Found an unpaired surrogate");qe=65533}ce[G++]=qe>>12|224,ce[G++]=qe>>6&63|128}ce[G++]=qe&63|128}}O=ce.subarray(0,G)}return O}var _e={},Y=null;function re(O,U){U===void 0&&(U=0),de(),U=_e[U];for(var G=Array(Math.floor(O.length/3)),ce=U[64]||"",Ne=0,qe=0;Ne<O.length-2;Ne+=3){var Ae=O[Ne],Ye=O[Ne+1],ot=O[Ne+2],bt=U[Ae>>2];Ae=U[(Ae&3)<<4|Ye>>4],Ye=U[(Ye&15)<<2|ot>>6],ot=U[ot&63],G[qe++]=bt+Ae+Ye+ot}switch(bt=0,ot=ce,O.length-Ne){case 2:bt=O[Ne+1],ot=U[(bt&15)<<2]||ce;case 1:O=O[Ne],G[qe]=U[O>>2]+U[(O&3)<<4|bt>>4]+ot+ce}return G.join("")}function Te(O){var U=O.length,G=3*U/4;G%3?G=Math.floor(G):"=.".indexOf(O[U-1])!=-1&&(G="=.".indexOf(O[U-2])!=-1?G-2:G-1);var ce=new Uint8Array(G),Ne=0;return Pe(O,function(qe){ce[Ne++]=qe}),ce.subarray(0,Ne)}function Pe(O,U){function G(ot){for(;ce<O.length;){var bt=O.charAt(ce++),tn=Y[bt];if(tn!=null)return tn;if(!/^[\s\xa0]*$/.test(bt))throw Error("Unknown base64 encoding at char: "+bt)}return ot}de();for(var ce=0;;){var Ne=G(-1),qe=G(0),Ae=G(64),Ye=G(64);if(Ye===64&&Ne===-1)break;U(Ne<<2|qe>>4),Ae!=64&&(U(qe<<4&240|Ae>>2),Ye!=64&&U(Ae<<6&192|Ye))}}function de(){if(!Y){Y={};for(var O="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),U=["+/=","+/","-_=","-_.","-_"],G=0;5>G;G++){var ce=O.concat(U[G].split(""));_e[G]=ce;for(var Ne=0;Ne<ce.length;Ne++){var qe=ce[Ne];Y[qe]===void 0&&(Y[qe]=Ne)}}}}var ge=typeof Uint8Array.prototype.slice=="function",Re;function Oe(O,U,G){return U===G?Re||(Re=new Uint8Array(0)):ge?O.slice(U,G):new Uint8Array(O.subarray(U,G))}var Ve=0,We=0;function nt(O,U){U=U===void 0?{}:U,U=U.v===void 0?!1:U.v,this.h=null,this.g=this.j=this.l=0,this.m=!1,this.v=U,O&&ct(this,O)}function ct(O,U){U=U.constructor===Uint8Array?U:U.constructor===ArrayBuffer?new Uint8Array(U):U.constructor===Array?new Uint8Array(U):U.constructor===String?Te(U):U instanceof Uint8Array?new Uint8Array(U.buffer,U.byteOffset,U.byteLength):new Uint8Array(0),O.h=U,O.l=0,O.j=O.h.length,O.g=O.l}nt.prototype.reset=function(){this.g=this.l};function Ct(O){for(var U=128,G=0,ce=0,Ne=0;4>Ne&&128<=U;Ne++)U=O.h[O.g++],G|=(U&127)<<7*Ne;if(128<=U&&(U=O.h[O.g++],G|=(U&127)<<28,ce|=(U&127)>>4),128<=U)for(Ne=0;5>Ne&&128<=U;Ne++)U=O.h[O.g++],ce|=(U&127)<<7*Ne+3;if(128>U)return O=G>>>0,U=ce>>>0,(ce=U&2147483648)&&(O=~O+1>>>0,U=~U>>>0,O==0&&(U=U+1>>>0)),O=4294967296*U+(O>>>0),ce?-O:O;O.m=!0}nt.prototype.i=function(){var O=this.h,U=O[this.g],G=U&127;return 128>U?(this.g+=1,G):(U=O[this.g+1],G|=(U&127)<<7,128>U?(this.g+=2,G):(U=O[this.g+2],G|=(U&127)<<14,128>U?(this.g+=3,G):(U=O[this.g+3],G|=(U&127)<<21,128>U?(this.g+=4,G):(U=O[this.g+4],G|=(U&15)<<28,128>U?(this.g+=5,G>>>0):(this.g+=5,128<=O[this.g++]&&128<=O[this.g++]&&128<=O[this.g++]&&128<=O[this.g++]&&this.g++,G)))))},nt.prototype.o=function(){var O=this.h[this.g],U=this.h[this.g+1],G=this.h[this.g+2],ce=this.h[this.g+3];return this.g+=4,G=(O<<0|U<<8|G<<16|ce<<24)>>>0,O=2*(G>>31)+1,U=G>>>23&255,G&=8388607,U==255?G?NaN:1/0*O:U==0?O*Math.pow(2,-149)*G:O*Math.pow(2,U-150)*(G+Math.pow(2,23))};var Wt=[];function Et(){this.g=new Uint8Array(64),this.h=0}Et.prototype.push=function(O){if(!(this.h+1<this.g.length)){var U=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(U)}this.g[this.h++]=O},Et.prototype.length=function(){return this.h},Et.prototype.end=function(){var O=this.g,U=this.h;return this.h=0,Oe(O,0,U)};function vt(O,U){for(;127<U;)O.push(U&127|128),U>>>=7;O.push(U)}function Ht(O){var U={},G=U.N===void 0?!1:U.N;this.o={v:U.v===void 0?!1:U.v},this.N=G,U=this.o,Wt.length?(G=Wt.pop(),U&&(G.v=U.v),O&&ct(G,O),O=G):O=new nt(O,U),this.g=O,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}Ht.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function Tt(O){var U=O.g;if((U=U.g==U.j)||(U=O.j)||(U=O.g,U=U.m||0>U.g||U.g>U.j),U)return!1;O.m=O.g.g,U=O.g.i();var G=U&7;return G!=0&&G!=5&&G!=1&&G!=2&&G!=3&&G!=4?(O.j=!0,!1):(O.i=U,O.l=U>>>3,O.h=G,!0)}function Pt(O){switch(O.h){case 0:if(O.h!=0)Pt(O);else{for(O=O.g;O.h[O.g]&128;)O.g++;O.g++}break;case 1:O.h!=1?Pt(O):(O=O.g,O.g+=8);break;case 2:if(O.h!=2)Pt(O);else{var U=O.g.i();O=O.g,O.g+=U}break;case 5:O.h!=5?Pt(O):(O=O.g,O.g+=4);break;case 3:U=O.l;do{if(!Tt(O)){O.j=!0;break}if(O.h==4){O.l!=U&&(O.j=!0);break}Pt(O)}while(!0);break;default:O.j=!0}}function Rt(O,U,G){var ce=O.g.j,Ne=O.g.i(),qe=O.g.g+Ne;if(O.g.j=qe,G(U,O),G=qe-O.g.g,G!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+Ne+" bytes, instead read "+(Ne-G)+" bytes, either the data ended unexpectedly or the message misreported its own length");return O.g.g=qe,O.g.j=ce,U}function Yt(O){return O.g.o()}function mn(O){var U=O.g.i();O=O.g;var G=O.g;O.g+=U,O=O.h;var ce;if(me)(ce=fe)||(ce=fe=new TextDecoder("utf-8",{fatal:!1})),ce=ce.decode(O.subarray(G,G+U));else{U=G+U;for(var Ne=[],qe=null,Ae,Ye,ot;G<U;)Ae=O[G++],128>Ae?Ne.push(Ae):224>Ae?G>=U?Ne.push(65533):(Ye=O[G++],194>Ae||(Ye&192)!==128?(G--,Ne.push(65533)):Ne.push((Ae&31)<<6|Ye&63)):240>Ae?G>=U-1?Ne.push(65533):(Ye=O[G++],(Ye&192)!==128||Ae===224&&160>Ye||Ae===237&&160<=Ye||((ce=O[G++])&192)!==128?(G--,Ne.push(65533)):Ne.push((Ae&15)<<12|(Ye&63)<<6|ce&63)):244>=Ae?G>=U-2?Ne.push(65533):(Ye=O[G++],(Ye&192)!==128||(Ae<<28)+(Ye-144)>>30!==0||((ce=O[G++])&192)!==128||((ot=O[G++])&192)!==128?(G--,Ne.push(65533)):(Ae=(Ae&7)<<18|(Ye&63)<<12|(ce&63)<<6|ot&63,Ae-=65536,Ne.push((Ae>>10&1023)+55296,(Ae&1023)+56320))):Ne.push(65533),8192<=Ne.length&&(qe=se(qe,Ne),Ne.length=0);ce=se(qe,Ne)}return ce}function jt(O,U,G){var ce=O.g.i();for(ce=O.g.g+ce;O.g.g<ce;)G.push(U.call(O.g))}function Fn(O,U){O.h==2?jt(O,nt.prototype.o,U):U.push(Yt(O))}function Vn(){this.h=[],this.i=0,this.g=new Et}function Bn(O,U){U.length!==0&&(O.h.push(U),O.i+=U.length)}function Ln(O){var U=O.i+O.g.length();if(U===0)return new Uint8Array(0);U=new Uint8Array(U);for(var G=O.h,ce=G.length,Ne=0,qe=0;qe<ce;qe++){var Ae=G[qe];Ae.length!==0&&(U.set(Ae,Ne),Ne+=Ae.length)}return G=O.g,ce=G.h,ce!==0&&(U.set(G.g.subarray(0,ce),Ne),G.h=0),O.h=[U],U}function Tn(O,U,G){if(G!=null){vt(O.g,8*U+5),O=O.g;var ce=G;ce=(G=0>ce?1:0)?-ce:ce,ce===0?0<1/ce?Ve=We=0:(We=0,Ve=2147483648):isNaN(ce)?(We=0,Ve=2147483647):34028234663852886e22<ce?(We=0,Ve=(G<<31|2139095040)>>>0):11754943508222875e-54>ce?(ce=Math.round(ce/Math.pow(2,-149)),We=0,Ve=(G<<31|ce)>>>0):(U=Math.floor(Math.log(ce)/Math.LN2),ce*=Math.pow(2,-U),ce=Math.round(8388608*ce),16777216<=ce&&++U,We=0,Ve=(G<<31|U+127<<23|ce&8388607)>>>0),G=Ve,O.push(G>>>0&255),O.push(G>>>8&255),O.push(G>>>16&255),O.push(G>>>24&255)}}var xr=typeof Uint8Array=="function";function fr(O,U,G){if(O!=null)return typeof O=="object"?xr&&O instanceof Uint8Array?G(O):Ar(O,U,G):U(O)}function Ar(O,U,G){if(Array.isArray(O)){for(var ce=Array(O.length),Ne=0;Ne<O.length;Ne++)ce[Ne]=fr(O[Ne],U,G);return Array.isArray(O)&&O.W&&gr(ce),ce}ce={};for(Ne in O)ce[Ne]=fr(O[Ne],U,G);return ce}function Hs(O){return typeof O=="number"?isFinite(O)?O:String(O):O}var qr={W:{value:!0,configurable:!0}};function gr(O){return Array.isArray(O)&&!Object.isFrozen(O)&&Object.defineProperties(O,qr),O}var ir;function Un(O,U,G){var ce=ir;ir=null,O||(O=ce),ce=this.constructor.ca,O||(O=ce?[ce]:[]),this.j=ce?0:-1,this.m=this.g=null,this.h=O;e:{if(ce=this.h.length,O=ce-1,ce&&(ce=this.h[O],!(ce===null||typeof ce!="object"||Array.isArray(ce)||xr&&ce instanceof Uint8Array))){this.l=O-this.j,this.i=ce;break e}U!==void 0&&-1<U?(this.l=Math.max(U,O+1-this.j),this.i=null):this.l=Number.MAX_VALUE}if(G)for(U=0;U<G.length;U++)O=G[U],O<this.l?(O+=this.j,(ce=this.h[O])?gr(ce):this.h[O]=Kr):(ui(this),(ce=this.i[O])?gr(ce):this.i[O]=Kr)}var Kr=Object.freeze(gr([]));function ui(O){var U=O.l+O.j;O.h[U]||(O.i=O.h[U]={})}function Gn(O,U,G){return U===-1?null:G!==void 0&&G||U>=O.l?O.i?O.i[U]:void 0:O.h[U+O.j]}function Cs(O,U){var G=G===void 0?!1:G,ce=Gn(O,U,G);return ce==null&&(ce=Kr),ce===Kr&&(ce=gr([]),hn(O,U,ce,G)),ce}function ci(O){var U=Cs(O,3);if(O.m||(O.m={}),!O.m[3]){for(var G=0;G<U.length;G++)U[G]=+U[G];O.m[3]=!0}return U}function Kn(O,U,G){return O=Gn(O,U),O??G}function Dn(O,U,G){return O=Gn(O,U),O=O==null?O:+O,O??(G===void 0?0:G)}function hn(O,U,G,ce){ce!==void 0&&ce||U>=O.l?(ui(O),O.i[U]=G):O.h[U+O.j]=G}function Qi(O,U,G){if(G===-1)return null;if(O.g||(O.g={}),!O.g[G]){var ce=Gn(O,G,!1);ce&&(O.g[G]=new U(ce))}return O.g[G]}function Po(O,U){O.g||(O.g={});var G=O.g[1];if(!G){var ce=Cs(O,1);G=[];for(var Ne=0;Ne<ce.length;Ne++)G[Ne]=new U(ce[Ne]);O.g[1]=G}return G}function bo(O,U,G){var ce=ce===void 0?!1:ce;O.g||(O.g={});var Ne=G&&hi(G);O.g[U]=G,hn(O,U,Ne,ce)}function bs(O,U,G,ce){var Ne=Po(O,G);U=U||new G,O=Cs(O,1),ce!=null?(Ne.splice(ce,0,U),O.splice(ce,0,hi(U))):(Ne.push(U),O.push(hi(U)))}Un.prototype.toJSON=function(){var O=hi(this);return Ar(O,Hs,re)};function hi(O,U){if(O.g)for(var G in O.g){var ce=O.g[G];if(Array.isArray(ce))for(var Ne=0;Ne<ce.length;Ne++)ce[Ne]&&hi(ce[Ne]);else ce&&hi(ce)}return O.h}Un.prototype.toString=function(){return hi(this).toString()};function Pi(O,U){if(O=O.o){Bn(U,U.g.end());for(var G=0;G<O.length;G++)Bn(U,O[G])}}function Or(O,U){if(U.h==4)return!1;var G=U.m;return Pt(U),U.N||(U=Oe(U.g.h,G,U.g.g),(G=O.o)?G.push(U):O.o=[U]),!0}function cs(O){Un.call(this,O,-1,Ji)}y(cs,Un),cs.prototype.getRows=function(){return Gn(this,1)},cs.prototype.getCols=function(){return Gn(this,2)},cs.prototype.getPackedDataList=function(){return ci(this)},cs.prototype.getLayout=function(){return Kn(this,4,0)};function Aa(O,U){for(;Tt(U);)switch(U.i){case 8:var G=U.g.i();hn(O,1,G);break;case 16:G=U.g.i(),hn(O,2,G);break;case 29:case 26:Fn(U,O.getPackedDataList());break;case 32:G=Ct(U.g),hn(O,4,G);break;default:if(!Or(O,U))return O}return O}var Ji=[3];function cr(O,U){var G=void 0;return new(G||(G=Promise))(function(ce,Ne){function qe(ot){try{Ye(U.next(ot))}catch(bt){Ne(bt)}}function Ae(ot){try{Ye(U.throw(ot))}catch(bt){Ne(bt)}}function Ye(ot){ot.done?ce(ot.value):new G(function(bt){bt(ot.value)}).then(qe,Ae)}Ye((U=U.apply(O,void 0)).next())})}function Es(O){Un.call(this,O)}y(Es,Un);function ks(O,U){for(;Tt(U);)switch(U.i){case 8:var G=U.g.i();hn(O,1,G);break;case 21:G=Yt(U),hn(O,2,G);break;case 26:G=mn(U),hn(O,3,G);break;case 34:G=mn(U),hn(O,4,G);break;default:if(!Or(O,U))return O}return O}function ua(O){Un.call(this,O,-1,Ns)}y(ua,Un),ua.prototype.addClassification=function(O,U){return bs(this,O,Es,U),this};var Ns=[1];function di(O){Un.call(this,O)}y(di,Un);function qs(O,U){for(;Tt(U);)switch(U.i){case 13:var G=Yt(U);hn(O,1,G);break;case 21:G=Yt(U),hn(O,2,G);break;case 29:G=Yt(U),hn(O,3,G);break;case 37:G=Yt(U),hn(O,4,G);break;case 45:G=Yt(U),hn(O,5,G);break;default:if(!Or(O,U))return O}return O}function Fi(O){Un.call(this,O,-1,Ra)}y(Fi,Un);function Ks(O){e:{var U=new Fi;for(O=new Ht(O);Tt(O);)switch(O.i){case 10:var G=Rt(O,new di,qs);bs(U,G,di,void 0);break;default:if(!Or(U,O))break e}}return U}var Ra=[1];function ca(O){Un.call(this,O)}y(ca,Un);function Rr(O){Un.call(this,O,-1,Fo)}y(Rr,Un),Rr.prototype.getVertexType=function(){return Kn(this,1,0)},Rr.prototype.getPrimitiveType=function(){return Kn(this,2,0)},Rr.prototype.getVertexBufferList=function(){return ci(this)},Rr.prototype.getIndexBufferList=function(){return Cs(this,4)};function cl(O,U){for(;Tt(U);)switch(U.i){case 8:var G=Ct(U.g);hn(O,1,G);break;case 16:G=Ct(U.g),hn(O,2,G);break;case 29:case 26:Fn(U,O.getVertexBufferList());break;case 32:case 34:G=U;var ce=O.getIndexBufferList();G.h==2?jt(G,nt.prototype.i,ce):ce.push(G.g.i());break;default:if(!Or(O,U))return O}return O}var Fo=[3,4];function Xr(O){Un.call(this,O)}y(Xr,Un),Xr.prototype.getMesh=function(){return Qi(this,Rr,1)},Xr.prototype.getPoseTransformMatrix=function(){return Qi(this,cs,2)};function fi(O){e:{var U=new Xr;for(O=new Ht(O);Tt(O);)switch(O.i){case 10:var G=Rt(O,new Rr,cl);bo(U,1,G);break;case 18:G=Rt(O,new cs,Aa),bo(U,2,G);break;default:if(!Or(U,O))break e}}return U}function gn(O,U,G){if(G=O.createShader(G===0?O.VERTEX_SHADER:O.FRAGMENT_SHADER),O.shaderSource(G,U),O.compileShader(G),!O.getShaderParameter(G,O.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+O.getShaderInfoLog(G));return G}function hs(O){return Po(O,Es).map(function(U){return{index:Kn(U,1,0),Y:Dn(U,2),label:Gn(U,3)!=null?Kn(U,3,""):void 0,displayName:Gn(U,4)!=null?Kn(U,4,""):void 0}})}function Zi(O){return{x:Dn(O,1),y:Dn(O,2),z:Dn(O,3),visibility:Gn(O,4)!=null?Dn(O,4):void 0}}function xo(O,U){this.h=O,this.g=U,this.l=0}function pi(O,U,G){return xs(O,U),typeof O.g.canvas.transferToImageBitmap=="function"?Promise.resolve(O.g.canvas.transferToImageBitmap()):G?Promise.resolve(O.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(O.g.canvas):(O.i===void 0&&(O.i=document.createElement("canvas")),new Promise(function(ce){O.i.height=O.g.canvas.height,O.i.width=O.g.canvas.width,O.i.getContext("2d",{}).drawImage(O.g.canvas,0,0,O.g.canvas.width,O.g.canvas.height),ce(O.i)}))}function xs(O,U){var G=O.g;if(O.m===void 0){var ce=gn(G,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),Ne=gn(G,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),qe=G.createProgram();if(G.attachShader(qe,ce),G.attachShader(qe,Ne),G.linkProgram(qe),!G.getProgramParameter(qe,G.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+G.getProgramInfoLog(qe));ce=O.m=qe,G.useProgram(ce),Ne=G.getUniformLocation(ce,"sampler0"),O.j={I:G.getAttribLocation(ce,"aVertex"),H:G.getAttribLocation(ce,"aTex"),da:Ne},O.s=G.createBuffer(),G.bindBuffer(G.ARRAY_BUFFER,O.s),G.enableVertexAttribArray(O.j.I),G.vertexAttribPointer(O.j.I,2,G.FLOAT,!1,0,0),G.bufferData(G.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),G.STATIC_DRAW),G.bindBuffer(G.ARRAY_BUFFER,null),O.o=G.createBuffer(),G.bindBuffer(G.ARRAY_BUFFER,O.o),G.enableVertexAttribArray(O.j.H),G.vertexAttribPointer(O.j.H,2,G.FLOAT,!1,0,0),G.bufferData(G.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),G.STATIC_DRAW),G.bindBuffer(G.ARRAY_BUFFER,null),G.uniform1i(Ne,0)}ce=O.j,G.useProgram(O.m),G.canvas.width=U.width,G.canvas.height=U.height,G.viewport(0,0,U.width,U.height),G.activeTexture(G.TEXTURE0),O.h.bindTexture2d(U.glName),G.enableVertexAttribArray(ce.I),G.bindBuffer(G.ARRAY_BUFFER,O.s),G.vertexAttribPointer(ce.I,2,G.FLOAT,!1,0,0),G.enableVertexAttribArray(ce.H),G.bindBuffer(G.ARRAY_BUFFER,O.o),G.vertexAttribPointer(ce.H,2,G.FLOAT,!1,0,0),G.bindFramebuffer(G.DRAW_FRAMEBUFFER?G.DRAW_FRAMEBUFFER:G.FRAMEBUFFER,null),G.clearColor(0,0,0,0),G.clear(G.COLOR_BUFFER_BIT),G.colorMask(!0,!0,!0,!0),G.drawArrays(G.TRIANGLE_FAN,0,4),G.disableVertexAttribArray(ce.I),G.disableVertexAttribArray(ce.H),G.bindBuffer(G.ARRAY_BUFFER,null),O.h.bindTexture2d(0)}function Da(O){this.g=O}var ha=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function As(O,U){return U+O}function mi(O,U){window[O]=U}function hr(O){var U=document.createElement("script");return U.setAttribute("src",O),U.setAttribute("crossorigin","anonymous"),new Promise(function(G){U.addEventListener("load",function(){G()},!1),U.addEventListener("error",function(){G()},!1),document.body.appendChild(U)})}function Li(){return cr(this,function O(){return A(O,function(U){switch(U.g){case 1:return U.m=2,$(U,WebAssembly.instantiate(ha),4);case 4:U.g=3,U.m=0;break;case 2:return U.m=0,U.j=null,U.return(!1);case 3:return U.return(!0)}})})}function Pr(O){if(this.g=O,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=O&&O.locateFile||As,typeof window=="object")var U=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")U=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=U,O.options){U=a(Object.keys(O.options));for(var G=U.next();!G.done;G=U.next()){G=G.value;var ce=O.options[G].default;ce!==void 0&&(this.j[G]=typeof ce=="function"?ce():ce)}}}t=Pr.prototype,t.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function Lo(O,U){return O.g.files===void 0?[]:typeof O.g.files=="function"?O.g.files(U):O.g.files}function gi(O){return cr(O,function U(){var G=this,ce,Ne,qe,Ae,Ye,ot,bt,tn,bn,Zt,an;return A(U,function(kt){switch(kt.g){case 1:return ce=G,G.R?(Ne=Lo(G,G.j),$(kt,Li(),2)):kt.return();case 2:if(qe=kt.h,typeof window=="object")return mi("createMediapipeSolutionsWasm",{locateFile:G.locateFile}),mi("createMediapipeSolutionsPackedAssets",{locateFile:G.locateFile}),ot=Ne.filter(function(C){return C.data!==void 0}),bt=Ne.filter(function(C){return C.data===void 0}),tn=Promise.all(ot.map(function(C){var W=Rs(ce,C.url);if(C.path!==void 0){var X=C.path;W=W.then(function(te){return ce.overrideFile(X,te),Promise.resolve(te)})}return W})),bn=Promise.all(bt.map(function(C){return C.simd===void 0||C.simd&&qe||!C.simd&&!qe?hr(ce.locateFile(C.url,ce.S)):Promise.resolve()})).then(function(){return cr(ce,function C(){var W,X,te=this;return A(C,function(ae){if(ae.g==1)return W=window.createMediapipeSolutionsWasm,X=window.createMediapipeSolutionsPackedAssets,$(ae,W(X),2);te.h=ae.h,ae.g=0})})}),Zt=(function(){return cr(ce,function C(){var W=this;return A(C,function(X){return W.g.graph&&W.g.graph.url?X=$(X,Rs(W,W.g.graph.url),0):(X.g=0,X=void 0),X})})})(),$(kt,Promise.all([bn,tn,Zt]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return Ae=Ne.filter(function(C){return C.simd===void 0||C.simd&&qe||!C.simd&&!qe}).map(function(C){return ce.locateFile(C.url,ce.S)}),importScripts.apply(null,l(Ae)),$(kt,createMediapipeSolutionsWasm(Module),6);case 6:G.h=kt.h,G.l=new OffscreenCanvas(1,1),G.h.canvas=G.l,Ye=G.h.GL.createContext(G.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),G.h.GL.makeContextCurrent(Ye),kt.g=4;break;case 7:if(G.l=document.createElement("canvas"),an=G.l.getContext("webgl2",{}),!an&&(an=G.l.getContext("webgl",{}),!an))return alert("Failed to create WebGL canvas context when passing video frame."),kt.return();G.D=an,G.h.canvas=G.l,G.h.createContext(G.l,!0,!0,{});case 4:G.i=new G.h.SolutionWasm,G.R=!1,kt.g=0}})})}function Mo(O){return cr(O,function U(){var G=this,ce,Ne,qe,Ae,Ye,ot,bt,tn;return A(U,function(bn){if(bn.g==1){if(G.g.graph&&G.g.graph.url&&G.P===G.g.graph.url)return bn.return();if(G.o=!0,!G.g.graph||!G.g.graph.url){bn.g=2;return}return G.P=G.g.graph.url,$(bn,Rs(G,G.g.graph.url),3)}for(bn.g!=2&&(ce=bn.h,G.i.loadGraph(ce)),Ne=a(Object.keys(G.B)),qe=Ne.next();!qe.done;qe=Ne.next())Ae=qe.value,G.i.overrideFile(Ae,G.B[Ae]);if(G.B={},G.g.listeners)for(Ye=a(G.g.listeners),ot=Ye.next();!ot.done;ot=Ye.next())bt=ot.value,hl(G,bt);tn=G.j,G.j={},G.setOptions(tn),bn.g=0})})}t.reset=function(){return cr(this,function O(){var U=this;return A(O,function(G){U.i&&(U.i.reset(),U.m={},U.s={}),G.g=0})})},t.setOptions=function(O,U){var G=this;if(U=U||this.g.options){for(var ce=[],Ne=[],qe={},Ae=a(Object.keys(O)),Ye=Ae.next();!Ye.done;qe={K:qe.K,L:qe.L},Ye=Ae.next()){var ot=Ye.value;ot in this.j&&this.j[ot]===O[ot]||(this.j[ot]=O[ot],Ye=U[ot],Ye!==void 0&&(Ye.onChange&&(qe.K=Ye.onChange,qe.L=O[ot],ce.push((function(bt){return function(){return cr(G,function tn(){var bn,Zt=this;return A(tn,function(an){if(an.g==1)return $(an,bt.K(bt.L),2);bn=an.h,bn===!0&&(Zt.o=!0),an.g=0})})}})(qe))),Ye.graphOptionXref&&(ot={valueNumber:Ye.type===1?O[ot]:0,valueBoolean:Ye.type===0?O[ot]:!1,valueString:Ye.type===2?O[ot]:""},Ye=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),Ye.graphOptionXref),ot),Ne.push(Ye))))}(ce.length!==0||Ne.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(Ne),this.u=(this.u===void 0?[]:this.u).concat(ce))}};function Hn(O){return cr(O,function U(){var G=this,ce,Ne,qe,Ae,Ye,ot,bt;return A(U,function(tn){switch(tn.g){case 1:if(!G.o)return tn.return();if(!G.u){tn.g=2;break}ce=a(G.u),Ne=ce.next();case 3:if(Ne.done){tn.g=5;break}return qe=Ne.value,$(tn,qe(),4);case 4:Ne=ce.next(),tn.g=3;break;case 5:G.u=void 0;case 2:if(G.A){for(Ae=new G.h.GraphOptionChangeRequestList,Ye=a(G.A),ot=Ye.next();!ot.done;ot=Ye.next())bt=ot.value,Ae.push_back(bt);G.i.changeOptions(Ae),Ae.delete(),G.A=void 0}G.o=!1,tn.g=0}})})}t.initialize=function(){return cr(this,function O(){var U=this;return A(O,function(G){return G.g==1?$(G,gi(U),2):G.g!=3?$(G,Mo(U),3):$(G,Hn(U),0)})})};function Rs(O,U){return cr(O,function G(){var ce=this,Ne,qe;return A(G,function(Ae){return U in ce.F?Ae.return(ce.F[U]):(Ne=ce.locateFile(U,""),qe=fetch(Ne).then(function(Ye){return Ye.arrayBuffer()}),ce.F[U]=qe,Ae.return(qe))})})}t.overrideFile=function(O,U){this.i?this.i.overrideFile(O,U):this.B[O]=U},t.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},t.send=function(O,U){return cr(this,function G(){var ce=this,Ne,qe,Ae,Ye,ot,bt,tn,bn,Zt;return A(G,function(an){switch(an.g){case 1:return ce.g.inputs?(Ne=1e3*(U??performance.now()),$(an,ce.C,2)):an.return();case 2:return $(an,ce.initialize(),3);case 3:for(qe=new ce.h.PacketDataList,Ae=a(Object.keys(O)),Ye=Ae.next();!Ye.done;Ye=Ae.next())if(ot=Ye.value,bt=ce.g.inputs[ot]){e:{var kt=ce,C=O[ot];switch(bt.type){case"video":var W=kt.m[bt.stream];if(W||(W=new xo(kt.h,kt.D),kt.m[bt.stream]=W),kt=W,kt.l===0&&(kt.l=kt.h.createTexture()),typeof HTMLVideoElement<"u"&&C instanceof HTMLVideoElement){var X=C.videoWidth;W=C.videoHeight}else typeof HTMLImageElement<"u"&&C instanceof HTMLImageElement?(X=C.naturalWidth,W=C.naturalHeight):(X=C.width,W=C.height);W={glName:kt.l,width:X,height:W},X=kt.g,X.canvas.width=W.width,X.canvas.height=W.height,X.activeTexture(X.TEXTURE0),kt.h.bindTexture2d(kt.l),X.texImage2D(X.TEXTURE_2D,0,X.RGBA,X.RGBA,X.UNSIGNED_BYTE,C),kt.h.bindTexture2d(0),kt=W;break e;case"detections":for(W=kt.m[bt.stream],W||(W=new Da(kt.h),kt.m[bt.stream]=W),kt=W,kt.data||(kt.data=new kt.g.DetectionListData),kt.data.reset(C.length),W=0;W<C.length;++W){X=C[W];var te=kt.data,ae=te.setBoundingBox,ie=W,he=X.T,xe=new ca;hn(xe,1,he.Z),hn(xe,2,he.$),hn(xe,3,he.height),hn(xe,4,he.width),hn(xe,5,he.rotation),hn(xe,6,he.X);var Me=he=new Vn;Tn(Me,1,Gn(xe,1)),Tn(Me,2,Gn(xe,2)),Tn(Me,3,Gn(xe,3)),Tn(Me,4,Gn(xe,4)),Tn(Me,5,Gn(xe,5));var Qe=Gn(xe,6);if(Qe!=null&&Qe!=null){vt(Me.g,48);var Ze=Me.g,dt=Qe;Qe=0>dt,dt=Math.abs(dt);var mt=dt>>>0;for(dt=Math.floor((dt-mt)/4294967296),dt>>>=0,Qe&&(dt=~dt>>>0,mt=(~mt>>>0)+1,4294967295<mt&&(mt=0,dt++,4294967295<dt&&(dt=0))),Ve=mt,We=dt,Qe=Ve,mt=We;0<mt||127<Qe;)Ze.push(Qe&127|128),Qe=(Qe>>>7|mt<<25)>>>0,mt>>>=7;Ze.push(Qe)}if(Pi(xe,Me),he=Ln(he),ae.call(te,ie,he),X.O)for(te=0;te<X.O.length;++te)xe=X.O[te],Me=!!xe.visibility,ae=kt.data,ie=ae.addNormalizedLandmark,he=W,xe=Object.assign(Object.assign({},xe),{visibility:Me?xe.visibility:0}),Me=new di,hn(Me,1,xe.x),hn(Me,2,xe.y),hn(Me,3,xe.z),xe.visibility&&hn(Me,4,xe.visibility),Ze=xe=new Vn,Tn(Ze,1,Gn(Me,1)),Tn(Ze,2,Gn(Me,2)),Tn(Ze,3,Gn(Me,3)),Tn(Ze,4,Gn(Me,4)),Tn(Ze,5,Gn(Me,5)),Pi(Me,Ze),xe=Ln(xe),ie.call(ae,he,xe);if(X.M)for(te=0;te<X.M.length;++te){if(ae=kt.data,ie=ae.addClassification,he=W,xe=X.M[te],Me=new Es,hn(Me,2,xe.Y),xe.index&&hn(Me,1,xe.index),xe.label&&hn(Me,3,xe.label),xe.displayName&&hn(Me,4,xe.displayName),Ze=xe=new Vn,mt=Gn(Me,1),mt!=null&&mt!=null)if(vt(Ze.g,8),Qe=Ze.g,0<=mt)vt(Qe,mt);else{for(dt=0;9>dt;dt++)Qe.push(mt&127|128),mt>>=7;Qe.push(1)}Tn(Ze,2,Gn(Me,2)),Qe=Gn(Me,3),Qe!=null&&(Qe=ue(Qe),vt(Ze.g,26),vt(Ze.g,Qe.length),Bn(Ze,Ze.g.end()),Bn(Ze,Qe)),Qe=Gn(Me,4),Qe!=null&&(Qe=ue(Qe),vt(Ze.g,34),vt(Ze.g,Qe.length),Bn(Ze,Ze.g.end()),Bn(Ze,Qe)),Pi(Me,Ze),xe=Ln(xe),ie.call(ae,he,xe)}}kt=kt.data;break e;default:kt={}}}switch(tn=kt,bn=bt.stream,bt.type){case"video":qe.pushTexture2d(Object.assign(Object.assign({},tn),{stream:bn,timestamp:Ne}));break;case"detections":Zt=tn,Zt.stream=bn,Zt.timestamp=Ne,qe.pushDetectionList(Zt);break;default:throw Error("Unknown input config type: '"+bt.type+"'")}}return ce.i.send(qe),$(an,ce.C,4);case 4:qe.delete(),an.g=0}})})};function zo(O,U,G){return cr(O,function ce(){var Ne,qe,Ae,Ye,ot,bt,tn=this,bn,Zt,an,kt,C,W,X,te;return A(ce,function(ae){switch(ae.g){case 1:if(!G)return ae.return(U);for(Ne={},qe=0,Ae=a(Object.keys(G)),Ye=Ae.next();!Ye.done;Ye=Ae.next())ot=Ye.value,bt=G[ot],typeof bt!="string"&&bt.type==="texture"&&U[bt.stream]!==void 0&&++qe;1<qe&&(tn.G=!1),bn=a(Object.keys(G)),Ye=bn.next();case 2:if(Ye.done){ae.g=4;break}if(Zt=Ye.value,an=G[Zt],typeof an=="string")return X=Ne,te=Zt,$(ae,Vo(tn,Zt,U[an]),14);if(kt=U[an.stream],an.type==="detection_list"){if(kt){for(var ie=kt.getRectList(),he=kt.getLandmarksList(),xe=kt.getClassificationsList(),Me=[],Qe=0;Qe<ie.size();++Qe){var Ze=ie.get(Qe);e:{var dt=new ca;for(Ze=new Ht(Ze);Tt(Ze);)switch(Ze.i){case 13:var mt=Yt(Ze);hn(dt,1,mt);break;case 21:mt=Yt(Ze),hn(dt,2,mt);break;case 29:mt=Yt(Ze),hn(dt,3,mt);break;case 37:mt=Yt(Ze),hn(dt,4,mt);break;case 45:mt=Yt(Ze),hn(dt,5,mt);break;case 48:mt=Ct(Ze.g),hn(dt,6,mt);break;default:if(!Or(dt,Ze))break e}}dt={Z:Dn(dt,1),$:Dn(dt,2),height:Dn(dt,3),width:Dn(dt,4),rotation:Dn(dt,5,0),X:Kn(dt,6,0)},Ze=Po(Ks(he.get(Qe)),di).map(Zi);var yt=xe.get(Qe);e:for(mt=new ua,yt=new Ht(yt);Tt(yt);)switch(yt.i){case 10:mt.addClassification(Rt(yt,new Es,ks));break;default:if(!Or(mt,yt))break e}dt={T:dt,O:Ze,M:hs(mt)},Me.push(dt)}ie=Me}else ie=[];Ne[Zt]=ie,ae.g=7;break}if(an.type==="proto_list"){if(kt){for(ie=Array(kt.size()),he=0;he<kt.size();he++)ie[he]=kt.get(he);kt.delete()}else ie=[];Ne[Zt]=ie,ae.g=7;break}if(kt===void 0){ae.g=3;break}if(an.type==="float_list"){Ne[Zt]=kt,ae.g=7;break}if(an.type==="proto"){Ne[Zt]=kt,ae.g=7;break}if(an.type!=="texture")throw Error("Unknown output config type: '"+an.type+"'");return C=tn.s[Zt],C||(C=new xo(tn.h,tn.D),tn.s[Zt]=C),$(ae,pi(C,kt,tn.G),13);case 13:W=ae.h,Ne[Zt]=W;case 7:an.transform&&Ne[Zt]&&(Ne[Zt]=an.transform(Ne[Zt])),ae.g=3;break;case 14:X[te]=ae.h;case 3:Ye=bn.next(),ae.g=2;break;case 4:return ae.return(Ne)}})})}function Vo(O,U,G){return cr(O,function ce(){var Ne=this,qe;return A(ce,function(Ae){return typeof G=="number"||G instanceof Uint8Array||G instanceof Ne.h.Uint8BlobList?Ae.return(G):G instanceof Ne.h.Texture2dDataOut?(qe=Ne.s[U],qe||(qe=new xo(Ne.h,Ne.D),Ne.s[U]=qe),Ae.return(pi(qe,G,Ne.G))):Ae.return(void 0)})})}function hl(O,U){for(var G=U.name||"$",ce=[].concat(l(U.wants)),Ne=new O.h.StringList,qe=a(U.wants),Ae=qe.next();!Ae.done;Ae=qe.next())Ne.push_back(Ae.value);qe=O.h.PacketListener.implement({onResults:function(Ye){for(var ot={},bt=0;bt<U.wants.length;++bt)ot[ce[bt]]=Ye.get(bt);var tn=O.listeners[G];tn&&(O.C=zo(O,ot,U.outs).then(function(bn){bn=tn(bn);for(var Zt=0;Zt<U.wants.length;++Zt){var an=ot[ce[Zt]];typeof an=="object"&&an.hasOwnProperty&&an.hasOwnProperty("delete")&&an.delete()}bn&&(O.C=bn)}))}}),O.i.attachMultiListener(Ne,qe),Ne.delete()}t.onResults=function(O,U){this.listeners[U||"$"]=O},j("Solution",Pr),j("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function dl(O){O=fi(O);var U=O.getMesh();if(!U)return O;var G=new Float32Array(U.getVertexBufferList());U.getVertexBufferList=function(){return G};var ce=new Uint32Array(U.getIndexBufferList());return U.getIndexBufferList=function(){return ce},O}var _o={files:[{url:"face_mesh_solution_packed_assets_loader.js"},{simd:!0,url:"face_mesh_solution_simd_wasm_bin.js"},{simd:!1,url:"face_mesh_solution_wasm_bin.js"}],graph:{url:"face_mesh.binarypb"},listeners:[{wants:["multi_face_geometry","image_transformed","multi_face_landmarks"],outs:{image:"image_transformed",multiFaceGeometry:{type:"proto_list",stream:"multi_face_geometry",transform:function(O){return O.map(dl)}},multiFaceLandmarks:{type:"proto_list",stream:"multi_face_landmarks",transform:function(O){return O.map(function(U){return Po(Ks(U),di).map(Zi)})}}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},enableFaceGeometry:{type:0,graphOptionXref:{calculatorName:"EnableFaceGeometryConstant",calculatorType:"ConstantSidePacketCalculator",fieldName:"bool_value"}},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumFaces:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorNumFaces",fieldName:"int_value"}},refineLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorRefineLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}},cameraNear:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"near"}},cameraFar:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"far"}},cameraVerticalFovDegrees:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"vertical_fov_degrees"}}}},Mi=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Bo=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],da=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],Sn=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],yi=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],fa=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],pa=[].concat(l(Mi),l(Bo),l(da),l(Sn),l(yi),l(fa));function Oa(O){O=O||{},O=Object.assign(Object.assign({},_o),O),this.g=new Pr(O)}t=Oa.prototype,t.close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(O){this.g.onResults(O)},t.initialize=function(){return cr(this,function O(){var U=this;return A(O,function(G){return $(G,U.g.initialize(),0)})})},t.reset=function(){this.g.reset()},t.send=function(O){return cr(this,function U(){var G=this;return A(U,function(ce){return $(ce,G.g.send(O),0)})})},t.setOptions=function(O){this.g.setOptions(O)},j("FACE_GEOMETRY",{Layout:{COLUMN_MAJOR:0,ROW_MAJOR:1,0:"COLUMN_MAJOR",1:"ROW_MAJOR"},PrimitiveType:{TRIANGLE:0,0:"TRIANGLE"},VertexType:{VERTEX_PT:0,0:"VERTEX_PT"},DEFAULT_CAMERA_PARAMS:{verticalFovDegrees:63,near:1,far:1e4}}),j("FaceMesh",Oa),j("FACEMESH_LIPS",Mi),j("FACEMESH_LEFT_EYE",Bo),j("FACEMESH_LEFT_EYEBROW",da),j("FACEMESH_LEFT_IRIS",[[474,475],[475,476],[476,477],[477,474]]),j("FACEMESH_RIGHT_EYE",Sn),j("FACEMESH_RIGHT_EYEBROW",yi),j("FACEMESH_RIGHT_IRIS",[[469,470],[470,471],[471,472],[472,469]]),j("FACEMESH_FACE_OVAL",fa),j("FACEMESH_CONTOURS",pa),j("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),j("matrixDataToMatrix",function(O){for(var U=O.getCols(),G=O.getRows(),ce=O.getPackedDataList(),Ne=[],qe=0;qe<G;qe++)Ne.push(Array(U));for(qe=0;qe<G;qe++)for(var Ae=0;Ae<U;Ae++){var Ye=O.getLayout()===1?qe*U+Ae:Ae*G+qe;Ne[qe][Ae]=ce[Ye]}return Ne}),j("VERSION","0.4.1633559619")}).call(AT)),AT}var o6e=i6e();var Pl=function(){return Pl=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t},Pl.apply(this,arguments)};function Qu(t,e,n,r){return new(n||(n=Promise))((function(s,i){function o(u){try{l(r.next(u))}catch(c){i(c)}}function a(u){try{l(r.throw(u))}catch(c){i(c)}}function l(u){var c;u.done?s(u.value):(c=u.value,c instanceof n?c:new n((function(d){d(c)}))).then(o,a)}l((r=r.apply(t,[])).next())}))}function Ju(t,e){var n,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(u){return(function(c){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,r=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){o.label=c[1];break}if(c[0]===6&&o.label<s[1]){o.label=s[1],s=c;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(c);break}s[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(t,o)}catch(d){c=[6,d],r=0}finally{n=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}})([l,u])}}}function Hc(t){var e=t.map((function(n){return n[0]}));return e.push(t[t.length-1][1]),e}var sH={lips:Hc([[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]]),leftEye:Hc([[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]]),leftEyebrow:Hc([[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]]),leftIris:Hc([[474,475],[475,476],[476,477],[477,474]]),rightEye:Hc([[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]]),rightEyebrow:Hc([[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]]),rightIris:Hc([[469,470],[470,471],[471,472],[472,469]]),faceOval:Hc([[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]])},a6e=[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]],l6e=Object.entries(sH).map((function(t){var e=t[0];return t[1].map((function(n){return[n,e]}))})).flat(),iH=new Map(l6e);function rC(t){for(var e={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,o=0;o<t.length;++o){var a=t[o];n=Math.min(n,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),i=Math.max(i,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:i,width:r-n,height:i-s},e}var RT={runtime:"mediapipe",maxFaces:1,refineLandmarks:!1},u6e=(function(){function t(e){var n=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceMeshSolution=new o6e.FaceMesh({locateFile:function(r,s){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+r:s+"/"+r}}),this.faceMeshSolution.setOptions({refineLandmarks:e.refineLandmarks,selfieMode:this.selfieMode,maxNumFaces:e.maxFaces}),this.faceMeshSolution.onResults((function(r){if(n.height=r.image.height,n.width=r.image.width,n.faces=[],r.multiFaceLandmarks!==null)for(var s=r.multiFaceLandmarks,i=0;i<s.length;i++){var o=n.translateOutput(s[i]);n.faces.push({keypoints:o,box:rC(o).locationData.relativeBoundingBox})}}))}return t.prototype.translateOutput=function(e){var n=this;return e.map((function(r,s){var i={x:r.x*n.width,y:r.y*n.height,z:r.z*n.width},o=iH.get(s);return o!=null&&(i.name=o),i}))},t.prototype.estimateFaces=function(e,n){return Qu(this,void 0,void 0,(function(){var r,s;return Ju(this,(function(i){switch(i.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.faceMeshSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Rn?(s=ImageData.bind,[4,kk(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,i.label=3;case 3:return e=r,[4,this.faceMeshSolution.send({image:e})];case 4:return i.sent(),[2,this.faces]}}))}))},t.prototype.dispose=function(){this.faceMeshSolution.close()},t.prototype.reset=function(){this.faceMeshSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.faceMeshSolution.initialize()},t})();function c6e(t){return Qu(this,void 0,void 0,(function(){var e,n;return Ju(this,(function(r){switch(r.label){case 0:return e=(function(s){if(s==null)return Pl({},RT);var i=Pl({},s);return i.runtime="mediapipe",i.maxFaces==null&&(i.maxFaces=RT.maxFaces),i.refineLandmarks==null&&(i.refineLandmarks=RT.refineLandmarks),i})(t),[4,(n=new u6e(e)).initialize()];case 1:return r.sent(),[2,n]}}))}))}var DT=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},h6e={};(function(){var t;function e(C){var W=0;return function(){return W<C.length?{done:!1,value:C[W++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(C,W,X){return C==Array.prototype||C==Object.prototype||(C[W]=X.value),C},r=(function(C){C=[typeof globalThis=="object"&&globalThis,C,typeof window=="object"&&window,typeof self=="object"&&self,typeof DT=="object"&&DT];for(var W=0;W<C.length;++W){var X=C[W];if(X&&X.Math==Math)return X}throw Error("Cannot find global object")})(this);function s(C,W){if(W)e:{var X=r;C=C.split(".");for(var te=0;te<C.length-1;te++){var ae=C[te];if(!(ae in X))break e;X=X[ae]}(W=W(te=X[C=C[C.length-1]]))!=te&&W!=null&&n(X,C,{configurable:!0,writable:!0,value:W})}}function i(C){return(C={next:C})[Symbol.iterator]=function(){return this},C}function o(C){var W=typeof Symbol<"u"&&Symbol.iterator&&C[Symbol.iterator];return W?W.call(C):{next:e(C)}}function a(C){if(!(C instanceof Array)){C=o(C);for(var W,X=[];!(W=C.next()).done;)X.push(W.value);C=X}return C}s("Symbol",(function(C){function W(ae,ie){this.g=ae,n(this,"description",{configurable:!0,writable:!0,value:ie})}if(C)return C;W.prototype.toString=function(){return this.g};var X="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",te=0;return function ae(ie){if(this instanceof ae)throw new TypeError("Symbol is not a constructor");return new W(X+(ie||"")+"_"+te++,ie)}})),s("Symbol.iterator",(function(C){if(C)return C;C=Symbol("Symbol.iterator");for(var W="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),X=0;X<W.length;X++){var te=r[W[X]];typeof te=="function"&&typeof te.prototype[C]!="function"&&n(te.prototype,C,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return C}));var l,u=typeof Object.create=="function"?Object.create:function(C){function W(){}return W.prototype=C,new W};if(typeof Object.setPrototypeOf=="function")l=Object.setPrototypeOf;else{var c;e:{var d={};try{d.__proto__={a:!0},c=d.a;break e}catch{}c=!1}l=c?function(C,W){if(C.__proto__=W,C.__proto__!==W)throw new TypeError(C+" is not extensible");return C}:null}var f=l;function m(C,W){if(C.prototype=u(W.prototype),C.prototype.constructor=C,f)f(C,W);else for(var X in W)if(X!="prototype")if(Object.defineProperties){var te=Object.getOwnPropertyDescriptor(W,X);te&&Object.defineProperty(C,X,te)}else C[X]=W[X];C.na=W.prototype}function g(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.u=this.o=0,this.j=null}function y(C){if(C.l)throw new TypeError("Generator is already running");C.l=!0}function v(C,W){C.j={da:W,ea:!0},C.g=C.o||C.u}function b(C,W,X){return C.g=X,{value:W}}function x(C){this.g=new g,this.h=C}function $(C,W,X,te){try{var ae=W.call(C.g.i,X);if(!(ae instanceof Object))throw new TypeError("Iterator result "+ae+" is not an object");if(!ae.done)return C.g.l=!1,ae;var ie=ae.value}catch(he){return C.g.i=null,v(C.g,he),S(C)}return C.g.i=null,te.call(C.g,ie),S(C)}function S(C){for(;C.g.g;)try{var W=C.h(C.g);if(W)return C.g.l=!1,{value:W.value,done:!1}}catch(X){C.g.h=void 0,v(C.g,X)}if(C.g.l=!1,C.g.j){if(W=C.g.j,C.g.j=null,W.ea)throw W.da;return{value:W.return,done:!0}}return{value:void 0,done:!0}}function E(C){this.next=function(W){return y(C.g),C.g.i?W=$(C,C.g.i.next,W,C.g.s):(C.g.s(W),W=S(C)),W},this.throw=function(W){return y(C.g),C.g.i?W=$(C,C.g.i.throw,W,C.g.s):(v(C.g,W),W=S(C)),W},this.return=function(W){return(function(X,te){y(X.g);var ae=X.g.i;return ae?$(X,"return"in ae?ae.return:function(ie){return{value:ie,done:!0}},te,X.g.return):(X.g.return(te),S(X))})(C,W)},this[Symbol.iterator]=function(){return this}}function L(C){return(function(W){function X(ae){return W.next(ae)}function te(ae){return W.throw(ae)}return new Promise((function(ae,ie){(function he(xe){xe.done?ae(xe.value):Promise.resolve(xe.value).then(X,te).then(he,ie)})(W.next())}))})(new E(new x(C)))}g.prototype.s=function(C){this.h=C},g.prototype.return=function(C){this.j={return:C},this.g=this.u},s("Promise",(function(C){function W(he){this.h=0,this.i=void 0,this.g=[],this.s=!1;var xe=this.j();try{he(xe.resolve,xe.reject)}catch(Me){xe.reject(Me)}}function X(){this.g=null}function te(he){return he instanceof W?he:new W((function(xe){xe(he)}))}if(C)return C;X.prototype.h=function(he){if(this.g==null){this.g=[];var xe=this;this.i((function(){xe.l()}))}this.g.push(he)};var ae=r.setTimeout;X.prototype.i=function(he){ae(he,0)},X.prototype.l=function(){for(;this.g&&this.g.length;){var he=this.g;this.g=[];for(var xe=0;xe<he.length;++xe){var Me=he[xe];he[xe]=null;try{Me()}catch(Qe){this.j(Qe)}}}this.g=null},X.prototype.j=function(he){this.i((function(){throw he}))},W.prototype.j=function(){function he(Qe){return function(Ze){Me||(Me=!0,Qe.call(xe,Ze))}}var xe=this,Me=!1;return{resolve:he(this.D),reject:he(this.l)}},W.prototype.D=function(he){if(he===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(he instanceof W)this.H(he);else{e:switch(typeof he){case"object":var xe=he!=null;break e;case"function":xe=!0;break e;default:xe=!1}xe?this.A(he):this.o(he)}},W.prototype.A=function(he){var xe=void 0;try{xe=he.then}catch(Me){return void this.l(Me)}typeof xe=="function"?this.I(xe,he):this.o(he)},W.prototype.l=function(he){this.u(2,he)},W.prototype.o=function(he){this.u(1,he)},W.prototype.u=function(he,xe){if(this.h!=0)throw Error("Cannot settle("+he+", "+xe+"): Promise already settled in state"+this.h);this.h=he,this.i=xe,this.h===2&&this.G(),this.B()},W.prototype.G=function(){var he=this;ae((function(){if(he.C()){var xe=r.console;xe!==void 0&&xe.error(he.i)}}),1)},W.prototype.C=function(){if(this.s)return!1;var he=r.CustomEvent,xe=r.Event,Me=r.dispatchEvent;return Me===void 0||(typeof he=="function"?he=new he("unhandledrejection",{cancelable:!0}):typeof xe=="function"?he=new xe("unhandledrejection",{cancelable:!0}):(he=r.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,he),he.promise=this,he.reason=this.i,Me(he))},W.prototype.B=function(){if(this.g!=null){for(var he=0;he<this.g.length;++he)ie.h(this.g[he]);this.g=null}};var ie=new X;return W.prototype.H=function(he){var xe=this.j();he.M(xe.resolve,xe.reject)},W.prototype.I=function(he,xe){var Me=this.j();try{he.call(xe,Me.resolve,Me.reject)}catch(Qe){Me.reject(Qe)}},W.prototype.then=function(he,xe){function Me(mt,yt){return typeof mt=="function"?function(nn){try{Qe(mt(nn))}catch(sn){Ze(sn)}}:yt}var Qe,Ze,dt=new W((function(mt,yt){Qe=mt,Ze=yt}));return this.M(Me(he,Qe),Me(xe,Ze)),dt},W.prototype.catch=function(he){return this.then(void 0,he)},W.prototype.M=function(he,xe){function Me(){switch(Qe.h){case 1:he(Qe.i);break;case 2:xe(Qe.i);break;default:throw Error("Unexpected state: "+Qe.h)}}var Qe=this;this.g==null?ie.h(Me):this.g.push(Me),this.s=!0},W.resolve=te,W.reject=function(he){return new W((function(xe,Me){Me(he)}))},W.race=function(he){return new W((function(xe,Me){for(var Qe=o(he),Ze=Qe.next();!Ze.done;Ze=Qe.next())te(Ze.value).M(xe,Me)}))},W.all=function(he){var xe=o(he),Me=xe.next();return Me.done?te([]):new W((function(Qe,Ze){function dt(nn){return function(sn){mt[nn]=sn,--yt==0&&Qe(mt)}}var mt=[],yt=0;do mt.push(void 0),yt++,te(Me.value).M(dt(mt.length-1),Ze),Me=xe.next();while(!Me.done)}))},W}));var R=typeof Object.assign=="function"?Object.assign:function(C,W){for(var X=1;X<arguments.length;X++){var te=arguments[X];if(te)for(var ae in te)Object.prototype.hasOwnProperty.call(te,ae)&&(C[ae]=te[ae])}return C};s("Object.assign",(function(C){return C||R})),s("Object.is",(function(C){return C||function(W,X){return W===X?W!==0||1/W==1/X:W!=W&&X!=X}})),s("Array.prototype.includes",(function(C){return C||function(W,X){var te=this;te instanceof String&&(te=String(te));var ae=te.length;for(0>(X=X||0)&&(X=Math.max(X+ae,0));X<ae;X++){var ie=te[X];if(ie===W||Object.is(ie,W))return!0}return!1}})),s("String.prototype.includes",(function(C){return C||function(W,X){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(W instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(W,X||0)!==-1}})),s("Array.prototype.keys",(function(C){return C||function(){return(function(W,X){W instanceof String&&(W+="");var te=0,ae=!1,ie={next:function(){if(!ae&&te<W.length){var he=te++;return{value:X(he,W[he]),done:!1}}return ae=!0,{done:!0,value:void 0}}};return ie[Symbol.iterator]=function(){return ie},ie})(this,(function(W){return W}))}}));var D=this||self;function A(C,W){C=C.split(".");var X,te=D;for((C[0]in te)||te.execScript===void 0||te.execScript("var "+C[0]);C.length&&(X=C.shift());)C.length||W===void 0?te=te[X]&&te[X]!==Object.prototype[X]?te[X]:te[X]={}:te[X]=W}function F(){throw Error("Invalid UTF8")}function P(C,W){return W=String.fromCharCode.apply(null,W),C==null?W:C+W}var K,j,se=typeof TextDecoder<"u",fe=typeof TextEncoder<"u",me={},ye=null;function oe(C){var W;W===void 0&&(W=0),_e(),W=me[W];for(var X=Array(Math.floor(C.length/3)),te=W[64]||"",ae=0,ie=0;ae<C.length-2;ae+=3){var he=C[ae],xe=C[ae+1],Me=C[ae+2],Qe=W[he>>2];he=W[(3&he)<<4|xe>>4],xe=W[(15&xe)<<2|Me>>6],Me=W[63&Me],X[ie++]=Qe+he+xe+Me}switch(Qe=0,Me=te,C.length-ae){case 2:Me=W[(15&(Qe=C[ae+1]))<<2]||te;case 1:C=C[ae],X[ie]=W[C>>2]+W[(3&C)<<4|Qe>>4]+Me+te}return X.join("")}function ue(C){var W=C.length,X=3*W/4;X%3?X=Math.floor(X):"=.".indexOf(C[W-1])!=-1&&(X="=.".indexOf(C[W-2])!=-1?X-2:X-1);var te=new Uint8Array(X),ae=0;return(function(ie,he){function xe(yt){for(;Me<ie.length;){var nn=ie.charAt(Me++),sn=ye[nn];if(sn!=null)return sn;if(!/^[\s\xa0]*$/.test(nn))throw Error("Unknown base64 encoding at char: "+nn)}return yt}_e();for(var Me=0;;){var Qe=xe(-1),Ze=xe(0),dt=xe(64),mt=xe(64);if(mt===64&&Qe===-1)break;he(Qe<<2|Ze>>4),dt!=64&&(he(Ze<<4&240|dt>>2),mt!=64&&he(dt<<6&192|mt))}})(C,(function(ie){te[ae++]=ie})),ae!==X?te.subarray(0,ae):te}function _e(){if(!ye){ye={};for(var C="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),W=["+/=","+/","-_=","-_.","-_"],X=0;5>X;X++){var te=C.concat(W[X].split(""));me[X]=te;for(var ae=0;ae<te.length;ae++){var ie=te[ae];ye[ie]===void 0&&(ye[ie]=ae)}}}}var Y,re=typeof Uint8Array=="function";function Te(C){return re&&C!=null&&C instanceof Uint8Array}function Pe(C){if(this.L=C,C!==null&&C.length===0)throw Error("ByteString should be constructed with non-empty values")}var de=typeof Uint8Array.prototype.slice=="function",ge=0;function Re(C,W){return Error("Invalid wire type: "+C+" (at position "+W+")")}function Oe(){return Error("Failed to read varint, encoding is invalid.")}function Ve(C,W){W=(W=W===void 0?{}:W).v!==void 0&&W.v,this.h=null,this.g=this.i=this.j=0,this.v=W,C&&We(this,C)}function We(C,W){C.h=(function(X,te){if(X.constructor===Uint8Array)return X;if(X.constructor===ArrayBuffer)return new Uint8Array(X);if(X.constructor===Array)return new Uint8Array(X);if(X.constructor===String)return ue(X);if(X.constructor===Pe)return!te&&(te=X.L)&&te.constructor===Uint8Array?te:(te=(te=X.L)==null||Te(te)?te:typeof te=="string"?ue(te):null,(X=X.L=te)?new Uint8Array(X):Y||(Y=new Uint8Array(0)));if(X instanceof Uint8Array)return new Uint8Array(X.buffer,X.byteOffset,X.byteLength);throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers")})(W,C.v),C.j=0,C.i=C.h.length,C.g=C.j}function nt(C){if(C.g>C.i)throw Error("Tried to read past the end of the data "+C.g+" > "+C.i)}function ct(C){var W=C.h,X=W[C.g],te=127&X;if(128>X)return C.g+=1,nt(C),te;if(te|=(127&(X=W[C.g+1]))<<7,128>X)return C.g+=2,nt(C),te;if(te|=(127&(X=W[C.g+2]))<<14,128>X)return C.g+=3,nt(C),te;if(te|=(127&(X=W[C.g+3]))<<21,128>X)return C.g+=4,nt(C),te;if(X=W[C.g+4],C.g+=5,te|=(15&X)<<28,128>X)return nt(C),te;if(128<=W[C.g++]&&128<=W[C.g++]&&128<=W[C.g++]&&128<=W[C.g++]&&128<=W[C.g++])throw Oe();return nt(C),te}Ve.prototype.reset=function(){this.g=this.j};var Ct=[];function Wt(){this.g=[]}function Et(C,W){for(;127<W;)C.g.push(127&W|128),W>>>=7;C.g.push(W)}function vt(C){var W={},X=W.W!==void 0&&W.W;this.l={v:W.v!==void 0&&W.v},this.W=X,W=this.l,Ct.length?(X=Ct.pop(),W&&(X.v=W.v),C&&We(X,C),C=X):C=new Ve(C,W),this.g=C,this.j=this.g.g,this.h=this.i=-1}function Ht(C){var W=C.g;if(W.g==W.i)return!1;C.j=C.g.g;var X=ct(C.g)>>>0;if(W=X>>>3,!(0<=(X&=7)&&5>=X))throw Re(X,C.j);if(1>W)throw Error("Invalid field number: "+W+" (at position "+C.j+")");return C.i=W,C.h=X,!0}function Tt(C){switch(C.h){case 0:if(C.h!=0)Tt(C);else e:{for(var W=(C=C.g).g,X=W+10;W<X;)if((128&C.h[W++])==0){C.g=W,nt(C);break e}throw Oe()}break;case 1:(C=C.g).g+=8,nt(C);break;case 2:C.h!=2?Tt(C):(W=ct(C.g)>>>0,(C=C.g).g+=W,nt(C));break;case 5:(C=C.g).g+=4,nt(C);break;case 3:for(W=C.i;;){if(!Ht(C))throw Error("Unmatched start-group tag: stream EOF");if(C.h==4){if(C.i!=W)throw Error("Unmatched end-group tag");break}Tt(C)}break;default:throw Re(C.h,C.j)}}Wt.prototype.length=function(){return this.g.length},Wt.prototype.end=function(){var C=this.g;return this.g=[],C},vt.prototype.reset=function(){this.g.reset(),this.j=this.g.g,this.h=this.i=-1};var Pt=[];function Rt(){this.i=[],this.h=0,this.g=new Wt}function Yt(C,W){W.length!==0&&(C.i.push(W),C.h+=W.length)}var mn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol(void 0):void 0;function jt(C,W){Object.isFrozen(C)||(mn?C[mn]|=W:C.N!==void 0?C.N|=W:Object.defineProperties(C,{N:{value:W,configurable:!0,writable:!0,enumerable:!1}}))}function Fn(C){var W;return(W=mn?C[mn]:C.N)==null?0:W}function Vn(C){return jt(C,1),C}function Bn(C){return!!Array.isArray(C)&&!!(2&Fn(C))}function Ln(C){if(!Array.isArray(C))throw Error("cannot mark non-array as immutable");jt(C,2)}function Tn(C){return C!==null&&typeof C=="object"&&!Array.isArray(C)&&C.constructor===Object}var xr=Object.freeze(Vn([]));function fr(C){if(Bn(C.m))throw Error("Cannot mutate an immutable Message")}var Ar,Hs=typeof Symbol<"u"&&Symbol.hasInstance!==void 0;function qr(C){return{value:C,configurable:!1,writable:!1,enumerable:!1}}function gr(C,W,X){return W===-1?null:W>=C.i?C.g?C.g[W]:void 0:X!==void 0&&X&&C.g&&(X=C.g[W])!=null?X:C.m[W+C.h]}function ir(C,W,X,te){te=te!==void 0&&te,fr(C),W<C.i&&!te?C.m[W+C.h]=X:(C.g||(C.g=C.m[C.i+C.h]={}))[W]=X}function Un(C,W,X,te){X=X===void 0||X;var ae=gr(C,W,te=te!==void 0&&te);return ae==null&&(ae=xr),Bn(C.m)?X&&(Ln(ae),Object.freeze(ae)):(ae===xr||Bn(ae))&&ir(C,W,ae=Vn(ae.slice()),te),ae}function Kr(C,W,X){return(C=(C=gr(C,W))==null?C:+C)==null?X===void 0?0:X:C}function ui(C,W,X,te){C.j||(C.j={});var ae=Bn(C.m),ie=C.j[X];if(!ie){te=Un(C,X,!0,te!==void 0&&te),ie=[],ae=ae||Bn(te);for(var he=0;he<te.length;he++)ie[he]=new W(te[he]),ae&&Ln(ie[he].m);ae&&(Ln(ie),Object.freeze(ie)),C.j[X]=ie}return ie}function Gn(C,W,X,te,ae){var ie=ie!==void 0&&ie;return fr(C),ie=ui(C,X,W,ie),X=te||new X,C=Un(C,W),ae!=null?(ie.splice(ae,0,X),C.splice(ae,0,X.m)):(ie.push(X),C.push(X.m)),X}function Cs(C,W){return(C=gr(C,W))==null?0:C}function ci(C,W){return(C=gr(C,W))==null?"":C}function Kn(C){var W=Qi;return hn(C,W=W===void 0?Po:W)}function Dn(C,W){if(C!=null){if(Array.isArray(C))C=hn(C,W);else if(Tn(C)){var X,te={};for(X in C)te[X]=Dn(C[X],W);C=te}else C=W(C);return C}}function hn(C,W){for(var X=C.slice(),te=0;te<X.length;te++)X[te]=Dn(X[te],W);return Array.isArray(C)&&1&Fn(C)&&Vn(X),X}function Qi(C){return C&&typeof C=="object"&&C.toJSON?C.toJSON():(C=(function(W){switch(typeof W){case"number":return isFinite(W)?W:String(W);case"object":if(W&&!Array.isArray(W)){if(Te(W))return oe(W);if(W instanceof Pe){var X=W.L;return X=X==null||typeof X=="string"?X:re&&X instanceof Uint8Array?oe(X):null,(W.L=X)||""}}}return W})(C),Array.isArray(C)?Kn(C):C)}function Po(C){return Te(C)?new Uint8Array(C):C}function bo(C,W,X){C||(C=Ar),Ar=null;var te=this.constructor.h;if(C||(C=te?[te]:[]),this.h=(te?0:-1)-(this.constructor.g||0),this.j=void 0,this.m=C,C=(te=this.m.length)-1,te&&Tn(te=this.m[C])?(this.i=C-this.h,this.g=te):W!==void 0&&-1<W?(this.i=Math.max(W,C+1-this.h),this.g=void 0):this.i=Number.MAX_VALUE,X)for(W=0;W<X.length;W++)if((C=X[W])<this.i)C+=this.h,(te=this.m[C])?Array.isArray(te)&&Vn(te):this.m[C]=xr;else{var ae=(te=this.g||(this.g=this.m[this.i+this.h]={}))[C];ae?Array.isArray(ae)&&Vn(ae):te[C]=xr}}function bs(){bo.apply(this,arguments)}if(bo.prototype.toJSON=function(){return Kn(this.m)},bo.prototype.toString=function(){return this.m.toString()},m(bs,bo),Hs){var hi={};Object.defineProperties(bs,(hi[Symbol.hasInstance]=qr((function(){throw Error("Cannot perform instanceof checks for MutableMessage")})),hi))}function Pi(C,W,X){if(X){var te,ae={};for(te in X){var ie=X[te],he=ie.ha;he||(ae.F=ie.la||ie.fa.P,ie.aa?(ae.U=ks(ie.aa),he=(function(xe){return function(Me,Qe,Ze){return xe.F(Me,Qe,Ze,xe.U)}})(ae)):ie.ca?(ae.T=ua(ie.X.g,ie.ca),he=(function(xe){return function(Me,Qe,Ze){return xe.F(Me,Qe,Ze,xe.T)}})(ae)):he=ae.F,ie.ha=he),he(W,C,ie.X),ae={F:ae.F,U:ae.U,T:ae.T}}}(function(xe,Me){if(Me=Me.ba){Yt(xe,xe.g.end());for(var Qe=0;Qe<Me.length;Qe++)Yt(xe,Me[Qe])}})(W,C)}var Or=Symbol();function cs(C,W,X){return C[Or]||(C[Or]=function(te,ae){return W(te,ae,X)})}function Aa(C){var W=C[Or];if(!W){var X=fi(C);W=function(te,ae){return gn(te,ae,X)},C[Or]=W}return W}function Ji(C){var W=(function(ae){var ie=ae.aa;return ie?Aa(ie):(ie=ae.ka)?cs(ae.X.g,ie,ae.ca):void 0})(C),X=C.X,te=C.fa.O;return W?function(ae,ie){return te(ae,ie,X,W)}:function(ae,ie){return te(ae,ie,X)}}function cr(C,W,X,te,ae,ie){var he=0;for((C=C()).length&&typeof C[0]!="number"&&(X(W,C[0]),he++);he<C.length;){X=C[he++];for(var xe=he+1;xe<C.length&&typeof C[xe]!="number";)xe++;var Me=C[he++];switch(xe-=he){case 0:te(W,X,Me);break;case 1:te(W,X,Me,C[he++]);break;case 2:ae(W,X,Me,C[he++],C[he++]);break;case 3:xe=C[he++];var Qe=C[he++],Ze=C[he++];Array.isArray(Ze)?ae(W,X,Me,xe,Qe,Ze):ie(W,X,Me,xe,Qe,Ze);break;case 4:ie(W,X,Me,C[he++],C[he++],C[he++],C[he++]);break;default:throw Error("unexpected number of binary field arguments: "+xe)}}return W}var Es=Symbol();function ks(C){var W=C[Es];if(!W){var X=Ra(C);W=function(te,ae){return Zi(te,ae,X)},C[Es]=W}return W}function ua(C,W){var X=C[Es];return X||(X=function(te,ae){return Pi(te,ae,W)},C[Es]=X),X}var Ns=Symbol();function di(C,W){C.push(W)}function qs(C,W,X){C.push(W,X.P)}function Fi(C,W,X,te,ae){var ie=ks(ae),he=X.P;C.push(W,(function(xe,Me,Qe){return he(xe,Me,Qe,te,ie)}))}function Ks(C,W,X,te,ae,ie){var he=ua(te,ie),xe=X.P;C.push(W,(function(Me,Qe,Ze){return xe(Me,Qe,Ze,te,he)}))}function Ra(C){var W=C[Ns];return W||cr(C,C[Ns]=[],di,qs,Fi,Ks)}var ca=Symbol();function Rr(C,W){C[0]=W}function cl(C,W,X,te){var ae=X.O;C[W]=te?function(ie,he,xe){return ae(ie,he,xe,te)}:ae}function Fo(C,W,X,te,ae,ie){var he=X.O,xe=Aa(ae);C[W]=function(Me,Qe,Ze){return he(Me,Qe,Ze,te,xe,ie)}}function Xr(C,W,X,te,ae,ie,he){var xe=X.O,Me=cs(te,ae,ie);C[W]=function(Qe,Ze,dt){return xe(Qe,Ze,dt,te,Me,he)}}function fi(C){var W=C[ca];return W||cr(C,C[ca]={},Rr,cl,Fo,Xr)}function gn(C,W,X){for(;Ht(W)&&W.h!=4;){var te=W.i,ae=X[te];if(!ae){var ie=X[0];ie&&(ie=ie[te])&&(ae=X[te]=Ji(ie))}if(!(ae&&ae(W,C,te)||(ae=W,te=C,ie=ae.j,Tt(ae),ae.W))){var he=ae.g.h;ae=ie===(ae=ae.g.g)?Y||(Y=new Uint8Array(0)):de?he.slice(ie,ae):new Uint8Array(he.subarray(ie,ae)),(ie=te.ba)?ie.push(ae):te.ba=[ae]}}return C}function hs(C,W,X){if(Pt.length){var te=Pt.pop();C&&(We(te.g,C),te.i=-1,te.h=-1),C=te}else C=new vt(C);try{return gn(new W,C,fi(X))}finally{(W=C.g).h=null,W.j=0,W.i=0,W.g=0,W.v=!1,C.i=-1,C.h=-1,100>Pt.length&&Pt.push(C)}}function Zi(C,W,X){for(var te=X.length,ae=te%2==1,ie=ae?1:0;ie<te;ie+=2)(0,X[ie+1])(W,C,X[ie]);Pi(C,W,ae?X[0]:void 0)}function xo(C,W){var X=new Rt;Zi(C,X,Ra(W)),Yt(X,X.g.end()),C=new Uint8Array(X.h);for(var te=(W=X.i).length,ae=0,ie=0;ie<te;ie++){var he=W[ie];C.set(he,ae),ae+=he.length}return X.i=[C],C}function pi(C,W){return{O:C,P:W}}var xs=pi((function(C,W,X){if(C.h!==5)return!1;var te=(C=C.g).h[C.g],ae=C.h[C.g+1],ie=C.h[C.g+2],he=C.h[C.g+3];return C.g+=4,nt(C),C=2*((ae=(te<<0|ae<<8|ie<<16|he<<24)>>>0)>>31)+1,te=ae>>>23&255,ae&=8388607,ir(W,X,te==255?ae?NaN:1/0*C:te==0?C*Math.pow(2,-149)*ae:C*Math.pow(2,te-150)*(ae+Math.pow(2,23))),!0}),(function(C,W,X){if((W=gr(W,X))!=null){Et(C.g,8*X+5),C=C.g;var te=W;(te=(X=0>te?1:0)?-te:te)===0?0<1/te?ge=0:ge=2147483648:isNaN(te)?ge=2147483647:34028234663852886e22<te?ge=(X<<31|2139095040)>>>0:11754943508222875e-54>te?(te=Math.round(te/Math.pow(2,-149)),ge=(X<<31|te)>>>0):(W=Math.floor(Math.log(te)/Math.LN2),te*=Math.pow(2,-W),16777216<=(te=Math.round(8388608*te))&&++W,ge=(X<<31|W+127<<23|8388607&te)>>>0),X=ge,C.g.push(X>>>0&255),C.g.push(X>>>8&255),C.g.push(X>>>16&255),C.g.push(X>>>24&255)}})),Da=pi((function(C,W,X){if(C.h!==0)return!1;for(var te=C.g,ae=128,ie=0,he=C=0;4>he&&128<=ae;he++)ae=te.h[te.g++],nt(te),ie|=(127&ae)<<7*he;if(128<=ae&&(ae=te.h[te.g++],nt(te),ie|=(127&ae)<<28,C|=(127&ae)>>4),128<=ae)for(he=0;5>he&&128<=ae;he++)ae=te.h[te.g++],nt(te),C|=(127&ae)<<7*he+3;if(!(128>ae))throw Oe();return te=ie>>>0,(C=2147483648&(ae=C>>>0))&&(ae=~ae>>>0,(te=1+~te>>>0)==0&&(ae=ae+1>>>0)),te=4294967296*ae+(te>>>0),ir(W,X,C?-te:te),!0}),(function(C,W,X){if((W=gr(W,X))!=null&&W!=null){Et(C.g,8*X),C=C.g;var te=W;for(X=0>te,W=(te=Math.abs(te))>>>0,te=Math.floor((te-W)/4294967296),te>>>=0,X&&(te=~te>>>0,4294967295<(W=1+(~W>>>0))&&(W=0,4294967295<++te&&(te=0))),X=ge=W,W=te;0<W||127<X;)C.g.push(127&X|128),X=(X>>>7|W<<25)>>>0,W>>>=7;C.g.push(X)}})),ha=pi((function(C,W,X){return C.h===0&&(ir(W,X,ct(C.g)),!0)}),(function(C,W,X){if((W=gr(W,X))!=null&&W!=null)if(Et(C.g,8*X),C=C.g,0<=(X=W))Et(C,X);else{for(W=0;9>W;W++)C.g.push(127&X|128),X>>=7;C.g.push(1)}})),As=pi((function(C,W,X){if(C.h!==2)return!1;var te,ae=ct(C.g)>>>0,ie=(C=C.g).g;if(C.g+=ae,nt(C),C=C.h,se)(te=K)||(te=K=new TextDecoder("utf-8",{fatal:!0})),te=te.decode(C.subarray(ie,ie+ae));else{ae=ie+ae;for(var he,xe,Me,Qe=[],Ze=null;ie<ae;)128>(he=C[ie++])?Qe.push(he):224>he?ie>=ae?F():(xe=C[ie++],194>he||(192&xe)!=128?(ie--,F()):Qe.push((31&he)<<6|63&xe)):240>he?ie>=ae-1?F():(192&(xe=C[ie++]))!=128||he===224&&160>xe||he===237&&160<=xe||(192&(te=C[ie++]))!=128?(ie--,F()):Qe.push((15&he)<<12|(63&xe)<<6|63&te):244>=he?ie>=ae-2?F():(192&(xe=C[ie++]))!=128||xe-144+(he<<28)>>30!=0||(192&(te=C[ie++]))!=128||(192&(Me=C[ie++]))!=128?(ie--,F()):(he=(7&he)<<18|(63&xe)<<12|(63&te)<<6|63&Me,he-=65536,Qe.push(55296+(he>>10&1023),56320+(1023&he))):F(),8192<=Qe.length&&(Ze=P(Ze,Qe),Qe.length=0);te=P(Ze,Qe)}return ir(W,X,te),!0}),(function(C,W,X){if((W=gr(W,X))!=null){var te=!1;if(te=te!==void 0&&te,fe){if(te&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(W))throw Error("Found an unpaired surrogate");W=(j||(j=new TextEncoder)).encode(W)}else{for(var ae=0,ie=new Uint8Array(3*W.length),he=0;he<W.length;he++){var xe=W.charCodeAt(he);if(128>xe)ie[ae++]=xe;else{if(2048>xe)ie[ae++]=xe>>6|192;else{if(55296<=xe&&57343>=xe){if(56319>=xe&&he<W.length){var Me=W.charCodeAt(++he);if(56320<=Me&&57343>=Me){xe=1024*(xe-55296)+Me-56320+65536,ie[ae++]=xe>>18|240,ie[ae++]=xe>>12&63|128,ie[ae++]=xe>>6&63|128,ie[ae++]=63&xe|128;continue}he--}if(te)throw Error("Found an unpaired surrogate");xe=65533}ie[ae++]=xe>>12|224,ie[ae++]=xe>>6&63|128}ie[ae++]=63&xe|128}}W=ie.subarray(0,ae)}Et(C.g,8*X+2),Et(C.g,W.length),Yt(C,C.g.end()),Yt(C,W)}})),mi=pi((function(C,W,X,te,ae){if(C.h!==2)return!1;W=Gn(W,X,te),X=C.g.i,te=ct(C.g)>>>0;var ie=C.g.g+te,he=ie-X;if(0>=he&&(C.g.i=ie,ae(W,C),he=ie-C.g.g),he)throw Error("Message parsing ended unexpectedly. Expected to read "+te+" bytes, instead read "+(te-he)+" bytes, either the data ended unexpectedly or the message misreported its own length");return C.g.g=ie,C.g.i=X,!0}),(function(C,W,X,te,ae){if((W=ui(W,te,X))!=null)for(te=0;te<W.length;te++){var ie=C;Et(ie.g,8*X+2);var he=ie.g.end();Yt(ie,he),he.push(ie.h),ie=he,ae(W[te],C),he=C;var xe=ie.pop();for(xe=he.h+he.g.length()-xe;127<xe;)ie.push(127&xe|128),xe>>>=7,he.h++;ie.push(xe),he.h++}}));function hr(){bs.apply(this,arguments)}if(m(hr,bs),Hs){var Li={};Object.defineProperties(hr,(Li[Symbol.hasInstance]=qr(Object[Symbol.hasInstance]),Li))}function Pr(C){hr.call(this,C)}function Lo(){return[1,ha,2,xs,3,As,4,As]}function gi(C){hr.call(this,C,-1,Hn)}function Mo(){return[1,mi,Pr,Lo]}m(Pr,hr),m(gi,hr),gi.prototype.addClassification=function(C,W){return Gn(this,1,Pr,C,W),this};var Hn=[1];function Rs(C){hr.call(this,C)}function zo(){return[1,xs,2,xs,3,xs,4,xs,5,xs]}function Vo(C){hr.call(this,C,-1,dl)}function hl(){return[1,mi,Rs,zo]}m(Rs,hr),m(Vo,hr);var dl=[1];function _o(C){hr.call(this,C)}function Mi(){return[1,xs,2,xs,3,xs,4,xs,5,xs,6,Da]}m(_o,hr);var Bo=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],da=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],Sn=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],yi=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],fa=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],pa=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],Oa=[].concat(a(Bo),a(da),a(Sn),a(yi),a(fa),a(pa));function O(C,W,X){if(X=C.createShader(X===0?C.VERTEX_SHADER:C.FRAGMENT_SHADER),C.shaderSource(X,W),C.compileShader(X),!C.getShaderParameter(X,C.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+C.getShaderInfoLog(X));return X}function U(C){return ui(C,Pr,1).map((function(W){return{index:Cs(W,1),ga:Kr(W,2),label:gr(W,3)!=null?ci(W,3):void 0,displayName:gr(W,4)!=null?ci(W,4):void 0}}))}function G(C){return{x:Kr(C,1),y:Kr(C,2),z:Kr(C,3),visibility:gr(C,4)!=null?Kr(C,4):void 0}}function ce(C,W){this.h=C,this.g=W,this.l=0}function Ne(C,W,X){return(function(te,ae){var ie=te.g;if(te.o===void 0){var he=O(ie,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),xe=O(ie,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),Me=ie.createProgram();if(ie.attachShader(Me,he),ie.attachShader(Me,xe),ie.linkProgram(Me),!ie.getProgramParameter(Me,ie.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+ie.getProgramInfoLog(Me));he=te.o=Me,ie.useProgram(he),xe=ie.getUniformLocation(he,"sampler0"),te.j={K:ie.getAttribLocation(he,"aVertex"),J:ie.getAttribLocation(he,"aTex"),ma:xe},te.u=ie.createBuffer(),ie.bindBuffer(ie.ARRAY_BUFFER,te.u),ie.enableVertexAttribArray(te.j.K),ie.vertexAttribPointer(te.j.K,2,ie.FLOAT,!1,0,0),ie.bufferData(ie.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),ie.STATIC_DRAW),ie.bindBuffer(ie.ARRAY_BUFFER,null),te.s=ie.createBuffer(),ie.bindBuffer(ie.ARRAY_BUFFER,te.s),ie.enableVertexAttribArray(te.j.J),ie.vertexAttribPointer(te.j.J,2,ie.FLOAT,!1,0,0),ie.bufferData(ie.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),ie.STATIC_DRAW),ie.bindBuffer(ie.ARRAY_BUFFER,null),ie.uniform1i(xe,0)}he=te.j,ie.useProgram(te.o),ie.canvas.width=ae.width,ie.canvas.height=ae.height,ie.viewport(0,0,ae.width,ae.height),ie.activeTexture(ie.TEXTURE0),te.h.bindTexture2d(ae.glName),ie.enableVertexAttribArray(he.K),ie.bindBuffer(ie.ARRAY_BUFFER,te.u),ie.vertexAttribPointer(he.K,2,ie.FLOAT,!1,0,0),ie.enableVertexAttribArray(he.J),ie.bindBuffer(ie.ARRAY_BUFFER,te.s),ie.vertexAttribPointer(he.J,2,ie.FLOAT,!1,0,0),ie.bindFramebuffer(ie.DRAW_FRAMEBUFFER?ie.DRAW_FRAMEBUFFER:ie.FRAMEBUFFER,null),ie.clearColor(0,0,0,0),ie.clear(ie.COLOR_BUFFER_BIT),ie.colorMask(!0,!0,!0,!0),ie.drawArrays(ie.TRIANGLE_FAN,0,4),ie.disableVertexAttribArray(he.K),ie.disableVertexAttribArray(he.J),ie.bindBuffer(ie.ARRAY_BUFFER,null),te.h.bindTexture2d(0)})(C,W),typeof C.g.canvas.transferToImageBitmap=="function"?Promise.resolve(C.g.canvas.transferToImageBitmap()):X?Promise.resolve(C.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(C.g.canvas):(C.i===void 0&&(C.i=document.createElement("canvas")),new Promise((function(te){C.i.height=C.g.canvas.height,C.i.width=C.g.canvas.width,C.i.getContext("2d",{}).drawImage(C.g.canvas,0,0,C.g.canvas.width,C.g.canvas.height),te(C.i)})))}function qe(C){this.g=C}var Ae=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Ye(C,W){return W+C}function ot(C,W){window[C]=W}function bt(C){if(this.g=C,this.listeners={},this.j={},this.H={},this.o={},this.u={},this.I=this.s=this.Z=!0,this.D=Promise.resolve(),this.Y="",this.C={},this.locateFile=C&&C.locateFile||Ye,typeof window=="object")var W=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if(typeof location>"u")throw Error("solutions can only be loaded on a web page or in a web worker");W=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.$=W,C.options)for(var X=(W=o(Object.keys(C.options))).next();!X.done;X=W.next()){X=X.value;var te=C.options[X].default;te!==void 0&&(this.j[X]=typeof te=="function"?te():te)}}function tn(C){var W,X,te,ae,ie,he,xe,Me,Qe,Ze,dt;return L((function(mt){switch(mt.g){case 1:return C.Z?(W=C.g.files===void 0?[]:typeof C.g.files=="function"?C.g.files(C.j):C.g.files,b(mt,L((function(yt){switch(yt.g){case 1:return yt.o=2,b(yt,WebAssembly.instantiate(Ae),4);case 4:yt.g=3,yt.o=0;break;case 2:return yt.o=0,yt.j=null,yt.return(!1);case 3:return yt.return(!0)}})),2)):mt.return();case 2:if(X=mt.h,typeof window=="object")return ot("createMediapipeSolutionsWasm",{locateFile:C.locateFile}),ot("createMediapipeSolutionsPackedAssets",{locateFile:C.locateFile}),he=W.filter((function(yt){return yt.data!==void 0})),xe=W.filter((function(yt){return yt.data===void 0})),Me=Promise.all(he.map((function(yt){var nn=bn(C,yt.url);if(yt.path!==void 0){var sn=yt.path;nn=nn.then((function(er){return C.overrideFile(sn,er),Promise.resolve(er)}))}return nn}))),Qe=Promise.all(xe.map((function(yt){return yt.simd===void 0||yt.simd&&X||!yt.simd&&!X?(function(nn){var sn=document.createElement("script");return sn.setAttribute("src",nn),sn.setAttribute("crossorigin","anonymous"),new Promise((function(er){sn.addEventListener("load",(function(){er()}),!1),sn.addEventListener("error",(function(){er()}),!1),document.body.appendChild(sn)}))})(C.locateFile(yt.url,C.$)):Promise.resolve()}))).then((function(){var yt,nn,sn;return L((function(er){if(er.g==1)return yt=window.createMediapipeSolutionsWasm,nn=window.createMediapipeSolutionsPackedAssets,sn=C,b(er,yt(nn),2);sn.h=er.h,er.g=0}))})),Ze=L((function(yt){return C.g.graph&&C.g.graph.url?yt=b(yt,bn(C,C.g.graph.url),0):(yt.g=0,yt=void 0),yt})),b(mt,Promise.all([Qe,Me,Ze]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return te=W.filter((function(yt){return yt.simd===void 0||yt.simd&&X||!yt.simd&&!X})).map((function(yt){return C.locateFile(yt.url,C.$)})),importScripts.apply(null,a(te)),ae=C,b(mt,createMediapipeSolutionsWasm(Module),6);case 6:ae.h=mt.h,C.l=new OffscreenCanvas(1,1),C.h.canvas=C.l,ie=C.h.GL.createContext(C.l,{antialias:!1,alpha:!1,ja:typeof WebGL2RenderingContext<"u"?2:1}),C.h.GL.makeContextCurrent(ie),mt.g=4;break;case 7:if(C.l=document.createElement("canvas"),!(dt=C.l.getContext("webgl2",{}))&&!(dt=C.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),mt.return();C.G=dt,C.h.canvas=C.l,C.h.createContext(C.l,!0,!0,{});case 4:C.i=new C.h.SolutionWasm,C.Z=!1,mt.g=0}}))}function bn(C,W){var X,te;return L((function(ae){return W in C.H?ae.return(C.H[W]):(X=C.locateFile(W,""),te=fetch(X).then((function(ie){return ie.arrayBuffer()})),C.H[W]=te,ae.return(te))}))}function Zt(C,W,X){var te,ae,ie,he,xe,Me,Qe,Ze,dt,mt,yt,nn,sn,er;return L((function(Xn){switch(Xn.g){case 1:if(!X)return Xn.return(W);for(te={},ae=0,ie=o(Object.keys(X)),he=ie.next();!he.done;he=ie.next())xe=he.value,typeof(Me=X[xe])!="string"&&Me.type==="texture"&&W[Me.stream]!==void 0&&++ae;1<ae&&(C.I=!1),Qe=o(Object.keys(X)),he=Qe.next();case 2:if(he.done){Xn.g=4;break}if(Ze=he.value,typeof(dt=X[Ze])=="string")return sn=te,er=Ze,b(Xn,(function(zi,Pa,Io){var Ps;return L((function(Uo){return typeof Io=="number"||Io instanceof Uint8Array||Io instanceof zi.h.Uint8BlobList?Uo.return(Io):Io instanceof zi.h.Texture2dDataOut?((Ps=zi.u[Pa])||(Ps=new ce(zi.h,zi.G),zi.u[Pa]=Ps),Uo.return(Ne(Ps,Io,zi.I))):Uo.return(void 0)}))})(C,Ze,W[dt]),14);if(mt=W[dt.stream],dt.type==="detection_list"){if(mt){for(var Ir=mt.getRectList(),Ds=mt.getLandmarksList(),or=mt.getClassificationsList(),Cn=[],Cr=0;Cr<Ir.size();++Cr){var Os=hs(Ir.get(Cr),_o,Mi);Os={boundingBox:{xCenter:Kr(Os,1),yCenter:Kr(Os,2),height:Kr(Os,3),width:Kr(Os,4),rotation:Kr(Os,5,0),rectId:Cs(Os,6)},landmarks:ui(hs(Ds.get(Cr),Vo,hl),Rs,1).map(G),V:U(hs(or.get(Cr),gi,Mo))},Cn.push(Os)}Ir=Cn}else Ir=[];te[Ze]=Ir,Xn.g=7;break}if(dt.type==="proto_list"){if(mt){for(Ir=Array(mt.size()),Ds=0;Ds<mt.size();Ds++)Ir[Ds]=mt.get(Ds);mt.delete()}else Ir=[];te[Ze]=Ir,Xn.g=7;break}if(mt===void 0){Xn.g=3;break}if(dt.type==="float_list"){te[Ze]=mt,Xn.g=7;break}if(dt.type==="proto"){te[Ze]=mt,Xn.g=7;break}if(dt.type!=="texture")throw Error("Unknown output config type: '"+dt.type+"'");return(yt=C.u[Ze])||(yt=new ce(C.h,C.G),C.u[Ze]=yt),b(Xn,Ne(yt,mt,C.I),13);case 13:nn=Xn.h,te[Ze]=nn;case 7:dt.transform&&te[Ze]&&(te[Ze]=dt.transform(te[Ze])),Xn.g=3;break;case 14:sn[er]=Xn.h;case 3:he=Qe.next(),Xn.g=2;break;case 4:return Xn.return(te)}}))}function an(C,W){for(var X=W.name||"$",te=[].concat(a(W.wants)),ae=new C.h.StringList,ie=o(W.wants),he=ie.next();!he.done;he=ie.next())ae.push_back(he.value);ie=C.h.PacketListener.implement({onResults:function(xe){for(var Me={},Qe=0;Qe<W.wants.length;++Qe)Me[te[Qe]]=xe.get(Qe);var Ze=C.listeners[X];Ze&&(C.D=Zt(C,Me,W.outs).then((function(dt){dt=Ze(dt);for(var mt=0;mt<W.wants.length;++mt){var yt=Me[te[mt]];typeof yt=="object"&&yt.hasOwnProperty&&yt.hasOwnProperty("delete")&&yt.delete()}dt&&(C.D=dt)})))}}),C.i.attachMultiListener(ae,ie),ae.delete()}function kt(C){var W=this;C=C||{};var X={url:"face_detection_short.binarypb"},te={type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}};this.g=new bt({locateFile:C.locateFile,files:[{data:!0,url:"face_detection_short.binarypb"},{data:!0,url:"face_detection_short_range.tflite"},{simd:!0,url:"face_detection_solution_simd_wasm_bin.js"},{simd:!1,url:"face_detection_solution_wasm_bin.js"}],graph:X,listeners:[{wants:["detections","image_transformed"],outs:{image:"image_transformed",detections:{type:"detection_list",stream:"detections"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window=="object"&&window.navigator!==void 0&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},model:{type:0,onChange:function(ae){var ie,he,xe,Me,Qe;return L((function(Ze){switch(Ze.g){case 1:ie=o(ae==="short"?["face_detection_short_range.tflite"]:["face_detection_full_range_sparse.tflite"]),he=ie.next();case 2:if(he.done){Ze.g=4;break}return xe=he.value,Me="third_party/mediapipe/modules/face_detection/"+xe,b(Ze,bn(W.g,xe),5);case 5:Qe=Ze.h,W.g.overrideFile(Me,Qe),he=ie.next(),Ze.g=2;break;case 4:return X.url=ae==="short"?"face_detection_short.binarypb":"face_detection_full.binarypb",te.graphOptionXref.calculatorName=ae==="short"?"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator":"facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator",Ze.return(!0)}}))}},minDetectionConfidence:te}})}(t=bt.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},t.reset=function(){var C=this;return L((function(W){C.i&&(C.i.reset(),C.o={},C.u={}),W.g=0}))},t.setOptions=function(C,W){var X=this;if(W=W||this.g.options){for(var te=[],ae=[],ie={},he=o(Object.keys(C)),xe=he.next();!xe.done;ie={R:ie.R,S:ie.S},xe=he.next()){var Me=xe.value;Me in this.j&&this.j[Me]===C[Me]||(this.j[Me]=C[Me],(xe=W[Me])!==void 0&&(xe.onChange&&(ie.R=xe.onChange,ie.S=C[Me],te.push((function(Qe){return function(){return L((function(Ze){if(Ze.g==1)return b(Ze,Qe.R(Qe.S),2);Ze.h===!0&&(X.s=!0),Ze.g=0}))}})(ie))),xe.graphOptionXref&&(Me={valueNumber:xe.type===1?C[Me]:0,valueBoolean:xe.type===0&&C[Me],valueString:xe.type===2?C[Me]:""},xe=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),xe.graphOptionXref),Me),ae.push(xe))))}te.length===0&&ae.length===0||(this.s=!0,this.B=(this.B===void 0?[]:this.B).concat(ae),this.A=(this.A===void 0?[]:this.A).concat(te))}},t.initialize=function(){var C=this;return L((function(W){return W.g==1?b(W,tn(C),2):W.g!=3?b(W,(function(X){var te,ae,ie,he,xe,Me,Qe,Ze;return L((function(dt){if(dt.g==1)return X.g.graph&&X.g.graph.url&&X.Y===X.g.graph.url?dt.return():(X.s=!0,X.g.graph&&X.g.graph.url?(X.Y=X.g.graph.url,b(dt,bn(X,X.g.graph.url),3)):void(dt.g=2));for(dt.g!=2&&(te=dt.h,X.i.loadGraph(te)),ae=o(Object.keys(X.C)),ie=ae.next();!ie.done;ie=ae.next())he=ie.value,X.i.overrideFile(he,X.C[he]);if(X.C={},X.g.listeners)for(xe=o(X.g.listeners),Me=xe.next();!Me.done;Me=xe.next())Qe=Me.value,an(X,Qe);Ze=X.j,X.j={},X.setOptions(Ze),dt.g=0}))})(C),3):b(W,(function(X){var te,ae,ie,he,xe,Me;return L((function(Qe){switch(Qe.g){case 1:if(!X.s)return Qe.return();if(!X.A){Qe.g=2;break}te=o(X.A),ae=te.next();case 3:if(ae.done){Qe.g=5;break}return b(Qe,(0,ae.value)(),4);case 4:ae=te.next(),Qe.g=3;break;case 5:X.A=void 0;case 2:if(X.B){for(ie=new X.h.GraphOptionChangeRequestList,he=o(X.B),xe=he.next();!xe.done;xe=he.next())Me=xe.value,ie.push_back(Me);X.i.changeOptions(ie),ie.delete(),X.B=void 0}X.s=!1,Qe.g=0}}))})(C),0)}))},t.overrideFile=function(C,W){this.i?this.i.overrideFile(C,W):this.C[C]=W},t.clearOverriddenFiles=function(){this.C={},this.i&&this.i.clearOverriddenFiles()},t.send=function(C,W){var X,te,ae,ie,he,xe,Me,Qe,Ze,dt=this;return L((function(mt){switch(mt.g){case 1:return dt.g.inputs?(X=1e3*(W??performance.now()),b(mt,dt.D,2)):mt.return();case 2:return b(mt,dt.initialize(),3);case 3:for(te=new dt.h.PacketDataList,ae=o(Object.keys(C)),ie=ae.next();!ie.done;ie=ae.next())if(he=ie.value,xe=dt.g.inputs[he]){e:{var yt=C[he];switch(xe.type){case"video":var nn=dt.o[xe.stream];if(nn||(nn=new ce(dt.h,dt.G),dt.o[xe.stream]=nn),nn.l===0&&(nn.l=nn.h.createTexture()),typeof HTMLVideoElement<"u"&&yt instanceof HTMLVideoElement)var sn=yt.videoWidth,er=yt.videoHeight;else typeof HTMLImageElement<"u"&&yt instanceof HTMLImageElement?(sn=yt.naturalWidth,er=yt.naturalHeight):(sn=yt.width,er=yt.height);er={glName:nn.l,width:sn,height:er},(sn=nn.g).canvas.width=er.width,sn.canvas.height=er.height,sn.activeTexture(sn.TEXTURE0),nn.h.bindTexture2d(nn.l),sn.texImage2D(sn.TEXTURE_2D,0,sn.RGBA,sn.RGBA,sn.UNSIGNED_BYTE,yt),nn.h.bindTexture2d(0),nn=er;break e;case"detections":for((nn=dt.o[xe.stream])||(nn=new qe(dt.h),dt.o[xe.stream]=nn),nn.data||(nn.data=new nn.g.DetectionListData),nn.data.reset(yt.length),er=0;er<yt.length;++er){sn=yt[er];var Xn=nn.data,Ir=Xn.setBoundingBox,Ds=er,or=sn.boundingBox,Cn=new _o;if(ir(Cn,1,or.xCenter),ir(Cn,2,or.yCenter),ir(Cn,3,or.height),ir(Cn,4,or.width),ir(Cn,5,or.rotation),ir(Cn,6,or.rectId),or=xo(Cn,Mi),Ir.call(Xn,Ds,or),sn.landmarks)for(Xn=0;Xn<sn.landmarks.length;++Xn){var Cr=!!(Cn=sn.landmarks[Xn]).visibility;Ds=(Ir=nn.data).addNormalizedLandmark,or=er,Cn=Object.assign(Object.assign({},Cn),{visibility:Cr?Cn.visibility:0}),ir(Cr=new Rs,1,Cn.x),ir(Cr,2,Cn.y),ir(Cr,3,Cn.z),Cn.visibility&&ir(Cr,4,Cn.visibility),Cn=xo(Cr,zo),Ds.call(Ir,or,Cn)}if(sn.V)for(Xn=0;Xn<sn.V.length;++Xn)Ds=(Ir=nn.data).addClassification,or=er,Cn=sn.V[Xn],ir(Cr=new Pr,2,Cn.ga),Cn.index&&ir(Cr,1,Cn.index),Cn.label&&ir(Cr,3,Cn.label),Cn.displayName&&ir(Cr,4,Cn.displayName),Cn=xo(Cr,Lo),Ds.call(Ir,or,Cn)}nn=nn.data;break e;default:nn={}}}switch(Me=nn,Qe=xe.stream,xe.type){case"video":te.pushTexture2d(Object.assign(Object.assign({},Me),{stream:Qe,timestamp:X}));break;case"detections":(Ze=Me).stream=Qe,Ze.timestamp=X,te.pushDetectionList(Ze);break;default:throw Error("Unknown input config type: '"+xe.type+"'")}}return dt.i.send(te),b(mt,dt.D,4);case 4:te.delete(),mt.g=0}}))},t.onResults=function(C,W){this.listeners[W||"$"]=C},A("Solution",bt),A("OptionType",{BOOL:0,NUMBER:1,ia:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(t=kt.prototype).close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(C){this.g.onResults(C)},t.initialize=function(){var C=this;return L((function(W){return b(W,C.g.initialize(),0)}))},t.reset=function(){this.g.reset()},t.send=function(C){var W=this;return L((function(X){return b(X,W.g.send(C),0)}))},t.setOptions=function(C){this.g.setOptions(C)},A("FaceDetection",kt),A("FACEDETECTION_LIPS",Bo),A("FACEDETECTION_LEFT_EYE",da),A("FACEDETECTION_LEFT_EYEBROW",Sn),A("FACEDETECTION_RIGHT_EYE",yi),A("FACEDETECTION_RIGHT_EYEBROW",fa),A("FACEDETECTION_FACE_OVAL",pa),A("FACEDETECTION_CONTOURS",Oa),A("FACEDETECTION_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),A("VERSION","0.4.1646425229")}).call(DT);var zh=function(){return zh=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t},zh.apply(this,arguments)};function dc(t,e,n,r){return new(n||(n=Promise))((function(s,i){function o(u){try{l(r.next(u))}catch(c){i(c)}}function a(u){try{l(r.throw(u))}catch(c){i(c)}}function l(u){var c;u.done?s(u.value):(c=u.value,c instanceof n?c:new n((function(d){d(c)}))).then(o,a)}l((r=r.apply(t,[])).next())}))}function fc(t,e){var n,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(u){return(function(c){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,r=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(!((s=(s=o.trys).length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){o.label=c[1];break}if(c[0]===6&&o.label<s[1]){o.label=s[1],s=c;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(c);break}s[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(t,o)}catch(d){c=[6,d],r=0}finally{n=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}})([l,u])}}}var oH=["rightEye","leftEye","noseTip","mouthCenter","rightEarTragion","leftEarTragion"],OT={modelType:"short",runtime:"mediapipe",maxFaces:1},d6e=(function(){function t(e){var n=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceDetectorSolution=new h6e.FaceDetection({locateFile:function(r,s){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(r)}return"".concat(s,"/").concat(r)}}),this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode,model:e.modelType}),this.faceDetectorSolution.onResults((function(r){if(n.height=r.image.height,n.width=r.image.width,n.faces=[],r.detections!==null)for(var s=0,i=r.detections;s<i.length;s++){var o=i[s];n.faces.push(n.normalizedToAbsolute(o.landmarks,{xMin:l=(a=o.boundingBox).xCenter-a.width/2,xMax:l+a.width,yMin:u=a.yCenter-a.height/2,yMax:u+a.height,width:a.width,height:a.height}))}var a,l,u}))}return t.prototype.normalizedToAbsolute=function(e,n){var r=this;return{keypoints:e.map((function(s,i){return{x:s.x*r.width,y:s.y*r.height,name:oH[i]}})),box:{xMin:n.xMin*this.width,yMin:n.yMin*this.height,xMax:n.xMax*this.width,yMax:n.yMax*this.height,width:n.width*this.width,height:n.height*this.height}}},t.prototype.estimateFaces=function(e,n){return dc(this,void 0,void 0,(function(){var r,s;return fc(this,(function(i){switch(i.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Rn?(s=ImageData.bind,[4,kk(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,i.label=3;case 3:return e=r,[4,this.faceDetectorSolution.send({image:e})];case 4:return i.sent(),[2,this.faces]}}))}))},t.prototype.dispose=function(){this.faceDetectorSolution.close()},t.prototype.reset=function(){this.faceDetectorSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.faceDetectorSolution.initialize()},t})();function f6e(t){return dc(this,void 0,void 0,(function(){var e,n;return fc(this,(function(r){switch(r.label){case 0:return e=(function(s){if(s==null)return zh({},OT);var i=zh({},s);return i.runtime="mediapipe",i.modelType==null&&(i.modelType=OT.modelType),i.maxFaces==null&&(i.maxFaces=OT.maxFaces),i})(t),[4,(n=new d6e(e)).initialize()];case 1:return r.sent(),[2,n]}}))}))}function aH(t){return t instanceof Rn?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function lH(t){return t instanceof Rn?t:Q_(t)}function PT(t,e){J(t.width!==0,(function(){return"".concat(e," width cannot be 0.")})),J(t.height!==0,(function(){return"".concat(e," height cannot be 0.")}))}function p6e(t,e,n){var r=e.outputTensorSize,s=e.keepAspectRatio,i=e.borderMode,o=e.outputTensorFloatRange,a=aH(t),l=(function(f,m){return{xCenter:.5*f.width,yCenter:.5*f.height,width:f.width,height:f.height,rotation:0}})(a),u=(function(f,m,g){if(g===void 0&&(g=!1),!g)return{top:0,left:0,right:0,bottom:0};var y=m.height,v=m.width;PT(m,"targetSize"),PT(f,"roi");var b,x,$=y/v,S=f.height/f.width,E=0,L=0;return $>S?(b=f.width,x=f.width*$,L=(1-S/$)/2):(b=f.height/$,x=f.height,E=(1-$/S)/2),f.width=b,f.height=x,{top:L,left:E,right:E,bottom:L}})(l,r,s),c=(function(f,m,g,y){var v=f.width,b=f.height,x=1,$=Math.cos(f.rotation),S=Math.sin(f.rotation),E=f.xCenter,L=f.yCenter,R=1/m,D=1/g,A=new Array(16);return A[0]=v*$*x*R,A[1]=-b*S*R,A[2]=0,A[3]=(-.5*v*$*x+.5*b*S+E)*R,A[4]=v*S*x*D,A[5]=b*$*D,A[6]=0,A[7]=(-.5*b*$-.5*v*S*x+L)*D,A[8]=0,A[9]=0,A[10]=v*R,A[11]=0,A[12]=0,A[13]=0,A[14]=0,A[15]=1,(function(F){if(F.length!==16)throw new Error("Array length must be 16 but got ".concat(F.length));return[[F[0],F[1],F[2],F[3]],[F[4],F[5],F[6],F[7]],[F[8],F[9],F[10],F[11]],[F[12],F[13],F[14],F[15]]]})(A)})(l,a.width,a.height),d=ke((function(){var f=lH(t),m=rl((function(v,b,x){return PT(x,"inputResolution"),[1/x.width*v[0][0]*b.width,1/x.height*v[0][1]*b.width,v[0][3]*b.width,1/x.width*v[1][0]*b.height,1/x.height*v[1][1]*b.height,v[1][3]*b.height,0,0]})(c,a,r),[1,8]),g=i==="zero"?"constant":"nearest",y=Ci.transform(os(gt(f,"float32")),m,"bilinear",g,0,[r.height,r.width]);return o!=null?(function(v,b){var x=(function($,S,E,L){var R=(L-E)/255;return{scale:R,offset:E-0*R}})(0,0,b[0],b[1]);return ke((function(){return tt(be(v,x.scale),x.offset)}))})(y,o):y}));return{imageTensor:d,padding:u,transformationMatrix:c}}function YP(t){t.reduceBoxesInLowestLayer==null&&(t.reduceBoxesInLowestLayer=!1),t.interpolatedScaleAspectRatio==null&&(t.interpolatedScaleAspectRatio=1),t.fixedAnchorSize==null&&(t.fixedAnchorSize=!1);for(var e=[],n=0;n<t.numLayers;){for(var r=[],s=[],i=[],o=[],a=n;a<t.strides.length&&t.strides[a]===t.strides[n];){var l=QP(t.minScale,t.maxScale,a,t.strides.length);if(a===0&&t.reduceBoxesInLowestLayer)i.push(1),i.push(2),i.push(.5),o.push(.1),o.push(l),o.push(l);else{for(var u=0;u<t.aspectRatios.length;++u)i.push(t.aspectRatios[u]),o.push(l);if(t.interpolatedScaleAspectRatio>0){var c=a===t.strides.length-1?1:QP(t.minScale,t.maxScale,a+1,t.strides.length);o.push(Math.sqrt(l*c)),i.push(t.interpolatedScaleAspectRatio)}}a++}for(var d=0;d<i.length;++d){var f=Math.sqrt(i[d]);r.push(o[d]/f),s.push(o[d]*f)}var m=0,g=0;if(t.featureMapHeight.length>0)m=t.featureMapHeight[n],g=t.featureMapWidth[n];else{var y=t.strides[n];m=Math.ceil(t.inputSizeHeight/y),g=Math.ceil(t.inputSizeWidth/y)}for(var v=0;v<m;++v)for(var b=0;b<g;++b)for(var x=0;x<r.length;++x){var $={xCenter:(b+t.anchorOffsetX)/g,yCenter:(v+t.anchorOffsetY)/m,width:0,height:0};t.fixedAnchorSize?($.width=1,$.height=1):($.width=s[x],$.height=r[x]),e.push($)}n=a}return e}function QP(t,e,n,r){return r===1?.5*(t+e):t+(e-t)*n/(r-1)}function JP(t,e){var n=e[0],r=e[1];return[n*t[0]+r*t[1]+t[3],n*t[4]+r*t[5]+t[7]]}function m6e(t,e,n,r){return dc(this,void 0,void 0,(function(){var s,i,o,a,l;return fc(this,(function(u){switch(u.label){case 0:return t.sort((function(c,d){return Math.max.apply(Math,d.score)-Math.max.apply(Math,c.score)})),s=rl(t.map((function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]}))),i=Zr(t.map((function(c){return c.score[0]}))),[4,Ci.nonMaxSuppressionAsync(s,i,e,n)];case 1:return[4,(o=u.sent()).array()];case 2:return a=u.sent(),l=t.filter((function(c,d){return a.indexOf(d)>-1})),en([s,i,o]),[2,l]}}))}))}function g6e(t,e,n){return dc(this,void 0,void 0,(function(){var r,s,i,o,a;return fc(this,(function(l){switch(l.label){case 0:return r=t[0],s=t[1],i=(function(u,c,d){return ke((function(){var f,m,g,y;d.reverseOutputOrder?(m=Vr(cn(u,[0,d.boxCoordOffset+0],[-1,1])),f=Vr(cn(u,[0,d.boxCoordOffset+1],[-1,1])),y=Vr(cn(u,[0,d.boxCoordOffset+2],[-1,1])),g=Vr(cn(u,[0,d.boxCoordOffset+3],[-1,1]))):(f=Vr(cn(u,[0,d.boxCoordOffset+0],[-1,1])),m=Vr(cn(u,[0,d.boxCoordOffset+1],[-1,1])),g=Vr(cn(u,[0,d.boxCoordOffset+2],[-1,1])),y=Vr(cn(u,[0,d.boxCoordOffset+3],[-1,1]))),m=tt(be(St(m,d.xScale),c.w),c.x),f=tt(be(St(f,d.yScale),c.h),c.y),d.applyExponentialOnBoxSize?(g=be(ki(St(g,d.hScale)),c.h),y=be(ki(St(y,d.wScale)),c.w)):(g=be(St(g,d.hScale),c.h),y=be(St(y,d.wScale),c.h));var v=$t(f,St(g,2)),b=$t(m,St(y,2)),x=tt(f,St(g,2)),$=tt(m,St(y,2)),S=Gr([Ie(v,[d.numBoxes,1]),Ie(b,[d.numBoxes,1]),Ie(x,[d.numBoxes,1]),Ie($,[d.numBoxes,1])],1);if(d.numKeypoints)for(var E=0;E<d.numKeypoints;++E){var L=d.keypointCoordOffset+E*d.numValuesPerKeypoint,R=void 0,D=void 0;d.reverseOutputOrder?(R=Vr(cn(u,[0,L],[-1,1])),D=Vr(cn(u,[0,L+1],[-1,1]))):(D=Vr(cn(u,[0,L],[-1,1])),R=Vr(cn(u,[0,L+1],[-1,1])));var A=tt(be(St(R,d.xScale),c.w),c.x),F=tt(be(St(D,d.yScale),c.h),c.y);S=Gr([S,Ie(A,[d.numBoxes,1]),Ie(F,[d.numBoxes,1])],1)}return S}))})(s,e,n),o=ke((function(){var u=r;return n.sigmoidScore?(n.scoreClippingThresh!=null&&(u=Hi(r,-n.scoreClippingThresh,n.scoreClippingThresh)),u=Ca(u)):u})),[4,y6e(i,o,n)];case 1:return a=l.sent(),en([i,o]),[2,a]}}))}))}function y6e(t,e,n){return dc(this,void 0,void 0,(function(){var r,s,i,o,a,l,u,c,d,f,m,g;return fc(this,(function(y){switch(y.label){case 0:return r=[],[4,t.data()];case 1:return s=y.sent(),[4,e.data()];case 2:for(i=y.sent(),o=0;o<n.numBoxes;++o)if(!(n.minScoreThresh!=null&&i[o]<n.minScoreThresh||(a=o*n.numCoords,l=w6e(s[a+0],s[a+1],s[a+2],s[a+3],i[o],n.flipVertically,o),(u=l.locationData.relativeBoundingBox).width<0||u.height<0))){if(n.numKeypoints>0)for((c=l.locationData).relativeKeypoints=[],d=n.numKeypoints*n.numValuesPerKeypoint,f=0;f<d;f+=n.numValuesPerKeypoint)m=a+n.keypointCoordOffset+f,g={x:s[m+0],y:n.flipVertically?1-s[m+1]:s[m+1]},c.relativeKeypoints.push(g);r.push(l)}return[2,r]}}))}))}function w6e(t,e,n,r,s,i,o){return{score:[s],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-n:t,xMax:r,yMax:i?1-t:n,width:r-e,height:n-t}}}}var sx,v6e={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:4,minScale:.1484375,maxScale:.75,inputSizeHeight:128,inputSizeWidth:128,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,16,16],aspectRatios:[1],fixedAnchorSize:!0},b6e={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:0,featureMapHeight:[],featureMapWidth:[],numLayers:1,minScale:.1484375,maxScale:.75,inputSizeHeight:192,inputSizeWidth:192,anchorOffsetX:.5,anchorOffsetY:.5,strides:[4],aspectRatios:[1],fixedAnchorSize:!0},FT={runtime:"tfjs",modelType:"short",maxFaces:1,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"},x6e={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:896,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:128,yScale:128,hScale:128,wScale:128,minScoreThresh:.5},_6e={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2304,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:192,yScale:192,hScale:192,wScale:192,minScoreThresh:.6},I6e={outputTensorSize:{width:128,height:128},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},T6e={outputTensorSize:{width:192,height:192},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},S6e=(function(){function t(e,n,r){this.detectorModel=n,this.maxFaces=r,e==="full"?(this.imageToTensorConfig=T6e,this.tensorsToDetectionConfig=_6e,this.anchors=YP(b6e)):(this.imageToTensorConfig=I6e,this.tensorsToDetectionConfig=x6e,this.anchors=YP(v6e));var s=Zr(this.anchors.map((function(l){return l.width}))),i=Zr(this.anchors.map((function(l){return l.height}))),o=Zr(this.anchors.map((function(l){return l.xCenter}))),a=Zr(this.anchors.map((function(l){return l.yCenter})));this.anchorTensor={x:o,y:a,w:s,h:i}}return t.prototype.dispose=function(){this.detectorModel.dispose(),en([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},t.prototype.reset=function(){},t.prototype.detectFaces=function(e,n){return n===void 0&&(n=!1),dc(this,void 0,void 0,(function(){var r,s,i,o,a,l,u,c,d,f,m;return fc(this,(function(g){switch(g.label){case 0:return e==null?(this.reset(),[2,[]]):(r=ke((function(){var y=gt(lH(e),"float32");return n&&(y=Vr(Ci.flipLeftRight(os(y,0)),[0])),y})),s=p6e(r,this.imageToTensorConfig),i=s.imageTensor,o=s.transformationMatrix,a=this.detectorModel.execute(i,"Identity:0"),l=(function(y){return ke((function(){var v=(function($){return ke((function(){return[cn($,[0,0,0],[1,-1,1]),cn($,[0,0,1],[1,-1,-1])]}))})(y),b=v[0],x=v[1];return{boxes:Vr(x),logits:Vr(b)}}))})(a),u=l.boxes,[4,g6e([c=l.logits,u],this.anchorTensor,this.tensorsToDetectionConfig)]);case 1:return(d=g.sent()).length===0?(en([r,i,a,c,u]),[2,d]):[4,m6e(d,this.maxFaces,.3)];case 2:return f=g.sent(),m=(function(y,v){y===void 0&&(y=[]);var b,x=(b=v,[].concat.apply([],b));return y.forEach((function($){var S=$.locationData;S.relativeKeypoints.forEach((function(F){var P=JP(x,[F.x,F.y]),K=P[0],j=P[1];F.x=K,F.y=j}));var E=S.relativeBoundingBox,L=Number.MAX_VALUE,R=Number.MAX_VALUE,D=Number.MIN_VALUE,A=Number.MIN_VALUE;[[E.xMin,E.yMin],[E.xMin+E.width,E.yMin],[E.xMin+E.width,E.yMin+E.height],[E.xMin,E.yMin+E.height]].forEach((function(F){var P=JP(x,F),K=P[0],j=P[1];L=Math.min(L,K),D=Math.max(D,K),R=Math.min(R,j),A=Math.max(A,j)})),S.relativeBoundingBox={xMin:L,xMax:D,yMin:R,yMax:A,width:D-L,height:A-R}})),y})(f,o),en([r,i,a,c,u]),[2,m]}}))}))},t.prototype.estimateFaces=function(e,n){return dc(this,void 0,void 0,(function(){var r,s;return fc(this,(function(i){return r=aH(e),s=!!n&&n.flipHorizontal,[2,this.detectFaces(e,s).then((function(o){return o.map((function(a){for(var l=a.locationData.relativeKeypoints.map((function(g,y){return zh(zh({},g),{x:g.x*r.width,y:g.y*r.height,name:oH[y]})})),u=a.locationData.relativeBoundingBox,c=0,d=["width","xMax","xMin"];c<d.length;c++)u[d[c]]*=r.width;for(var f=0,m=["height","yMax","yMin"];f<m.length;f++)u[m[f]]*=r.height;return{keypoints:l,box:u}}))}))]}))}))},t})();function $6e(t){return dc(this,void 0,void 0,(function(){var e,n,r;return fc(this,(function(s){switch(s.label){case 0:return e=(function(i){if(i==null)return zh({},FT);var o=zh({},i);return o.modelType==null&&(o.modelType=FT.modelType),o.maxFaces==null&&(o.maxFaces=FT.maxFaces),o.detectorModelUrl==null&&(o.modelType==="full"?o.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1":o.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"),o})(t),n=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,[4,S4(e.detectorModelUrl,{fromTFHub:n})];case 1:return r=s.sent(),[2,new S6e(e.modelType,r,e.maxFaces)]}}))}))}function C6e(t,e){return dc(this,void 0,void 0,(function(){var n,r;return fc(this,(function(s){if(t===sx.MediaPipeFaceDetector){if(r=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,$6e(n)];if(n.runtime==="mediapipe")return[2,f6e(n)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r))}throw new Error("".concat(t," is not a supported model name."))}))}))}function LT(t){return t.width*t.height}function ZP(t){var e=t.xCenter-t.width/2,n=e+t.width,r=t.yCenter-t.height/2;return{xMin:e,xMax:n,yMin:r,yMax:r+t.height,width:t.width,height:t.height}}function E6e(t,e){var n=ZP(t),r=ZP(e);if(!(function(o,a){return!(o.xMax<a.xMin||a.xMax<o.xMin||o.yMax<a.yMin||a.yMax<o.yMin)})(n,r))return 0;var s=LT((function(o,a){var l=Math.max(o.xMin,a.xMin),u=Math.min(o.xMax,a.xMax),c=Math.max(o.yMin,a.yMin),d=Math.min(o.yMax,a.yMax);return{xMin:l,xMax:u,yMin:c,yMax:d,width:Math.max(u-l,0),height:Math.max(d-c,0)}})(n,r)),i=LT(n)+LT(r)-s;return i>0?s/i:0}function k6e(t,e,n,r){var s=t.width,i=t.height,o=1,a=Math.cos(t.rotation),l=Math.sin(t.rotation),u=t.xCenter,c=t.yCenter,d=1/e,f=1/n,m=new Array(16);return m[0]=s*a*o*d,m[1]=-i*l*d,m[2]=0,m[3]=(-.5*s*a*o+.5*i*l+u)*d,m[4]=s*l*o*f,m[5]=i*a*f,m[6]=0,m[7]=(-.5*i*a-.5*s*l*o+c)*f,m[8]=0,m[9]=0,m[10]=s*d,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,(function(g){if(g.length!==16)throw new Error("Array length must be 16 but got "+g.length);return[[g[0],g[1],g[2],g[3]],[g[4],g[5],g[6],g[7]],[g[8],g[9],g[10],g[11]],[g[12],g[13],g[14],g[15]]]})(m)}function uH(t){return t instanceof Rn?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function cH(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function hH(t){return t instanceof Rn?t:Q_(t)}function MT(t,e){J(t.width!==0,(function(){return e+" width cannot be 0."})),J(t.height!==0,(function(){return e+" height cannot be 0."}))}function N6e(t,e){var n=(function(r,s,i,o){var a=s-r,l=o-i,u=l/a;return{scale:u,offset:i-r*u}})(0,255,e[0],e[1]);return ke((function(){return tt(be(t,n.scale),n.offset)}))}function A6e(t,e,n){var r=e.outputTensorSize,s=e.keepAspectRatio,i=e.outputTensorFloatRange,o=uH(t),a=(function(d,f){return f?{xCenter:f.xCenter*d.width,yCenter:f.yCenter*d.height,width:f.width*d.width,height:f.height*d.height,rotation:f.rotation}:{xCenter:.5*d.width,yCenter:.5*d.height,width:d.width,height:d.height,rotation:0}})(o,n),l=(function(d,f,m){if(m===void 0&&(m=!1),!m)return{top:0,left:0,right:0,bottom:0};var g=f.height,y=f.width;MT(f,"targetSize"),MT(d,"roi");var v,b,x=g/y,$=d.height/d.width,S=0,E=0;return x>$?(v=d.width,b=d.width*x,E=(1-$/x)/2):(v=d.height/x,b=d.height,S=(1-x/$)/2),d.width=v,d.height=b,{top:E,left:S,right:S,bottom:E}})(a,r,s),u=k6e(a,o.width,o.height),c=ke((function(){var d=hH(t),f=rl((function(y,v,b){return MT(b,"inputResolution"),[1/b.width*y[0][0]*v.width,1/b.height*y[0][1]*v.width,y[0][3]*v.width,1/b.width*y[1][0]*v.height,1/b.height*y[1][1]*v.height,y[1][3]*v.height,0,0]})(u,o,r),[1,8]),m="nearest",g=Ci.transform(os(gt(d,"float32")),f,"bilinear",m,0,[r.height,r.width]);return i!=null?N6e(g,i):g}));return{imageTensor:c,padding:l,transformationMatrix:u}}function e8(t){return{xCenter:t.xMin+t.width/2,yCenter:t.yMin+t.height/2,width:t.width,height:t.height}}function R6e(t){var e=t.relativeKeypoints;if(e.length<=1)throw new Error("2 or more keypoints required to calculate a rect.");var n=Number.MAX_VALUE,r=Number.MAX_VALUE,s=Number.MIN_VALUE,i=Number.MIN_VALUE;return e.forEach((function(o){n=Math.min(n,o.x),s=Math.max(s,o.x),r=Math.min(r,o.y),i=Math.max(i,o.y)})),{xCenter:(n+s)/2,yCenter:(r+i)/2,width:s-n,height:i-r}}function t8(t,e,n,r,s){var i=n==="rect"?(function(o,a,l){var u,c=o.locationData;return u=e8(c.boundingBox),u})(t):(function(o,a){var l=o.locationData;return a==="boundingbox"?e8(l.relativeBoundingBox):R6e(l)})(t,e);return s&&(i.rotation=(function(o,a,l){var u,c=o.locationData,d=l.rotationVectorStartKeypointIndex,f=l.rotationVectorEndKeypointIndex;u=l.rotationVectorTargetAngle?l.rotationVectorTargetAngle:Math.PI*l.rotationVectorTargetAngleDegree/180;var m=c.relativeKeypoints[d].x*a.width,g=c.relativeKeypoints[d].y*a.height,y=c.relativeKeypoints[f].x*a.width,v=c.relativeKeypoints[f].y*a.height;return cH(u-Math.atan2(-(v-g),y-m))})(t,r,s)),i}function D6e(t,e,n){for(var r=0;r<e.length;++r){var s=e[r],i=n[t[r]];i.x=s.x,i.y=s.y}}function O6e(t,e,n,r){if(typeof e=="string"){if(e==="copy")for(var s=0;s<n.length;++s)r[t[s]].z=n[s].z}else{var i=(function(o,a){for(var l=0,u=0;u<a.length;++u)l+=o[a[u]].z;return l/a.length})(r,e);for(s=0;s<t.length;++s)r[t[s]].z=i}}function P6e(t,e){for(var n=(function(a){var l=[].concat.apply([],a.map((function(m){return m.indexesMapping})));if(l.length===0)throw new Error("There should be at least one landmark in indexes mapping");var u=l[0],c=l[0],d=new Set(l);d.forEach((function(m){u=Math.min(u,m),c=Math.max(c,m)}));var f=d.size;if(u!==0)throw new Error("Indexes are expected to start with 0 instead of "+u);if(c+1!==f)throw new Error("Indexes should have no gaps but "+(c-f+1)+" indexes are missing");return f})(e),r=new Array(n).fill(null).map(Object),s=0;s<t.length;++s){var i=t[s],o=e[s];if(i.length!==o.indexesMapping.length)throw new Error("There are "+i.length+" refinement landmarks while mapping has "+o.indexesMapping.length);D6e(o.indexesMapping,i,r),O6e(o.indexesMapping,o.zRefinement,i,r)}return r}function F6e(t,e){return t.map((function(n){var r=Pl(Pl({},n),{x:n.x*e.width,y:n.y*e.height});return n.z!=null&&(r.z=n.z*e.width),r}))}function L6e(t,e){return t==="none"?e:(function(n){return 1/(1+Math.exp(-n))})(e)}function md(t,e,n,r){return Qu(this,void 0,void 0,(function(){var s,i,o,a,l,u,c,d;return Ju(this,(function(f){switch(f.label){case 0:return n=n||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=t.size,i=s/e.numLandmarks,[4,t.data()];case 1:for(o=f.sent(),a=[],l=0;l<e.numLandmarks;++l)u=l*i,(d={x:0,y:0}).x=n?e.inputImageWidth-o[u]:o[u],i>1&&(d.y=r?e.inputImageHeight-o[u+1]:o[u+1]),i>2&&(d.z=o[u+2]),i>3&&(d.score=L6e(e.visibilityActivation,o[u+3])),a.push(d);for(c=0;c<a.length;++c)(d=a[c]).x=d.x/e.inputImageWidth,d.y=d.y/e.inputImageHeight,d.z=d.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}}))}))}function n8(t,e,n){var r=t.width,s=t.height,i=t.rotation;if(n.rotation==null&&n.rotationDegree==null||(i=(function(u,c){return c.rotation!=null?u+=c.rotation:c.rotationDegree!=null&&(u+=Math.PI*c.rotationDegree/180),cH(u)})(i,n)),i===0)t.xCenter=t.xCenter+r*n.shiftX,t.yCenter=t.yCenter+s*n.shiftY;else{var o=(e.width*r*n.shiftX*Math.cos(i)-e.height*s*n.shiftY*Math.sin(i))/e.width,a=(e.width*r*n.shiftX*Math.sin(i)+e.height*s*n.shiftY*Math.cos(i))/e.height;t.xCenter=t.xCenter+o,t.yCenter=t.yCenter+a}{var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return t.width=r*n.scaleX,t.height=s*n.scaleY,t}(sx||(sx={})).MediaPipeFaceDetector="MediaPipeFaceDetector";var zT={runtime:"tfjs",maxFaces:1,refineLandmarks:!1,landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"},VT={flipHorizontal:!1,staticImageMode:!1},r8={shiftX:0,shiftY:0,scaleX:1.5,scaleY:1.5},M6e={outputTensorSize:{width:192,height:192},outputTensorFloatRange:[0,1]},s8={numLandmarks:468,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},z6e={numLandmarks:80,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},i8={numLandmarks:71,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},o8={numLandmarks:5,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},V6e={indexesMapping:Array.from(Array(468).keys()),zRefinement:"copy"},B6e={indexesMapping:[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407],zRefinement:"none"},U6e={indexesMapping:[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],zRefinement:"none"},W6e={indexesMapping:[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417],zRefinement:"none"},j6e={indexesMapping:[468,469,470,471,472],zRefinement:[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173]},G6e={indexesMapping:[473,474,475,476,477],zRefinement:[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398]},Ym,H6e=(function(){function t(e,n,r,s){this.detector=e,this.landmarkModel=n,this.maxFaces=r,this.withAttention=s,this.prevFaceRectsFromLandmarks=null}return t.prototype.estimateFaces=function(e,n){return Qu(this,void 0,void 0,(function(){var r,s,i,o,a,l,u,c,d,f,m,g,y,v=this;return Ju(this,(function(b){switch(b.label){case 0:return r=(function(S){if(S==null)return Pl({},VT);var E=Pl({},S);return E.flipHorizontal==null&&(E.flipHorizontal=VT.flipHorizontal),E.staticImageMode==null&&(E.staticImageMode=VT.staticImageMode),E})(n),e==null?(this.reset(),[2,[]]):(s=uH(e),i=ke((function(){var S=gt(hH(e),"float32");return r.flipHorizontal&&(S=Vr(Ci.flipLeftRight(os(S,0)),[0])),S})),o=this.prevFaceRectsFromLandmarks,r.staticImageMode||o==null||o.length<this.maxFaces?[4,this.detector.detectFaces(i,!1)]:[3,2]);case 1:return(l=b.sent()).length===0?(this.reset(),i.dispose(),[2,[]]):(a=l.map((function(S){return v.faceDetectionFrontDetectionToRoi(S,s)})),[3,3]);case 2:a=[],b.label=3;case 3:return x=.5,$=[],[a,o||[]].forEach((function(S){return S.forEach((function(E){($=$.filter((function(L){return E6e(E,L)<=x}))).push(E)}))})),u=$,[4,Promise.all(u.map((function(S){return v.faceLandmark(S,i)})))];case 4:for(c=b.sent(),d=[],this.prevFaceRectsFromLandmarks=[],f=0;f<c.length;++f)(m=c[f])!=null&&(this.prevFaceRectsFromLandmarks.push(this.faceLandmarksToRoi(m,s)),(g=F6e(m,s))!=null&&g.forEach((function(S,E){var L=iH.get(E);L!=null&&(S.name=L)})),y=rC(g),d.push({keypoints:g,box:y.locationData.relativeBoundingBox}));return i.dispose(),[2,d]}var x,$}))}))},t.prototype.dispose=function(){this.detector.dispose(),this.landmarkModel.dispose()},t.prototype.reset=function(){this.detector.reset(),this.prevFaceRectsFromLandmarks=null},t.prototype.faceDetectionFrontDetectionToRoi=function(e,n){return n8(t8(e,"boundingbox","normRect",n,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:0}),n,r8)},t.prototype.faceLandmark=function(e,n){return Qu(this,void 0,void 0,(function(){var r,s,i,o,a,l,u;return Ju(this,(function(c){switch(c.label){case 0:return r=A6e(n,M6e,e).imageTensor,s=["output_faceflag"].concat(this.withAttention?["output_mesh_identity","output_lips","Identity_6:0","Identity_1:0","Identity_2:0","Identity_5:0"]:["output_mesh"]),i=this.landmarkModel.execute(r,s),o=i[0],a=i.slice(1),[4,o.data()];case 1:return c.sent()[0]<.5?(en(i),en(r),[2,null]):this.withAttention?[4,this.tensorsToFaceLandmarksWithAttention(a)]:[3,3];case 2:return l=c.sent(),[3,5];case 3:return[4,this.tensorsToFaceLandmarks(a)];case 4:l=c.sent(),c.label=5;case 5:return u=(function(d,f,m){m===void 0&&(m={ignoreRotation:!1});for(var g=[],y=0,v=d;y<v.length;y++){var b=v[y],x=b.x-.5,$=b.y-.5,S=m.ignoreRotation?0:f.rotation,E=Math.cos(S)*x-Math.sin(S)*$,L=Math.sin(S)*x+Math.cos(S)*$;E=E*f.width+f.xCenter,L=L*f.height+f.yCenter;var R=b.z*f.width,D=Pl({},b);D.x=E,D.y=L,D.z=R,g.push(D)}return g})(l,e),en(i),en(r),[2,u]}}))}))},t.prototype.tensorsToFaceLandmarks=function(e){return Qu(this,void 0,void 0,(function(){return Ju(this,(function(n){return[2,md(e[0],s8)]}))}))},t.prototype.tensorsToFaceLandmarksWithAttention=function(e){return Qu(this,void 0,void 0,(function(){var n,r,s,i,o,a;return Ju(this,(function(l){switch(l.label){case 0:return[4,md(e[0],s8)];case 1:return n=l.sent(),[4,md(e[1],z6e)];case 2:return r=l.sent(),[4,md(e[3],i8)];case 3:return s=l.sent(),[4,md(e[5],i8)];case 4:return i=l.sent(),[4,md(e[4],o8)];case 5:return o=l.sent(),[4,md(e[2],o8)];case 6:return a=l.sent(),[2,P6e([n,r,s,i,o,a],[V6e,B6e,U6e,W6e,j6e,G6e])]}}))}))},t.prototype.faceLandmarksToRoi=function(e,n){return n8(t8(rC(e),"boundingbox","normRect",n,{rotationVectorStartKeypointIndex:33,rotationVectorEndKeypointIndex:263,rotationVectorTargetAngleDegree:0}),n,r8)},t})();function q6e(t){return Qu(this,void 0,void 0,(function(){var e,n,r,s;return Ju(this,(function(i){switch(i.label){case 0:return e=(function(o){if(o==null)return Pl({},zT);var a=Pl({},o);return a.runtime="tfjs",a.maxFaces==null&&(a.maxFaces=zT.maxFaces),a.refineLandmarks==null&&(a.refineLandmarks=zT.refineLandmarks),a.landmarkModelUrl==null&&(a.landmarkModelUrl=a.refineLandmarks?"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/attention_mesh/1":"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"),a})(t),n=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,S4(e.landmarkModelUrl,{fromTFHub:n})];case 1:return r=i.sent(),[4,C6e(sx.MediaPipeFaceDetector,{modelType:"short",maxFaces:e.maxFaces,detectorModelUrl:e.detectorModelUrl,runtime:e.runtime})];case 2:return s=i.sent(),[2,new H6e(s,r,e.maxFaces,e.refineLandmarks)]}}))}))}function K6e(t,e){return Qu(this,void 0,void 0,(function(){var n,r;return Ju(this,(function(s){if(t===Ym.MediaPipeFaceMesh){if(r=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,q6e(n)];if(n.runtime==="mediapipe")return[2,c6e(n)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r)}throw new Error(t+" is not a supported model name.")}))}))}(function(t){t.MediaPipeFaceMesh="MediaPipeFaceMesh"})(Ym||(Ym={}));var X6e=Object.freeze({__proto__:null,getKeypointIndexByContour:function(t){if(t===Ym.MediaPipeFaceMesh)return sH;throw new Error("Model "+t+" is not supported.")},getAdjacentPairs:function(t){if(t===Ym.MediaPipeFaceMesh)return a6e;throw new Error("Model "+t+" is not supported.")}});const a8=Object.freeze(Object.defineProperty({__proto__:null,get SupportedModels(){return Ym},createDetector:K6e,util:X6e},Symbol.toStringTag,{value:"Module"}));var ty={exports:{}};const Y6e=xC(Pye),Q6e=xC(tde);var J6e=ty.exports,l8;function Z6e(){return l8||(l8=1,(function(t,e){(function(n,r){r(e,Y6e,Q6e)})(J6e,(function(n,r,s){const i={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(l,u){this.modelPath=u||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(l)}/model.json`}getPrefix(l){return l==="lite_mobilenet_v2"?`ssd${l}`:`ssd_${l}`}async load(){this.model=await r.loadGraphModel(this.modelPath);const l=s.zeros([1,300,300,3],"int32"),u=await this.model.executeAsync(l);await Promise.all(u.map((c=>c.data()))),u.map((c=>c.dispose())),l.dispose()}async infer(l,u,c){const d=s.tidy((()=>(l instanceof s.Tensor||(l=s.browser.fromPixels(l)),s.expandDims(l)))),f=d.shape[1],m=d.shape[2],g=await this.model.executeAsync(d),y=g[0].dataSync(),v=g[1].dataSync();d.dispose(),s.dispose(g);const[b,x]=this.calculateMaxScores(y,g[0].shape[1],g[0].shape[2]),$=s.getBackend();s.getBackend()==="webgl"&&s.setBackend("cpu");const S=s.tidy((()=>{const L=s.tensor2d(v,[g[1].shape[1],g[1].shape[3]]);return s.image.nonMaxSuppression(L,b,u,c,c)})),E=S.dataSync();return S.dispose(),$!==s.getBackend()&&s.setBackend($),this.buildDetectedObjects(m,f,v,b,E,x)}buildDetectedObjects(l,u,c,d,f,m){const g=f.length,y=[];for(let v=0;v<g;v++){const b=[];for(let L=0;L<4;L++)b[L]=c[4*f[v]+L];const x=b[0]*u,$=b[1]*l,S=b[2]*u,E=b[3]*l;b[0]=$,b[1]=x,b[2]=E-$,b[3]=S-x,y.push({bbox:b,class:i[m[f[v]]+1].displayName,score:d[f[v]]})}return y}calculateMaxScores(l,u,c){const d=[],f=[];for(let m=0;m<u;m++){let g=Number.MIN_VALUE,y=-1;for(let v=0;v<c;v++)l[m*c+v]>g&&(g=l[m*c+v],y=v);d[m]=g,f[m]=y}return[d,f]}async detect(l,u=20,c=.5){return this.infer(l,u,c)}dispose(){this.model!=null&&this.model.dispose()}}n.ObjectDetection=o,n.load=async function(a={}){if(s==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const l=a.base||"lite_mobilenet_v2",u=a.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(l)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${l}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const c=new o(l,u);return await c.load(),c},n.version="2.2.3",Object.defineProperty(n,"__esModule",{value:!0})}))})(ty,ty.exports)),ty.exports}var dH=Z6e();const eDe=bC(dH),u8=WF({__proto__:null,default:eDe},[dH]);async function tDe(t,e={}){if(!Gd)throw new Error("Firestore not initialized");const n=rz(Gd,"rooms",t);return await lse(n,{createdAt:Date.now(),...e}),n}async function _v(t,e){if(!Gd)throw new Error("Firestore not initialized");const n=nz(Gd,"rooms",t,"signals");await use(n,{payload:e,ts:Date.now()})}function nDe(t,e){if(!Gd)throw new Error("Firestore not initialized");const n=nz(Gd,"rooms",t,"signals");return cse(n,r=>{r.docChanges().forEach(s=>{s.type==="added"&&e(s.doc.data().payload)})})}function rDe(t,e){const n=t.length,r=e.length,s=Array.from({length:n+1},(i,o)=>Array(r+1).fill(0));for(let i=0;i<=n;i++)s[i][0]=i;for(let i=0;i<=r;i++)s[0][i]=i;for(let i=1;i<=n;i++)for(let o=1;o<=r;o++)s[i][o]=t[i-1]===e[o-1]?s[i-1][o-1]:1+Math.min(s[i-1][o],s[i][o-1],s[i-1][o-1]);return s[n][r]}function sDe(t,e){const n=t.trim().toLowerCase().split(/\s+/).filter(Boolean),r=e.trim().toLowerCase().split(/\s+/).filter(Boolean);return n.length===0?1:rDe(n,r)/n.length}var uR=Object.defineProperty,iDe=Object.getOwnPropertyDescriptor,oDe=Object.getOwnPropertyNames,aDe=Object.prototype.hasOwnProperty,lDe=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),ht=(t,e)=>()=>(t&&(e=t(t=0)),e),W1=(t,e)=>{for(var n in e)uR(t,n,{get:e[n],enumerable:!0})},uDe=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of oDe(e))!aDe.call(t,s)&&s!==n&&uR(t,s,{get:()=>e[s],enumerable:!(r=iDe(e,s))||r.enumerable});return t},Uy=t=>uDe(uR({},"__esModule",{value:!0}),t),E2,qc,Rd,c8,fH,pH=ht(()=>{E2=new Map,qc=[],Rd=(t,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let r=E2.get(t);if(r===void 0)E2.set(t,{backend:e,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let s=qc.indexOf(t);s!==-1&&qc.splice(s,1);for(let i=0;i<qc.length;i++)if(E2.get(qc[i]).priority<=n){qc.splice(i,0,t);return}qc.push(t)}return}throw new TypeError("not a valid backend")},c8=async t=>{let e=E2.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let n=!!e.initPromise;try{return n||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(r){return n||(e.error=`${r}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},fH=async t=>{let e=t.executionProviders||[],n=e.map(l=>typeof l=="string"?l:l.name),r=n.length===0?qc:n,s,i=[],o=new Set;for(let l of r){let u=await c8(l);typeof u=="string"?i.push({name:l,err:u}):(s||(s=u),s===u&&o.add(l))}if(!s)throw new Error(`no available backend found. ERR: ${i.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(let{name:l,err:u}of i)n.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);let a=e.filter(l=>o.has(typeof l=="string"?l:l.name));return[s,new Proxy(t,{get:(l,u)=>u==="executionProviders"?a:Reflect.get(l,u)})]}}),cDe=ht(()=>{pH()}),mH,hDe=ht(()=>{mH="1.23.2"}),BT,xi,gH=ht(()=>{hDe(),BT="warning",xi={wasm:{},webgl:{},webgpu:{},versions:{common:mH},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);BT=t}},get logLevel(){return BT}},Object.defineProperty(xi,"logLevel",{enumerable:!0})}),Er,dDe=ht(()=>{gH(),Er=xi}),yH,wH,fDe=ht(()=>{yH=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let r=n.getContext("2d");if(r!=null){let s,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(s=t.dims[2],i=t.dims[3]):(s=t.dims[3],i=t.dims[2]);let o=e?.format!==void 0?e.format:"RGB",a=e?.norm,l,u;a===void 0||a.mean===void 0?l=[255,255,255,255]:typeof a.mean=="number"?l=[a.mean,a.mean,a.mean,a.mean]:(l=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(l[3]=a.mean[3])),a===void 0||a.bias===void 0?u=[0,0,0,0]:typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(u[3]=a.bias[3]));let c=i*s,d=0,f=c,m=c*2,g=-1;o==="RGBA"?(d=0,f=c,m=c*2,g=c*3):o==="RGB"?(d=0,f=c,m=c*2):o==="RBG"&&(d=0,m=c,f=c*2);for(let y=0;y<i;y++)for(let v=0;v<s;v++){let b=(t.data[d++]-u[0])*l[0],x=(t.data[f++]-u[1])*l[1],$=(t.data[m++]-u[2])*l[2],S=g===-1?255:(t.data[g++]-u[3])*l[3];r.fillStyle="rgba("+b+","+x+","+$+","+S+")",r.fillRect(v,y,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},wH=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),r;if(n!=null){let s,i,o;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(s=t.dims[2],i=t.dims[1],o=t.dims[3]):(s=t.dims[3],i=t.dims[2],o=t.dims[1]);let a=e!==void 0&&e.format!==void 0?e.format:"RGB",l=e?.norm,u,c;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?c=[0,0,0,0]:typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(c[3]=l.bias[3]));let d=i*s;if(e!==void 0&&(e.format!==void 0&&o===4&&e.format!=="RGBA"||o===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let f=4,m=0,g=1,y=2,v=3,b=0,x=d,$=d*2,S=-1;a==="RGBA"?(b=0,x=d,$=d*2,S=d*3):a==="RGB"?(b=0,x=d,$=d*2):a==="RBG"&&(b=0,$=d,x=d*2),r=n.createImageData(s,i);for(let E=0;E<i*s;m+=f,g+=f,y+=f,v+=f,E++)r.data[m]=(t.data[b++]-c[0])*u[0],r.data[g]=(t.data[x++]-c[1])*u[1],r.data[y]=(t.data[$++]-c[2])*u[2],r.data[v]=S===-1?255:(t.data[S++]-c[3])*u[3]}else throw new Error("Can not access image data");return r}}),Iv,vH,bH,xH,_H,IH,pDe=ht(()=>{cR(),Iv=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:r}=e,s=e.norm??{mean:255,bias:0},i,o;typeof s.mean=="number"?i=[s.mean,s.mean,s.mean,s.mean]:i=[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],typeof s.bias=="number"?o=[s.bias,s.bias,s.bias,s.bias]:o=[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let a=e.format!==void 0?e.format:"RGBA",l=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",u=n*r,c=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),d=4,f=0,m=1,g=2,y=3,v=0,b=u,x=u*2,$=-1;a==="RGB"&&(d=3,f=0,m=1,g=2,y=-1),l==="RGBA"?$=u*3:l==="RBG"?(v=0,x=u,b=u*2):l==="BGR"&&(x=0,b=u,v=u*2);for(let S=0;S<u;S++,f+=d,g+=d,m+=d,y+=d)c[v++]=(t[f]+o[0])/i[0],c[b++]=(t[m]+o[1])/i[1],c[x++]=(t[g]+o[2])/i[2],$!==-1&&y!==-1&&(c[$++]=(t[y]+o[3])/i[3]);return l==="RGBA"?new xa("float32",c,[1,4,n,r]):new xa("float32",c,[1,3,n,r])},vH=async(t,e)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,r=typeof ImageData<"u"&&t instanceof ImageData,s=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,i=typeof t=="string",o,a=e??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(n){let c=l();c.width=t.width,c.height=t.height;let d=u(c);if(d!=null){let f=t.height,m=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(f=e.resizedHeight,m=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=f,a.width=m}else a.tensorFormat="RGBA",a.height=f,a.width=m;d.drawImage(t,0,0),o=d.getImageData(0,0,m,f).data}else throw new Error("Can not access image data")}else if(r){let c,d;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(c=e.resizedHeight,d=e.resizedWidth):(c=t.height,d=t.width),e!==void 0&&(a=e),a.format="RGBA",a.height=c,a.width=d,e!==void 0){let f=l();f.width=d,f.height=c;let m=u(f);if(m!=null)m.putImageData(t,0,0),o=m.getImageData(0,0,d,c).data;else throw new Error("Can not access image data")}else o=t.data}else if(s){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=l();c.width=t.width,c.height=t.height;let d=u(c);if(d!=null){let f=t.height,m=t.width;return d.drawImage(t,0,0,m,f),o=d.getImageData(0,0,m,f).data,a.height=f,a.width=m,Iv(o,a)}else throw new Error("Can not access image data")}else{if(i)return new Promise((c,d)=>{let f=l(),m=u(f);if(!t||!m)return d();let g=new Image;g.crossOrigin="Anonymous",g.src=t,g.onload=()=>{f.width=g.width,f.height=g.height,m.drawImage(g,0,0,f.width,f.height);let y=m.getImageData(0,0,f.width,f.height);a.height=f.height,a.width=f.width,c(Iv(y.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return Iv(o,a);throw new Error("Input data provided is not supported - aborted tensor creation")},bH=(t,e)=>{let{width:n,height:r,download:s,dispose:i}=e,o=[1,r,n,4];return new xa({location:"texture",type:"float32",texture:t,dims:o,download:s,dispose:i})},xH=(t,e)=>{let{dataType:n,dims:r,download:s,dispose:i}=e;return new xa({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:r,download:s,dispose:i})},_H=(t,e)=>{let{dataType:n,dims:r,download:s,dispose:i}=e;return new xa({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:r,download:s,dispose:i})},IH=(t,e,n)=>new xa({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})}),$d,ny,UT,TH,mDe=ht(()=>{$d=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),ny=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),UT=!1,TH=()=>{if(!UT){UT=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<"u"&&n.from;t&&($d.set("int64",BigInt64Array),ny.set(BigInt64Array,"int64")),e&&($d.set("uint64",BigUint64Array),ny.set(BigUint64Array,"uint64")),r?($d.set("float16",n),ny.set(n,"float16")):$d.set("float16",Uint16Array)}}}),SH,$H,gDe=ht(()=>{cR(),SH=t=>{let e=1;for(let n=0;n<t.length;n++){let r=t[n];if(typeof r!="number"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);e*=r}return e},$H=(t,e)=>{switch(t.location){case"cpu":return new xa(t.type,t.data,e);case"cpu-pinned":return new xa({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new xa({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new xa({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});case"ml-tensor":return new xa({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),xa,cR=ht(()=>{fDe(),pDe(),mDe(),gDe(),xa=class{constructor(t,e,n){TH();let r,s;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,r=t.type,s=t.dims,t.location){case"cpu-pinned":{let o=$d.get(r);if(!o)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(t.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=t.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,a;if(typeof t=="string")if(r=t,a=n,t==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");o=e}else{let l=$d.get(t);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e)){if(t==="float16"&&l===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${l.name} as data.`);t==="uint64"||t==="int64"?o=l.from(e,BigInt):o=l.from(e)}else if(e instanceof l)o=e;else if(e instanceof Uint8ClampedArray)if(t==="uint8")o=Uint8Array.from(e);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&e instanceof Uint16Array&&l!==Uint16Array)o=new globalThis.Float16Array(e.buffer,e.byteOffset,e.length);else throw new TypeError(`A ${r} tensor's data must be type of ${l}`)}else if(a=e,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof t[0];if(l==="string")r="string",o=t;else if(l==="boolean")r="bool",o=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else if(t instanceof Uint8ClampedArray)r="uint8",o=Uint8Array.from(t);else{let l=ny.get(t.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);r=l,o=t}if(a===void 0)a=[o.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");s=a,this.cpuData=o,this.dataLocation="cpu"}let i=SH(s);if(this.cpuData&&i!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(i/2)===this.cpuData.length))throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(t,e){return vH(t,e)}static fromTexture(t,e){return bH(t,e)}static fromGpuBuffer(t,e){return xH(t,e)}static fromMLTensor(t,e){return _H(t,e)}static fromPinnedBuffer(t,e,n){return IH(t,e,n)}toDataURL(t){return yH(this,t)}toImageData(t){return wH(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,t&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return $H(this,t)}}}),tl,CH=ht(()=>{cR(),tl=xa}),Wy,WT,Wl,sl,vh,bh,EH=ht(()=>{gH(),Wy=(t,e)=>{(typeof xi.trace>"u"?!xi.wasm.trace:!xi.trace)||console.timeStamp(`${t}::ORT::${e}`)},WT=(t,e)=>{let n=new Error().stack?.split(/\r\n|\r|\n/g)||[],r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let i=`FUNC_${t}::${n[s].trim().split(" ")[1]}`;e&&(i+=`::${e}`),Wy("CPU",i);return}n[s].includes("TRACE_FUNC")&&(r=!0)}},Wl=t=>{(typeof xi.trace>"u"?!xi.wasm.trace:!xi.trace)||WT("BEGIN",t)},sl=t=>{(typeof xi.trace>"u"?!xi.wasm.trace:!xi.trace)||WT("END",t)},vh=t=>{(typeof xi.trace>"u"?!xi.wasm.trace:!xi.trace)||console.time(`ORT::${t}`)},bh=t=>{(typeof xi.trace>"u"?!xi.wasm.trace:!xi.trace)||console.timeEnd(`ORT::${t}`)}}),kH,yDe=ht(()=>{pH(),CH(),EH(),kH=class NH{constructor(e){this.handler=e}async run(e,n,r){Wl(),vh("InferenceSession.run");let s={},i={};if(typeof e!="object"||e===null||e instanceof tl||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof tl)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(let u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);s[u]=null}if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,c=Object.getOwnPropertyNames(n);for(let d of this.outputNames)if(c.indexOf(d)!==-1){let f=n[d];(f===null||f instanceof tl)&&(u=!0,o=!1,s[d]=f)}if(u){if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof e[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(o)for(let u of this.outputNames)s[u]=null;let a=await this.handler.run(e,s,i),l={};for(let u in a)if(Object.hasOwnProperty.call(a,u)){let c=a[u];c instanceof tl?l[u]=c:l[u]=new tl(c.type,c.data,c.dims)}return bh("InferenceSession.run"),sl(),l}async release(){return this.handler.dispose()}static async create(e,n,r,s){Wl(),vh("InferenceSession.create");let i,o={};if(typeof e=="string"){if(i=e,typeof n=="object"&&n!==null)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof n=="object"&&n!==null)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let c=e,d=0,f=e.byteLength;if(typeof n=="object"&&n!==null)o=n;else if(typeof n=="number"){if(d=n,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(f=e.byteLength-d,typeof r=="number"){if(f=r,!Number.isSafeInteger(f))throw new RangeError("'byteLength' must be an integer.");if(f<=0||d+f>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-d}].`);if(typeof s=="object"&&s!==null)o=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(c,d,f)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[a,l]=await fH(o),u=await a.createInferenceSessionHandler(i,l);return bh("InferenceSession.create"),sl(),new NH(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),R4,wDe=ht(()=>{yDe(),R4=kH}),vDe=ht(()=>{}),bDe=ht(()=>{}),xDe=ht(()=>{}),_De=ht(()=>{}),AH={};W1(AH,{InferenceSession:()=>R4,TRACE:()=>Wy,TRACE_EVENT_BEGIN:()=>vh,TRACE_EVENT_END:()=>bh,TRACE_FUNC_BEGIN:()=>Wl,TRACE_FUNC_END:()=>sl,Tensor:()=>tl,env:()=>Er,registerBackend:()=>Rd});var ul=ht(()=>{cDe(),dDe(),wDe(),CH(),vDe(),bDe(),EH(),xDe(),_De()}),hR=ht(()=>{}),RH={};W1(RH,{default:()=>DH});var jT,GT,DH,IDe=ht(()=>{MX(),Op(),dR(),jT="ort-wasm-proxy-worker",GT=globalThis.self?.name===jT,GT&&(self.onmessage=t=>{let{type:e,in:n}=t.data;try{switch(e){case"init-wasm":fR(n.wasm).then(()=>{NR(n).then(()=>{postMessage({type:e})},r=>{postMessage({type:e,err:r})})},r=>{postMessage({type:e,err:r})});break;case"init-ep":{let{epName:r,env:s}=n;AR(s,r).then(()=>{postMessage({type:e})},i=>{postMessage({type:e,err:i})});break}case"copy-from":{let{buffer:r}=n,s=hx(r);postMessage({type:e,out:s});break}case"create":{let{model:r,options:s}=n;RR(r,s).then(i=>{postMessage({type:e,out:i})},i=>{postMessage({type:e,err:i})});break}case"release":DR(n),postMessage({type:e});break;case"run":{let{sessionId:r,inputIndices:s,inputs:i,outputIndices:o,options:a}=n;OR(r,s,i,o,new Array(o.length).fill(null),a).then(l=>{l.some(u=>u[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:l},FR([...i,...l]))},l=>{postMessage({type:e,err:l})});break}case"end-profiling":PR(n),postMessage({type:e});break;default:}}catch(r){postMessage({type:e,err:r})}}),DH=GT?null:t=>new Worker(t??va,{type:"module",name:jT})}),OH={};W1(OH,{default:()=>PH});var HT,PH,h8,TDe=ht(()=>{HT=async function(t={}){var e,n,r=t,s=new Promise((T,k)=>{e=T,n=k}),i=typeof window=="object",o=typeof WorkerGlobalScope<"u",a=o&&self.name?.startsWith("em-pthread");r.mountExternalData=(T,k)=>{T.startsWith("./")&&(T=T.substring(2)),(r.Fb||(r.Fb=new Map)).set(T,k)},r.unmountExternalData=()=>{delete r.Fb};var l=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,qc:!0}).buffer.constructor;let u=T=>async(...k)=>{try{if(r.Gb)throw Error("Session already started");let V=r.Gb={ec:k[0],errors:[]},H=await T(...k);if(r.Gb!==V)throw Error("Session mismatch");r.Kb?.flush();let Q=V.errors;if(0<Q.length){let le=await Promise.all(Q);if(le=le.filter(Ee=>Ee),0<le.length)throw Error(le.join(`
`))}return H}finally{r.Gb=null}};r.jsepInit=(T,k)=>{if(T==="webgpu"){[r.Kb,r.Vb,r.Zb,r.Lb,r.Yb,r.Ab,r.$b,r.bc,r.Wb,r.Xb,r.ac]=k;let V=r.Kb;r.jsepRegisterBuffer=(H,Q,le,Ee)=>V.registerBuffer(H,Q,le,Ee),r.jsepGetBuffer=H=>V.getBuffer(H),r.jsepCreateDownloader=(H,Q,le)=>V.createDownloader(H,Q,le),r.jsepOnCreateSession=H=>{V.onCreateSession(H)},r.jsepOnReleaseSession=H=>{V.onReleaseSession(H)},r.jsepOnRunStart=H=>V.onRunStart(H),r.cc=(H,Q)=>{V.upload(H,Q)}}else if(T==="webnn"){let V=k[0];[r.oc,r.Ob,r.webnnEnsureTensor,r.Pb,r.webnnDownloadTensor,r.nc,r.webnnEnableTraceEvent]=k.slice(1),r.webnnReleaseTensorId=r.Ob,r.webnnUploadTensor=r.Pb,r.webnnRegisterMLContext=r.nc,r.webnnOnRunStart=H=>V.onRunStart(H),r.webnnOnRunEnd=V.onRunEnd.bind(V),r.webnnOnReleaseSession=H=>{V.onReleaseSession(H)},r.webnnCreateMLTensorDownloader=(H,Q)=>V.createMLTensorDownloader(H,Q),r.webnnRegisterMLTensor=(H,Q,le,Ee)=>V.registerMLTensor(H,Q,le,Ee),r.webnnCreateMLContext=H=>V.createMLContext(H),r.webnnRegisterMLConstant=(H,Q,le,Ee,Be,rt)=>V.registerMLConstant(H,Q,le,Ee,Be,r.Fb,rt),r.webnnRegisterGraphInput=V.registerGraphInput.bind(V),r.webnnIsGraphInput=V.isGraphInput.bind(V),r.webnnRegisterGraphOutput=V.registerGraphOutput.bind(V),r.webnnIsGraphOutput=V.isGraphOutput.bind(V),r.webnnCreateTemporaryTensor=V.createTemporaryTensor.bind(V),r.webnnIsGraphInputOutputTypeSupported=V.isGraphInputOutputTypeSupported.bind(V)}};let c=()=>{let T=(k,V,H)=>(...Q)=>{let le=Ae,Ee=V?.();Q=k(...Q);let Be=V?.();return Ee!==Be&&(k=Be,H(Ee),V=H=null),Ae!=le?new Promise((rt,ft)=>{Zt={resolve:rt,reject:ft}}):Q};(()=>{for(let k of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])r[k]=T(r[k],()=>r[k],V=>r[k]=V)})(),u!==void 0&&(r._OrtRun=u(r._OrtRun),r._OrtRunWithBinding=u(r._OrtRunWithBinding)),c=void 0};r.asyncInit=()=>{c?.()};var d,f,m=(T,k)=>{throw k},g=import.meta.url,y="";if(i||o){try{y=new URL(".",g).href}catch{}o&&(f=T=>{var k=new XMLHttpRequest;return k.open("GET",T,!1),k.responseType="arraybuffer",k.send(null),new Uint8Array(k.response)}),d=async T=>{if(_e(T))return new Promise((V,H)=>{var Q=new XMLHttpRequest;Q.open("GET",T,!0),Q.responseType="arraybuffer",Q.onload=()=>{Q.status==200||Q.status==0&&Q.response?V(Q.response):H(Q.status)},Q.onerror=H,Q.send(null)});var k=await fetch(T,{credentials:"same-origin"});if(k.ok)return k.arrayBuffer();throw Error(k.status+" : "+k.url)}}var v,b,x,$,S,E,L,R,D,A,F,P,K,j,se,fe=console.log.bind(console),me=console.error.bind(console),ye=fe,oe=me,ue=!1,_e=T=>T.startsWith("file://");function Y(){return b.buffer!=S.buffer&&We(),S}function re(){return b.buffer!=S.buffer&&We(),E}function Te(){return b.buffer!=S.buffer&&We(),L}function Pe(){return b.buffer!=S.buffer&&We(),R}function de(){return b.buffer!=S.buffer&&We(),D}function ge(){return b.buffer!=S.buffer&&We(),A}function Re(){return b.buffer!=S.buffer&&We(),F}function Oe(){return b.buffer!=S.buffer&&We(),j}if(a){let T=function(k){try{var V=k.data,H=V.Db;if(H==="load"){let Q=[];self.onmessage=le=>Q.push(le),self.startWorker=()=>{postMessage({Db:"loaded"});for(let le of Q)T(le);self.onmessage=T};for(let le of V.Sb)r[le]&&!r[le].proxy||(r[le]=(...Ee)=>{postMessage({Db:"callHandler",Rb:le,args:Ee})},le=="print"&&(ye=r[le]),le=="printErr"&&(oe=r[le]));b=V.kc,We(),se(V.lc)}else if(H==="run"){ir(V.Bb),X1(V.Bb,0,0,1,0,0),Hs(),Mi(V.Bb),Ve||(Ec(),Ve=!0);try{Un(V.hc,V.Jb)}catch(Q){if(Q!="unwind")throw Q}}else V.target!=="setimmediate"&&(H==="checkMailbox"?Ve&&Bo():H&&(oe(`worker: received unknown command ${H}`),oe(V)))}catch(Q){throw Y1(),Q}};var Ve=!1;self.onunhandledrejection=k=>{throw k.reason||k},self.onmessage=T}function We(){var T=b.buffer;r.HEAP8=S=new Int8Array(T),L=new Int16Array(T),r.HEAPU8=E=new Uint8Array(T),R=new Uint16Array(T),r.HEAP32=D=new Int32Array(T),r.HEAPU32=A=new Uint32Array(T),F=new Float32Array(T),j=new Float64Array(T),P=new BigInt64Array(T),K=new BigUint64Array(T)}function nt(){a?startWorker(r):Xe.Da()}var ct,Ct=0,Wt=null;function Et(){if(--Ct==0&&Wt){var T=Wt;Wt=null,T()}}function vt(T){throw oe(T="Aborted("+T+")"),ue=!0,T=new WebAssembly.RuntimeError(T+". Build with -sASSERTIONS for more info."),n(T),T}function Ht(){return{a:{L:P4,Aa:O4,b:ui,$:Cs,A:hn,pa:Qi,X:Po,Z:bo,qa:bs,na:hi,ga:Pi,ma:Or,J:cs,Y:Aa,V:Ji,oa:cr,W:Es,va:ua,E:ca,Q:cl,O:pi,D:Da,v:ha,s:As,P:Li,z:Vo,R:hl,ja:dl,T:da,aa:yi,M:fa,F:pa,ia:Mi,sa:Oa,r:G,Ca:ce,w:C,o:X,m:ie,c:fi,Ba:he,n:Me,j:dt,u:mt,p:yt,f:nn,t:sn,l:er,e:Xn,k:Ir,h:Ds,g:or,d:Cn,da:Cr,ea:Io,fa:Ps,ba:Uo,ca:Sc,N:Nu,xa:Xs,ua:Mp,i:z,C:q,G:ne,ta:Lp,x:Fe,ra:Ge,U:xt,q:Fp,y:xn,K:rs,S:pr,za:Ma,ya:za,ka:i3,la:zp,_:Bn,B:$c,I:o3,ha:j1,H:G1,a:b,wa:Fn}}}class Tt{name="ExitStatus";constructor(k){this.message=`Program terminated with exit(${k})`,this.status=k}}var Pt=T=>{T.terminate(),T.onmessage=()=>{}},Rt=[],Yt=T=>{Ln.length==0&&(gr(),qr(Ln[0]));var k=Ln.pop();if(!k)return 6;Tn.push(k),fr[T.Bb]=k,k.Bb=T.Bb;var V={Db:"run",hc:T.fc,Jb:T.Jb,Bb:T.Bb};return k.postMessage(V,T.Nb),0},mn=0,jt=(T,k,...V)=>{for(var H=2*V.length,Q=e2(),le=Z1(8*H),Ee=le>>>3,Be=0;Be<V.length;Be++){var rt=V[Be];typeof rt=="bigint"?(P[Ee+2*Be]=1n,P[Ee+2*Be+1]=rt):(P[Ee+2*Be]=0n,Oe()[Ee+2*Be+1>>>0]=rt)}return T=Vp(T,0,H,le,k),Wp(Q),T};function Fn(T){if(a)return jt(0,1,T);if($=T,!(0<mn)){for(var k of Tn)Pt(k);for(k of Ln)Pt(k);Ln=[],Tn=[],fr={},ue=!0}m(0,new Tt(T))}function Vn(T){if(a)return jt(1,0,T);Bn(T)}var Bn=T=>{if($=T,a)throw Vn(T),"unwind";Fn(T)},Ln=[],Tn=[],xr=[],fr={},Ar=T=>{var k=T.Bb;delete fr[k],Ln.push(T),Tn.splice(Tn.indexOf(T),1),T.Bb=0,Bp(k)};function Hs(){xr.forEach(T=>T())}var qr=T=>new Promise(k=>{T.onmessage=Q=>{var le=(Q=Q.data).Db;if(Q.Hb&&Q.Hb!=Ru()){var Ee=fr[Q.Hb];Ee?Ee.postMessage(Q,Q.Nb):oe(`Internal error! Worker sent a message "${le}" to target pthread ${Q.Hb}, but that thread no longer exists!`)}else le==="checkMailbox"?Bo():le==="spawnThread"?Yt(Q):le==="cleanupThread"?Ar(fr[Q.ic]):le==="loaded"?(T.loaded=!0,k(T)):Q.target==="setimmediate"?T.postMessage(Q):le==="callHandler"?r[Q.Rb](...Q.args):le&&oe(`worker sent an unknown command ${le}`)},T.onerror=Q=>{throw oe(`worker sent an error! ${Q.filename}:${Q.lineno}: ${Q.message}`),Q};var V,H=[];for(V of[])r.propertyIsEnumerable(V)&&H.push(V);T.postMessage({Db:"load",Sb:H,kc:b,lc:x})});function gr(){var T=new Worker((()=>{let k=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new k("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});Ln.push(T)}var ir=T=>{We();var k=ge()[T+52>>>2>>>0];T=ge()[T+56>>>2>>>0],l3(k,k-T),Wp(k)},Un=(T,k)=>{mn=0,T=u3(T,k),0<mn?$=T:Up(T)};class Kr{constructor(k){this.Ib=k-24}}function ui(T,k,V){var H=new Kr(T>>>=0);throw k>>>=0,V>>>=0,ge()[H.Ib+16>>>2>>>0]=0,ge()[H.Ib+4>>>2>>>0]=k,ge()[H.Ib+8>>>2>>>0]=V,T}function Gn(T,k,V,H){return a?jt(2,1,T,k,V,H):Cs(T,k,V,H)}function Cs(T,k,V,H){if(T>>>=0,V>>>=0,H>>>=0,l===void 0)return 6;var Q=[];return a&&Q.length===0?Gn(T,k>>>=0,V,H):(T={fc:V,Bb:T,Jb:H,Nb:Q},a?(T.Db="spawnThread",postMessage(T,Q),0):Yt(T))}var ci=typeof TextDecoder<"u"?new TextDecoder:void 0,Kn=(T,k=0,V=NaN)=>{var H=(k>>>=0)+V;for(V=k;T[V]&&!(V>=H);)++V;if(16<V-k&&T.buffer&&ci)return ci.decode(T.buffer instanceof ArrayBuffer?T.subarray(k,V):T.slice(k,V));for(H="";k<V;){var Q=T[k++];if(128&Q){var le=63&T[k++];if((224&Q)==192)H+=String.fromCharCode((31&Q)<<6|le);else{var Ee=63&T[k++];65536>(Q=(240&Q)==224?(15&Q)<<12|le<<6|Ee:(7&Q)<<18|le<<12|Ee<<6|63&T[k++])?H+=String.fromCharCode(Q):(Q-=65536,H+=String.fromCharCode(55296|Q>>10,56320|1023&Q))}}else H+=String.fromCharCode(Q)}return H},Dn=(T,k)=>(T>>>=0)?Kn(re(),T,k):"";function hn(T,k,V){return a?jt(3,1,T,k,V):0}function Qi(T,k){if(a)return jt(4,1,T,k)}function Po(T,k){if(a)return jt(5,1,T,k)}function bo(T,k,V){if(a)return jt(6,1,T,k,V)}function bs(T,k,V){return a?jt(7,1,T,k,V):0}function hi(T,k){if(a)return jt(8,1,T,k)}function Pi(T,k,V){if(a)return jt(9,1,T,k,V)}function Or(T,k,V,H){if(a)return jt(10,1,T,k,V,H)}function cs(T,k,V,H){if(a)return jt(11,1,T,k,V,H)}function Aa(T,k,V,H){if(a)return jt(12,1,T,k,V,H)}function Ji(T){if(a)return jt(13,1,T)}function cr(T,k){if(a)return jt(14,1,T,k)}function Es(T,k,V){if(a)return jt(15,1,T,k,V)}var ks,ua=()=>vt(""),Ns=T=>{for(var k="";re()[T>>>0];)k+=ks[re()[T++>>>0]];return k},di={},qs={},Fi=r.BindingError=class extends Error{constructor(T){super(T),this.name="BindingError"}};function Ks(T,k,V={}){return(function(H,Q,le={}){var Ee=Q.name;if(!H)throw new Fi(`type "${Ee}" must have a positive integer typeid pointer`);if(qs.hasOwnProperty(H)){if(le.Tb)return;throw new Fi(`Cannot register type '${Ee}' twice`)}qs[H]=Q,di.hasOwnProperty(H)&&(Q=di[H],delete di[H],Q.forEach(Be=>Be()))})(T,k,V)}var Ra=(T,k,V)=>{switch(k){case 1:return V?H=>Y()[H>>>0]:H=>re()[H>>>0];case 2:return V?H=>Te()[H>>>1>>>0]:H=>Pe()[H>>>1>>>0];case 4:return V?H=>de()[H>>>2>>>0]:H=>ge()[H>>>2>>>0];case 8:return V?H=>P[H>>>3]:H=>K[H>>>3];default:throw new TypeError(`invalid integer width (${k}): ${T}`)}};function ca(T,k,V){V>>>=0,Ks(T>>>=0,{name:k=Ns(k>>>0),fromWireType:H=>H,toWireType:function(H,Q){if(typeof Q!="bigint"&&typeof Q!="number")throw Q=Q===null?"null":(H=typeof Q)=="object"||H==="array"||H==="function"?Q.toString():""+Q,new TypeError(`Cannot convert "${Q}" to ${this.name}`);return typeof Q=="number"&&(Q=BigInt(Q)),Q},Cb:Rr,readValueFromPointer:Ra(k,V,k.indexOf("u")==-1),Eb:null})}var Rr=8;function cl(T,k,V,H){Ks(T>>>=0,{name:k=Ns(k>>>0),fromWireType:function(Q){return!!Q},toWireType:function(Q,le){return le?V:H},Cb:Rr,readValueFromPointer:function(Q){return this.fromWireType(re()[Q>>>0])},Eb:null})}var Fo=[],Xr=[];function fi(T){9<(T>>>=0)&&--Xr[T+1]==0&&(Xr[T]=void 0,Fo.push(T))}var gn=T=>{if(!T)throw new Fi(`Cannot use deleted val. handle = ${T}`);return Xr[T]},hs=T=>{switch(T){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let k=Fo.pop()||Xr.length;return Xr[k]=T,Xr[k+1]=1,k}};function Zi(T){return this.fromWireType(ge()[T>>>2>>>0])}var xo={name:"emscripten::val",fromWireType:T=>{var k=gn(T);return fi(T),k},toWireType:(T,k)=>hs(k),Cb:Rr,readValueFromPointer:Zi,Eb:null};function pi(T){return Ks(T>>>0,xo)}var xs=(T,k)=>{switch(k){case 4:return function(V){return this.fromWireType(Re()[V>>>2>>>0])};case 8:return function(V){return this.fromWireType(Oe()[V>>>3>>>0])};default:throw new TypeError(`invalid float width (${k}): ${T}`)}};function Da(T,k,V){V>>>=0,Ks(T>>>=0,{name:k=Ns(k>>>0),fromWireType:H=>H,toWireType:(H,Q)=>Q,Cb:Rr,readValueFromPointer:xs(k,V),Eb:null})}function ha(T,k,V,H,Q){if(T>>>=0,V>>>=0,k=Ns(k>>>0),Q===-1&&(Q=4294967295),Q=Be=>Be,H===0){var le=32-8*V;Q=Be=>Be<<le>>>le}var Ee=k.includes("unsigned")?function(Be,rt){return rt>>>0}:function(Be,rt){return rt};Ks(T,{name:k,fromWireType:Q,toWireType:Ee,Cb:Rr,readValueFromPointer:Ra(k,V,H!==0),Eb:null})}function As(T,k,V){function H(le){var Ee=ge()[le>>>2>>>0];return le=ge()[le+4>>>2>>>0],new Q(Y().buffer,le,Ee)}var Q=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][k];Ks(T>>>=0,{name:V=Ns(V>>>0),fromWireType:H,Cb:Rr,readValueFromPointer:H},{Tb:!0})}var mi=(T,k,V)=>{var H=re();if(k>>>=0,0<V){var Q=k;V=k+V-1;for(var le=0;le<T.length;++le){var Ee=T.charCodeAt(le);if(55296<=Ee&&57343>=Ee&&(Ee=65536+((1023&Ee)<<10)|1023&T.charCodeAt(++le)),127>=Ee){if(k>=V)break;H[k++>>>0]=Ee}else{if(2047>=Ee){if(k+1>=V)break;H[k++>>>0]=192|Ee>>6}else{if(65535>=Ee){if(k+2>=V)break;H[k++>>>0]=224|Ee>>12}else{if(k+3>=V)break;H[k++>>>0]=240|Ee>>18,H[k++>>>0]=128|Ee>>12&63}H[k++>>>0]=128|Ee>>6&63}H[k++>>>0]=128|63&Ee}}H[k>>>0]=0,T=k-Q}else T=0;return T},hr=T=>{for(var k=0,V=0;V<T.length;++V){var H=T.charCodeAt(V);127>=H?k++:2047>=H?k+=2:55296<=H&&57343>=H?(k+=4,++V):k+=3}return k};function Li(T,k){Ks(T>>>=0,{name:k=Ns(k>>>0),fromWireType:function(V){for(var H,Q=ge()[V>>>2>>>0],le=V+4,Ee=le,Be=0;Be<=Q;++Be){var rt=le+Be;Be!=Q&&re()[rt>>>0]!=0||(Ee=Dn(Ee,rt-Ee),H===void 0?H=Ee:(H+="\0",H+=Ee),Ee=rt+1)}return fl(V),H},toWireType:function(V,H){H instanceof ArrayBuffer&&(H=new Uint8Array(H));var Q=typeof H=="string";if(!(Q||ArrayBuffer.isView(H)&&H.BYTES_PER_ELEMENT==1))throw new Fi("Cannot pass non-string to std::string");var le=Q?hr(H):H.length,Ee=Du(4+le+1),Be=Ee+4;return ge()[Ee>>>2>>>0]=le,Q?mi(H,Be,le+1):re().set(H,Be>>>0),V!==null&&V.push(fl,Ee),Ee},Cb:Rr,readValueFromPointer:Zi,Eb(V){fl(V)}})}var Pr=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Lo=(T,k)=>{for(var V=T>>1,H=V+k/2;!(V>=H)&&Pe()[V>>>0];)++V;if(32<(V<<=1)-T&&Pr)return Pr.decode(re().slice(T,V));for(V="",H=0;!(H>=k/2);++H){var Q=Te()[T+2*H>>>1>>>0];if(Q==0)break;V+=String.fromCharCode(Q)}return V},gi=(T,k,V)=>{if(V??=2147483647,2>V)return 0;var H=k;V=(V-=2)<2*T.length?V/2:T.length;for(var Q=0;Q<V;++Q){var le=T.charCodeAt(Q);Te()[k>>>1>>>0]=le,k+=2}return Te()[k>>>1>>>0]=0,k-H},Mo=T=>2*T.length,Hn=(T,k)=>{for(var V=0,H="";!(V>=k/4);){var Q=de()[T+4*V>>>2>>>0];if(Q==0)break;++V,65536<=Q?(Q-=65536,H+=String.fromCharCode(55296|Q>>10,56320|1023&Q)):H+=String.fromCharCode(Q)}return H},Rs=(T,k,V)=>{if(k>>>=0,V??=2147483647,4>V)return 0;var H=k;V=H+V-4;for(var Q=0;Q<T.length;++Q){var le=T.charCodeAt(Q);if(55296<=le&&57343>=le&&(le=65536+((1023&le)<<10)|1023&T.charCodeAt(++Q)),de()[k>>>2>>>0]=le,(k+=4)+4>V)break}return de()[k>>>2>>>0]=0,k-H},zo=T=>{for(var k=0,V=0;V<T.length;++V){var H=T.charCodeAt(V);55296<=H&&57343>=H&&++V,k+=4}return k};function Vo(T,k,V){if(T>>>=0,k>>>=0,V=Ns(V>>>=0),k===2)var H=Lo,Q=gi,le=Mo,Ee=Be=>Pe()[Be>>>1>>>0];else k===4&&(H=Hn,Q=Rs,le=zo,Ee=Be=>ge()[Be>>>2>>>0]);Ks(T,{name:V,fromWireType:Be=>{for(var rt,ft=ge()[Be>>>2>>>0],Nt=Be+4,qt=0;qt<=ft;++qt){var yn=Be+4+qt*k;qt!=ft&&Ee(yn)!=0||(Nt=H(Nt,yn-Nt),rt===void 0?rt=Nt:(rt+="\0",rt+=Nt),Nt=yn+k)}return fl(Be),rt},toWireType:(Be,rt)=>{if(typeof rt!="string")throw new Fi(`Cannot pass non-string to C++ string type ${V}`);var ft=le(rt),Nt=Du(4+ft+k);return ge()[Nt>>>2>>>0]=ft/k,Q(rt,Nt+4,ft+k),Be!==null&&Be.push(fl,Nt),Nt},Cb:Rr,readValueFromPointer:Zi,Eb(Be){fl(Be)}})}function hl(T,k){Ks(T>>>=0,{Ub:!0,name:k=Ns(k>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function dl(T){X1(T>>>0,!o,1,!i,131072,!1),Hs()}var _o=T=>{if(!ue)try{if(T(),!(0<mn))try{a?Up($):Bn($)}catch(k){k instanceof Tt||k=="unwind"||m(0,k)}}catch(k){k instanceof Tt||k=="unwind"||m(0,k)}};function Mi(T){T>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(de(),T>>>2,T).value.then(Bo),T+=128,Atomics.store(de(),T>>>2,1))}var Bo=()=>{var T=Ru();T&&(Mi(T),_o(J1))};function da(T,k){(T>>>=0)==k>>>0?setTimeout(Bo):a?postMessage({Hb:T,Db:"checkMailbox"}):(T=fr[T])&&T.postMessage({Db:"checkMailbox"})}var Sn=[];function yi(T,k,V,H,Q){for(k>>>=0,H/=2,Sn.length=H,V=Q>>>0>>>3,Q=0;Q<H;Q++)Sn[Q]=P[V+2*Q]?P[V+2*Q+1]:Oe()[V+2*Q+1>>>0];return(k?q1[k]:Cc[T])(...Sn)}var fa=()=>{mn=0};function pa(T){T>>>=0,a?postMessage({Db:"cleanupThread",ic:T}):Ar(fr[T])}function Oa(T){}var O=(T,k)=>{var V=qs[T];if(V===void 0)throw T=K1(T),V=Ns(T),fl(T),new Fi(`${k} has unknown type ${V}`);return V},U=(T,k,V)=>{var H=[];return T=T.toWireType(H,V),H.length&&(ge()[k>>>2>>>0]=hs(H)),T};function G(T,k,V){return k>>>=0,V>>>=0,T=gn(T>>>0),k=O(k,"emval::as"),U(k,V,T)}function ce(T,k){return k>>>=0,T=gn(T>>>0),(k=O(k,"emval::as")).toWireType(null,T)}var Ne=T=>{try{T()}catch(k){vt(k)}},qe=0,Ae=null,Ye=0,ot=[],bt={},tn={},bn=0,Zt=null,an=[];function kt(T){return(function(k){if(!ue){if(qe===0){var V=!1,H=!1;k((Q=0)=>{if(!ue&&(Ye=Q,V=!0,H)){qe=2,Ne(()=>t2(Ae)),typeof MainLoop<"u"&&MainLoop.Qb&&MainLoop.resume(),Q=!1;try{var le=(function(){var rt=de()[Ae+8>>>2>>>0];return rt=Xe[tn[rt]],--mn,rt()})()}catch(rt){le=rt,Q=!0}var Ee=!1;if(!Ae){var Be=Zt;Be&&(Zt=null,(Q?Be.reject:Be.resolve)(le),Ee=!0)}if(Q&&!Ee)throw le}}),H=!0,V||(qe=1,Ae=(function(){var Q=Du(65548),le=Q+12;ge()[Q>>>2>>>0]=le,ge()[Q+4>>>2>>>0]=le+65536,le=ot[0];var Ee=bt[le];return Ee===void 0&&(Ee=bn++,bt[le]=Ee,tn[Ee]=le),le=Ee,de()[Q+8>>>2>>>0]=le,Q})(),typeof MainLoop<"u"&&MainLoop.Qb&&MainLoop.pause(),Ne(()=>Wo(Ae)))}else qe===2?(qe=0,Ne(n2),fl(Ae),Ae=null,an.forEach(_o)):vt(`invalid state: ${qe}`);return Ye}})(k=>{T().then(k)})}function C(T){return T>>>=0,kt(async()=>{var k=await gn(T);return hs(k)})}var W=[];function X(T,k,V,H){return V>>>=0,H>>>=0,(T=W[T>>>0])(null,k=gn(k>>>0),V,H)}var te={},ae=T=>{var k=te[T];return k===void 0?Ns(T):k};function ie(T,k,V,H,Q){return V>>>=0,H>>>=0,Q>>>=0,(T=W[T>>>0])(k=gn(k>>>0),k[V=ae(V)],H,Q)}function he(T,k){return k>>>=0,(T=gn(T>>>0))==gn(k)}var xe=()=>typeof globalThis=="object"?globalThis:Function("return this")();function Me(T){return(T>>>=0)==0?hs(xe()):(T=ae(T),hs(xe()[T]))}var Qe=T=>{var k=W.length;return W.push(T),k},Ze=(T,k)=>{for(var V=Array(T),H=0;H<T;++H)V[H]=O(ge()[k+4*H>>>2>>>0],`parameter ${H}`);return V};function dt(T,k,V){var H=(k=Ze(T,k>>>0)).shift();T--;var Q=`return function (obj, func, destructorsRef, args) {
`,le=0,Ee=[];V===0&&Ee.push("obj");for(var Be=["retType"],rt=[H],ft=0;ft<T;++ft)Ee.push(`arg${ft}`),Be.push(`argType${ft}`),rt.push(k[ft]),Q+=`  var arg${ft} = argType${ft}.readValueFromPointer(args${le?"+"+le:""});
`,le+=k[ft].Cb;return Q+=`  var rv = ${V===1?"new func":"func.call"}(${Ee.join(", ")});
`,H.Ub||(Be.push("emval_returnValue"),rt.push(U),Q+=`  return emval_returnValue(retType, destructorsRef, rv);
`),T=new Function(...Be,Q+`};
`)(...rt),V=`methodCaller<(${k.map(Nt=>Nt.name).join(", ")}) => ${H.name}>`,Qe(Object.defineProperty(T,"name",{value:V}))}function mt(T){return T=ae(T>>>0),hs(r[T])}function yt(T,k){return k>>>=0,T=gn(T>>>0),k=gn(k),hs(T[k])}function nn(T){9<(T>>>=0)&&(Xr[T+1]+=1)}function sn(){return hs([])}function er(T){T=gn(T>>>0);for(var k=Array(T.length),V=0;V<T.length;V++)k[V]=T[V];return hs(k)}function Xn(T){return hs(ae(T>>>0))}function Ir(){return hs({})}function Ds(T){for(var k=gn(T>>>=0);k.length;){var V=k.pop();k.pop()(V)}fi(T)}function or(T,k,V){k>>>=0,V>>>=0,T=gn(T>>>0),k=gn(k),V=gn(V),T[k]=V}function Cn(T,k){return k>>>=0,T=(T=O(T>>>0,"_emval_take_value")).readValueFromPointer(k),hs(T)}function Cr(T,k){T=-9007199254740992>T||9007199254740992<T?NaN:Number(T),k>>>=0,T=new Date(1e3*T),de()[k>>>2>>>0]=T.getUTCSeconds(),de()[k+4>>>2>>>0]=T.getUTCMinutes(),de()[k+8>>>2>>>0]=T.getUTCHours(),de()[k+12>>>2>>>0]=T.getUTCDate(),de()[k+16>>>2>>>0]=T.getUTCMonth(),de()[k+20>>>2>>>0]=T.getUTCFullYear()-1900,de()[k+24>>>2>>>0]=T.getUTCDay(),T=(T.getTime()-Date.UTC(T.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,de()[k+28>>>2>>>0]=T}var Os=T=>T%4==0&&(T%100!=0||T%400==0),zi=[0,31,60,91,121,152,182,213,244,274,305,335],Pa=[0,31,59,90,120,151,181,212,243,273,304,334];function Io(T,k){T=-9007199254740992>T||9007199254740992<T?NaN:Number(T),k>>>=0,T=new Date(1e3*T),de()[k>>>2>>>0]=T.getSeconds(),de()[k+4>>>2>>>0]=T.getMinutes(),de()[k+8>>>2>>>0]=T.getHours(),de()[k+12>>>2>>>0]=T.getDate(),de()[k+16>>>2>>>0]=T.getMonth(),de()[k+20>>>2>>>0]=T.getFullYear()-1900,de()[k+24>>>2>>>0]=T.getDay();var V=(Os(T.getFullYear())?zi:Pa)[T.getMonth()]+T.getDate()-1|0;de()[k+28>>>2>>>0]=V,de()[k+36>>>2>>>0]=-60*T.getTimezoneOffset(),V=new Date(T.getFullYear(),6,1).getTimezoneOffset();var H=new Date(T.getFullYear(),0,1).getTimezoneOffset();T=0|(V!=H&&T.getTimezoneOffset()==Math.min(H,V)),de()[k+32>>>2>>>0]=T}function Ps(T){T>>>=0;var k=new Date(de()[T+20>>>2>>>0]+1900,de()[T+16>>>2>>>0],de()[T+12>>>2>>>0],de()[T+8>>>2>>>0],de()[T+4>>>2>>>0],de()[T>>>2>>>0],0),V=de()[T+32>>>2>>>0],H=k.getTimezoneOffset(),Q=new Date(k.getFullYear(),6,1).getTimezoneOffset(),le=new Date(k.getFullYear(),0,1).getTimezoneOffset(),Ee=Math.min(le,Q);return 0>V?de()[T+32>>>2>>>0]=+(Q!=le&&Ee==H):0<V!=(Ee==H)&&(Q=Math.max(le,Q),k.setTime(k.getTime()+6e4*((0<V?Ee:Q)-H))),de()[T+24>>>2>>>0]=k.getDay(),V=(Os(k.getFullYear())?zi:Pa)[k.getMonth()]+k.getDate()-1|0,de()[T+28>>>2>>>0]=V,de()[T>>>2>>>0]=k.getSeconds(),de()[T+4>>>2>>>0]=k.getMinutes(),de()[T+8>>>2>>>0]=k.getHours(),de()[T+12>>>2>>>0]=k.getDate(),de()[T+16>>>2>>>0]=k.getMonth(),de()[T+20>>>2>>>0]=k.getYear(),T=k.getTime(),BigInt(isNaN(T)?-1:T/1e3)}function Uo(T,k,V,H,Q,le,Ee){return a?jt(16,1,T,k,V,H,Q,le,Ee):-52}function Sc(T,k,V,H,Q,le){if(a)return jt(17,1,T,k,V,H,Q,le)}var Kl={},Fp=()=>performance.timeOrigin+performance.now();function Nu(T,k){if(a)return jt(18,1,T,k);if(Kl[T]&&(clearTimeout(Kl[T].id),delete Kl[T]),!k)return 0;var V=setTimeout(()=>{delete Kl[T],_o(()=>Q1(T,performance.timeOrigin+performance.now()))},k);return Kl[T]={id:V,rc:k},0}function Xs(T,k,V,H){T>>>=0,k>>>=0,V>>>=0,H>>>=0;var Q=new Date().getFullYear(),le=new Date(Q,0,1).getTimezoneOffset();Q=new Date(Q,6,1).getTimezoneOffset();var Ee=Math.max(le,Q);ge()[T>>>2>>>0]=60*Ee,de()[k>>>2>>>0]=+(le!=Q),T=(k=Be=>{var rt=Math.abs(Be);return`UTC${0<=Be?"-":"+"}${String(Math.floor(rt/60)).padStart(2,"0")}${String(rt%60).padStart(2,"0")}`})(le),k=k(Q),Q<le?(mi(T,V,17),mi(k,H,17)):(mi(T,H,17),mi(k,V,17))}var Lp=()=>Date.now();function Mp(T,k,V){return 0<=T&&3>=T?(T===0?T=Date.now():T=performance.timeOrigin+performance.now(),P[V>>>0>>>3]=BigInt(Math.round(1e6*T)),0):28}var Fa=[],_=(T,k)=>{Fa.length=0;for(var V;V=re()[T++>>>0];){var H=V!=105;k+=(H&=V!=112)&&k%8?4:0,Fa.push(V==112?ge()[k>>>2>>>0]:V==106?P[k>>>3]:V==105?de()[k>>>2>>>0]:Oe()[k>>>3>>>0]),k+=H?8:4}return Fa};function z(T,k,V){return T>>>=0,k=_(k>>>0,V>>>0),q1[T](...k)}function q(T,k,V){return T>>>=0,k=_(k>>>0,V>>>0),q1[T](...k)}var ne=()=>{};function Fe(T,k){return oe(Dn(T>>>0,k>>>0))}var Ge=()=>{throw mn+=1,"unwind"};function xt(){return 4294901760}var xn=()=>navigator.hardwareConcurrency;function rs(){return vt("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function pr(T){T>>>=0;var k=re().length;if(T<=k||4294901760<T)return!1;for(var V=1;4>=V;V*=2){var H=k*(1+.2/V);H=Math.min(H,T+100663296);e:{H=(Math.min(4294901760,65536*Math.ceil(Math.max(T,H)/65536))-b.buffer.byteLength+65535)/65536|0;try{b.grow(H),We();var Q=1;break e}catch{}Q=void 0}if(Q)return!0}return!1}var Fr=()=>(vt("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Ys={},La=T=>{T.forEach(k=>{Fr()})};function Ma(){var T=Error().stack.toString().split(`
`);return T[0]=="Error"&&T.shift(),La(T),Ys.Mb=Fr(),Ys.dc=T,Ys.Mb}function za(T,k,V){if(T>>>=0,k>>>=0,Ys.Mb==T)var H=Ys.dc;else(H=Error().stack.toString().split(`
`))[0]=="Error"&&H.shift(),La(H);for(var Q=3;H[Q]&&Fr()!=T;)++Q;for(T=0;T<V&&H[T+Q];++T)de()[k+4*T>>>2>>>0]=Fr();return T}var Xl,Au={},s3=()=>{if(!Xl){var T,k={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(T in Au)Au[T]===void 0?delete k[T]:k[T]=Au[T];var V=[];for(T in k)V.push(`${T}=${k[T]}`);Xl=V}return Xl};function i3(T,k){if(a)return jt(19,1,T,k);T>>>=0,k>>>=0;var V,H=0,Q=0;for(V of s3()){var le=k+H;ge()[T+Q>>>2>>>0]=le,H+=mi(V,le,1/0)+1,Q+=4}return 0}function zp(T,k){if(a)return jt(20,1,T,k);T>>>=0,k>>>=0;var V=s3();for(var H of(ge()[T>>>2>>>0]=V.length,T=0,V))T+=hr(H)+1;return ge()[k>>>2>>>0]=T,0}function $c(T){return a?jt(21,1,T):52}function o3(T,k,V,H){return a?jt(22,1,T,k,V,H):52}function j1(T,k,V,H){return a?jt(23,1,T,k,V,H):70}var a3=[null,[],[]];function G1(T,k,V,H){if(a)return jt(24,1,T,k,V,H);k>>>=0,V>>>=0,H>>>=0;for(var Q=0,le=0;le<V;le++){var Ee=ge()[k>>>2>>>0],Be=ge()[k+4>>>2>>>0];k+=8;for(var rt=0;rt<Be;rt++){var ft=T,Nt=re()[Ee+rt>>>0],qt=a3[ft];Nt===0||Nt===10?((ft===1?ye:oe)(Kn(qt)),qt.length=0):qt.push(Nt)}Q+=Be}return ge()[H>>>2>>>0]=Q,0}a||(function(){for(var T=r.numThreads-1;T--;)gr();Rt.push(()=>{Ct++,(function(k){a?k():Promise.all(Ln.map(qr)).then(k)})(()=>Et())})})();for(var H1=Array(256),ed=0;256>ed;++ed)H1[ed]=String.fromCharCode(ed);ks=H1,Xr.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>Xr.length/2-5-Fo.length,a||(b=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),We()),r.wasmBinary&&(v=r.wasmBinary),r.stackSave=()=>e2(),r.stackRestore=T=>Wp(T),r.stackAlloc=T=>Z1(T),r.setValue=function(T,k,V="i8"){switch(V.endsWith("*")&&(V="*"),V){case"i1":case"i8":Y()[T>>>0]=k;break;case"i16":Te()[T>>>1>>>0]=k;break;case"i32":de()[T>>>2>>>0]=k;break;case"i64":P[T>>>3]=BigInt(k);break;case"float":Re()[T>>>2>>>0]=k;break;case"double":Oe()[T>>>3>>>0]=k;break;case"*":ge()[T>>>2>>>0]=k;break;default:vt(`invalid type for setValue: ${V}`)}},r.getValue=function(T,k="i8"){switch(k.endsWith("*")&&(k="*"),k){case"i1":case"i8":return Y()[T>>>0];case"i16":return Te()[T>>>1>>>0];case"i32":return de()[T>>>2>>>0];case"i64":return P[T>>>3];case"float":return Re()[T>>>2>>>0];case"double":return Oe()[T>>>3>>>0];case"*":return ge()[T>>>2>>>0];default:vt(`invalid type for getValue: ${k}`)}},r.UTF8ToString=Dn,r.stringToUTF8=mi,r.lengthBytesUTF8=hr;var Cc=[Fn,Vn,Gn,hn,Qi,Po,bo,bs,hi,Pi,Or,cs,Aa,Ji,cr,Es,Uo,Sc,Nu,i3,zp,$c,o3,j1,G1],q1={893836:(T,k,V,H,Q)=>{if(r===void 0||!r.Fb)return 1;if((T=Dn(Number(T>>>0))).startsWith("./")&&(T=T.substring(2)),!(T=r.Fb.get(T)))return 2;if(k=Number(k>>>0),V=Number(V>>>0),H=Number(H>>>0),k+V>T.byteLength)return 3;try{let le=T.subarray(k,k+V);switch(Q){case 0:re().set(le,H>>>0);break;case 1:r.mc?r.mc(H,le):r.cc(H,le);break;default:return 4}return 0}catch{return 4}},894660:(T,k,V)=>{r.Pb(T,re().subarray(k>>>0,k+V>>>0))},894724:()=>r.oc(),894766:T=>{r.Ob(T)},894803:()=>{r.Wb()},894834:()=>{r.Xb()},894863:()=>{r.ac()},894888:T=>r.Vb(T),894921:T=>r.Zb(T),894953:(T,k,V)=>{r.Lb(Number(T),Number(k),Number(V),!0)},895016:(T,k,V)=>{r.Lb(Number(T),Number(k),Number(V))},895073:()=>typeof wasmOffsetConverter<"u",895130:T=>{r.Ab("Abs",T,void 0)},895181:T=>{r.Ab("Neg",T,void 0)},895232:T=>{r.Ab("Floor",T,void 0)},895285:T=>{r.Ab("Ceil",T,void 0)},895337:T=>{r.Ab("Reciprocal",T,void 0)},895395:T=>{r.Ab("Sqrt",T,void 0)},895447:T=>{r.Ab("Exp",T,void 0)},895498:T=>{r.Ab("Erf",T,void 0)},895549:T=>{r.Ab("Sigmoid",T,void 0)},895604:(T,k,V)=>{r.Ab("HardSigmoid",T,{alpha:k,beta:V})},895683:T=>{r.Ab("Log",T,void 0)},895734:T=>{r.Ab("Sin",T,void 0)},895785:T=>{r.Ab("Cos",T,void 0)},895836:T=>{r.Ab("Tan",T,void 0)},895887:T=>{r.Ab("Asin",T,void 0)},895939:T=>{r.Ab("Acos",T,void 0)},895991:T=>{r.Ab("Atan",T,void 0)},896043:T=>{r.Ab("Sinh",T,void 0)},896095:T=>{r.Ab("Cosh",T,void 0)},896147:T=>{r.Ab("Asinh",T,void 0)},896200:T=>{r.Ab("Acosh",T,void 0)},896253:T=>{r.Ab("Atanh",T,void 0)},896306:T=>{r.Ab("Tanh",T,void 0)},896358:T=>{r.Ab("Not",T,void 0)},896409:(T,k,V)=>{r.Ab("Clip",T,{min:k,max:V})},896478:T=>{r.Ab("Clip",T,void 0)},896530:(T,k)=>{r.Ab("Elu",T,{alpha:k})},896588:T=>{r.Ab("Gelu",T,void 0)},896640:T=>{r.Ab("Relu",T,void 0)},896692:(T,k)=>{r.Ab("LeakyRelu",T,{alpha:k})},896756:(T,k)=>{r.Ab("ThresholdedRelu",T,{alpha:k})},896826:(T,k)=>{r.Ab("Cast",T,{to:k})},896884:T=>{r.Ab("Add",T,void 0)},896935:T=>{r.Ab("Sub",T,void 0)},896986:T=>{r.Ab("Mul",T,void 0)},897037:T=>{r.Ab("Div",T,void 0)},897088:T=>{r.Ab("Pow",T,void 0)},897139:T=>{r.Ab("Equal",T,void 0)},897192:T=>{r.Ab("Greater",T,void 0)},897247:T=>{r.Ab("GreaterOrEqual",T,void 0)},897309:T=>{r.Ab("Less",T,void 0)},897361:T=>{r.Ab("LessOrEqual",T,void 0)},897420:(T,k,V,H,Q)=>{r.Ab("ReduceMean",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},897595:(T,k,V,H,Q)=>{r.Ab("ReduceMax",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},897769:(T,k,V,H,Q)=>{r.Ab("ReduceMin",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},897943:(T,k,V,H,Q)=>{r.Ab("ReduceProd",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},898118:(T,k,V,H,Q)=>{r.Ab("ReduceSum",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},898292:(T,k,V,H,Q)=>{r.Ab("ReduceL1",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},898465:(T,k,V,H,Q)=>{r.Ab("ReduceL2",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},898638:(T,k,V,H,Q)=>{r.Ab("ReduceLogSum",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},898815:(T,k,V,H,Q)=>{r.Ab("ReduceSumSquare",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},898995:(T,k,V,H,Q)=>{r.Ab("ReduceLogSumExp",T,{keepDims:!!k,noopWithEmptyAxes:!!V,axes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},899175:T=>{r.Ab("Where",T,void 0)},899228:(T,k,V)=>{r.Ab("Transpose",T,{perm:k?Array.from(de().subarray(Number(k)>>>0,Number(V)>>>0)):[]})},899352:(T,k,V,H)=>{r.Ab("DepthToSpace",T,{blocksize:k,mode:Dn(V),format:H?"NHWC":"NCHW"})},899485:(T,k,V,H)=>{r.Ab("DepthToSpace",T,{blocksize:k,mode:Dn(V),format:H?"NHWC":"NCHW"})},899618:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr)=>{r.Ab("ConvTranspose",T,{format:rt?"NHWC":"NCHW",autoPad:k,dilations:[V],group:H,kernelShape:[Q],pads:[le,Ee],strides:[Be],wIsConst:()=>!!Y()[ft>>>0],outputPadding:Nt?Array.from(de().subarray(Number(Nt)>>>0,Number(qt)>>>0)):[],outputShape:yn?Array.from(de().subarray(Number(yn)>>>0,Number(Yn)>>>0)):[],activation:Dn(Lr)})},900051:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn)=>{r.Ab("ConvTranspose",T,{format:Be?"NHWC":"NCHW",autoPad:k,dilations:Array.from(de().subarray(Number(V)>>>0,2+(Number(V)>>>0)>>>0)),group:H,kernelShape:Array.from(de().subarray(Number(Q)>>>0,2+(Number(Q)>>>0)>>>0)),pads:Array.from(de().subarray(Number(le)>>>0,4+(Number(le)>>>0)>>>0)),strides:Array.from(de().subarray(Number(Ee)>>>0,2+(Number(Ee)>>>0)>>>0)),wIsConst:()=>!!Y()[rt>>>0],outputPadding:ft?Array.from(de().subarray(Number(ft)>>>0,Number(Nt)>>>0)):[],outputShape:qt?Array.from(de().subarray(Number(qt)>>>0,Number(yn)>>>0)):[],activation:Dn(Yn)})},900712:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr)=>{r.Ab("ConvTranspose",T,{format:rt?"NHWC":"NCHW",autoPad:k,dilations:[V],group:H,kernelShape:[Q],pads:[le,Ee],strides:[Be],wIsConst:()=>!!Y()[ft>>>0],outputPadding:Nt?Array.from(de().subarray(Number(Nt)>>>0,Number(qt)>>>0)):[],outputShape:yn?Array.from(de().subarray(Number(yn)>>>0,Number(Yn)>>>0)):[],activation:Dn(Lr)})},901145:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn)=>{r.Ab("ConvTranspose",T,{format:Be?"NHWC":"NCHW",autoPad:k,dilations:Array.from(de().subarray(Number(V)>>>0,2+(Number(V)>>>0)>>>0)),group:H,kernelShape:Array.from(de().subarray(Number(Q)>>>0,2+(Number(Q)>>>0)>>>0)),pads:Array.from(de().subarray(Number(le)>>>0,4+(Number(le)>>>0)>>>0)),strides:Array.from(de().subarray(Number(Ee)>>>0,2+(Number(Ee)>>>0)>>>0)),wIsConst:()=>!!Y()[rt>>>0],outputPadding:ft?Array.from(de().subarray(Number(ft)>>>0,Number(Nt)>>>0)):[],outputShape:qt?Array.from(de().subarray(Number(qt)>>>0,Number(yn)>>>0)):[],activation:Dn(Yn)})},901806:(T,k)=>{r.Ab("GlobalAveragePool",T,{format:k?"NHWC":"NCHW"})},901897:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn)=>{r.Ab("AveragePool",T,{format:Yn?"NHWC":"NCHW",auto_pad:k,ceil_mode:V,count_include_pad:H,storage_order:Q,dilations:le?Array.from(de().subarray(Number(le)>>>0,Number(Ee)>>>0)):[],kernel_shape:Be?Array.from(de().subarray(Number(Be)>>>0,Number(rt)>>>0)):[],pads:ft?Array.from(de().subarray(Number(ft)>>>0,Number(Nt)>>>0)):[],strides:qt?Array.from(de().subarray(Number(qt)>>>0,Number(yn)>>>0)):[]})},902376:(T,k)=>{r.Ab("GlobalAveragePool",T,{format:k?"NHWC":"NCHW"})},902467:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn)=>{r.Ab("AveragePool",T,{format:Yn?"NHWC":"NCHW",auto_pad:k,ceil_mode:V,count_include_pad:H,storage_order:Q,dilations:le?Array.from(de().subarray(Number(le)>>>0,Number(Ee)>>>0)):[],kernel_shape:Be?Array.from(de().subarray(Number(Be)>>>0,Number(rt)>>>0)):[],pads:ft?Array.from(de().subarray(Number(ft)>>>0,Number(Nt)>>>0)):[],strides:qt?Array.from(de().subarray(Number(qt)>>>0,Number(yn)>>>0)):[]})},902946:(T,k)=>{r.Ab("GlobalMaxPool",T,{format:k?"NHWC":"NCHW"})},903033:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn)=>{r.Ab("MaxPool",T,{format:Yn?"NHWC":"NCHW",auto_pad:k,ceil_mode:V,count_include_pad:H,storage_order:Q,dilations:le?Array.from(de().subarray(Number(le)>>>0,Number(Ee)>>>0)):[],kernel_shape:Be?Array.from(de().subarray(Number(Be)>>>0,Number(rt)>>>0)):[],pads:ft?Array.from(de().subarray(Number(ft)>>>0,Number(Nt)>>>0)):[],strides:qt?Array.from(de().subarray(Number(qt)>>>0,Number(yn)>>>0)):[]})},903508:(T,k)=>{r.Ab("GlobalMaxPool",T,{format:k?"NHWC":"NCHW"})},903595:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn)=>{r.Ab("MaxPool",T,{format:Yn?"NHWC":"NCHW",auto_pad:k,ceil_mode:V,count_include_pad:H,storage_order:Q,dilations:le?Array.from(de().subarray(Number(le)>>>0,Number(Ee)>>>0)):[],kernel_shape:Be?Array.from(de().subarray(Number(Be)>>>0,Number(rt)>>>0)):[],pads:ft?Array.from(de().subarray(Number(ft)>>>0,Number(Nt)>>>0)):[],strides:qt?Array.from(de().subarray(Number(qt)>>>0,Number(yn)>>>0)):[]})},904070:(T,k,V,H,Q)=>{r.Ab("Gemm",T,{alpha:k,beta:V,transA:H,transB:Q})},904174:T=>{r.Ab("MatMul",T,void 0)},904228:(T,k,V,H)=>{r.Ab("ArgMax",T,{keepDims:!!k,selectLastIndex:!!V,axis:H})},904336:(T,k,V,H)=>{r.Ab("ArgMin",T,{keepDims:!!k,selectLastIndex:!!V,axis:H})},904444:(T,k)=>{r.Ab("Softmax",T,{axis:k})},904507:(T,k)=>{r.Ab("Concat",T,{axis:k})},904567:(T,k,V,H,Q)=>{r.Ab("Split",T,{axis:k,numOutputs:V,splitSizes:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},904723:T=>{r.Ab("Expand",T,void 0)},904777:(T,k)=>{r.Ab("Gather",T,{axis:Number(k)})},904848:(T,k)=>{r.Ab("GatherElements",T,{axis:Number(k)})},904927:(T,k)=>{r.Ab("GatherND",T,{batch_dims:Number(k)})},905006:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt)=>{r.Ab("Resize",T,{antialias:k,axes:V?Array.from(de().subarray(Number(V)>>>0,Number(H)>>>0)):[],coordinateTransformMode:Dn(Q),cubicCoeffA:le,excludeOutside:Ee,extrapolationValue:Be,keepAspectRatioPolicy:Dn(rt),mode:Dn(ft),nearestMode:Dn(Nt)})},905368:(T,k,V,H,Q,le,Ee)=>{r.Ab("Slice",T,{starts:k?Array.from(de().subarray(Number(k)>>>0,Number(V)>>>0)):[],ends:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[],axes:le?Array.from(de().subarray(Number(le)>>>0,Number(Ee)>>>0)):[]})},905632:T=>{r.Ab("Tile",T,void 0)},905684:(T,k,V)=>{r.Ab("InstanceNormalization",T,{epsilon:k,format:V?"NHWC":"NCHW"})},905798:(T,k,V)=>{r.Ab("InstanceNormalization",T,{epsilon:k,format:V?"NHWC":"NCHW"})},905912:T=>{r.Ab("Range",T,void 0)},905965:(T,k)=>{r.Ab("Einsum",T,{equation:Dn(k)})},906046:(T,k,V,H,Q)=>{r.Ab("Pad",T,{mode:k,value:V,pads:H?Array.from(de().subarray(Number(H)>>>0,Number(Q)>>>0)):[]})},906189:(T,k,V,H,Q,le)=>{r.Ab("BatchNormalization",T,{epsilon:k,momentum:V,spatial:!!Q,trainingMode:!!H,format:le?"NHWC":"NCHW"})},906358:(T,k,V,H,Q,le)=>{r.Ab("BatchNormalization",T,{epsilon:k,momentum:V,spatial:!!Q,trainingMode:!!H,format:le?"NHWC":"NCHW"})},906527:(T,k,V)=>{r.Ab("CumSum",T,{exclusive:Number(k),reverse:Number(V)})},906624:(T,k,V)=>{r.Ab("DequantizeLinear",T,{axis:k,blockSize:V})},906714:(T,k,V,H,Q)=>{r.Ab("GridSample",T,{align_corners:k,mode:Dn(V),padding_mode:Dn(H),format:Q?"NHWC":"NCHW"})},906884:(T,k,V,H,Q)=>{r.Ab("GridSample",T,{align_corners:k,mode:Dn(V),padding_mode:Dn(H),format:Q?"NHWC":"NCHW"})},907054:(T,k)=>{r.Ab("ScatterND",T,{reduction:Dn(k)})},907139:(T,k,V,H,Q,le,Ee,Be,rt)=>{r.Ab("Attention",T,{numHeads:k,isUnidirectional:V,maskFilterValue:H,scale:Q,doRotary:le,qkvHiddenSizes:Ee?Array.from(de().subarray(Number(Be)>>>0,Number(Be)+Ee>>>0)):[],pastPresentShareBuffer:!!rt})},907411:T=>{r.Ab("BiasAdd",T,void 0)},907466:T=>{r.Ab("BiasSplitGelu",T,void 0)},907527:T=>{r.Ab("FastGelu",T,void 0)},907583:(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo)=>{r.Ab("Conv",T,{format:qt?"NHWC":"NCHW",auto_pad:k,dilations:V?Array.from(de().subarray(Number(V)>>>0,Number(H)>>>0)):[],group:Q,kernel_shape:le?Array.from(de().subarray(Number(le)>>>0,Number(Ee)>>>0)):[],pads:Be?Array.from(de().subarray(Number(Be)>>>0,Number(rt)>>>0)):[],strides:ft?Array.from(de().subarray(Number(ft)>>>0,Number(Nt)>>>0)):[],w_is_const:()=>!!Y()[Number(yn)>>>0],activation:Dn(Yn),activation_params:Lr?Array.from(Re().subarray(Number(Lr)>>>0,Number(eo)>>>0)):[]})},908167:T=>{r.Ab("Gelu",T,void 0)},908219:(T,k,V,H,Q,le,Ee,Be,rt)=>{r.Ab("GroupQueryAttention",T,{numHeads:k,kvNumHeads:V,scale:H,softcap:Q,doRotary:le,rotaryInterleaved:Ee,smoothSoftmax:Be,localWindowSize:rt})},908436:(T,k,V,H)=>{r.Ab("LayerNormalization",T,{axis:k,epsilon:V,simplified:!!H})},908547:(T,k,V,H)=>{r.Ab("LayerNormalization",T,{axis:k,epsilon:V,simplified:!!H})},908658:(T,k,V,H,Q,le)=>{r.Ab("MatMulNBits",T,{k,n:V,accuracyLevel:H,bits:Q,blockSize:le})},908785:(T,k,V,H,Q,le)=>{r.Ab("MultiHeadAttention",T,{numHeads:k,isUnidirectional:V,maskFilterValue:H,scale:Q,doRotary:le})},908944:(T,k)=>{r.Ab("QuickGelu",T,{alpha:k})},909008:(T,k,V,H,Q)=>{r.Ab("RotaryEmbedding",T,{interleaved:!!k,numHeads:V,rotaryEmbeddingDim:H,scale:Q})},909147:(T,k,V)=>{r.Ab("SkipLayerNormalization",T,{epsilon:k,simplified:!!V})},909249:(T,k,V)=>{r.Ab("SkipLayerNormalization",T,{epsilon:k,simplified:!!V})},909351:(T,k,V,H)=>{r.Ab("GatherBlockQuantized",T,{gatherAxis:k,quantizeAxis:V,blockSize:H})},909472:T=>{r.$b(T)},909506:(T,k)=>r.bc(Number(T),Number(k),r.Gb.ec,r.Gb.errors)};function O4(T,k,V){return kt(async()=>{await r.Yb(Number(T),Number(k),Number(V))})}function P4(){return typeof wasmOffsetConverter<"u"}var Xe=await(async function(){function T(H,Q){return Xe=H.exports,Xe=(function(){var le=Xe,Ee={};for(let[Be,rt]of Object.entries(le))Ee[Be]=typeof rt=="function"?(...ft)=>{ot.push(Be);try{return rt(...ft)}finally{ue||(ot.pop(),Ae&&qe===1&&ot.length===0&&(qe=0,mn+=1,Ne(kc),typeof Fibers<"u"&&Fibers.sc()))}}:rt;return Ee})(),Xe=(function(){var le=Xe,Ee=rt=>ft=>rt(ft)>>>0,Be=rt=>()=>rt()>>>0;return(le=Object.assign({},le)).Ea=Ee(le.Ea),le.gb=Be(le.gb),le.ib=Ee(le.ib),le.tb=Ee(le.tb),le.ub=Be(le.ub),le.__cxa_get_exception_ptr=Ee(le.__cxa_get_exception_ptr),le})(),xr.push(Xe.jb),x=Q,Et(),Xe}Ct++;var k=Ht();if(r.instantiateWasm)return new Promise(H=>{r.instantiateWasm(k,(Q,le)=>{H(T(Q,le))})});if(a)return new Promise(H=>{se=Q=>{var le=new WebAssembly.Instance(Q,Ht());H(T(le,Q))}});ct??=r.locateFile?r.locateFile?r.locateFile("ort-wasm-simd-threaded.jsep.wasm",y):y+"ort-wasm-simd-threaded.jsep.wasm":new URL("/assets/ort-wasm-simd-threaded.jsep-BGTZ4Y7F.wasm",import.meta.url).href;try{var V=await(async function(H){var Q=ct;if(!v&&typeof WebAssembly.instantiateStreaming=="function"&&!_e(Q))try{var le=fetch(Q,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(le,H)}catch(Ee){oe(`wasm streaming compile failed: ${Ee}`),oe("falling back to ArrayBuffer instantiation")}return(async function(Ee,Be){try{var rt=await(async function(ft){if(!v)try{var Nt=await d(ft);return new Uint8Array(Nt)}catch{}if(ft==ct&&v)ft=new Uint8Array(v);else{if(!f)throw"both async and sync fetching of the wasm failed";ft=f(ft)}return ft})(Ee);return await WebAssembly.instantiate(rt,Be)}catch(ft){oe(`failed to asynchronously prepare wasm: ${ft}`),vt(ft)}})(Q,H)})(k);return T(V.instance,V.module)}catch(H){return n(H),Promise.reject(H)}})(),K1=T=>(K1=Xe.Ea)(T),Ec=()=>(Ec=Xe.Fa)();r._OrtInit=(T,k)=>(r._OrtInit=Xe.Ga)(T,k),r._OrtGetLastError=(T,k)=>(r._OrtGetLastError=Xe.Ha)(T,k),r._OrtCreateSessionOptions=(T,k,V,H,Q,le,Ee,Be,rt,ft)=>(r._OrtCreateSessionOptions=Xe.Ia)(T,k,V,H,Q,le,Ee,Be,rt,ft),r._OrtAppendExecutionProvider=(T,k,V,H,Q)=>(r._OrtAppendExecutionProvider=Xe.Ja)(T,k,V,H,Q),r._OrtAddFreeDimensionOverride=(T,k,V)=>(r._OrtAddFreeDimensionOverride=Xe.Ka)(T,k,V),r._OrtAddSessionConfigEntry=(T,k,V)=>(r._OrtAddSessionConfigEntry=Xe.La)(T,k,V),r._OrtReleaseSessionOptions=T=>(r._OrtReleaseSessionOptions=Xe.Ma)(T),r._OrtCreateSession=(T,k,V)=>(r._OrtCreateSession=Xe.Na)(T,k,V),r._OrtReleaseSession=T=>(r._OrtReleaseSession=Xe.Oa)(T),r._OrtGetInputOutputCount=(T,k,V)=>(r._OrtGetInputOutputCount=Xe.Pa)(T,k,V),r._OrtGetInputOutputMetadata=(T,k,V,H)=>(r._OrtGetInputOutputMetadata=Xe.Qa)(T,k,V,H),r._OrtFree=T=>(r._OrtFree=Xe.Ra)(T),r._OrtCreateTensor=(T,k,V,H,Q,le)=>(r._OrtCreateTensor=Xe.Sa)(T,k,V,H,Q,le),r._OrtGetTensorData=(T,k,V,H,Q)=>(r._OrtGetTensorData=Xe.Ta)(T,k,V,H,Q),r._OrtReleaseTensor=T=>(r._OrtReleaseTensor=Xe.Ua)(T),r._OrtCreateRunOptions=(T,k,V,H)=>(r._OrtCreateRunOptions=Xe.Va)(T,k,V,H),r._OrtAddRunConfigEntry=(T,k,V)=>(r._OrtAddRunConfigEntry=Xe.Wa)(T,k,V),r._OrtReleaseRunOptions=T=>(r._OrtReleaseRunOptions=Xe.Xa)(T),r._OrtCreateBinding=T=>(r._OrtCreateBinding=Xe.Ya)(T),r._OrtBindInput=(T,k,V)=>(r._OrtBindInput=Xe.Za)(T,k,V),r._OrtBindOutput=(T,k,V,H)=>(r._OrtBindOutput=Xe._a)(T,k,V,H),r._OrtClearBoundOutputs=T=>(r._OrtClearBoundOutputs=Xe.$a)(T),r._OrtReleaseBinding=T=>(r._OrtReleaseBinding=Xe.ab)(T),r._OrtRunWithBinding=(T,k,V,H,Q)=>(r._OrtRunWithBinding=Xe.bb)(T,k,V,H,Q),r._OrtRun=(T,k,V,H,Q,le,Ee,Be)=>(r._OrtRun=Xe.cb)(T,k,V,H,Q,le,Ee,Be),r._OrtEndProfiling=T=>(r._OrtEndProfiling=Xe.db)(T),r._JsepOutput=(T,k,V)=>(r._JsepOutput=Xe.eb)(T,k,V),r._JsepGetNodeName=T=>(r._JsepGetNodeName=Xe.fb)(T);var Ru=()=>(Ru=Xe.gb)(),fl=r._free=T=>(fl=r._free=Xe.hb)(T),Du=r._malloc=T=>(Du=r._malloc=Xe.ib)(T),X1=(T,k,V,H,Q,le)=>(X1=Xe.kb)(T,k,V,H,Q,le),Y1=()=>(Y1=Xe.lb)(),Vp=(T,k,V,H,Q)=>(Vp=Xe.mb)(T,k,V,H,Q),Bp=T=>(Bp=Xe.nb)(T),Up=T=>(Up=Xe.ob)(T),Q1=(T,k)=>(Q1=Xe.pb)(T,k),J1=()=>(J1=Xe.qb)(),l3=(T,k)=>(l3=Xe.rb)(T,k),Wp=T=>(Wp=Xe.sb)(T),Z1=T=>(Z1=Xe.tb)(T),e2=()=>(e2=Xe.ub)(),u3=r.dynCall_ii=(T,k)=>(u3=r.dynCall_ii=Xe.vb)(T,k);r.dynCall_vii=(T,k,V)=>(r.dynCall_vii=Xe.dynCall_vii)(T,k,V),r.dynCall_iiiii=(T,k,V,H,Q)=>(r.dynCall_iiiii=Xe.dynCall_iiiii)(T,k,V,H,Q),r.dynCall_iii=(T,k,V)=>(r.dynCall_iii=Xe.dynCall_iii)(T,k,V),r.dynCall_iiiiii=(T,k,V,H,Q,le)=>(r.dynCall_iiiiii=Xe.dynCall_iiiiii)(T,k,V,H,Q,le),r.dynCall_iiiiiiii=(T,k,V,H,Q,le,Ee,Be)=>(r.dynCall_iiiiiiii=Xe.dynCall_iiiiiiii)(T,k,V,H,Q,le,Ee,Be),r.dynCall_iiiiiii=(T,k,V,H,Q,le,Ee)=>(r.dynCall_iiiiiii=Xe.dynCall_iiiiiii)(T,k,V,H,Q,le,Ee),r.dynCall_vi=(T,k)=>(r.dynCall_vi=Xe.dynCall_vi)(T,k),r.dynCall_iiii=(T,k,V,H)=>(r.dynCall_iiii=Xe.dynCall_iiii)(T,k,V,H),r.dynCall_i=T=>(r.dynCall_i=Xe.dynCall_i)(T),r.dynCall_viiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt)=>(r.dynCall_viiiiiiii=Xe.dynCall_viiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt),r.dynCall_viii=(T,k,V,H)=>(r.dynCall_viii=Xe.dynCall_viii)(T,k,V,H),r.dynCall_viijj=(T,k,V,H,Q)=>(r.dynCall_viijj=Xe.dynCall_viijj)(T,k,V,H,Q),r.dynCall_viiiiii=(T,k,V,H,Q,le,Ee)=>(r.dynCall_viiiiii=Xe.dynCall_viiiiii)(T,k,V,H,Q,le,Ee),r.dynCall_viiii=(T,k,V,H,Q)=>(r.dynCall_viiii=Xe.dynCall_viiii)(T,k,V,H,Q),r.dynCall_viiiii=(T,k,V,H,Q,le)=>(r.dynCall_viiiii=Xe.dynCall_viiiii)(T,k,V,H,Q,le),r.dynCall_vfiii=(T,k,V,H,Q)=>(r.dynCall_vfiii=Xe.dynCall_vfiii)(T,k,V,H,Q),r.dynCall_viiiiff=(T,k,V,H,Q,le,Ee)=>(r.dynCall_viiiiff=Xe.dynCall_viiiiff)(T,k,V,H,Q,le,Ee),r.dynCall_viiiiiff=(T,k,V,H,Q,le,Ee,Be)=>(r.dynCall_viiiiiff=Xe.dynCall_viiiiiff)(T,k,V,H,Q,le,Ee,Be),r.dynCall_ffff=(T,k,V,H)=>(r.dynCall_ffff=Xe.dynCall_ffff)(T,k,V,H),r.dynCall_viiff=(T,k,V,H,Q)=>(r.dynCall_viiff=Xe.dynCall_viiff)(T,k,V,H,Q),r.dynCall_fffffff=(T,k,V,H,Q,le,Ee)=>(r.dynCall_fffffff=Xe.dynCall_fffffff)(T,k,V,H,Q,le,Ee),r.dynCall_jjjjjjj=(T,k,V,H,Q,le,Ee)=>(r.dynCall_jjjjjjj=Xe.dynCall_jjjjjjj)(T,k,V,H,Q,le,Ee),r.dynCall_jjjjjj=(T,k,V,H,Q,le)=>(r.dynCall_jjjjjj=Xe.dynCall_jjjjjj)(T,k,V,H,Q,le),r.dynCall_iijjii=(T,k,V,H,Q,le)=>(r.dynCall_iijjii=Xe.dynCall_iijjii)(T,k,V,H,Q,le),r.dynCall_viiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn)=>(r.dynCall_viiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn),r.dynCall_viiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt)=>(r.dynCall_viiiiiiiiii=Xe.dynCall_viiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt),r.dynCall_viiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt)=>(r.dynCall_viiiiiiiiiii=Xe.dynCall_viiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt),r.dynCall_viiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn)=>(r.dynCall_viiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn),r.dynCall_viiiiiiiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl,Nc)=>(r.dynCall_viiiiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl,Nc),r.dynCall_viiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft)=>(r.dynCall_viiiiiiiii=Xe.dynCall_viiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft),r.dynCall_viiiiiiiiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl,Nc,jp)=>(r.dynCall_viiiiiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl,Nc,jp),r.dynCall_viiiiiii=(T,k,V,H,Q,le,Ee,Be)=>(r.dynCall_viiiiiii=Xe.dynCall_viiiiiii)(T,k,V,H,Q,le,Ee,Be),r.dynCall_viiiiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo)=>(r.dynCall_viiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo),r.dynCall_jiji=(T,k,V,H)=>(r.dynCall_jiji=Xe.dynCall_jiji)(T,k,V,H),r.dynCall_v=T=>(r.dynCall_v=Xe.dynCall_v)(T),r.dynCall_iidiiii=(T,k,V,H,Q,le,Ee)=>(r.dynCall_iidiiii=Xe.dynCall_iidiiii)(T,k,V,H,Q,le,Ee),r.dynCall_iiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt)=>(r.dynCall_iiiiiiiii=Xe.dynCall_iiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt),r.dynCall_iiij=(T,k,V,H)=>(r.dynCall_iiij=Xe.dynCall_iiij)(T,k,V,H),r.dynCall_iiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft)=>(r.dynCall_iiiiiiiiii=Xe.dynCall_iiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft),r.dynCall_iiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn)=>(r.dynCall_iiiiiiiiiiiii=Xe.dynCall_iiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn),r.dynCall_iiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt)=>(r.dynCall_iiiiiiiiiii=Xe.dynCall_iiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt),r.dynCall_ji=(T,k)=>(r.dynCall_ji=Xe.dynCall_ji)(T,k),r.dynCall_iijii=(T,k,V,H,Q)=>(r.dynCall_iijii=Xe.dynCall_iijii)(T,k,V,H,Q),r.dynCall_vij=(T,k,V)=>(r.dynCall_vij=Xe.dynCall_vij)(T,k,V),r.dynCall_viiijii=(T,k,V,H,Q,le,Ee)=>(r.dynCall_viiijii=Xe.dynCall_viiijii)(T,k,V,H,Q,le,Ee),r.dynCall_viijiiiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl)=>(r.dynCall_viijiiiiiiiiiiiiii=Xe.dynCall_viijiiiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl),r.dynCall_viiiji=(T,k,V,H,Q,le)=>(r.dynCall_viiiji=Xe.dynCall_viiiji)(T,k,V,H,Q,le),r.dynCall_fiii=(T,k,V,H)=>(r.dynCall_fiii=Xe.dynCall_fiii)(T,k,V,H),r.dynCall_viijii=(T,k,V,H,Q,le)=>(r.dynCall_viijii=Xe.dynCall_viijii)(T,k,V,H,Q,le),r.dynCall_viij=(T,k,V,H)=>(r.dynCall_viij=Xe.dynCall_viij)(T,k,V,H),r.dynCall_jiij=(T,k,V,H)=>(r.dynCall_jiij=Xe.dynCall_jiij)(T,k,V,H),r.dynCall_fi=(T,k)=>(r.dynCall_fi=Xe.dynCall_fi)(T,k),r.dynCall_fii=(T,k,V)=>(r.dynCall_fii=Xe.dynCall_fii)(T,k,V),r.dynCall_jii=(T,k,V)=>(r.dynCall_jii=Xe.dynCall_jii)(T,k,V),r.dynCall_dii=(T,k,V)=>(r.dynCall_dii=Xe.dynCall_dii)(T,k,V),r.dynCall_fiiii=(T,k,V,H,Q)=>(r.dynCall_fiiii=Xe.dynCall_fiiii)(T,k,V,H,Q),r.dynCall_fif=(T,k,V)=>(r.dynCall_fif=Xe.dynCall_fif)(T,k,V),r.dynCall_jfi=(T,k,V)=>(r.dynCall_jfi=Xe.dynCall_jfi)(T,k,V),r.dynCall_viiiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr)=>(r.dynCall_viiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr),r.dynCall_viiiiiiiiiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl,Nc,jp,c3)=>(r.dynCall_viiiiiiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va,Yl,Nc,jp,c3),r.dynCall_viiiiiiiiiiiiiiii=(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va)=>(r.dynCall_viiiiiiiiiiiiiiii=Xe.dynCall_viiiiiiiiiiiiiiii)(T,k,V,H,Q,le,Ee,Be,rt,ft,Nt,qt,yn,Yn,Lr,eo,Va),r.dynCall_iif=(T,k,V)=>(r.dynCall_iif=Xe.dynCall_iif)(T,k,V),r.dynCall_jiiii=(T,k,V,H,Q)=>(r.dynCall_jiiii=Xe.dynCall_jiiii)(T,k,V,H,Q),r.dynCall_jiii=(T,k,V,H)=>(r.dynCall_jiii=Xe.dynCall_jiii)(T,k,V,H),r.dynCall_viif=(T,k,V,H)=>(r.dynCall_viif=Xe.dynCall_viif)(T,k,V,H),r.dynCall_viiij=(T,k,V,H,Q)=>(r.dynCall_viiij=Xe.dynCall_viiij)(T,k,V,H,Q),r.dynCall_viiiijii=(T,k,V,H,Q,le,Ee,Be)=>(r.dynCall_viiiijii=Xe.dynCall_viiiijii)(T,k,V,H,Q,le,Ee,Be),r.dynCall_iiiiij=(T,k,V,H,Q,le)=>(r.dynCall_iiiiij=Xe.dynCall_iiiiij)(T,k,V,H,Q,le),r.dynCall_iiiiid=(T,k,V,H,Q,le)=>(r.dynCall_iiiiid=Xe.dynCall_iiiiid)(T,k,V,H,Q,le),r.dynCall_iiiiijj=(T,k,V,H,Q,le,Ee)=>(r.dynCall_iiiiijj=Xe.dynCall_iiiiijj)(T,k,V,H,Q,le,Ee),r.dynCall_iiiiiijj=(T,k,V,H,Q,le,Ee,Be)=>(r.dynCall_iiiiiijj=Xe.dynCall_iiiiiijj)(T,k,V,H,Q,le,Ee,Be);var Wo=T=>(Wo=Xe.wb)(T),kc=()=>(kc=Xe.xb)(),t2=T=>(t2=Xe.yb)(T),n2=()=>(n2=Xe.zb)();return(function T(){if(0<Ct)Wt=T;else if(a)e(r),nt();else{for(;0<Rt.length;)Rt.shift()(r);0<Ct?Wt=T:(r.calledRun=!0,ue||(nt(),e(r)))}})(),r.PTR_SIZE=4,s},PH=HT,h8=globalThis.self?.name?.startsWith("em-pthread"),h8&&HT()}),qT,sC,d8,va,FH,Tv,f8,p8,KT,m8,XT,LH,YT,MH,dR=ht(()=>{hR(),qT=typeof location>"u"?void 0:location.origin,sC=import.meta.url>"file:"&&import.meta.url<"file;",d8=()=>{{if(sC){let t=URL;return new URL(new t("ort.bundle.min.mjs",import.meta.url).href,qT).href}return import.meta.url}},va=d8(),FH=()=>{if(va&&!va.startsWith("blob:"))return va.substring(0,va.lastIndexOf("/")+1)},Tv=(t,e)=>{try{let n=e??va;return(n?new URL(t,n):new URL(t)).origin===qT}catch{return!1}},f8=(t,e)=>{let n=e??va;try{return(n?new URL(t,n):new URL(t)).href}catch{return}},p8=(t,e)=>`${e??"./"}${t}`,KT=async t=>{let e=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(e)},m8=async t=>(await import(t)).default,XT=(IDe(),Uy(RH)).default,LH=async()=>{if(!va)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Tv(va))return[void 0,XT()];let t=await KT(va);return[t,XT(t)]},YT=(TDe(),Uy(OH)).default,MH=async(t,e,n,r)=>{let s=YT&&!(t||e);if(s)if(va)s=Tv(va);else if(r&&!n)s=!0;else throw new Error("cannot determine the script source URL.");if(s)return[void 0,YT];{let i="ort-wasm-simd-threaded.jsep.mjs",o=t??f8(i,e),a=n&&o&&!Tv(o,e),l=a?await KT(o):o??p8(i,e);return[a?l:void 0,await m8(l)]}}}),QT,Sv,k2,JT,g8,y8,w8,fR,Tr,Op=ht(()=>{dR(),Sv=!1,k2=!1,JT=!1,g8=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},y8=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},w8=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},fR=async t=>{if(Sv)return Promise.resolve();if(k2)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(JT)throw new Error("previous call to 'initializeWebAssembly()' failed.");k2=!0;let e=t.initTimeout,n=t.numThreads;if(t.simd!==!1){if(t.simd==="relaxed"){if(!w8())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!y8())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let r=g8();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let s=t.wasmPaths,i=typeof s=="string"?s:void 0,o=s?.mjs,a=o?.href??o,l=s?.wasm,u=l?.href??l,c=t.wasmBinary,[d,f]=await MH(a,i,n>1,!!c||!!u),m=!1,g=[];if(e>0&&g.push(new Promise(y=>{setTimeout(()=>{m=!0,y()},e)})),g.push(new Promise((y,v)=>{let b={numThreads:n};if(c)b.wasmBinary=c;else if(u||i)b.locateFile=x=>u??i+x;else if(a&&a.indexOf("blob:")!==0)b.locateFile=x=>new URL(x,a).href;else if(d){let x=FH();x&&(b.locateFile=$=>x+$)}f(b).then(x=>{k2=!1,Sv=!0,QT=x,y(),d&&URL.revokeObjectURL(d)},x=>{k2=!1,JT=!0,v(x)})})),await Promise.race(g),m)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},Tr=()=>{if(Sv&&QT)return QT;throw new Error("WebAssembly is not initialized yet.")}}),El,ix,mr,pR=ht(()=>{Op(),El=(t,e)=>{let n=Tr(),r=n.lengthBytesUTF8(t)+1,s=n._malloc(r);return n.stringToUTF8(t,s,r),e.push(s),s},ix=(t,e,n,r)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([s,i])=>{let o=e?e+s:s;if(typeof i=="object")ix(i,o+".",n,r);else if(typeof i=="string"||typeof i=="number")r(o,i.toString());else if(typeof i=="boolean")r(o,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},mr=t=>{let e=Tr(),n=e.stackSave();try{let r=e.PTR_SIZE,s=e.stackAlloc(2*r);e._OrtGetLastError(s,s+r);let i=Number(e.getValue(s,r===4?"i32":"i64")),o=e.getValue(s+r,"*"),a=o?e.UTF8ToString(o):"";throw new Error(`${t} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{e.stackRestore(n)}}}),zH,SDe=ht(()=>{Op(),pR(),zH=t=>{let e=Tr(),n=0,r=[],s=t||{};try{if(t?.logSeverityLevel===void 0)s.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)s.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(s.terminate=!1);let i=0;return t?.tag!==void 0&&(i=El(t.tag,r)),n=e._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,i),n===0&&mr("Can't create run options."),t?.extra!==void 0&&ix(t.extra,"",new WeakSet,(o,a)=>{let l=El(o,r),u=El(a,r);e._OrtAddRunConfigEntry(n,l,u)!==0&&mr(`Can't set a run config entry: ${o} - ${a}.`)}),[n,r]}catch(i){throw n!==0&&e._OrtReleaseRunOptions(n),r.forEach(o=>e._free(o)),i}}}),v8,b8,x8,N2,_8,VH,$De=ht(()=>{Op(),pR(),v8=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},b8=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},x8=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},N2=(t,e,n,r)=>{let s=El(e,r),i=El(n,r);Tr()._OrtAddSessionConfigEntry(t,s,i)!==0&&mr(`Can't set a session config entry: ${e} - ${n}.`)},_8=async(t,e,n)=>{for(let r of e){let s=typeof r=="string"?r:r.name,i=[];switch(s){case"webnn":if(s="WEBNN",typeof r!="string"){let c=r?.deviceType;c&&N2(t,"deviceType",c,n)}break;case"webgpu":if(s="JS",typeof r!="string"){let c=r;if(c?.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);N2(t,"preferredLayout",c.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${s}`)}let o=El(s,n),a=i.length,l=0,u=0;if(a>0){l=Tr()._malloc(a*Tr().PTR_SIZE),n.push(l),u=Tr()._malloc(a*Tr().PTR_SIZE),n.push(u);for(let c=0;c<a;c++)Tr().setValue(l+c*Tr().PTR_SIZE,i[c][0],"*"),Tr().setValue(u+c*Tr().PTR_SIZE,i[c][1],"*")}await Tr()._OrtAppendExecutionProvider(t,o,l,u,a)!==0&&mr(`Can't append execution provider: ${s}.`)}},VH=async t=>{let e=Tr(),n=0,r=[],s=t||{};x8(s);try{let i=v8(s.graphOptimizationLevel??"all"),o=b8(s.executionMode??"sequential"),a=typeof s.logId=="string"?El(s.logId,r):0,l=s.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log severity level is not valid: ${l}`);let u=s.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let c=typeof s.optimizedModelFilePath=="string"?El(s.optimizedModelFilePath,r):0;if(n=e._OrtCreateSessionOptions(i,!!s.enableCpuMemArena,!!s.enableMemPattern,o,!!s.enableProfiling,0,a,l,u,c),n===0&&mr("Can't create session options."),s.executionProviders&&await _8(n,s.executionProviders,r),s.enableGraphCapture!==void 0){if(typeof s.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);N2(n,"enableGraphCapture",s.enableGraphCapture.toString(),r)}if(s.freeDimensionOverrides)for(let[d,f]of Object.entries(s.freeDimensionOverrides)){if(typeof d!="string")throw new Error(`free dimension override name must be a string: ${d}`);if(typeof f!="number"||!Number.isInteger(f)||f<0)throw new Error(`free dimension override value must be a non-negative integer: ${f}`);let m=El(d,r);e._OrtAddFreeDimensionOverride(n,m,f)!==0&&mr(`Can't set a free dimension override: ${d} - ${f}.`)}return s.extra!==void 0&&ix(s.extra,"",new WeakSet,(d,f)=>{N2(n,d,f,r)}),[n,r]}catch(i){throw n!==0&&e._OrtReleaseSessionOptions(n)!==0&&mr("Can't release session options."),r.forEach(o=>e._free(o)),i}}}),Cd,Ku,Ed,D4,ox,mR,gR,iC,rn=ht(()=>{Cd=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},Ku=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},Ed=(t,e)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],r=typeof e=="number"?e:e.reduce((s,i)=>s*i,1);return n>0?Math.ceil(r*n):void 0},D4=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},ox=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},mR=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",gR=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",iC=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}}),yR,BH=ht(()=>{hR(),yR=async t=>{if(typeof t=="string"){let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let n=e.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let s=e.body.getReader(),i;try{i=new ArrayBuffer(r)}catch(a){if(a instanceof RangeError){let l=Math.ceil(r/65536);i=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw a}let o=0;for(;;){let{done:a,value:l}=await s.read();if(a)break;let u=l.byteLength;new Uint8Array(i,o,u).set(l),o+=u}return new Uint8Array(i,0,r)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}}),I8,T8,S8,$8,wR,C8,qn,Tc=ht(()=>{rn(),I8=["V","I","W","E","F"],T8=(t,e)=>{console.log(`[${I8[t]},${new Date().toISOString()}]${e}`)},wR=(t,e)=>{S8=t,$8=e},C8=(t,e)=>{let n=ox(t),r=ox(S8);n>=r&&T8(n,typeof e=="function"?e():e)},qn=(...t)=>{$8&&C8(...t)}}),E8,Qm,He,ax,UH,WH,jH,vn=ht(()=>{E8=class{static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}},Qm=class{static calcShape(t,e,n=!1){let r=t.length,s=e.length;if(r===0)return e;if(s===0)return t;let i=Math.max(t.length,e.length),o=new Array(i);if(n){if(r<2||s<2)return;let a=E8.calcMatMulShape([t[r-2],t[r-1]],[e[s-2],e[s-1]]);if(a===void 0)return;[o[i-2],o[i-1]]=a}for(let a=n?3:1;a<=i;a++){let l=r-a<0?1:t[r-a],u=s-a<0?1:e[s-a];if(l!==u&&l>1&&u>1)return;let c=Math.max(l,u);if(l&&u)o[i-a]=Math.max(l,u);else{if(c>1)return;o[i-a]=0}}return o}static isValidBroadcast(t,e){let n=t.length,r=e.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(t[n-s]!==1&&t[n-s]!==e[r-s])return!1;return!0}},He=class lb{static size(e){return lb.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,n=4){let r=e.length;if(r===0)return[];let s=new Array(r),i=r-1;for(;i>=0;){if(e[i]%n===0){s[i]=e[i]/n;break}if(n%e[i]!==0)throw new Error("cannot convert shape");s[i]=1,n/=e[i],i--}for(i--;i>=0;i--)s[i]=e[i];return s}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return lb.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return lb.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,r){let s=1;for(let i=n;i<r;i++){if(e[i]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");s*=Number(e[i])}return s}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let r=new Array(n);r[n-1]=1,r[n-2]=e[n-1];for(let s=n-3;s>=0;--s)r[s]=r[s+1]*e[s+1];return r}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(r=>this.normalizeAxis(r,n??e.length))}static sortBasedOnPerm(e,n){return n?n.map(r=>e[r]):e.slice().reverse()}static padShape(e,n){let r=e.length;return e.map((s,i)=>s+n[i]+n[i+r])}static areEqual(e,n){return e.length!==n.length?!1:e.every((r,s)=>r===n[s])}},ax=class ry{static adjustPoolAttributes(e,n,r,s,i,o){if(!e&&r.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<n.length-2;a++)a>=r.length?r.push(n[a+2]):r[a]=n[a+2];for(let a=0;a<r.length;a++)if(a<s.length){if(s[a]<0)throw new Error("strides should be greater than or equal to 1")}else s.push(1);for(let a=0;a<r.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<r.length*2;a++)if(a<o.length){if(o[a]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let a=0;a<r.length;a++){if(r[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[a]>=r[a]||o[a+r.length]>=r[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,r,s,i,o,a){if(a){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<e.length-2;l++)ry.adjustPadAndReturnShape(e[l+(o?1:2)],n[l],r[l],s[l],i,l,l+e.length-2,a)}}static computePoolOutputShape(e,n,r,s,i,o,a){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return ry.computeShapeHelper(e,n,l,r,s,i,o,a),l}static computeConvOutputShape(e,n,r,s,i,o,a){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[e[0],n[0]];return ry.computeShapeHelper(!1,e,l,r,s,i,o,a),l}static computeShapeHelper(e,n,r,s,i,o,a,l){if(e)for(let u=0;u<n.length-2;u++)r.push(1);else for(let u=0;u<n.length-2;u++)r.push(ry.adjustPadAndReturnShape(n[u+2],s[u],i[u],o[u],a,u,u+n.length-2,l))}static adjustPadAndReturnShape(e,n,r,s,i,o,a,l){let u=r*(s-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return i[o]=0,i[a]=0,Math.floor((e-u)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(r!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let c=((e+n-1)/n-1)*n+s-e;return i[o]=Math.floor(l==="SAME_LOWER"?(c+1)/2:c/2),i[a]=c-i[o],Math.floor((e+c-s)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[o]+i[a]-u)/n+1)}},UH=class{static getShapeOfGemmResult(t,e,n,r,s){if(t.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let i,o,a;e?(i=t[1],o=t[0]):(i=t[0],o=t[1]);let l=-1;if(r?(a=n[0],l=1):(a=n[1],l=0),n[l]!==o)throw new Error("dimension mismatch");if(i<=0||a<=0||o<=0)throw new Error("invalid shape specified");if(s&&!Qm.isValidBroadcast(s,[i,a]))throw new Error("gemm: invalid bias shape for broadcast");return[i,a,o]}},WH=-34028234663852886e22,jH=34028234663852886e22}),vR,GH=ht(()=>{rn(),vR=(t,e)=>new(D4(e))(t)}),ZT,oC,eS,k8,tS,N8,nS,rS,sS,A8,HH,CDe=ht(()=>{rn(),Tc(),ZT=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),oC=(t,e)=>{if(e==="int32")return t;let n=ZT.get(e);if(!n)throw new Error(`WebNN backend does not support data type: ${e}`);let r=n/8;if(t.byteLength%r!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${r}.`);let s=t.byteLength/r,i=new(D4(e))(t.buffer,t.byteOffset,s);switch(e){case"int64":case"uint64":{let o=new Int32Array(s);for(let a=0;a<s;a++){let l=i[a];if(l>2147483647n||l<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");o[a]=Number(l)}return new Uint8Array(o.buffer)}case"int8":case"uint8":case"uint32":{if(e==="uint32"&&i.some(a=>a>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let o=Int32Array.from(i,Number);return new Uint8Array(o.buffer)}default:throw new Error(`Unsupported data conversion from ${e} to 'int32'`)}},eS=(t,e)=>{if(e==="int32")return t;if(t.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let n=t.byteLength/4,r=new Int32Array(t.buffer,t.byteOffset,n);switch(e){case"int64":{let s=BigInt64Array.from(r,BigInt);return new Uint8Array(s.buffer)}case"uint64":{if(r.some(i=>i<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let s=BigUint64Array.from(r,BigInt);return new Uint8Array(s.buffer)}case"int8":{if(r.some(i=>i<-128||i>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let s=Int8Array.from(r,Number);return new Uint8Array(s.buffer)}case"uint8":{if(r.some(s=>s<0||s>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(r,Number)}case"uint32":{if(r.some(i=>i<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let s=Uint32Array.from(r,Number);return new Uint8Array(s.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${e}`)}},k8=1,tS=()=>k8++,N8=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),nS=(t,e)=>{let n=ZT.get(t);if(!n)throw new Error(`WebNN backend does not support data type: ${t}`);return e.length>0?Math.ceil(e.reduce((r,s)=>r*s)*n/8):0},rS=class{constructor(t){this.isDataConverted=!1;let{sessionId:e,context:n,tensor:r,dataType:s,shape:i,fallbackDataType:o}=t;this.sessionId=e,this.mlContext=n,this.mlTensor=r,this.dataType=s,this.tensorShape=i,this.fallbackDataType=o}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return nS(this.dataType,this.tensorShape)}destroy(){qn("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){if(this.fallbackDataType){let e=await this.mlContext.readTensor(this.mlTensor),n=eS(new Uint8Array(e),this.dataType);if(t){(t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)).set(n);return}else return n.buffer}else return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,e,n){return this.mlContext===t&&this.dataType===e&&this.tensorShape.length===n.length&&this.tensorShape.every((r,s)=>r===n[s])}setIsDataConverted(t){this.isDataConverted=t}},sS=class{constructor(t,e){this.tensorManager=t,this.wrapper=e}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,e,n,r){let s=this.tensorManager.getMLContext(t),i;if(!s.opSupportLimits().input.dataTypes.includes(e)){if(i=N8.get(e),!i||!s.opSupportLimits().input.dataTypes.includes(i))throw new Error(`WebNN backend does not support data type: ${e}`);qn("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${e} to ${i}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(s,e,n))return this.wrapper.tensor;if(r){if(this.wrapper.byteLength!==nS(e,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let o=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,e,n,o,!0,!0,i),r&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){let e=t;if(this.wrapper){if(this.wrapper.fallbackType)if(this.wrapper.fallbackType==="int32")e=oC(t,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(e);return}else qn("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(t){if(this.activeUpload){let e=this.wrapper?.isDataConverted?eS(this.activeUpload,this.wrapper?.type):this.activeUpload;if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(e):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(e);return}else return e.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return t?this.wrapper.read(t):this.wrapper.read()}},A8=class{constructor(t){this.backend=t,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(t){let e=this.backend.getMLContext(t);if(!e)throw new Error("MLContext not found for session.");return e}reserveTensorId(){let t=tS();return this.tensorTrackersById.set(t,new sS(this)),t}releaseTensorId(t){let e=this.tensorTrackersById.get(t);e&&(this.tensorTrackersById.delete(t),e.tensorWrapper&&this.releaseTensor(e.tensorWrapper))}async ensureTensor(t,e,n,r,s){qn("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${n}, shape: ${r}, copyOld: ${s}}`);let i=this.tensorTrackersById.get(e);if(!i)throw new Error("Tensor not found.");return i.ensureTensor(t,n,r,s)}upload(t,e){let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");n.upload(e)}async download(t,e){qn("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${e?.byteLength}}`);let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");return n.download(e)}releaseTensorsForSession(t){for(let e of this.freeTensors)e.sessionId===t&&e.destroy();this.freeTensors=this.freeTensors.filter(e=>e.sessionId!==t)}registerTensor(t,e,n,r){let s=this.getMLContext(t),i=tS(),o=new rS({sessionId:t,context:s,tensor:e,dataType:n,shape:r});return this.tensorTrackersById.set(i,new sS(this,o)),this.externalTensors.add(o),i}async getCachedTensor(t,e,n,r,s,i,o){let a=this.getMLContext(t);for(let[u,c]of this.freeTensors.entries())if(c.canReuseTensor(a,e,n)){qn("verbose",()=>`[WebNN] Reusing tensor {dataType: ${e}, ${o?`fallbackDataType: ${o},`:""} shape: ${n}`);let d=this.freeTensors.splice(u,1)[0];return d.sessionId=t,d}qn("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, ${o?`fallbackDataType: ${o},`:""} shape: ${n}}`);let l=await a.createTensor({dataType:o??e,shape:n,dimensions:n,usage:r,writable:s,readable:i});return new rS({sessionId:t,context:a,tensor:l,dataType:e,shape:n,fallbackDataType:o})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},HH=(...t)=>new A8(...t)}),A2,R8,qH,EDe=ht(()=>{rn(),Op(),GH(),CDe(),Tc(),A2=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),R8=(t,e)=>{if(t===e)return!0;if(t===void 0||e===void 0)return!1;let n=Object.keys(t).sort(),r=Object.keys(e).sort();return n.length===r.length&&n.every((s,i)=>s===r[i]&&t[s]===e[s])},qH=class{constructor(t){this.tensorManager=HH(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,wR(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(t){qn("verbose",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){qn("verbose",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let e=this.temporarySessionTensorIds.get(t);if(e){for(let n of e)qn("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let n=this.mlContextCache.findIndex(r=>r.gpuDevice===t);if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:r}),r}}else if(t===void 0){let n=this.mlContextCache.findIndex(r=>r.options===void 0&&r.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:r}),r}}let e=this.mlContextCache.findIndex(n=>R8(n.options,t));if(e!==-1)return this.mlContextCache[e].mlContext;{let n=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:n}),n}}registerMLContext(t,e){this.mlContextBySessionId.set(t,e);let n=this.sessionIdsByMLContext.get(e);n||(n=new Set,this.sessionIdsByMLContext.set(e,n)),n.add(t),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(t,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t),this.sessionGraphOutputs.delete(t);let e=this.mlContextBySessionId.get(t);if(!e)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let n=this.sessionIdsByMLContext.get(e);if(n.delete(t),n.size===0){this.sessionIdsByMLContext.delete(e);let r=this.mlContextCache.findIndex(s=>s.mlContext===e);r!==-1&&this.mlContextCache.splice(r,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){qn("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,e,n,r,s){let i=A2.get(n);if(!i)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,e,i,r,s)}async createTemporaryTensor(t,e,n){qn("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${e}, shape: ${n}}`);let r=A2.get(e);if(!r)throw new Error(`Unsupported ONNX data type: ${e}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,s,r,n,!1);let i=this.temporarySessionTensorIds.get(t);return i?i.push(s):this.temporarySessionTensorIds.set(t,[s]),s}uploadTensor(t,e){if(!Tr().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");qn("verbose",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${e.byteLength}}`),this.tensorManager.upload(t,e)}async downloadTensor(t,e){return this.tensorManager.download(t,e)}createMLTensorDownloader(t,e){return async()=>{let n=await this.tensorManager.download(t);return vR(n,e)}}registerMLTensor(t,e,n,r){let s=A2.get(n);if(!s)throw new Error(`Unsupported ONNX data type: ${n}`);let i=this.tensorManager.registerTensor(t,e,s,r);return qn("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${s}, dimensions: ${r}} -> {tensorId: ${i}}`),i}registerMLConstant(t,e,n,r,s,i,o=!1){if(!i)throw new Error("External mounted files are not available.");let a=t;t.startsWith("./")&&(a=t.substring(2));let l=i.get(a);if(!l)throw new Error(`File with name ${a} not found in preloaded files.`);if(e+n>l.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let u=l.slice(e,e+n).buffer,c;switch(s.dataType){case"float32":c=new Float32Array(u);break;case"float16":c=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(u):new Uint16Array(u);break;case"int32":c=new Int32Array(u);break;case"uint32":c=new Uint32Array(u);break;case"int64":if(o){let d=oC(new Uint8Array(u),"int64");c=new Int32Array(d.buffer),s.dataType="int32"}else c=new BigInt64Array(u);break;case"uint64":c=new BigUint64Array(u);break;case"int8":c=new Int8Array(u);break;case"int4":case"uint4":case"uint8":c=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return qn("verbose",()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${o?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),r.constant(s,c)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}registerGraphOutput(t){this.temporaryGraphOutputs.push(t)}isGraphInput(t,e){let n=this.sessionGraphInputs.get(t);return n?n.includes(e):!1}isGraphOutput(t,e){let n=this.sessionGraphOutputs.get(t);return n?n.includes(e):!1}isGraphInputOutputTypeSupported(t,e,n=!0){let r=this.mlContextBySessionId.get(t),s=A2.get(Cd(e));return typeof s>"u"?!1:n?!!r?.opSupportLimits().input.dataTypes.includes(s):!!r?.opSupportLimits().output.dataTypes.includes(s)}flush(){}}}),bR=ht(()=>{}),iS,$v,Cv,D8,O8,oS,aC,P8,KH,kDe=ht(()=>{Tc(),bR(),iS=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),$v=[],Cv=t=>Math.ceil(Number(t)/16)*16,D8=t=>{for(let e=0;e<$v.length;e++){let n=$v[e];if(t<=n)return n}return Math.ceil(t/16)*16},O8=1,oS=()=>O8++,aC=async(t,e,n,r)=>{let s=Cv(n),i=t.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=t.getCommandEncoder();t.endComputePass(),o.copyBufferToBuffer(e,0,i,0,s),t.flush(),await i.mapAsync(GPUMapMode.READ);let a=i.getMappedRange();if(r){let l=r();return l.set(new Uint8Array(a,0,n)),l}else return new Uint8Array(a.slice(0,n))}finally{i.destroy()}},P8=class{constructor(t){this.backend=t,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of iS)$v.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(t,e){let n=e.buffer,r=e.byteOffset,s=e.byteLength,i=Cv(s),o=this.storageCache.get(t);if(!o)throw new Error("gpu data for uploading does not exist");if(Number(o.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=a.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,r,s)),a.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(a,0,o.gpuData.buffer,0,i),this.backend.device.queue.submit([u.finish()]),a.destroy(),qn("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,e){let n=this.storageCache.get(t);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(e);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Cv(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,s)}registerExternalBuffer(t,e,n){let r;if(n){if(r=n[0],t===n[1])return qn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${r}, buffer is the same, skip.`),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else r=oS();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:t},originalSize:e}),qn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${r}, registered.`),r}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),qn("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=D8(t),r,s=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||i){let a=(s?this.freeBuffers:this.freeUniformBuffers).get(n);a?a.length>0?r=a.pop():r=this.backend.device.createBuffer({size:n,usage:e}):r=this.backend.device.createBuffer({size:n,usage:e})}else r=this.backend.device.createBuffer({size:n,usage:e});let o={id:oS(),type:0,buffer:r};return this.storageCache.set(o.id,{gpuData:o,originalSize:Number(t)}),qn("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${o.id}`),o}get(t){return this.storageCache.get(t)?.gpuData}release(t){let e=typeof t=="bigint"?Number(t):t,n=this.storageCache.get(e);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return qn("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(t,e){let n=this.storageCache.get(Number(t));if(!n)throw new Error("data does not exist");await aC(this.backend,n.gpuData.buffer,n.originalSize,e)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending){let e=iS.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];e===void 0||n.length>=e?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];e===void 0||n.length>=e?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let e of this.buffersPending)t.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let e=this.capturedPendingBuffers.get(t);e&&(e.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(qn("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},KH=(...t)=>new P8(...t)}),F8,ur,us=ht(()=>{F8=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ur=t=>new F8(t)}),Jm,Ev,si,oo,Ut,Jr,lC,wm,Vh,Mt,R2,Je,Ft,XH,xR,L8,YH,In=ht(()=>{rn(),vn(),Jm=64,Ev=(t,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(t)){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${t}`)}},si=(t,e=1)=>{let n=Ev(t,e);return typeof n=="string"?n:n[0]},oo=(t,e=1)=>{let n=Ev(t,e);return typeof n=="string"?n:n[1]},Ut=(...t)=>{let e=[];return t.forEach(n=>{n.length!==0&&e.push({type:12,data:n},{type:12,data:He.computeStrides(n)})}),e},Jr=t=>t%4===0?4:t%2===0?2:1,lC=(t="f32",e,n="0")=>!e||e===1?`${t}(${n})`:`vec${e}<${t}>(${n})`,wm=(t,e,n)=>t==="f32"?n:e===1?`f32(${n})`:`vec${e}<f32>(${n})`,Vh=(t,e)=>e===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:e===2?`(${t}.x + ${t}.y)`:e===3?`(${t}.x + ${t}.y + ${t}.z)`:t,Mt=(t,e,n,r)=>t.startsWith("uniforms.")&&n>4?typeof e=="string"?r==="f16"?`${t}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${t}[(${e}) / 4][(${e}) % 4]`:r==="f16"?`${t}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${t}[${Math.floor(e/4)}][${e%4}]`:n>1?`${t}[${e}]`:t,R2=(t,e,n,r,s)=>{let i=typeof n=="number",o=i?n:n.length,a=[...new Array(o).keys()],l=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,u=Ev(e,s),c=typeof u=="string"?u:u[1],d=typeof u=="string"?u:u[0],f={indices:l,value:c,storage:d,tensor:e},m=Y=>typeof Y=="string"?Y:`${Y}u`,g={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=i?"uniforms.":"",v=`${y}${t}_shape`,b=`${y}${t}_strides`,x="";for(let Y=0;Y<o-1;Y++)x+=`
    let dim${Y} = current / ${Mt(b,Y,o)};
    let rest${Y} = current % ${Mt(b,Y,o)};
    indices[${Y}] = dim${Y};
    current = rest${Y};
    `;x+=`indices[${o-1}] = current;`;let $=o<2?"":`
  fn o2i_${t}(offset: u32) -> ${f.indices} {
    var indices: ${f.indices};
    var current = offset;
    ${x}
    return indices;
  }`,S=Y=>(g.offsetToIndices=!0,o<2?Y:`o2i_${t}(${Y})`),E=[];if(o>=2)for(let Y=o-1;Y>=0;Y--)E.push(`${Mt(b,Y,o)} * (indices[${Y}])`);let L=o<2?"":`
  fn i2o_${t}(indices: ${f.indices}) -> u32 {
    return ${E.join("+")};
  }`,R=Y=>(g.indicesToOffset=!0,o<2?Y:`i2o_${t}(${Y})`),D=(...Y)=>o===0?"0u":`${f.indices}(${Y.map(m).join(",")})`,A=(Y,re)=>o<2?`${Y}`:`${Mt(Y,re,o)}`,F=(Y,re,Te)=>o<2?`${Y}=${Te};`:`${Mt(Y,re,o)}=${Te};`,P={},K=(Y,re)=>{g.broadcastedIndicesToOffset=!0;let Te=`${re.name}broadcastedIndicesTo${t}Offset`;if(Te in P)return`${Te}(${Y})`;let Pe=[];for(let de=o-1;de>=0;de--){let ge=re.indicesGet("outputIndices",de+re.rank-o);Pe.push(`${A(b,de)} * (${ge} % ${A(v,de)})`)}return P[Te]=`fn ${Te}(outputIndices: ${re.type.indices}) -> u32 {
             return ${Pe.length>0?Pe.join("+"):"0u"};
           }`,`${Te}(${Y})`},j=(Y,re)=>(()=>{if(f.storage===f.value)return`${t}[${Y}]=${re};`;if(f.storage==="vec2<u32>"&&f.value==="i32")return`${t}[${Y}]=vec2<u32>(u32(${re}), select(0u, 0xFFFFFFFFu, ${re} < 0));`;if(f.storage==="vec2<u32>"&&f.value==="u32")return`${t}[${Y}]=vec2<u32>(u32(${re}), 0u);`;if(f.storage==="u32"&&f.value==="vec4<bool>")return`${t}[${Y}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${re}));`;throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`)})(),se=Y=>(()=>{if(f.storage===f.value)return`${t}[${Y}]`;if(f.storage==="vec2<u32>"&&f.value==="i32")return`i32(${t}[${Y}].x)`;if(f.storage==="vec2<u32>"&&f.value==="u32")return`u32(${t}[${Y}].x)`;if(f.storage==="u32"&&f.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${Y}] & 0xFFu), bool(${t}[${Y}] & 0xFF00u), bool(${t}[${Y}] & 0xFF0000u), bool(${t}[${Y}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`)})(),fe=o<2?"":`
  fn get_${t}ByIndices(indices: ${f.indices}) -> ${c} {
    return ${se(`i2o_${t}(indices)`)};
  }`,me=o<2?"":(()=>{let Y=a.map(Te=>`d${Te}: u32`).join(", "),re=a.map(Te=>`d${Te}`).join(", ");return`
  fn get_${t}(${Y}) -> ${c} {
    return get_${t}ByIndices(${D(re)});
  }`})(),ye=(...Y)=>{if(Y.length!==o)throw new Error(`indices length must be ${o}`);let re=Y.map(m).join(",");return o===0?se("0u"):o===1?se(re[0]):(g.get=!0,g.getByIndices=!0,g.indicesToOffset=!0,`get_${t}(${re})`)},oe=Y=>o<2?se(Y):(g.getByIndices=!0,g.indicesToOffset=!0,`get_${t}ByIndices(${Y})`),ue=o<2?"":`
  fn set_${t}ByIndices(indices: ${f.indices}, value: ${c}) {
    ${j(`i2o_${t}(indices)`,"value")}
  }`,_e=o<2?"":(()=>{let Y=a.map(Te=>`d${Te}: u32`).join(", "),re=a.map(Te=>`d${Te}`).join(", ");return`
  fn set_${t}(${Y}, value: ${c}) {
    set_${t}ByIndices(${D(re)}, value);
  }`})();return{impl:()=>{let Y=[],re=!1;return g.offsetToIndices&&(Y.push($),re=!0),g.indicesToOffset&&(Y.push(L),re=!0),g.broadcastedIndicesToOffset&&(Object.values(P).forEach(Te=>Y.push(Te)),re=!0),g.set&&(Y.push(_e),re=!0),g.setByIndices&&(Y.push(ue),re=!0),g.get&&(Y.push(me),re=!0),g.getByIndices&&(Y.push(fe),re=!0),!i&&re&&Y.unshift(`const ${v} = ${f.indices}(${n.join(",")});`,`const ${b} = ${f.indices}(${He.computeStrides(n).join(",")});`),Y.join(`
`)},type:f,offsetToIndices:S,indicesToOffset:R,broadcastedIndicesToOffset:K,indices:D,indicesGet:A,indicesSet:F,set:(...Y)=>{if(Y.length!==o+1)throw new Error(`indices length must be ${o}`);let re=Y[o];if(typeof re!="string")throw new Error("value must be string");let Te=Y.slice(0,o).map(m).join(",");return o===0?j("0u",re):o===1?j(Te[0],re):(g.set=!0,g.setByIndices=!0,g.indicesToOffset=!0,`set_${t}(${Te}, ${re})`)},setByOffset:j,setByIndices:(Y,re)=>o<2?j(Y,re):(g.setByIndices=!0,g.indicesToOffset=!0,`set_${t}ByIndices(${Y}, ${re});`),get:ye,getByOffset:se,getByIndices:oe,usage:r,name:t,strides:b,shape:v,rank:o}},Je=(t,e,n,r=1)=>R2(t,e,n,"input",r),Ft=(t,e,n,r=1)=>R2(t,e,n,"output",r),XH=(t,e,n)=>R2(t,e,n,"atomicOutput",1),xR=(t,e,n,r=1)=>R2(t,e,n,"internal",r),L8=class{constructor(t,e){this.normalizedDispatchGroup=t,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Jm){let e=typeof t=="number"?t:t[0],n=typeof t=="number"?1:t[1],r=typeof t=="number"?1:t[2];if(e>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,i=s?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,o=s?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${e*n*r}u + local_idx;`;return`@compute @workgroup_size(${e}, ${n}, ${r})
  fn main(${i}) {
    ${o}
  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,e){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage==="input"?"read":"read_write",r=t.usage==="atomicOutput"?"atomic<i32>":t.type.storage;return`@group(0) @binding(${e}) var<storage, ${n}> ${t.name}: array<${r}>;`}declareVariables(...t){return t.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(t,e,n=1){return this.uniforms.push({name:t,type:e,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:e,type:n,length:r}of this.uniforms)if(r&&r>4)n==="f16"?t.push(`@align(16) ${e}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):t.push(`${e}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let s=r==null||r===1?n:`vec${r}<${n}>`;t.push(`${e}:${s}`)}return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`
`)+this.internalVariables.map(t=>t.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[t(e.type),e.length??1])}},YH=(t,e)=>new L8(t,e)}),M8,aS,z8,V8,B8,U8,Ea,QH,JH,Zh=ht(()=>{rn(),vn(),us(),In(),M8=(t,e)=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(e.length!==0&&e.length!==t[0].dims.length)throw new Error(`perm size ${e.length} does not match input rank ${t[0].dims.length}`)},aS=(t,e)=>e.length!==0?e:[...new Array(t).keys()].reverse(),z8=(t,e)=>He.sortBasedOnPerm(t,aS(t.length,e)),V8=(t,e,n,r)=>{let s=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let i=0;i<e;++i)s+=`a[${t[i]}]=i[${i}];`;return s+="return a;}"},B8=(t,e)=>{let n=[],r=[];for(let s=0;s<t.length;++s)t[s]!==1&&n.push(t[s]),t[e[s]]!==1&&r.push(e[s]);return{newShape:n,newPerm:r}},U8=(t,e)=>{let n=0;for(let r=0;r<t.length;++r)if(e[t[r]]!==1){if(t[r]<n)return!1;n=t[r]}return!0},Ea=(t,e)=>{let n=t.dataType,r=t.dims.length,s=aS(r,e),i=z8(t.dims,s),o=t.dims,a=i,l=r<2||U8(s,t.dims),u;if(l)return u=g=>{let y=Je("input",n,o,4),v=Ft("output",n,a,4);return`
  ${g.registerUniform("output_size","u32").declareVariables(y,v)}
  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let g=He.size(i);return{outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(g/64/4)},programUniforms:[{type:12,data:Math.ceil(g/4)}]}},getShaderSource:u};let{newShape:c,newPerm:d}=B8(t.dims,s),f=He.areEqual(d,[2,3,1]),m=He.areEqual(d,[3,1,2]);if(c.length===2||f||m){o=f?[c[0],c[1]*c[2]]:m?[c[0]*c[1],c[2]]:c,a=[o[1],o[0]];let g=16;return u=y=>{let v=Je("a",n,o.length),b=Ft("output",n,a.length);return`
  ${y.registerUniform("output_size","u32").declareVariables(v,b)}
  var<workgroup> tile : array<array<${b.type.value}, ${g+1}>, ${g}>;
  ${y.mainStart([g,g,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${g} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${g}u + local_id.x;
    let input_row = workgroup_id_x * ${g}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${v.getByIndices(`${v.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${g}u + local_id.x;
    let output_row = workgroup_id_y * ${g}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${b.setByIndices(`${b.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let y=He.size(i);return{outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(a[1]/g),y:Math.ceil(a[0]/g)},programUniforms:[{type:12,data:y},...Ut(o,a)]}},getShaderSource:u}}return u=g=>{let y=Je("a",n,o.length),v=Ft("output",n,a.length);return`
  ${g.registerUniform("output_size","u32").declareVariables(y,v)}

  ${V8(s,r,y,v)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${v.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${v.setByOffset("global_idx",y.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:()=>{let g=He.size(i);return{outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},...Ut(o,a)]}},getShaderSource:u}},QH=(t,e)=>{M8(t.inputs,e.perm),t.compute(Ea(t.inputs[0],e.perm))},JH=t=>ur({perm:t.perm})}),W8,j8,G8,H8,q8,K8,X8,Y8,Q8,J8,bl,ZH,eq,tq,nq,rq,sq,iq,oq,aq,lq,NDe=ht(()=>{rn(),vn(),In(),_R(),Zh(),W8={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},j8={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},G8={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},H8={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},q8=(t,e)=>{let n=[];for(let r=e-t;r<e;++r)n.push(r);return n},K8=(t,e)=>{let n=[],r=t.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&n.push(t[i]);let s=e.map(i=>t[i]);return[n,s]},X8=(t,e)=>{let n=t.length+e.length,r=[],s=0;for(let i=0;i<n;i++)e.indexOf(i)===-1?r.push(t[s++]):r.push(1);return r},Y8=(t,e)=>{for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0},Q8=(t,e)=>{let n=[];if(!Y8(t,e)){for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);t.forEach(r=>n.push(r))}return n},J8=(t,e,n,r,s,i,o)=>{let a=n[0].dims,l=He.size(i),u=He.size(o),c=Je("_A",n[0].dataType,a),d=Ft("output",s,i),f=64;l===1&&(f=256);let m=`
          var<workgroup> aBestValues : array<f32, ${f}>;
       `,g=y=>`
        ${y.registerUniform("reduceSize","u32").declareVariables(c,d)}
        ${m}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${y.mainStart(f)}

          let outputIndex = global_idx / ${f};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${G8[r]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${f}) {
           let candidate = f32(${c.getByOffset("offset + k")});
           bestValue = ${W8[r]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${f}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${j8[r]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${d.setByOffset("outputIndex",`${r==="mean"?`${d.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${d.type.storage}(${H8[r]})`}`)};
         }
        }`;return{name:t,shaderCache:{hint:`${e};${f}`,inputDependencies:["type"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:i,dataType:s}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},bl=(t,e,n,r)=>{let s=t.inputs.length===1?n:uC(t.inputs,n),i=s.axes;i.length===0&&!s.noopWithEmptyAxes&&(i=t.inputs[0].dims.map((m,g)=>g));let o=He.normalizeAxes(i,t.inputs[0].dims.length),a=o,l=t.inputs[0],u=Q8(a,t.inputs[0].dims.length);u.length>0&&(l=t.compute(Ea(t.inputs[0],u),{inputs:[0],outputs:[-1]})[0],a=q8(a.length,l.dims.length));let[c,d]=K8(l.dims,a),f=c;s.keepDims&&(f=X8(c,o)),t.compute(J8(e,s.cacheKey,[l],r,t.inputs[0].dataType,f,d),{inputs:[l]})},ZH=(t,e)=>{bl(t,"ReduceMeanShared",e,"mean")},eq=(t,e)=>{bl(t,"ReduceL1Shared",e,"l1")},tq=(t,e)=>{bl(t,"ReduceL2Shared",e,"l2")},nq=(t,e)=>{bl(t,"ReduceLogSumExpShared",e,"logSumExp")},rq=(t,e)=>{bl(t,"ReduceMaxShared",e,"max")},sq=(t,e)=>{bl(t,"ReduceMinShared",e,"min")},iq=(t,e)=>{bl(t,"ReduceProdShared",e,"prod")},oq=(t,e)=>{bl(t,"ReduceSumShared",e,"sum")},aq=(t,e)=>{bl(t,"ReduceSumSquareShared",e,"sumSquare")},lq=(t,e)=>{bl(t,"ReduceLogSumShared",e,"logSum")}}),xl,Z8,lx,uC,_l,e9,t9,n9,r9,s9,i9,o9,a9,l9,u9,Il,uq,cq,hq,dq,fq,pq,mq,gq,yq,wq,_R=ht(()=>{rn(),vn(),us(),In(),NDe(),xl=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Z8=t=>["","",`var value = ${t.getByIndices("input_indices")};`,""],lx=(t,e,n,r,s,i,o=!1,a=!1)=>{let l=[],u=n[0].dims,c=u.length,d=He.normalizeAxes(s,c),f=!a&&d.length===0;u.forEach((y,v)=>{f||d.indexOf(v)>=0?o&&l.push(1):l.push(y)});let m=l.length,g=He.size(l);return{name:t,shaderCache:e,getShaderSource:y=>{let v=[],b=Je("_A",n[0].dataType,c),x=Ft("output",i,m),$=r(b,x,d),S=$[2];for(let E=0,L=0;E<c;E++)f||d.indexOf(E)>=0?(o&&L++,S=`for(var j${E}: u32 = 0; j${E} < ${u[E]}; j${E}++) {
                  ${$[2].includes("last_index")?`let last_index = j${E};`:""}
                  ${b.indicesSet("input_indices",E,`j${E}`)}
                  ${S}
                }`):(v.push(`${b.indicesSet("input_indices",E,x.indicesGet("output_indices",L))};`),L++);return`

        ${y.registerUniform("output_size","u32").declareVariables(b,x)}

        ${y.mainStart()}
          ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${b.type.indices};
          let output_indices = ${x.offsetToIndices("global_idx")};

          ${v.join(`
`)}
          ${$[0]}       // init ops for reduce max/min
          ${$[1]}
          ${S}
          ${$[3]}
          ${$.length===4?x.setByOffset("global_idx","value"):$.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},...Ut(u,l)]})}},uC=(t,e)=>{let n=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(r=>n.push(Number(r))),ur({axes:n,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},_l=(t,e,n,r)=>{let s=t.inputs,i=s.length===1?n:uC(s,n);t.compute(lx(e,{hint:i.cacheKey,inputDependencies:["rank"]},[s[0]],i.noopWithEmptyAxes&&i.axes.length===0?Z8:r,i.axes,s[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},e9=(t,e)=>{xl(t.inputs),_l(t,"ReduceLogSum",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},t9=(t,e)=>{xl(t.inputs),_l(t,"ReduceL1",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},n9=(t,e)=>{xl(t.inputs),_l(t,"ReduceL2",e,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},r9=(t,e)=>{xl(t.inputs),_l(t,"ReduceLogSumExp",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},s9=(t,e)=>{xl(t.inputs),_l(t,"ReduceMax",e,(n,r,s)=>{let i=[];for(let o=0;o<n.rank;o++)(s.indexOf(o)>=0||s.length===0)&&i.push(n.indicesSet("input_indices",o,0));return[`${i.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},i9=(t,e)=>{xl(t.inputs),_l(t,"ReduceMean",e,(n,r,s)=>{let i=1;for(let o=0;o<n.rank;o++)(s.indexOf(o)>=0||s.length===0)&&(i*=t.inputs[0].dims[o]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${r.type.value}(sum / ${i});`]})},o9=(t,e)=>{xl(t.inputs),_l(t,"ReduceMin",e,(n,r,s)=>{let i=[];for(let o=0;o<n.rank;o++)(s.indexOf(o)>=0||s.length===0)&&i.push(`input_indices[${o}] = 0;`);return[`${i.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},a9=(t,e)=>{xl(t.inputs),_l(t,"ReduceProd",e,(n,r)=>[`var value = ${r.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},l9=(t,e)=>{xl(t.inputs),_l(t,"ReduceSum",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},u9=(t,e)=>{xl(t.inputs),_l(t,"ReduceSumSquare",e,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},Il=(t,e,n)=>{if(e.length===0)return n;let r=1,s=1;for(let i=0;i<e.length;i++)e.indexOf(i)===-1?r*=t[i]:s*=t[i];return s<32&&r>1024},uq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?i9(t,e):ZH(t,e)},cq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?t9(t,e):eq(t,e)},hq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?n9(t,e):tq(t,e)},dq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?r9(t,e):nq(t,e)},fq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?s9(t,e):rq(t,e)},pq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?o9(t,e):sq(t,e)},mq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?a9(t,e):iq(t,e)},gq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?l9(t,e):oq(t,e)},yq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?u9(t,e):aq(t,e)},wq=(t,e)=>{Il(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?e9(t,e):lq(t,e)}}),lS,vq,bq,cC,ADe=ht(()=>{rn(),us(),_R(),lS=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},vq=(t,e)=>{lS(t.inputs);let n=(r,s,i)=>{let o=[];for(let a=0;a<r.rank;a++)(i.indexOf(a)>=0||i.length===0)&&o.push(`input_indices[${a}] = 0;`);return[`${o.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",s.setByOffset("global_idx","best_index")]};t.compute(lx("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},bq=(t,e)=>{lS(t.inputs);let n=(r,s,i)=>{let o=[];for(let a=0;a<r.rank;a++)(i.indexOf(a)>=0||i.length===0)&&o.push(`input_indices[${a}] = 0;`);return[`${o.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",s.setByOffset("global_idx","best_index")]};t.compute(lx("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},cC=t=>ur(t)}),c9,kv,h9,d9,f9,jy,p9,xq,IR=ht(()=>{rn(),vn(),bR(),In(),c9=(t,e)=>{let n=t[0],r=t[1],s=t[2],i=t[3],o=t[4],a=t[5];if(o&&a)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let l=n.dims[0],u=n.dims[1],c=n.dims[2];if(s.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(r.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(r.dims[0]!==c)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==r.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let d=s.dims[0]/3,f=d,m=f;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let $ of e.qkvHiddenSizes)if($%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");d=e.qkvHiddenSizes[0],f=e.qkvHiddenSizes[1],m=e.qkvHiddenSizes[2]}let g=u;if(d!==f)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==d+f+m)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let y=0;if(o){if(f!==m)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(o.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(o.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(o.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(o.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(o.dims[4]!==f/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(y=o.dims[3])}let v=g+y,b=-1,x=0;if(i)throw new Error("Mask not supported");if(o)throw new Error("past is not supported");if(a){if(a.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(a.dims[0]!==l||a.dims[1]!==e.numHeads||a.dims[2]!==u||a.dims[3]!==v)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:u,pastSequenceLength:y,kvSequenceLength:g,totalSequenceLength:v,maxSequenceLength:b,inputHiddenSize:c,hiddenSize:d,vHiddenSize:m,headSize:Math.floor(d/e.numHeads),vHeadSize:Math.floor(m/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:x,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},kv=(t,e,n)=>e&&t?`
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${t?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,h9=(t,e,n,r,s,i,o,a)=>{let l=Jr(o?1:i),u=64,c=i/l;c<u&&(u=32);let d=Math.ceil(i/l/u),f=[{type:12,data:e},{type:12,data:n},{type:12,data:r},{type:12,data:s},{type:12,data:c},{type:12,data:d}],m=si(t.dataType,l),g=oo(1,l),y=["type"];o&&y.push("type"),a&&y.push("type");let v=b=>{let x=Ft("x",t.dataType,t.dims,l),$=[x],S=o?Je("seq_lens",o.dataType,o.dims):void 0;S&&$.push(S);let E=a?Je("total_sequence_length_input",a.dataType,a.dims):void 0;E&&$.push(E);let L=oo(t.dataType),R=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${u}>;
  var<workgroup> thread_sum: array<f32, ${u}>;
  ${b.registerUniforms(R).declareVariables(...$)}
  ${b.mainStart([u,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${kv(S,E,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${o?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${g}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${g}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${u}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${g}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${g}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${u}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${x.type.value}(${L}(1.0) / ${L}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${g}(x[offset + i]);
        x[offset + i] = ${x.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${o?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${x.type.value}(${L}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${m};${l}`,inputDependencies:y},getShaderSource:v,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:s,z:e*n},programUniforms:f})}},d9=(t,e,n,r,s,i,o,a,l)=>{let u=o+i.kvSequenceLength,c=[i.batchSize,i.numHeads,i.sequenceLength,u],d=t>1&&r,f=i.kvNumHeads?i.kvNumHeads:i.numHeads,m=d?[i.batchSize,f,u,i.headSize]:void 0,g=i.nReps?i.nReps:1,y=i.scale===0?1/Math.sqrt(i.headSize):i.scale,v=Jr(i.headSize),b=i.headSize/v,x=12,$={x:Math.ceil(u/x),y:Math.ceil(i.sequenceLength/x),z:i.batchSize*i.numHeads},S=[{type:12,data:i.sequenceLength},{type:12,data:b},{type:12,data:u},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:y},{type:12,data:o},{type:12,data:i.kvSequenceLength},{type:12,data:g}],E=d&&r&&He.size(r.dims)>0,L=["type","type"];E&&L.push("type"),s&&L.push("type"),a&&L.push("type"),l&&L.push("type");let R=[{dims:c,dataType:e.dataType,gpuDataType:0}];d&&R.push({dims:m,dataType:e.dataType,gpuDataType:0});let D=A=>{let F=Je("q",e.dataType,e.dims,v),P=Je("key",n.dataType,n.dims,v),K=[F,P];if(E){let ue=Je("past_key",r.dataType,r.dims,v);K.push(ue)}s&&K.push(Je("attention_bias",s.dataType,s.dims));let j=a?Je("seq_lens",a.dataType,a.dims):void 0;j&&K.push(j);let se=l?Je("total_sequence_length_input",l.dataType,l.dims):void 0;se&&K.push(se);let fe=Ft("output",e.dataType,c),me=[fe];d&&me.push(Ft("present_key",e.dataType,m,v));let ye=oo(1,v),oe=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${x}u;

  var<workgroup> tileQ: array<${F.type.storage}, ${x*x}>;
  var<workgroup> tileK: array<${F.type.storage}, ${x*x}>;
  ${A.registerUniforms(oe).declareVariables(...K,...me)}
  ${A.mainStart([x,x,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${g===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${g===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${kv(j,se,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${E&&d?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${d?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${ye}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${E&&d?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${d?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${ye}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(v){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${v}`)}})()};
        output[outputIdx] = ${fe.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${v};${s!==void 0};${r!==void 0};${t}`,inputDependencies:L},getRunData:()=>({outputs:R,dispatchGroup:$,programUniforms:S}),getShaderSource:D}},f9=(t,e,n,r,s,i,o=void 0,a=void 0)=>{let l=i+s.kvSequenceLength,u=s.nReps?s.nReps:1,c=s.vHiddenSize*u,d=t>1&&r,f=s.kvNumHeads?s.kvNumHeads:s.numHeads,m=d?[s.batchSize,f,l,s.headSize]:void 0,g=[s.batchSize,s.sequenceLength,c],y=12,v={x:Math.ceil(s.vHeadSize/y),y:Math.ceil(s.sequenceLength/y),z:s.batchSize*s.numHeads},b=[{type:12,data:s.sequenceLength},{type:12,data:l},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:c},{type:12,data:i},{type:12,data:s.kvSequenceLength},{type:12,data:u}],x=d&&r&&He.size(r.dims)>0,$=["type","type"];x&&$.push("type"),o&&$.push("type"),a&&$.push("type");let S=[{dims:g,dataType:e.dataType,gpuDataType:0}];d&&S.push({dims:m,dataType:e.dataType,gpuDataType:0});let E=L=>{let R=Je("probs",e.dataType,e.dims),D=Je("v",n.dataType,n.dims),A=[R,D];x&&A.push(Je("past_value",r.dataType,r.dims));let F=o?Je("seq_lens",o.dataType,o.dims):void 0;o&&A.push(F);let P=a?Je("total_sequence_length_input",a.dataType,a.dims):void 0;a&&A.push(P);let K=[Ft("output",e.dataType,g)];d&&K.push(Ft("present_value",e.dataType,m));let j=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${y}u;
  var<workgroup> tileQ: array<${R.type.value}, ${y*y}>;
  var<workgroup> tileV: array<${R.type.value}, ${y*y}>;
  ${L.registerUniforms(j).declareVariables(...A,...K)}
  ${L.mainStart([y,y,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${u===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${u===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${kv(F,P,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${x&&d?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${d?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${R.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${x&&d?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${d?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${r!==void 0};${t}`,inputDependencies:$},getRunData:()=>({outputs:S,dispatchGroup:v,programUniforms:b}),getShaderSource:E}},jy=(t,e,n,r,s,i,o,a,l,u,c=void 0,d=void 0)=>{let f=Math.min(t.outputCount,1+(o?1:0)+(a?1:0)),m=f>1?u.pastSequenceLength:0,g=m+u.kvSequenceLength,y=l&&He.size(l.dims)>0?l:void 0,v=[e,n];f>1&&o&&He.size(o.dims)>0&&v.push(o),y&&v.push(y),c&&v.push(c),d&&v.push(d);let b=t.compute(d9(f,e,n,o,y,u,m,c,d),{inputs:v,outputs:f>1?[-1,1]:[-1]})[0];t.compute(h9(b,u.batchSize,u.numHeads,m,u.sequenceLength,g,c,d),{inputs:c&&d?[b,c,d]:[b],outputs:[]});let x=[b,r];f>1&&a&&He.size(a.dims)>0&&x.push(a),c&&x.push(c),d&&x.push(d),t.compute(f9(f,b,r,a,u,m,c,d),{inputs:x,outputs:f>1?[0,2]:[0]})},p9=(t,e)=>{let n=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],r=e.sequenceLength,s=e.inputHiddenSize,i=e.headSize,o=12,a={x:Math.ceil(e.headSize/o),y:Math.ceil(e.sequenceLength/o),z:e.batchSize*e.numHeads},l=[t.inputs[0],t.inputs[1],t.inputs[2]],u=[{type:12,data:r},{type:12,data:s},{type:12,data:i},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],c=d=>{let f=Ft("output_q",l[0].dataType,n),m=Ft("output_k",l[0].dataType,n),g=Ft("output_v",l[0].dataType,n),y=Je("input",l[0].dataType,l[0].dims),v=Je("weight",l[1].dataType,l[1].dims),b=Je("bias",l[2].dataType,l[2].dims),x=y.type.storage,$=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${o}u;
  var<workgroup> tileInput: array<${x}, ${o*o}>;
  var<workgroup> tileWeightQ: array<${x}, ${o*o}>;
  var<workgroup> tileWeightK: array<${x}, ${o*o}>;
  var<workgroup> tileWeightV: array<${x}, ${o*o}>;
  ${d.registerUniforms($).declareVariables(y,v,b,f,m,g)}
  ${d.mainStart([o,o,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${x}(0);
    var valueK = ${x}(0);
    var valueV = ${x}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return t.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a,programUniforms:u}),getShaderSource:c},{inputs:l,outputs:[-1,-1,-1]})},xq=(t,e)=>{let n=c9(t.inputs,e),[r,s,i]=p9(t,n);return jy(t,r,s,i,t.inputs[4],void 0,void 0,void 0,t.inputs[5],n)}}),m9,g9,y9,_q,RDe=ht(()=>{ul(),rn(),vn(),us(),In(),m9=(t,e)=>{if(!t||t.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(r,s,i)=>{let o=s.length;if(o!==r.length)throw new Error(`${i}: num dimensions != ${o}`);s.forEach((a,l)=>{if(a!==r[l])throw new Error(`${i}: dim[${l}] do not match`)})};if(t[0].dims.length>1){let r=e.format==="NHWC"?e.spatial?t[0].dims.slice(-1):t[0].dims.slice(-1).concat(t[0].dims.slice(1,t[0].dims.length-1)):t[0].dims.slice(1,e.spatial?2:void 0);n(t[1].dims,r,"Invalid input scale"),n(t[2].dims,r,"Invalid input B"),n(t[3].dims,r,"Invalid input mean"),n(t[4].dims,r,"Invalid input var")}else n(t[1].dims,[1],"Invalid input scale"),n(t[2].dims,[1],"Invalid input B"),n(t[3].dims,[1],"Invalid input mean"),n(t[4].dims,[1],"Invalid input var")},g9=(t,e)=>{let{epsilon:n,spatial:r,format:s}=e,i=t[0].dims,o=r?Jr(i[i.length-1]):1,a=s==="NHWC"&&i.length>1?o:1,l=He.size(i)/o,u=r,c=u?i.length:i,d=Je("x",t[0].dataType,t[0].dims,o),f=Je("scale",t[1].dataType,t[1].dims,a),m=Je("bias",t[2].dataType,t[2].dims,a),g=Je("inputMean",t[3].dataType,t[3].dims,a),y=Je("inputVar",t[4].dataType,t[4].dims,a),v=Ft("y",t[0].dataType,c,o),b=()=>{let $="";if(r)$=`let cOffset = ${i.length===1?"0u":s==="NHWC"?`outputIndices[${i.length-1}] / ${o}`:"outputIndices[1]"};`;else if(s==="NCHW")$=`
            ${v.indicesSet("outputIndices","0","0")}
            let cOffset = ${v.indicesToOffset("outputIndices")};`;else{$=`var cIndices = ${f.type.indices}(0);
                       cIndices[0] = outputIndices[${i.length-1}];`;for(let S=1;S<f.rank;S++)$+=`cIndices[${S}] = outputIndices[${S}];`;$+=`let cOffset = ${f.indicesToOffset("cIndices")};`}return $},x=$=>`
  const epsilon = ${n};
  ${$.registerUniform("outputSize","u32").declareVariables(d,f,m,g,y,v)}
  ${$.mainStart()}
  ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${v.offsetToIndices(`global_idx * ${o}`)};
    ${b()}
    let scale = ${f.getByOffset("cOffset")};
    let bias = ${m.getByOffset("cOffset")};
    let inputMean = ${g.getByOffset("cOffset")};
    let inputVar = ${y.getByOffset("cOffset")};
    let x = ${d.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${v.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${r}_${o}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:x,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...Ut(i)]:[{type:12,data:l}]})}},y9=t=>ur(t),_q=(t,e)=>{let{inputs:n,outputCount:r}=t,s=y9({...e,outputCount:r});if(Er.webgpu.validateInputContent&&m9(n,s),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");t.compute(g9(n,s))}}),w9,v9,Iq,DDe=ht(()=>{vn(),In(),w9=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},v9=t=>{let e=t[0].dims,n=t[0].dims[2],r=He.size(e)/4,s=t[0].dataType,i=Je("input",s,e,4),o=Je("bias",s,[n],4),a=Je("residual",s,e,4),l=Ft("output",s,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:u=>`
  const channels = ${n}u / 4;
  ${u.declareVariables(i,o,a,l)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(r)}
    let value = ${i.getByOffset("global_idx")}
      + ${o.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${l.setByOffset("global_idx","value")}
  }`}},Iq=t=>{w9(t.inputs),t.compute(v9(t.inputs))}}),b9,rr,Tq,Sq,$q,Cq,Eq,kq,Nq,Aq,Rq,x9,Dq,Oq,Pq,Fq,sy,Lq,ub,Mq,zq,Vq,Bq,Uq,Wq,jq,Gq,Hq,qq,Kq,Xq,Yq,Qq,Jq,Zq,uS,eK,hC,dC,tK,nK,rK,_9,I9,sK,TR=ht(()=>{rn(),vn(),us(),In(),b9=(t,e,n,r,s,i,o)=>{let a=Math.ceil(e/4),l="";typeof s=="string"?l=`${s}(a)`:l=s("a");let u=Je("inputData",n,[a],4),c=Ft("outputData",r,[a],4),d=[{name:"vec_size",type:"u32"}];return o&&d.push(...o),`
      ${t.registerUniforms(d).declareVariables(u,c)}

  ${i??""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${c.setByOffset("global_idx",l)}
  }`},rr=(t,e,n,r,s,i=t.dataType,o,a)=>{let l=[{type:12,data:Math.ceil(He.size(t.dims)/4)}];return o&&l.push(...o),{name:e,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:u=>b9(u,He.size(t.dims),t.dataType,i,n,r,a),getRunData:u=>({outputs:[{dims:t.dims,dataType:i}],dispatchGroup:{x:Math.ceil(He.size(u[0].dims)/64/4)},programUniforms:l})}},Tq=t=>{t.compute(rr(t.inputs[0],"Abs","abs"))},Sq=t=>{t.compute(rr(t.inputs[0],"Acos","acos"))},$q=t=>{t.compute(rr(t.inputs[0],"Acosh","acosh"))},Cq=t=>{t.compute(rr(t.inputs[0],"Asin","asin"))},Eq=t=>{t.compute(rr(t.inputs[0],"Asinh","asinh"))},kq=t=>{t.compute(rr(t.inputs[0],"Atan","atan"))},Nq=t=>{t.compute(rr(t.inputs[0],"Atanh","atanh"))},Aq=t=>ur(t),Rq=(t,e)=>{let n;switch(e.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}t.compute(rr(t.inputs[0],"Cast",n,void 0,e.cacheKey,e.to))},x9=t=>{let e,n,r=t.length>=2&&t[1].data!==0,s=t.length>=3&&t[2].data!==0;switch(t[0].dataType){case 1:e=r?t[1].getFloat32Array()[0]:-34028234663852886e22,n=s?t[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:e=r?t[1].getUint16Array()[0]:64511,n=s?t[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return ur({min:e,max:n})},Dq=(t,e)=>{let n=e||x9(t.inputs),r=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"Clip",s=>`clamp(${s}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:t.inputs[0].dataType,data:n.min},{type:t.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},Oq=t=>{t.compute(rr(t.inputs[0],"Ceil","ceil"))},Pq=t=>{t.compute(rr(t.inputs[0],"Cos","cos"))},Fq=t=>{t.compute(rr(t.inputs[0],"Cosh","cosh"))},sy=t=>ur(t),Lq=(t,e)=>{let n=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_ = ${n}(${e.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},ub=(t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: vec4<${t}>) -> vec4<${t}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Mq=t=>{let e=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"Erf",n=>`erf_vf32(${n})`,ub(e)))},zq=t=>{t.compute(rr(t.inputs[0],"Exp","exp"))},Vq=t=>{t.compute(rr(t.inputs[0],"Floor","floor"))},Bq=t=>{let e=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,ub(e)))},Uq=(t,e)=>{let n=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${e.alpha});`,e.cacheKey))},Wq=t=>{t.compute(rr(t.inputs[0],"Not",e=>`!${e}`))},jq=t=>{t.compute(rr(t.inputs[0],"Neg",e=>`-${e}`))},Gq=t=>{t.compute(rr(t.inputs[0],"Reciprocal",e=>`1.0/${e}`))},Hq=t=>{let e=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"Relu",n=>`select(vec4<${e}>(0.0), ${n}, ${n} > vec4<${e}>(0.0))`))},qq=t=>{t.compute(rr(t.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},Kq=t=>ur(t),Xq=(t,e)=>{let n=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"HardSigmoid",r=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${e.alpha} * ${r} + vec4<${n}>(${e.beta})))`,void 0,e.cacheKey))},Yq=t=>{t.compute(rr(t.inputs[0],"Sin","sin"))},Qq=t=>{t.compute(rr(t.inputs[0],"Sinh","sinh"))},Jq=t=>{t.compute(rr(t.inputs[0],"Sqrt","sqrt"))},Zq=t=>{t.compute(rr(t.inputs[0],"Tan","tan"))},uS=t=>`sign(${t}) * (1 - exp(-2 * abs(${t}))) / (1 + exp(-2 * abs(${t})))`,eK=t=>{t.compute(rr(t.inputs[0],"Tanh",uS))},hC=(t="f32")=>`
const fast_gelu_a: ${t} = 0.5;
const fast_gelu_b: ${t} = 0.7978845608028654;
const fast_gelu_c: ${t} = 0.035677408136300125;

fn tanh_v(v: vec4<${t}>) -> vec4<${t}> {
  return ${uS("v")};
}
`,dC=t=>`(fast_gelu_a + fast_gelu_a * tanh_v(${t} * (fast_gelu_c * ${t} * ${t} + fast_gelu_b))) * ${t}`,tK=t=>{let e=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"FastGelu",dC,hC(e),void 0,t.inputs[0].dataType))},nK=(t,e)=>{let n=oo(t.inputs[0].dataType);return t.compute(rr(t.inputs[0],"ThresholdedRelu",r=>`select(vec4<${n}>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${e.alpha});`,e.cacheKey)),0},rK=t=>{t.compute(rr(t.inputs[0],"Log","log"))},_9=(t,e)=>`
const alpha = vec4<${t}>(${e});
const one = ${t}(1.0);
const zero = ${t}(0.0);

fn quick_gelu_impl(x: vec4<${t}>) -> vec4<${t}> {
  let v = x *alpha;
  var x1 : vec4<${t}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,I9=t=>`quick_gelu_impl(${t})`,sK=(t,e)=>{let n=oo(t.inputs[0].dataType);t.compute(rr(t.inputs[0],"QuickGelu",I9,_9(n,e.alpha),e.cacheKey,t.inputs[0].dataType))}}),T9,S9,iK,ODe=ht(()=>{vn(),In(),TR(),T9=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},S9=t=>{let e=t[0].dims.slice();e[2]=e[2]/2;let n=Je("input",t[0].dataType,t[0].dims,4),r=Je("bias",t[0].dataType,[t[0].dims[2]],4),s=Ft("output",t[0].dataType,e,4),i=He.size(e)/4,o=si(t[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:a=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2]/4/2}u;

  ${a.declareVariables(n,r,s)}

  ${ub(o)}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${s.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},iK=t=>{T9(t.inputs),t.compute(S9(t.inputs))}}),$9,C9,Tl,oK,aK,lK,uK,cK,hK,dK,fK,pK,mK,PDe=ht(()=>{rn(),vn(),In(),$9=(t,e,n,r,s,i,o,a,l,u,c,d)=>{let f,m;typeof a=="string"?f=m=(x,$)=>`${a}((${x}),(${$}))`:typeof a=="function"?f=m=a:(f=a.scalar,m=a.vector);let g=Ft("outputData",c,r.length,4),y=Je("aData",l,e.length,4),v=Je("bData",u,n.length,4),b;if(s)if(i){let x=He.size(e)===1,$=He.size(n)===1,S=e.length>0&&e[e.length-1]%4===0,E=n.length>0&&n[n.length-1]%4===0;x||$?b=g.setByOffset("global_idx",m(x?`${y.type.value}(${y.getByOffset("0")}.x)`:y.getByOffset("global_idx"),$?`${v.type.value}(${v.getByOffset("0")}.x)`:v.getByOffset("global_idx"))):b=`
            let outputIndices = ${g.offsetToIndices("global_idx * 4u")};
            let offsetA = ${y.broadcastedIndicesToOffset("outputIndices",g)};
            let offsetB = ${v.broadcastedIndicesToOffset("outputIndices",g)};
            ${g.setByOffset("global_idx",m(o||S?y.getByOffset("offsetA / 4u"):`${y.type.value}(${y.getByOffset("offsetA / 4u")}[offsetA % 4u])`,o||E?v.getByOffset("offsetB / 4u"):`${v.type.value}(${v.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else b=g.setByOffset("global_idx",m(y.getByOffset("global_idx"),v.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let x=($,S,E="")=>{let L=`aData[indexA${S}][componentA${S}]`,R=`bData[indexB${S}][componentB${S}]`;return`
            let outputIndices${S} = ${g.offsetToIndices(`global_idx * 4u + ${S}u`)};
            let offsetA${S} = ${y.broadcastedIndicesToOffset(`outputIndices${S}`,g)};
            let offsetB${S} = ${v.broadcastedIndicesToOffset(`outputIndices${S}`,g)};
            let indexA${S} = offsetA${S} / 4u;
            let indexB${S} = offsetB${S} / 4u;
            let componentA${S} = offsetA${S} % 4u;
            let componentB${S} = offsetB${S} % 4u;
            ${$}[${S}] = ${E}(${f(L,R)});
          `};c===9?b=`
            var data = vec4<u32>(0);
            ${x("data",0,"u32")}
            ${x("data",1,"u32")}
            ${x("data",2,"u32")}
            ${x("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:b=`
            ${x("outputData[global_idx]",0)}
            ${x("outputData[global_idx]",1)}
            ${x("outputData[global_idx]",2)}
            ${x("outputData[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(y,v,g)}

        ${d??""}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${b}
      }`},C9=(t,e,n,r,s,i,o=n.dataType)=>{let a=n.dims.map(y=>Number(y)??1),l=r.dims.map(y=>Number(y)??1),u=!He.areEqual(a,l),c=a,d=He.size(a),f=!1,m=!1,g=[u];if(u){let y=Qm.calcShape(a,l,!1);if(!y)throw new Error("Can't perform binary op on the given tensors");c=y.slice(),d=He.size(c);let v=He.size(a)===1,b=He.size(l)===1,x=a.length>0&&a[a.length-1]%4===0,$=l.length>0&&l[l.length-1]%4===0;g.push(v),g.push(b),g.push(x),g.push($);let S=1;for(let E=1;E<c.length;E++){let L=a[a.length-E],R=l[l.length-E];if(L===R)S*=L;else break}S%4===0?(m=!0,f=!0):(v||b||x||$)&&(f=!0)}else f=!0;return g.push(f),{name:t,shaderCache:{hint:e+g.map(y=>y.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:y=>$9(y,a,l,c,f,u,m,s,n.dataType,r.dataType,o,i),getRunData:()=>({outputs:[{dims:c,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:Math.ceil(He.size(c)/4)},...Ut(a,l,c)]})}},Tl=(t,e,n,r,s,i)=>{t.compute(C9(e,s??"",t.inputs[0],t.inputs[1],n,r,i))},oK=t=>{Tl(t,"Add",(e,n)=>`${e}+${n}`)},aK=t=>{Tl(t,"Div",(e,n)=>`${e}/${n}`)},lK=t=>{Tl(t,"Equal",{scalar:(e,n)=>`u32(${e}==${n})`,vector:(e,n)=>`vec4<u32>(${e}==${n})`},void 0,void 0,9)},uK=t=>{Tl(t,"Mul",(e,n)=>`${e}*${n}`)},cK=t=>{let e=Je("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;Tl(t,"Pow",{scalar:(n,r)=>`pow_custom(${n},${r})`,vector:(n,r)=>`pow_vector_custom(${n},${r})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},hK=t=>{Tl(t,"Sub",(e,n)=>`${e}-${n}`)},dK=t=>{Tl(t,"Greater",{scalar:(e,n)=>`u32(${e}>${n})`,vector:(e,n)=>`vec4<u32>(${e}>${n})`},void 0,void 0,9)},fK=t=>{Tl(t,"Less",{scalar:(e,n)=>`u32(${e}<${n})`,vector:(e,n)=>`vec4<u32>(${e}<${n})`},void 0,void 0,9)},pK=t=>{Tl(t,"GreaterOrEqual",{scalar:(e,n)=>`u32(${e}>=${n})`,vector:(e,n)=>`vec4<u32>(${e}>=${n})`},void 0,void 0,9)},mK=t=>{Tl(t,"LessOrEqual",{scalar:(e,n)=>`u32(${e}<=${n})`,vector:(e,n)=>`vec4<u32>(${e}<=${n})`},void 0,void 0,9)}}),E9,k9,N9,A9,gK,yK,FDe=ht(()=>{rn(),vn(),us(),In(),E9=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");let n=0,r=t[n],s=r.dataType,i=r.dims.length;t.forEach((o,a)=>{if(a!==n){if(o.dataType!==s)throw new Error("input tensors should be one type");if(o.dims.length!==i)throw new Error("input tensors should have the same shape");o.dims.forEach((l,u)=>{if(u!==e&&l!==r.dims[u])throw new Error("non concat dimensions must match")})}})},k9=(t,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${t}u>(${e});
    for (var i: u32 = 0u; i < ${t}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`,N9=(t,e)=>{let n=t.length,r=[];for(let s=0;s<n;++s){let i=e.setByOffset("global_idx",t[s].getByIndices("indices"));n===1?r.push(i):s===0?r.push(`if (inputIndex == ${s}u) { ${i} }`):s===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${s}) { ${i} }`)}return r.join(`
`)},A9=(t,e,n,r)=>{let s=He.size(n),i=new Array(t.length),o=new Array(t.length),a=0,l=[],u=[],c=[{type:12,data:s}];for(let y=0;y<t.length;++y)a+=t[y].dims[e],i[y]=a,u.push(t[y].dims.length),o[y]=Je(`input${y}`,r,u[y]),l.push("rank"),c.push({type:12,data:i[y]});for(let y=0;y<t.length;++y)c.push(...Ut(t[y].dims));c.push(...Ut(n));let d=Ft("output",r,n.length),f=d.indicesGet("indices",e),m=Array.from(Array(i.length).keys()).map(y=>`uniforms.sizeInConcatAxis${y}`).join(","),g=y=>`

  ${(()=>{y.registerUniform("outputSize","u32");for(let v=0;v<t.length;v++)y.registerUniform(`sizeInConcatAxis${v}`,"u32");return y.declareVariables(...o,d)})()}

  ${k9(i.length,m)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${d.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${f});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${i.length}u>(${m});
      ${f} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${N9(o,d)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:c}),getShaderSource:g}},gK=(t,e)=>{let n=t.inputs,r=n[0].dims,s=He.normalizeAxis(e.axis,r.length);E9(n,s);let i=r.slice();i[s]=n.reduce((a,l)=>a+(l.dims.length>s?l.dims[s]:0),0);let o=n.filter(a=>He.size(a.dims)>0);t.compute(A9(o,s,i,n[0].dataType),{inputs:o})},yK=t=>ur({axis:t.axis})}),pf,mf,gf,SR,Pp=ht(()=>{rn(),vn(),pf=(t,e,n="f32")=>{switch(t.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${n}(uniforms.clip_min)), ${e}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${t.activation}`)}},mf=(t,e)=>{t.activation==="Clip"?e.push({type:1,data:t.clipMax},{type:1,data:t.clipMin}):t.activation==="HardSigmoid"?e.push({type:1,data:t.alpha},{type:1,data:t.beta}):t.activation==="LeakyRelu"&&e.push({type:1,data:t.alpha})},gf=(t,e)=>{t.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):t.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):t.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},SR=t=>{let e=t?.activation||"";if(e==="HardSigmoid"){let[n,r]=t?.activation_params||[.2,.5];return{activation:e,alpha:n,beta:r}}else if(e==="Clip"){let[n,r]=t?.activation_params||[WH,jH];return{activation:e,clipMax:r,clipMin:n}}else if(e==="LeakyRelu"){let[n]=t?.activation_params||[.01];return{activation:e,alpha:n}}return{activation:e}}}),_i,wK,$R=ht(()=>{_i=(t,e)=>{switch(t){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component is not supported.`)}},wK=t=>`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      `}),vK,LDe=ht(()=>{vK=t=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));
}
`}),fy,CR,ER=ht(()=>{rn(),vn(),In(),Pp(),fy=(t,e,n,r,s)=>{let i=r-n;return`
      ${Array.from({length:n}).map((o,a)=>`
      if (${Mt(e.shape,a,e.rank)} != 1) {
        ${e.indicesSet(t,a,Mt(s,a+i,r))}
      } else {
        ${e.indicesSet(t,a,0)}
      }`).join("")}
`},CR=(t,e,n,r,s=!1,i)=>{let o=t[0].dims,a=t[1].dims,l=o[o.length-2],u=a[a.length-1],c=o[o.length-1],d=Jr(u),f=Jr(c),m=Jr(l),g=He.size(n)/d/m,y=t.length>2,v=r?r.slice(0,-2):n.slice(0,-2),b=[He.size(v),l,u],x=[{type:12,data:g},{type:12,data:l},{type:12,data:u},{type:12,data:c}];mf(e,x),x.push(...Ut(v,o,a)),y&&x.push(...Ut(t[2].dims)),x.push(...Ut(b));let $=S=>{let E=xR("batch_dims",t[0].dataType,v.length),L=Je("a",t[0].dataType,o.length,f),R=Je("b",t[1].dataType,a.length,d),D=Ft("output",t[0].dataType,b.length,d),A=si(D.type.tensor),F=pf(e,D.type.value,A),P=[L,R],K="";if(y){let fe=s?d:1;P.push(Je("bias",t[2].dataType,t[2].dims.length,fe)),K=`${s?`value += bias[col / ${fe}];`:`value += ${D.type.value}(bias[row + i]);`}`}let j=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];gf(e,j);let se=()=>{let fe=`var a_data: ${L.type.value};`;for(let me=0;me<f;me++)fe+=`
              let b_data${me} = b[(b_offset + (k + ${me}) * uniforms.N + col) / ${d}];`;for(let me=0;me<m;me++){fe+=`a_data = a[(a_offset + (row + ${me}) * uniforms.K + k) / ${f}];`;for(let ye=0;ye<f;ye++)fe+=`
            values[${me}] = fma(${R.type.value}(a_data${f===1?"":`[${ye}]`}), b_data${ye}, values[${me}]);
`}return fe};return`
  ${S.registerUniforms(j).registerInternalVariables(E).declareVariables(...P,D)}
  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${d})) * ${d};
    var index1 = global_idx / (uniforms.N / ${d});
    let stride1 = uniforms.M / ${m};
    let row = (index1 % stride1) * ${m};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${E.offsetToIndices("batch")};`}

    var a_indices: ${L.type.indices};
    ${fy("a_indices",L,L.rank-2,E.rank,"batch_indices")}
    ${L.indicesSet("a_indices",L.rank-2,0)}
    ${L.indicesSet("a_indices",L.rank-1,0)}
    let a_offset = ${L.indicesToOffset("a_indices")};

    var b_indices: ${R.type.indices};
    ${fy("b_indices",R,R.rank-2,E.rank,"batch_indices")}
    ${R.indicesSet("b_indices",R.rank-2,0)}
    ${R.indicesSet("b_indices",R.rank-1,0)}
    let b_offset = ${R.indicesToOffset("b_indices")};
    var values: array<${D.type.value}, ${m}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${f}) {
      ${se()}
    }
    for (var i = 0u; i < ${m}u; i++) {
      var value = values[i];
      ${K}
      ${F}
      let cur_indices = ${D.type.indices}(batch, row + i, col);
      let offset = ${D.indicesToOffset("cur_indices")};
      ${D.setByOffset(`offset / ${d}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${d};${f};${m};${s}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:x}),getShaderSource:$}}}),R9,D9,fC,cS,O9,pC,P9,ux,kR=ht(()=>{rn(),vn(),In(),Pp(),ER(),$R(),R9=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,D9=(t,e)=>t?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,fC=(t,e,n="f32",r,s=!1,i=32,o=!1,a=32)=>{let l=e[1]*t[1],u=e[0]*t[0],c=s?l:i,d=s?i:l,f=c/e[0],m=i/e[1];if(!((s&&f===4&&t[1]===4||!s&&(f===3||f===4))&&c%e[0]===0&&i%e[1]===0&&t[0]===4))throw new Error(`If transposeA ${s} is true, innerElementSize ${f} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${f} must be 3 or 4.
  tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${f}<${n}>, ${c/f}>, ${d}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/t[0]}>, ${i}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${f};
const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${o?"0":"i32(globalId.z)"};
  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let num_tiles = ${o?`${Math.ceil(a/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${o?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${m};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${R9(s,r)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${f===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${D9(s,f)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},cS=(t,e)=>t?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,O9=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",pC=(t,e,n="f32",r,s=!1,i=32,o=!1,a=32,l=!1)=>{let u=t[1]*e[1],c=t[0]*e[0],d=s?u:i,f=s?i:u;if(!(f%e[1]===0&&d%e[0]===0&&i%e[1]===0))throw new Error(`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${i} must be divisible by workgroupSize[1]${e[1]}`);let m=f/e[1],g=d/e[0],y=i/e[1],v=l?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${u};
    let globalColStart = i32(workgroupId.x) * ${c};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
          ${cS(s,r)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${r?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${u};

let tileRowA = i32(localId.y) * ${m};
let tileColA = i32(localId.x) * ${g};
let tileRowB = i32(localId.y) * ${y};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${g}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${cS(s,r)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${r?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${O9(s)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${d}>, ${f}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${c}>, ${i}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o?"0":"i32(globalId.z)"};
    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${o?`${Math.ceil(a/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${v}
  }
`},P9=(t,e,n,r,s=!1)=>{let[i,o,a,l]=r,u=si(r[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${_i(t,u)} {
      var value = ${_i(t,u)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${o.type.indices};
        ${fy("aIndices",o,o.rank-2,i.rank,"batchIndices")}
        ${o.indicesSet("aIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("aIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${_i(t,u)} {
      var value = ${_i(t,u)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${a.type.indices};
        ${fy("bIndices",a,a.rank-2,i.rank,"batchIndices")}
        ${a.indicesSet("bIndices",a.rank-2,"u32(row)")}
        ${a.indicesSet("bIndices",a.rank-1,"u32(colIn)")}
        value = ${a.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${_i(t,u)}) {
      let col = colIn * ${t};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${s?"bias[colIn]":`${_i(t,u)}(bias[row])`};`:""}
        ${n}
        ${l.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},ux=(t,e,n,r,s=!1,i)=>{let o=t[0].dims,a=t[1].dims,l=o.slice(0,-2),u=a.slice(0,-2),c=r?r.slice(0,-2):n.slice(0,-2),d=He.size(c),f=o[o.length-2],m=o[o.length-1],g=a[a.length-1],y=m%4===0&&g%4===0,v=f<=8?[4,1,1]:[4,4,1],b=[8,8,1],x=[Math.ceil(g/b[0]/v[0]),Math.ceil(f/b[1]/v[1]),Math.ceil(d/b[2]/v[2])],$=y?4:1,S=[...l,f,m/$],E=S.length,L=[...u,m,g/$],R=L.length,D=[d,f,g/$],A=[{type:6,data:f},{type:6,data:g},{type:6,data:m}];mf(e,A),A.push(...Ut(c,S,L));let F=["rank","rank"],P=t.length>2;P&&(A.push(...Ut(t[2].dims)),F.push("rank")),A.push(...Ut(D));let K=j=>{let se=c.length,fe=xR("batchDims",t[0].dataType,se,1),me=si(t[0].dataType),ye=Je("a",t[0].dataType,E,$),oe=Je("b",t[1].dataType,R,$),ue=Ft("result",t[0].dataType,D.length,$),_e=[ye,oe];if(P){let de=s?$:1;_e.push(Je("bias",t[2].dataType,t[2].dims.length,de))}let Y=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];gf(e,Y);let re=si(ue.type.tensor),Te=pf(e,ue.type.value,re),Pe=P9($,P,Te,[fe,ye,oe,ue],s);return`
  ${j.registerUniforms(Y).registerInternalVariables(fe).declareVariables(..._e,ue)}
  ${Pe}
  ${y?fC(v,b,me,fe):pC(v,b,me,fe)}
                   `};return{name:"MatMul",shaderCache:{hint:`${v};${e.activation};${y};${s}`,inputDependencies:F},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:t[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]},programUniforms:A}),getShaderSource:K}}}),F9,bK,MDe=ht(()=>{rn(),Tc(),In(),Pp(),$R(),LDe(),kR(),F9=(t,e,n,r,s=!1,i,o=4,a=4,l=4,u="f32")=>{let c=A=>{switch(A){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${A} is not supported.`)}},d=A=>{switch(A){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${A} is not supported.`)}},f=t?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,m=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,g=t?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",y=t?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",v=t?"row":"col",b=t?"col":"row",x=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${v} / outWidth;
    let outCol = ${v} % outWidth;

    let WRow = ${b} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${b} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${b} % inChannels;
    var resData = ${_i(o,u)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${g} && xCol >= 0 && xCol < ${y}) {
      ${f}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${c(o)}
    }
    return resData;`,$=t?e&&r?`
    let col = colIn * ${o};
    ${x}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${x}
    }
    return ${_i(o,u)}(0.0);`:r&&n?`
    let col = colIn * ${o};
    ${x}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${x}
    }
    return ${_i(o,u)}(0.0);`,S=t?r&&n?d(a):`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${d(a)}
    }
    return ${_i(a,u)}(0.0);`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${d(a)}
    }
    return ${_i(a,u)}(0.0);`,E=_i(l,u),L=_i(t?o:a,u),R=_i(t?a:o,u),D=pf(i,E,u);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${L} {
      ${t?$:S}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${R} {
      ${t?S:$}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${E}) {
      let col = colIn * ${l};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${m}
      ${wK(s)}
      ${D}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},bK=(t,e,n,r,s,i,o,a,l)=>{let u=e.format==="NHWC",c=u?t[0].dims[3]:t[0].dims[1],d=n[0],f=u?n[2]:n[3],m=u?n[1]:n[2],g=u?n[3]:n[1],y=u&&(c%4===0||c%3===0)&&g%4===0,v=u?g:f*m,b=u?f*m:g,x=[8,8,1],$=r<=8?[4,1,1]:[4,4,1],S=[Math.ceil(v/x[0]/$[0]),Math.ceil(b/x[1]/$[1]),Math.ceil(d/x[2]/$[2])];qn("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${S}`);let E=y?u&&c%4!==0?3:4:1,L=x[1]*$[1],R=x[0]*$[0],D=Math.max(x[0]*E,x[1]),A=r%L===0,F=s%R===0,P=i%D===0,K=y?[E,4,4]:[1,1,1],j=[{type:6,data:r},{type:6,data:s},{type:6,data:i},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];mf(e,j),j.push(...Ut(t[0].dims,t[1].dims));let se=["rank","rank"];o&&(j.push(...Ut(t[2].dims)),se.push("rank")),j.push(...Ut(n));let fe=me=>{let ye=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];gf(e,ye);let oe=y?4:1,ue=si(t[0].dataType),_e=`
      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${ue}>`:ue}) {
        result[flatIndex] = ${y?`vec4<${ue}>`:ue}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${ue}>`:ue}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);
      }`,Y=Je("x",t[0].dataType,t[0].dims.length,E===3?1:E),re=Je("w",t[1].dataType,t[1].dims.length,oe),Te=[Y,re],Pe=Ft("result",t[0].dataType,n.length,oe);if(o){let de=Je("bias",t[2].dataType,t[2].dims.length,oe);Te.push(de),_e+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${ue}>`:ue} {
          return bias[coords.${u?"w":"y"}${y?"/ 4":""}];
        }`}return`
        ${vK("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${me.registerUniforms(ye).declareVariables(...Te,Pe)}
        ${_e}
        ${F9(u,A,F,P,o,e,K[0],K[1],K[2],ue)}
        ${y?fC($,x,ue,void 0,!u,D):pC($,x,ue,void 0,!u,D,!1,void 0,a)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${E};${y};${A};${F};${P};${L};${R};${D}`,inputDependencies:se},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:t[0].dataType}],dispatchGroup:{x:S[0],y:S[1],z:S[2]},programUniforms:j}),getShaderSource:fe}}}),L9,hS,D2,M9,dS,z9,xK,_K,zDe=ht(()=>{rn(),Tc(),vn(),In(),Pp(),$R(),L9=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e},hS=t=>typeof t=="number"?[t,t,t]:t,D2=(t,e)=>e<=1?t:t+(t-1)*(e-1),M9=(t,e,n,r=1)=>{let s=D2(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)},dS=(t,e,n,r,s)=>{s==null&&(s=M9(t,e[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)t[o]+2*s>=e[o]&&(i[o]=Math.trunc((t[o]-e[o]+2*s)/r[o]+1));return i},z9=(t,e,n,r,s,i,o,a,l,u)=>{let c,d,f,m;if(t==="VALID"&&(t=0),typeof t=="number"){c={top:t,bottom:t,left:t,right:t,front:t,back:t};let g=dS([e,n,r,1],[a,l,u],1,[s,i,o],t);d=g[0],f=g[1],m=g[2]}else if(Array.isArray(t)){if(!t.every((y,v,b)=>y===b[0]))throw Error(`Unsupported padding parameter: ${t}`);c={top:t[0],bottom:t[1],left:t[2],right:t[3],front:t[4],back:t[5]};let g=dS([e,n,r,1],[a,l,u],1,[s,i,o],t[0]);d=g[0],f=g[1],m=g[2]}else if(t==="SAME_UPPER"){d=Math.ceil(e/s),f=Math.ceil(n/i),m=Math.ceil(r/o);let g=(d-1)*s+a-e,y=(f-1)*i+l-n,v=(m-1)*o+u-r,b=Math.floor(g/2),x=g-b,$=Math.floor(y/2),S=y-$,E=Math.floor(v/2),L=v-E;c={top:$,bottom:S,left:E,right:L,front:b,back:x}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outDepth:d,outHeight:f,outWidth:m}},xK=(t,e,n,r,s,i=!1,o="channelsLast")=>{let a,l,u,c,d;if(o==="channelsLast")[a,l,u,c,d]=t;else if(o==="channelsFirst")[a,d,l,u,c]=t;else throw new Error(`Unknown dataFormat ${o}`);let[f,,m,g,y]=e,[v,b,x]=hS(n),[$,S,E]=hS(r),L=D2(m,$),R=D2(g,S),D=D2(y,E),{padInfo:A,outDepth:F,outHeight:P,outWidth:K}=z9(s,l,u,c,v,b,x,L,R,D),j=i?f*d:f,se=[0,0,0,0,0];return o==="channelsFirst"?se=[a,j,F,P,K]:o==="channelsLast"&&(se=[a,F,P,K,j]),{batchSize:a,dataFormat:o,inDepth:l,inHeight:u,inWidth:c,inChannels:d,outDepth:F,outHeight:P,outWidth:K,outChannels:j,padInfo:A,strideDepth:v,strideHeight:b,strideWidth:x,filterDepth:m,filterHeight:g,filterWidth:y,effectiveFilterDepth:L,effectiveFilterHeight:R,effectiveFilterWidth:D,dilationDepth:$,dilationHeight:S,dilationWidth:E,inShape:t,outShape:se,filterShape:e}},_K=(t,e,n,r,s,i)=>{let o=i==="channelsLast";o?t[0].dims[3]:t[0].dims[1];let a=[64,1,1],l={x:n.map((v,b)=>b)},u=[Math.ceil(L9(l.x.map(v=>n[v]))/a[0]),1,1];qn("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let c=1,d=He.size(n),f=[{type:12,data:d},{type:12,data:r},{type:12,data:s},{type:12,data:e.strides},{type:12,data:e.dilations}];mf(e,f),f.push(...Ut(t[0].dims,t[1].dims));let m=["rank","rank"],g=t.length===3;g&&(f.push(...Ut(t[2].dims)),m.push("rank")),f.push(...Ut(n));let y=v=>{let b=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:e.strides.length},{name:"dilations",type:"u32",length:e.dilations.length}];gf(e,b);let x=1,$=si(t[0].dataType),S=Je("x",t[0].dataType,t[0].dims.length,c),E=Je("W",t[1].dataType,t[1].dims.length,x),L=[S,E],R=Ft("result",t[0].dataType,n.length,x),D="";if(g){let P=Je("bias",t[2].dataType,t[2].dims.length,x);L.push(P),D+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${$} {
          return bias[${o?Mt("coords",4,5):Mt("coords",1,5)}];
        }`}let A=_i(c,$),F=pf(e,A,$);return`
            ${D}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${S.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${E.getByIndices("aIndices")};
            }
          ${v.registerUniforms(b).declareVariables(...L,R)}
          ${v.mainStart()}
          ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${R.offsetToIndices("global_idx")};
              let batch = ${Mt("coords",0,S.rank)};
              let d2 = ${o?Mt("coords",S.rank-1,S.rank):Mt("coords",1,S.rank)};
              let xFRCCorner = vec3<u32>(${o?Mt("coords",1,S.rank):Mt("coords",2,S.rank)},
              ${o?Mt("coords",2,S.rank):Mt("coords",3,S.rank)},
              ${o?Mt("coords",3,S.rank):Mt("coords",4,S.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${o?Mt("uniforms.x_shape",1,S.rank):Mt("uniforms.x_shape",2,S.rank)};
              let xShapeZ = ${o?Mt("uniforms.x_shape",2,S.rank):Mt("uniforms.x_shape",3,S.rank)};
              let xShapeW = ${o?Mt("uniforms.x_shape",3,S.rank):Mt("uniforms.x_shape",4,S.rank)};
              let xShapeU = ${o?Mt("uniforms.x_shape",4,S.rank):Mt("uniforms.x_shape",1,S.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${o?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${o?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${o?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${o?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${g?"value = value + getBiasByOutputCoords(coords)":""};
              ${F}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${e.cacheKey};${o};${c};${g}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:f}),getShaderSource:y}}}),IK,TK,VDe=ht(()=>{rn(),vn(),In(),Pp(),IK=(t,e,n,r)=>{let s=t.length>2,i=s?"value += b[output_channel];":"",o=t[0].dims,a=t[1].dims,l=e.format==="NHWC",u=l?n[3]:n[1],c=u/e.group,d=l&&c>=4?Jr(u):1,f=He.size(n)/d,m=[{type:12,data:f},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:c}];mf(e,m),m.push(...Ut(o,[a[0],a[1],a[2],a[3]/d]));let g=s?["rank","rank","rank"]:["rank","rank"];m.push(...Ut([n[0],n[1],n[2],n[3]/d]));let y=v=>{let b=Ft("output",t[0].dataType,n.length,d),x=si(b.type.tensor),$=pf(e,b.type.value,x),S=Je("x",t[0].dataType,o.length),E=Je("w",t[1].dataType,a.length,d),L=[S,E];s&&L.push(Je("b",t[2].dataType,t[2].dims,d));let R=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];gf(e,R);let D=l?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${S.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${E.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${S.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${E.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${v.registerUniforms(R).declareVariables(...L,b)}

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${b.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${d} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];

    var value: ${b.type.value} = ${b.type.value}(0);
    ${D}
    ${i}
    ${$}
    ${b.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${e.cacheKey}_${d}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:m}),getShaderSource:y}},TK=(t,e,n,r)=>{let s=t.length>2,i=Jr(n[3]),o=Jr(n[2]),a=He.size(n)/i/o,l=[t[0].dims[0],t[0].dims[1],t[0].dims[2],t[0].dims[3]/i],u=[t[1].dims[0],t[1].dims[1],t[1].dims[2],t[1].dims[3]/i],c=[n[0],n[1],n[2],n[3]/i],d=[{type:12,data:a},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];mf(e,d),d.push(...Ut(l,u,c));let f=(o-1)*e.strides[1]+u[1],m=g=>{let y=Ft("output",t[0].dataType,c.length,i),v=si(y.type.tensor),b=pf(e,y.type.value,v),x=Je("x",t[0].dataType,l.length,i),$=Je("w",t[1].dataType,u.length,i),S=[x,$];s&&S.push(Je("b",t[2].dataType,t[2].dims,i));let E=s?"value += b[output_channel];":"",L=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return gf(e,L),`
  ${g.registerUniforms(L).declareVariables(...S,y)}
  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${f}>;
    var values: array<${y.type.value}, ${o}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${f}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {
          let w_val = ${$.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${o}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${o}u; i++) {
      var value = values[i];
      ${E}
      ${b}
      ${y.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${i};${o};${f};${u[0]};${u[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d}),getShaderSource:m}}}),V9,Nv,B9,Av,mC,fS,U9,W9,gC,BDe=ht(()=>{vn(),MDe(),zDe(),kR(),VDe(),Pp(),ER(),Zh(),V9=(t,e,n,r,s,i)=>{let o=t[0],a=t.slice(i?1:2,i?3:4),l=a.length,u=e[0],c=e.slice(2).map((f,m)=>f+(f-1)*(n[m]-1)),d=a.map((f,m)=>f+r[m]+r[m+l]).map((f,m)=>Math.floor((f-c[m]+s[m])/s[m]));return d.splice(0,0,o),d.splice(i?3:1,0,u),d},Nv=[2,3,1,0],B9=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length>5)throw new Error("greater than 5D is not supported");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],r=t[1].dims[1]*e.group;if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let s=t[0].dims.length-2;if(e.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(e.strides.length!==s)throw new Error(`strides should be ${s}D`);if(e.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},Av=(t,e)=>{let n=t.kernelShape.slice();n.length<e[1].dims.length-2&&n.push(...Array(e[1].dims.length-2-n.length).fill(0));for(let i=2;i<e[1].dims.length;++i)n[i-2]===0&&(n[i-2]=e[1].dims[i]);let r=t.pads.slice();ax.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,r,t.format==="NHWC",t.autoPad);let s=Object.assign({},t);return Object.assign(s,{kernelShape:n,pads:r}),s},mC=t=>{let e=SR(t),n=t.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],s=t.dilations,i=t.group,o=t.kernel_shape,a=t.pads,l=t.strides,u=t.w_is_const();return{autoPad:r,format:n,dilations:s,group:i,kernelShape:o,pads:a,strides:l,wIsConst:u,...e,cacheKey:`${t.format};${e.activation};`}},fS=(t,e,n,r)=>{let s=n.format==="NHWC",i=V9(e[0].dims,e[1].dims,n.dilations,n.pads,n.strides,s);if(n.group!==1){let L=[e[0]];if(s){let R=t.kernelCustomData.wT??t.compute(Ea(e[1],Nv),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=R),L.push(R)}else L.push(e[1]);e.length===3&&L.push(e[2]),!t.adapterInfo.isArchitecture("ampere")&&s&&e[1].dims[0]===n.group&&e[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?t.compute(TK(L,n,i,r),{inputs:L}):t.compute(IK(L,n,i,r),{inputs:L});return}let o=e.length===3,a=e[0].dims[s?1:2],l=e[0].dims[s?2:3],u=e[0].dims[s?3:1],c=e[1].dims[2],d=e[1].dims[3],f=i[s?1:2],m=i[s?2:3],g=i[s?3:1],y=s&&c===a&&d===l&&n.pads[0]===0&&n.pads[1]===0;if(y||c===1&&d===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let L=i[0],R,D,A,F=[];if(s){let j=t.kernelCustomData.wT??t.compute(Ea(e[1],Nv),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=j),y){let se=a*l*u;R=e[0].reshape([1,L,se]),D=j.reshape([1,se,g]),A=[1,L,g]}else R=e[0].reshape([L,a*l,u]),D=j.reshape([1,u,g]),A=[L,f*m,g];F.push(R),F.push(D)}else R=e[0].reshape([L,u,a*l]),D=e[1].reshape([1,g,u]),A=[L,g,f*m],F.push(D),F.push(R);o&&F.push(e[2]);let P=A[2],K=F[0].dims[F[0].dims.length-1];P<8&&K<8?t.compute(CR(F,n,i,A,s,r),{inputs:F}):t.compute(ux(F,n,i,A,s,r),{inputs:F});return}let v=!0,b=t.kernelCustomData.wT??t.compute(Ea(e[1],Nv),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=b);let x=[e[0],b];o&&x.push(e[2]);let $=s?f*m:g,S=s?g:f*m,E=c*d*u;t.compute(bK(x,n,i,$,S,E,o,v,r),{inputs:x})},U9=(t,e)=>{let n=e.format==="NHWC",r=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&r.push(t.inputs[2]);let s=[0,e.pads[0],0,e.pads[1]],i=[1].concat(e.strides),o=[1].concat(e.dilations),a=[1].concat(e.kernelShape),l=Av({...e,pads:s,strides:i,dilations:o,kernelShape:a},r);fS(t,r,l,u=>n?[u[0],u[2],u[3]]:[u[0],u[1],u[3]])},W9=(t,e,n)=>{let r=n.format==="NHWC"?"channelsLast":"channelsFirst",s=Av(n,e),i=n.autoPad==="NOTSET"?n.pads:n.autoPad,o=xK(e[0].dims,e[1].dims,n.strides,n.dilations,i,!1,r);t.compute(_K(e,s,o.outShape,[o.filterDepth,o.filterHeight,o.filterWidth],[o.padInfo.front,o.padInfo.top,o.padInfo.left],r))},gC=(t,e)=>{if(B9(t.inputs,e),t.inputs[0].dims.length===3)U9(t,e);else if(t.inputs[0].dims.length===5)W9(t,t.inputs,e);else{let n=Av(e,t.inputs);fS(t,t.inputs,n)}}}),SK,UDe=ht(()=>{rn(),Tc(),vn(),In(),SK=(t,e,n)=>{let r=t.length>2,s=e.outputShape,i=e.format==="NHWC",o=e.group,a=t[1].dims,l=a[2]/o,u=a[3],c=i?Jr(l):1,d=i&&u===1&&l>=4,f=d?Math.floor(l/4)*4:Math.floor(l/c)*c,m=l-f,g=i?Jr(u):1,y=i?u===1?c:g:1,v=He.size(s)/g,b=[Math.ceil(v/64),1,1];qn("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${b}`);let x=["rank","rank"],$=[e.strides[0],e.strides[1]],S=[e.kernelShape[i?1:2],e.kernelShape[i?2:3]],E=[e.dilations[0],e.dilations[1]],L=[S[0]+(e.dilations[0]<=1?0:(e.kernelShape[i?1:2]-1)*(e.dilations[0]-1)),S[1]+(e.dilations[1]<=1?0:(e.kernelShape[i?2:3]-1)*(e.dilations[1]-1))],R=[L[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),L[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],D=[{type:12,data:v},{type:12,data:$},{type:12,data:S},{type:12,data:E},{type:12,data:L},{type:6,data:R},{type:12,data:f},{type:12,data:l},{type:12,data:u},...Ut(t[0].dims,t[1].dims)];r&&(D.push(...Ut(t[2].dims)),x.push("rank")),D.push(...Ut(s));let A=F=>{let P=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:$.length},{name:"filter_dims",type:"u32",length:S.length},{name:"dilations",type:"u32",length:S.length},{name:"effective_filter_dims",type:"u32",length:L.length},{name:"pads",type:"i32",length:R.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],K=si(t[0].dataType),j=i?1:2,se=i?2:3,fe=i?3:1,me=Je("W",t[1].dataType,t[1].dims.length,y),ye=Je("Dy",t[0].dataType,t[0].dims.length,c),oe=[ye,me];r&&oe.push(Je("bias",t[2].dataType,[s[fe]].length,g));let ue=Ft("result",t[0].dataType,s.length,g),_e=()=>{let Te="";if(d)c===4?Te+=`
        let xValue = ${ye.getByOffset("x_offset")};
        let wValue = ${me.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:c===2?Te+=`
          dotProd = dotProd + dot(vec4<${K}>(${ye.getByOffset("x_offset")}, ${ye.getByOffset("x_offset + 1u")}), vec4<${K}>(${me.getByOffset("w_offset")}, ${me.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:c===1&&(Te+=`
          dotProd = dotProd + dot(vec4<${K}>(${ye.getByOffset("x_offset")}, ${ye.getByOffset("x_offset + 1u")}, ${ye.getByOffset("x_offset + 2u")}, ${ye.getByOffset("x_offset + 3u")}), vec4<${K}>(${me.getByOffset("w_offset")}, ${me.getByOffset("w_offset + 1u")}, ${me.getByOffset("w_offset + 2u")}, ${me.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(Te+=`
                  let xValue = ${i?ye.getByOffset(`${ye.indicesToOffset(`${ye.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c}`):ye.get("batch","inputChannel","idyR","idyC")};
        `,c===1)Te+=`
          let w_offset = ${me.indicesToOffset(`${me.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${me.getByOffset(`w_offset / ${y}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let Pe=0;Pe<c;Pe++)Te+=`
            let wValue${Pe} = ${me.getByOffset(`${me.indicesToOffset(`${me.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${Pe}, wOutChannel)`)} / ${y}`)};
            dotProd = dotProd + xValue[${Pe}] * wValue${Pe};`;return Te},Y=()=>{if(m===0)return"";if(!d)throw new Error(`packInputAs4 ${d} is not true.`);let Te="";if(c===1){Te+="dotProd = dotProd";for(let Pe=0;Pe<m;Pe++)Te+=`
            + ${ye.getByOffset(`x_offset + ${Pe}`)} * ${me.getByOffset(`w_offset + ${Pe}`)}`;Te+=";"}else if(c===2){if(m!==2)throw new Error(`Invalid inputChannelsRemainder ${m}.`);Te+=`
          let xValue = ${ye.getByOffset("x_offset")};
          let wValue = ${me.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return Te},re=`
            let outputIndices = ${ue.offsetToIndices(`global_idx * ${g}`)};
            let batch = ${ue.indicesGet("outputIndices",0)};
            let d1 = ${ue.indicesGet("outputIndices",fe)};
            let r = ${ue.indicesGet("outputIndices",j)};
            let c = ${ue.indicesGet("outputIndices",se)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${ue.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${K}(dyRCorner) + ${K}(wR)) / ${K}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${K}(uniforms.Dy_shape[${j}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${K}(dyCCorner) + ${K}(wC)) / ${K}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${K}(uniforms.Dy_shape[${se}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${d?`
                var x_offset = ${ye.indicesToOffset(`${ye.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c};
                var w_offset = ${me.indicesToOffset(`${me.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${y};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${d?4:c}) {
                  ${_e()}
                  inputChannel = inputChannel + ${d?4:c};
                }
                ${Y()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${r?` + bias[d1 / ${g}]`:""};
            ${ue.setByOffset("global_idx","value")};
          `;return`
    ${F.registerUniforms(P).declareVariables(...oe,ue)}
      ${F.mainStart()}
      ${F.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${re}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};${c}${y}${g}${d}${m}`,inputDependencies:x},getRunData:()=>({dispatchGroup:{x:b[0],y:b[1],z:b[2]},outputs:[{dims:n?n(s):s,dataType:t[0].dataType}],programUniforms:D}),getShaderSource:A}}}),j9,G9,H9,pS,$K,q9,mS,K9,CK,WDe=ht(()=>{UDe(),Pp(),Zh(),j9=(t,e,n,r,s,i)=>(t-1)*e+n+(r-1)*s+1-i,G9=(t,e,n,r,s)=>{let i=Math.floor(t/2);e==="SAME_UPPER"?(n[r]=i,n[s]=t-i):e==="SAME_LOWER"&&(n[r]=t-i,n[s]=i)},H9=(t,e,n,r,s,i,o,a,l,u)=>{let c=t.length-2,d=u.length===0;l.length<c&&l.push(...Array(c-l.length).fill(0));let f=t[0],m=e[a?3:1]*s;for(let g=0,y=t.length-c-(a?1:0);g<c;++g,++y){let v=t[y],b=d?v*o[g]:u[g],x=j9(v,o[g],i[g],e[y],n[g],b);G9(x,r,i,g,g+c),d&&u.push(o[g]*(v-1)+l[g]+(e[y]-1)*n[g]+1-i[g]-i[g+c])}u.splice(0,0,f),u.splice(a?3:1,0,m)},pS=(t,e)=>{let n=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((d,f)=>d*f,1)===0){n.length=0;for(let d=2;d<e[1].dims.length;++d)n.push(e[1].dims[d])}let r=t.format==="NHWC";n.splice(0,0,e[1].dims[0]),n.splice(r?3:1,0,e[1].dims[1]);let s=t.pads.slice(),i=t.outputShape.slice(),o=t.outputPadding.slice(),a=e[0].dims,l=t.dilations.slice();if(l.reduce((d,f)=>d+f,0)===0){let d=e[0].dims.length-2;l=new Array(d).fill(1)}let u=t.strides.slice();if(u.reduce((d,f)=>d+f,0)===0){let d=e[0].dims.length-2;u=new Array(d).fill(1)}H9(a,n,l,t.autoPad,t.group,s,u,r,o,i);let c=Object.assign({},t);return Object.assign(c,{kernelShape:n,pads:s,outputPadding:o,outputShape:i,dilations:l,strides:u}),c},$K=t=>{let e=SR(t),n=t.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],s=t.dilations,i=t.group,o=t.kernelShape,a=t.pads,l=t.strides,u=t.wIsConst(),c=t.outputPadding,d=t.outputShape;return{autoPad:r,format:n,dilations:s,group:i,kernelShape:o,outputPadding:c,outputShape:d,pads:a,strides:l,wIsConst:u,...e,cacheKey:`${t.format};${e.activation};`}},q9=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],r=t[1].dims[0];if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let s=t[1].dims[1]*e.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==s))throw new Error("invalid bias");let i=t[0].dims.length-2;if(e.dilations.reduce((o,a)=>o+a,0)>0&&e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.reduce((o,a)=>o+a,0)>0&&e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.reduce((o,a)=>o+a,0)>0&&e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.reduce((o,a)=>o+a,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},mS=(t,e,n,r)=>{let s=t.kernelCustomData.wT??t.compute(Ea(e[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=s);let i=[e[0],s];e.length===3&&i.push(e[2]),t.compute(SK(i,n,r),{inputs:i})},K9=(t,e)=>{let n=e.format==="NHWC",r=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&r.push(t.inputs[2]);let s=e.kernelShape;(s.length===0||s[0]===0)&&(s=[t.inputs[1].dims[2]]);let i=e.dilations;(i.length===0||i[0]===0)&&(i=[1]);let o=e.strides;(o.length===0||o[0]===0)&&(o=[1]);let a=e.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],o=[1].concat(o),i=[1].concat(i),s=[1].concat(s);let l=e.outputPadding;l=[0].concat(l);let u=pS({...e,pads:a,strides:o,dilations:i,kernelShape:s,outputPadding:l},r);mS(t,r,u,c=>n?[c[0],c[2],c[3]]:[c[0],c[1],c[3]])},CK=(t,e)=>{if(q9(t.inputs,e),t.inputs[0].dims.length===3)K9(t,e);else{let n=pS(e,t.inputs);mS(t,t.inputs,n)}}}),X9,EK,kK,jDe=ht(()=>{rn(),vn(),us(),In(),X9=(t,e,n,r)=>{let s=He.size(e),i=e.length,o=Je("input",t,i),a=Ft("output",t,i),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=He.normalizeAxis(l,i),c=d=>{let f=` i32(${o.indicesGet("inputIndices","uniforms.axis")}) `,m=Mt("uniforms.input_shape","uniforms.axis",i),g=r.reverse?f+(r.exclusive?" + 1":""):"0",y=r.reverse?m:f+(r.exclusive?"":" + 1");return`
                ${d.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(o,a)}
                ${d.mainStart()}
                  ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${a.offsetToIndices("global_idx")};
                  var sum = ${a.type.value}(0);
                  let first : i32 = ${g};
                  let last : i32 = ${y};
                  for (var i : i32 = first; i < last; i++) {
                    ${o.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${o.getByIndices("inputIndices")};
                  }
                  ${a.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:u},...Ut(e,e)]}),getShaderSource:c}},EK=(t,e)=>{let n=t.inputs[0].dims,r=t.inputs[0].dataType,s=t.inputs[1];t.compute(X9(r,n,s,e),{inputs:[0]})},kK=t=>{let e=t.exclusive===1,n=t.reverse===1;return ur({exclusive:e,reverse:n})}}),Y9,Q9,J9,NK,AK,GDe=ht(()=>{rn(),vn(),us(),In(),Y9=t=>{if(!t||t.length!==1)throw new Error("DepthToSpace requires 1 input.");if(t[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Q9=(t,e,n,r)=>{let s=[];s.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let i=0;i<e;++i)s.push(n.indicesSet("a",t[i],`i[${i}]`));return s.push("return a;}"),s.join(`
`)},J9=(t,e)=>{let n,r,s,i,o,a,l=e.format==="NHWC",u=e.blocksize,c=e.mode==="DCR";l?([n,r,s,i]=t.dims,o=c?[n,r,s,u,u,i/u**2]:[n,r,s,i/u**2,u,u],a=c?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,s,i]=[t.dims[0],t.dims[2],t.dims[3],t.dims[1]],o=c?[n,u,u,i/u**2,r,s]:[n,i/u**2,u,u,r,s],a=c?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let d=t.reshape(o),f=d.dims.length,m=t.dataType,g=Je("a",m,f),y=Ft("output",m,f),v=b=>`
  ${b.registerUniform("output_size","u32").declareVariables(g,y)}

  ${Q9(a,f,g,y)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${y.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${y.setByOffset("global_idx",g.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${t.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:b=>{let x=l?[n,r*u,s*u,i/u**2]:[n,i/u**2,r*u,s*u],$=He.size(x),S=d.dims,E=He.sortBasedOnPerm(S,a);return{outputs:[{dims:x,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:[{type:12,data:$},...Ut(S,E)]}},getShaderSource:v}},NK=(t,e)=>{Y9(t.inputs),t.compute(J9(t.inputs[0],e))},AK=t=>ur({blocksize:t.blocksize,mode:t.mode,format:t.format})}),Rv,O2,gS,Z9,e7,t7,n7,yS,r7,RK,DK,HDe=ht(()=>{rn(),vn(),us(),In(),Rv="[a-zA-Z]|\\.\\.\\.",O2="("+Rv+")+",gS="^"+O2+"$",Z9="("+O2+",)*"+O2,e7="^"+Z9+"$",t7=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,e){let n=this.symbolToIndices.get(t);n===void 0?n=[e]:n.push(e),this.symbolToIndices.set(t,n)}},n7=class{constructor(t,e){this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=e.includes("->")?e.split("->",2):[e,""];if(!n.match(RegExp(e7)))throw new Error("Invalid LHS term");if(n.split(",").forEach((s,i)=>{let o=t[i].dims.slice();if(!s.match(RegExp(gS)))throw new Error("Invalid LHS term");let a=this.processTerm(s,!0,o,i);this.lhs.push(a)}),r==="")r+=[...this.symbolToInfo.entries()].filter(([s,i])=>i.count===1||s==="...").map(([s])=>s).join("");else if(!r.match(RegExp(O2)))throw new Error("Invalid RHS");r.match(RegExp(Rv,"g"))?.forEach(s=>{if(s==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let i=this.symbolToInfo.get(s);if(i===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(i.dimValue)}}),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(t,e,n){let r=this.symbolToInfo.get(t);if(r!==void 0){if(r.dimValue!==e&&r.count!==1)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:e,inputIndices:[n]};this.symbolToInfo.set(t,r)}processTerm(t,e,n,r=-1){let s=n.length,i=!1,o=[],a=0;if(!t.match(RegExp(gS))&&!e&&t!=="")throw new Error("Invalid LHS term");let l=t.match(RegExp(Rv,"g")),u=new t7(r);return l?.forEach((c,d)=>{if(c==="..."){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let f=s-l.length+1;if(f<0)throw new Error("Ellipsis out of bounds");if(o=n.slice(a,a+f),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=o;else throw new Error("Ellipsis must be specified in the LHS");for(let m=0;m<o.length;m++){let g=String.fromCharCode(48+m);u.addSymbol(g,d+m),this.addSymbol(g,n[a++],r)}}else u.addSymbol(c,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(c,n[a++],r)}),u}},yS=t=>t+"_max",r7=(t,e,n,r)=>{let s=t.map(u=>u.length).map((u,c)=>Je(`input${c}`,e,u)),i=He.size(r),o=Ft("output",e,r.length),a=[...n.symbolToInfo.keys()].filter(u=>!n.rhs.symbolToIndices.has(u)),l=u=>{let c=[],d="var prod = 1.0;",f="var sum = 0.0;",m="sum += prod;",g=[],y=[],v=[],b=[],x=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((S,E)=>{if(n.rhs.symbolToIndices.has(E)){let L=n.rhs.symbolToIndices.get(E)?.[0];L!==void 0&&n.lhs.forEach((R,D)=>{if(S.inputIndices.includes(D)){let A=R.symbolToIndices.get(E);if(A===void 0)throw new Error("Invalid symbol error");A.forEach(F=>{c.push(`${s[D].indicesSet(`input${D}Indices`,F,o.indicesGet("outputIndices",L))}`)})}})}else n.lhs.forEach((L,R)=>{if(S.inputIndices.includes(R)){let D=L.symbolToIndices.get(E);if(D===void 0)throw new Error("Invalid symbol error");D.forEach(A=>{g.push(`${s[R].indicesSet(`input${R}Indices`,A,`${E}`)}`)}),b.push(`prod *= ${s[R].getByIndices(`input${R}Indices`)};`)}}),y.push(`for(var ${E}: u32 = 0; ${E} < uniforms.${yS(E)}; ${E}++) {`),v.push("}")});let $=x?[...c,`let sum = ${s.map((S,E)=>S.getByIndices(`input${E}Indices`)).join(" * ")};`]:[...c,f,...y,...g,d,...b,m,...v];return`
            ${u.registerUniforms(a.map(S=>({name:`${yS(S)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...s,o)}

            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${o.offsetToIndices("global_idx")};
            ${s.map((S,E)=>`var input${E}Indices: ${s[E].type.indices};`).join(`
`)}
            ${$.join(`
`)};
            ${o.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:t.map(()=>"rank")},getRunData:()=>{let u=a.filter(d=>n.symbolToInfo.has(d)).map(d=>({type:12,data:n.symbolToInfo.get(d)?.dimValue||0}));u.push({type:12,data:i});let c=t.map((d,f)=>[...Ut(d)]).reduce((d,f)=>d.concat(f),u);return c.push(...Ut(r)),{outputs:[{dims:r,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:c}},getShaderSource:l}},RK=(t,e)=>{let n=new n7(t.inputs,e.equation),r=n.outputDims,s=t.inputs.map((i,o)=>i.dims);t.compute(r7(s,t.inputs[0].dataType,n,r))},DK=t=>{let e=t.equation.replace(/\s+/g,"");return ur({equation:e})}}),s7,wS,i7,o7,OK,qDe=ht(()=>{rn(),vn(),In(),s7=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),r=n.length<e.length?0:n.length-e.length,s=e.length<n.length?0:e.length-n.length;for(;r<n.length&&s<e.length;++r,++s)if(n[r]!==e[s]&&n[r]!==1&&e[s]!==1)throw new Error("Expand requires shape to be broadcastable to input")},wS=(t,e)=>{let n=t.length-e.length,r=[];for(let s=0;s<n;++s)r.push(t[s]);for(let s=0;s<e.length;++s)r.push(e[s]===1?t[s+n]:e[s]);return r},i7=(t,e)=>t.length>e.length?wS(t,e):wS(e,t),o7=t=>{let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),r=i7(e,n),s=t[0].dataType,i=s===9||He.size(e)===1,o=s===9||e.length>0&&e[e.length-1]%4===0?4:1,a=i||r.length>0&&r[r.length-1]%4===0?4:1,l=Math.ceil(He.size(r)/a),u=d=>{let f=Je("input",s,e.length,o),m=Ft("output",s,r.length,a),g;if(s===9){let y=(v,b,x="")=>`
          let outputIndices${b} = ${m.offsetToIndices(`outputOffset + ${b}u`)};
          let offset${b} = ${f.broadcastedIndicesToOffset(`outputIndices${b}`,m)};
          let index${b} = offset${b} / 4u;
          let component${b} = offset${b} % 4u;
          ${v}[${b}] = ${x}(${f.getByOffset(`index${b}`)}[component${b}]);
        `;g=`
        let outputOffset = global_idx * ${a};
        var data = vec4<u32>(0);
        ${y("data",0,"u32")}
        ${y("data",1,"u32")}
        ${y("data",2,"u32")}
        ${y("data",3,"u32")}
        ${m.setByOffset("global_idx","data")}
      }`}else g=`
        let outputIndices = ${m.offsetToIndices(`global_idx * ${a}`)};
        let inputOffset = ${f.broadcastedIndicesToOffset("outputIndices",m)};
        let data = ${m.type.value}(${f.getByOffset(`inputOffset / ${o}`)});
        ${m.setByOffset("global_idx","data")}
      }`;return`
    ${d.registerUniform("vec_size","u32").declareVariables(f,m)}
    ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${g}`},c=[{type:12,data:l},...Ut(e,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${o}${a}`,inputDependencies:["rank"]},getShaderSource:u,getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c})}},OK=t=>{s7(t.inputs),t.compute(o7(t.inputs),{inputs:[0]})}}),a7,PK,KDe=ht(()=>{rn(),vn(),In(),TR(),a7=t=>{let e=t[0].dataType,n=He.size(t[0].dims),r=He.size(t[1].dims),s=r%4===0,i=o=>{let a=Je("x",e,[1],4),l=Je("bias",e,[1],4),u=Ft("y",e,[1],4),c=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],d=m=>`
      let bias${m}_offset: u32 = (global_idx * 4 + ${m}) % uniforms.bias_size;
      let bias${m} = ${l.getByOffset(`bias${m}_offset / 4`)}[bias${m}_offset % 4];`,f=s?`
      let bias = ${l.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${d(0)}${d(1)}${d(2)}${d(3)}
      let bias = ${a.type.value}(bias0, bias1, bias2, bias3);`;return`${o.registerUniforms(c).declareVariables(a,l,u)}

    ${hC(oo(e))}

    ${o.mainStart(Jm)}
      ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${a.getByOffset("global_idx")};
      ${f}
      let x_in = x + bias;
      ${u.setByOffset("global_idx",dC("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:i,getRunData:o=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/Jm/4)}})}},PK=t=>{t.inputs.length<2||He.size(t.inputs[1].dims)===0?tK(t):t.compute(a7(t.inputs))}}),l7,u7,FK,LK,XDe=ht(()=>{rn(),vn(),us(),In(),l7=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},u7=(t,e)=>{let n=t[0].dims,r=t[1].dims,s=n.length,i=He.normalizeAxis(e.axis,s),o=n.slice(0);o.splice(i,1,...r);let a=n[i],l=t[0].dataType===9?4:1,u=Math.ceil(He.size(o)/l),c=[{type:12,data:u},{type:6,data:a},{type:12,data:i},...Ut(t[0].dims,t[1].dims,o)],d=f=>{let m=Je("data",t[0].dataType,t[0].dims.length,l),g=Je("inputIndices",t[1].dataType,t[1].dims.length),y=Ft("output",t[0].dataType,o.length,l),v=x=>{let $=r.length,S=`var indicesIndices${x}  = ${g.type.indices}(0);`;for(let E=0;E<$;E++)S+=`${$>1?`indicesIndices${x}[${E}]`:`indicesIndices${x}`} = ${o.length>1?`outputIndices${x}[uniforms.axis + ${E}]`:`outputIndices${x}`};`;S+=`
          var idx${x} = ${g.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${m.type.indices};
        `;for(let E=0,L=0;E<s;E++)E===i?(S+=`${s>1?`dataIndices${x}[${E}]`:`dataIndices${x}`} = u32(idx${x});`,L+=$):(S+=`${s>1?`dataIndices${x}[${E}]`:`dataIndices${x}`} = ${o.length>1?`outputIndices${x}[${L}]`:`outputIndices${x}`};`,L++);return S},b;if(t[0].dataType===9){let x=($,S,E="")=>`
          let outputIndices${S} = ${y.offsetToIndices(`outputOffset + ${S}u`)};
          ${v(S)};
          let offset${S} = ${m.indicesToOffset(`dataIndices${S}`)};
          let index${S} = offset${S} / 4u;
          let component${S} = offset${S} % 4u;
          ${$}[${S}] = ${E}(${m.getByOffset(`index${S}`)}[component${S}]);
        `;b=`
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${x("value",0,"u32")}
        ${x("value",1,"u32")}
        ${x("value",2,"u32")}
        ${x("value",3,"u32")}
        ${y.setByOffset("global_idx","value")}
      `}else b=`
      let outputIndices = ${y.offsetToIndices("global_idx")};
      ${v("")};
      let value = ${m.getByIndices("dataIndices")};
      ${y.setByOffset("global_idx","value")};
      `;return`
      ${f.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(m,g,y)}
      ${f.mainStart()}
        ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${b}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:d}},FK=t=>ur({axis:t.axis}),LK=(t,e)=>{let n=t.inputs;l7(n),t.compute(u7(t.inputs,e))}}),c7,MK,zK,YDe=ht(()=>{rn(),vn(),In(),c7=(t,e,n,r,s,i,o,a,l)=>{let u=[{type:12,data:i},{type:12,data:r},{type:12,data:s},{type:12,data:n},{type:12,data:o},{type:12,data:a},{type:12,data:l}],c=[i];u.push(...Ut(e.dims,c));let d=f=>{let m=Je("indices_data",e.dataType,e.dims.length),g=Ft("input_slice_offsets_data",12,1,1),y=[m,g],v=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${f.registerUniforms(v).declareVariables(...y)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${s.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return t.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:c,dataType:t.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:u}),getShaderSource:d},{inputs:[e],outputs:[-1]})[0]},MK=(t,e)=>{let n=t.inputs,r=n[0].dims,s=n[0].dataType,i=n[1].dims,o=i[i.length-1],a=He.sizeToDimension(i,i.length-1),l=He.sizeFromDimension(r,e.batchDims+o),u=He.sizeToDimension(r,e.batchDims),c=He.sizeFromDimension(r,e.batchDims),d=a/u,f=new Array(o),m=l;for(let S=0;S<o;++S)f[o-1-S]=m,m*=r[e.batchDims+o-1-S];let g=c7(t,n[1],f,e.batchDims,r,a,d,c,o),y=e.batchDims+o;if(y>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let v=i.slice(0,-1).concat(r.slice(y)),b=He.size(v),x=[{type:12,data:b},{type:12,data:l},...Ut(n[0].dims,g.dims,v)],$=S=>{let E=Je("data",n[0].dataType,n[0].dims.length),L=Je("slice_offsets",12,g.dims.length),R=Ft("output",n[0].dataType,v.length);return`
          ${S.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(E,L,R)}
            ${S.mainStart()}
            ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};t.compute({name:"GatherND",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:v,dataType:s}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:x}),getShaderSource:$},{inputs:[n[0],g]})},zK=t=>({batchDims:t.batch_dims,cacheKey:""})}),h7,d7,VK,BK,QDe=ht(()=>{rn(),vn(),us(),In(),h7=(t,e)=>{if(t.length<3||t.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=He.normalizeAxis(e.quantizeAxis,t[0].dims.length),r=e.blockSize,s=t[0],i=t[2],o=t.length===4?t[3]:void 0;if(i.dims.length!==s.dims.length||!s.dims.map((a,l)=>l===n?Math.ceil(a/r)===i.dims[l]:a===i.dims[l]).reduce((a,l)=>a&&l,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(o){if(o.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(o.dims.length!==i.dims.length||!o.dims.map((a,l)=>a===i.dims[l]).reduce((a,l)=>a&&l,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},d7=(t,e)=>{let n=t[0].dims,r=t[1].dims,s=n.length,i=He.normalizeAxis(e.gatherAxis,s),o=He.normalizeAxis(e.quantizeAxis,s),a=n.slice(0);a.splice(i,1,...r);let l=He.size(a),u=t[2].dataType,c=t[0].dataType===22,d=[{type:12,data:l},{type:12,data:o},{type:12,data:i},{type:12,data:e.blockSize},...Ut(...t.map((m,g)=>m.dims),a)],f=m=>{let g=Je("data",t[0].dataType,t[0].dims.length),y=Je("inputIndices",t[1].dataType,t[1].dims.length),v=Je("scales",t[2].dataType,t[2].dims.length),b=t.length>3?Je("zeroPoint",t[3].dataType,t[3].dims.length):void 0,x=Ft("output",u,a.length),$=[g,y,v];b&&$.push(b);let S=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${m.registerUniforms(S).declareVariables(...$,x)}
        ${m.mainStart()}
        let output_indices = ${x.offsetToIndices("global_idx")};
        var indices_indices = ${y.type.indices}(0);
        ${r.length>1?`
          for (var i: u32 = 0; i < ${r.length}; i++) {
            let index = ${x.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${y.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${x.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${g.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${x.indicesGet("output_indices","i")};
          ${g.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${y.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[i]};
        }
        ${g.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${a.length}; i++) {
          let index = ${x.indicesGet("output_indices",`i + ${r.length} - 1`)};
          ${g.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${g.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${g.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${v.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${v.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${v.getByIndices("scale_indices")};
        ${b?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${b.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${b.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${oo(u)}(quantized_data - zero_point) * scale;
        ${x.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${e.cacheKey};${t.filter((m,g)=>g!==1).map(m=>m.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:t.length},(m,g)=>"rank")},getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:f}},VK=(t,e)=>{let n=t.inputs;h7(n,e),t.compute(d7(t.inputs,e))},BK=t=>ur({blockSize:t.blockSize,gatherAxis:t.gatherAxis,quantizeAxis:t.quantizeAxis})}),f7,p7,UK,WK,JDe=ht(()=>{rn(),vn(),us(),In(),f7=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},p7=(t,e)=>{let n=t[0].dims,r=t[0].dataType,s=n.length,i=t[1].dims,o=t[1].dataType,a=He.normalizeAxis(e.axis,s),l=n[a],u=i.slice(0),c=He.size(u),d=Je("input",r,s),f=Je("indicesInput",o,i.length),m=Ft("output",r,u.length),g=[{type:12,data:c},{type:6,data:l},{type:12,data:a}];return g.push(...Ut(n,i,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:g}),getShaderSource:y=>`
      ${y.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(d,f,m)}
      ${y.mainStart()}
      ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${m.offsetToIndices("global_idx")};

      var idx = ${f.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${d.type.indices}(outputIndices);
      ${d.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${d.getByIndices("inputIndices")};

      ${m.setByOffset("global_idx","value")};
  }`}},UK=t=>ur({axis:t.axis}),WK=(t,e)=>{let n=t.inputs;f7(n),t.compute(p7(t.inputs,e))}}),m7,g7,jK,GK,ZDe=ht(()=>{rn(),vn(),In(),m7=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},g7=(t,e)=>{let n=t[0].dims.slice(),r=t[1].dims.slice(),[s,i,o]=UH.getShapeOfGemmResult(n,e.transA,r,e.transB,t.length===3?t[2].dims:void 0),a=[s,i];if(!a)throw new Error("Can't use gemm on the given tensors");let l=16,u=Math.ceil(i/l),c=Math.ceil(s/l),d=!0,f=He.size(a),m=[{type:12,data:d?u:f},{type:12,data:s},{type:12,data:i},{type:12,data:o},{type:1,data:e.alpha},{type:1,data:e.beta}],g=["type","type"];t.length===3&&(m.push(...Ut(t[2].dims)),g.push("rank")),m.push(...Ut(a));let y=b=>{let x="";e.transA&&e.transB?x="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?x="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?x="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(x="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let $=e.alpha===1?"":"value *= uniforms.alpha;",S=Je("a",t[0].dataType,t[0].dims),E=Je("b",t[1].dataType,t[1].dims),L=S.type.value,R=null,D=[S,E];t.length===3&&(R=Je("c",t[2].dataType,t[2].dims.length),D.push(R));let A=Ft("output",t[0].dataType,a.length);D.push(A);let F=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${b.registerUniforms(F).declareVariables(...D)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${L}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${x}
    }

    ${$}
    ${R!=null?`let cOffset = ${R.broadcastedIndicesToOffset("vec2(m, n)",A)}; value += ${L}(uniforms.beta) * ${R.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},v=b=>{let x=Je("a",t[0].dataType,t[0].dims),$=Je("b",t[1].dataType,t[1].dims),S=null,E=[x,$];t.length===3&&(S=Je("c",t[2].dataType,t[2].dims.length),E.push(S));let L=Ft("output",t[0].dataType,a.length);E.push(L);let R=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],D="",A="";e.transA&&e.transB?(A=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,D="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):e.transA&&!e.transB?(A=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,D="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!e.transA&&e.transB?(A=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,D="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!e.transA&&!e.transB&&(A=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,D="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let F=e.alpha===1?"":"value *= uniforms.alpha;";return`
  ${b.registerUniforms(R).declareVariables(...E)}
  var<workgroup> tile_a: array<array<${x.type.storage}, ${l}>, ${l}>;
  var<workgroup> tile_b: array<array<${$.type.storage}, ${l}>, ${l}>;
  ${b.mainStart([l,l,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};
    let num_tiles = (uniforms.K - 1) / ${l} + 1;
    var k_start = 0u;
    var value = ${L.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${A}
      k_start = k_start + ${l};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${l}; k++) {
        ${D}
      }
      workgroupBarrier();
    }

    ${F}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${S!=null?`let cOffset = ${S.broadcastedIndicesToOffset("vec2(m, n)",L)}; value += ${L.type.value}(uniforms.beta) * ${S.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return d?{name:"GemmShared",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:u*c},programUniforms:m}),getShaderSource:v}:{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:m}),getShaderSource:y}},jK=t=>{let e=t.transA,n=t.transB,r=t.alpha,s=t.beta;return{transA:e,transB:n,alpha:r,beta:s,cacheKey:`${t.transA};${t.transB};${t.alpha===1}`}},GK=(t,e)=>{m7(t.inputs),t.compute(g7(t.inputs,e))}}),tu,Uu,gd,yd,y7,w7,v7,b7,x7,_7,I7,T7,HK,qK,e5e=ht(()=>{rn(),vn(),us(),In(),[tu,Uu,gd,yd]=[0,1,2,3],y7=t=>{if(t[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(t[0].dims.length!==t[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(t[0].dims.length-2!==t[1].dims[t[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${t[0].dims.length-2}`);if(t[0].dims[0]!==t[1].dims[0])throw new Error("grid batch size must match input batch size")},w7=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,v7=t=>`
  fn gs_bicubic_interpolate(p: mat4x4<${t}>, x: f32, y: f32) -> ${t} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${t}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,b7=t=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${t.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,x7=t=>`
  ${t.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,_7=(t,e,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${tu}] = batch;
     indices[${Uu}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${gd}] = u32(r);
            indices[${yd}] = u32(c);
          } else {
            return ${e}(0);
          }
        `;case"border":return`
          indices[${gd}] = u32(clamp(r, 0, H - 1));
          indices[${yd}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${gd}] = gs_reflect(r, border[1], border[3]);
          indices[${yd}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${t.getByIndices("indices")};
  }
`,I7=(t,e,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${tu}], indices[${Uu}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${tu}], indices[${Uu}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${tu}], indices[${Uu}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${tu}], indices[${Uu}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${tu}], indices[${Uu}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${tu}], indices[${Uu}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${t.setByOffset("global_idx","result")}`,T7=(t,e)=>{let n=Je("x",t[0].dataType,t[0].dims.length),r=[t[1].dims[0],t[1].dims[1],t[1].dims[2]],s=Je("grid",t[1].dataType,r.length,2),i=[t[0].dims[0],t[0].dims[1],t[1].dims[1],t[1].dims[2]];e.format==="NHWC"&&(i=[t[0].dims[0],t[1].dims[1],t[1].dims[2],t[0].dims[3]],[tu,Uu,gd,yd]=[0,3,1,2]);let o=Ft("output",t[0].dataType,i.length),a=n.type.value,l=He.size(i),u=[{type:12,data:l},...Ut(t[0].dims,r,i)],c=d=>`
  ${d.registerUniform("output_size","u32").declareVariables(n,s,o)}
  ${w7}
  ${v7(a)}
  ${b7(e)}
  ${x7(e)}
  ${_7(n,a,e)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${gd}]);
      let W_in = i32(uniforms.x_shape[${yd}]);

      ${e.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${o.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${tu}], indices[${gd}], indices[${yd}]);
      let nxy = ${s.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${I7(o,a,e)}
  }`;return{name:"GridSample",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:["type","type"]},getRunData:d=>{let f=He.size(i);return{outputs:[{dims:i,dataType:d[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:u}},getShaderSource:c}},HK=(t,e)=>{y7(t.inputs),t.compute(T7(t.inputs,e))},qK=t=>ur({alignCorners:t.align_corners,mode:t.mode,paddingMode:t.padding_mode,format:t.format})}),$o,S7,KK,vS,$7,iy,XK,YK=ht(()=>{rn(),vn(),us(),bR(),IR(),In(),Zh(),$o=(t,e)=>t.length>e&&t[e].dims.length>0?t[e]:void 0,S7=(t,e)=>{let n=t[0],r=$o(t,1),s=$o(t,2),i=$o(t,3),o=$o(t,4),a=$o(t,5),l=$o(t,6),u=$o(t,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let c=n.dims[0],d=n.dims[1],f=n.dims.length===3?n.dims[2]:e.numHeads*n.dims[4],m=d,g=0,y=0,v=Math.floor(f/e.numHeads);if(l&&u&&He.size(l.dims)&&He.size(u.dims)){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==c||l.dims[1]!==e.numHeads||l.dims[3]!==v)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[0]!==c||u.dims[1]!==e.numHeads||u.dims[3]!==v)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==u.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(u.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');g=l.dims[2],y=l.dims[2]}else if(l&&He.size(l.dims)||u&&He.size(u.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let b;if(r&&He.size(r.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(r.dims.length===3){if(r.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');b=2,m=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==e.numHeads||r.dims[3]!==2||r.dims[4]!==v)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');b=5,m=r.dims[1]}else{if(r.dims[1]!==e.numHeads||r.dims[3]!==v)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');b=0,m=r.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==e.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');b=3}if(i&&He.size(i.dims)>0){if(i.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(r&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let x=g+m,$=0;if(o&&He.size(o.dims)>0){$=8;let R=o.dims;throw R.length===1?R[0]===c?$=1:R[0]===3*c+2&&($=3):R.length===2&&R[0]===c&&R[1]===x&&($=5),$===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let S=!1,E=f;if(s&&He.size(s.dims)>0){if(s.dims.length!==3&&s.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(s.dims.length===3){if(m!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');E=s.dims[2]}else{if(m!==s.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');E=s.dims[1]*s.dims[3],S=!0}}let L=!1;if(o&&He.size(o.dims)>0)throw new Error("Key padding mask is not supported");if(a&&He.size(a.dims)>0){if(a.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(a.dims[0]!==c||a.dims[1]!==e.numHeads||a.dims[2]!==d||a.dims[3]!==x)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:d,pastSequenceLength:g,kvSequenceLength:m,totalSequenceLength:x,maxSequenceLength:y,inputHiddenSize:0,hiddenSize:f,vHiddenSize:E,headSize:v,vHeadSize:Math.floor(E/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:$,scale:e.scale,broadcastResPosBias:L,passPastInKv:S,qkvFormat:b}},KK=t=>ur({...t}),vS=ur({perm:[0,2,1,3]}),$7=(t,e,n,r,s,i,o)=>{let a=[r,s,i],l=He.size(a),u=[{type:12,data:l},{type:12,data:o},{type:12,data:i}],c=d=>{let f=Ft("qkv_with_bias",e.dataType,a),m=Je("qkv",e.dataType,a),g=Je("bias",n.dataType,a),y=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${d.registerUniforms(y).declareVariables(m,g,f)}
  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return t.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:c},{inputs:[e,n],outputs:[-1]})[0]},iy=(t,e,n,r,s,i,o,a)=>{let l=i;if(o&&He.size(o.dims)>0){if(r===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=$7(t,i,o,e,r,n*s,a),l=l.reshape([e,r,n,s]),n===1||r===1?l:t.compute(Ea(l,vS.perm),{inputs:[l],outputs:[-1]})[0]}else return i.dims.length===3&&(l=i.reshape([e,r,n,s])),n===1||r===1?l:t.compute(Ea(l,vS.perm),{inputs:[l],outputs:[-1]})[0]},XK=(t,e)=>{let n=S7(t.inputs,e),r=t.inputs[0],s=$o(t.inputs,1),i=$o(t.inputs,2),o=$o(t.inputs,3),a=$o(t.inputs,4),l=$o(t.inputs,5),u=$o(t.inputs,6),c=$o(t.inputs,7);if(r.dims.length===5)throw new Error("Packed QKV is not implemented");if(s?.dims.length===5)throw new Error("Packed KV is not implemented");let d=s&&i&&s.dims.length===4&&i.dims.length===4,f=iy(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,o,0);if(d)return jy(t,f,s,i,a,void 0,u,c,l,n);if(!s||!i)throw new Error("key and value must be provided");let m=iy(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,s,o,n.hiddenSize),g=iy(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,i,o,2*n.hiddenSize);jy(t,f,m,g,a,void 0,u,c,l,n)}}),C7,E7,k7,N7,yC,QK,JK,ZK=ht(()=>{rn(),vn(),us(),In(),C7=t=>{if(!t||t.length<1)throw new Error("too few inputs")},E7=(t,e)=>{let n=[],r=e.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(s=>n.push(Number(s))),r=n.length),ur({numOutputs:r,axis:e.axis,splitSizes:n})},k7=t=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < ${Mt("uniforms.size_in_split_axis","i",t)}) {
        return i;
    }
    }
    return ${t}u;
}`,N7=t=>{let e=t.length,n=[];for(let r=0;r<e;++r){let s=t[r].setByIndices("indices","input[global_idx]");e===1?n.push(s):r===0?n.push(`if (output_number == ${r}u) { ${s} }`):r===e-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${r}) { ${s} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},yC=(t,e)=>{let n=t[0].dims,r=He.size(n),s=t[0].dataType,i=He.normalizeAxis(e.axis,n.length),o=new Array(e.numOutputs),a=Je("input",s,n.length),l=new Array(e.numOutputs),u=[],c=[],d=0,f=[{type:12,data:r}];for(let g=0;g<e.numOutputs;g++){d+=e.splitSizes[g],l[g]=d;let y=n.slice();y[i]=e.splitSizes[g],c.push(y),o[g]=Ft(`output${g}`,s,y.length),u.push({dims:c[g],dataType:t[0].dataType})}f.push({type:12,data:l},...Ut(n,...c));let m=g=>`
  ${g.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(a,...o)}
  ${k7(l.length)}
  ${N7(o)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${a.offsetToIndices("global_idx")};
    var index = ${a.indicesGet("indices",i)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Mt("uniforms.size_in_split_axis","output_number - 1u",l.length)};
      ${a.indicesSet("indices",i,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:m,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:f})}},QK=(t,e)=>{C7(t.inputs);let n=t.inputs.length===1?e:E7(t.inputs,e);t.compute(yC(t.inputs,n),{inputs:[0]})},JK=t=>{let e=t.axis,n=t.splitSizes,r=t.numOutputs<0?n.length:t.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes length must be equal");return ur({axis:e,numOutputs:r,splitSizes:n})}}),A7,cx,eX,tX=ht(()=>{rn(),vn(),us(),In(),A7=(t,e)=>{let[n,r,s,i]=t,{numHeads:o,rotaryEmbeddingDim:a}=e;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!He.areEqual(r.dims,[])&&!He.areEqual(r.dims,[1])&&r.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(s.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(!He.areEqual(s.dims,i.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(a>0&&o===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],c=s.dims[0],d=He.sizeFromDimension(n.dims,1)/u,f=a===0?s.dims[1]*2:d/o;if(a>f)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(r.dims.length===2){if(l!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(u!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(f/2!==s.dims[1]&&a/2!==s.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(u>c)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},cx=(t,e)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:s,scale:i}=e,o=t[0].dims[0],a=He.sizeFromDimension(t[0].dims,1),l=t[0].dims[t[0].dims.length-2],u=a/l,c=t[2].dims[1],d=s===0?c*2:u/r,f=new Array(o,l,u/d,d-c),m=He.computeStrides(f),g=[{type:1,data:i},{type:12,data:f},{type:12,data:m},...t[0].dims.length===3?new Array({type:12,data:[a,u,d,1]}):[],...t[0].dims.length===4?new Array({type:12,data:[a,d,l*d,1]}):[],...Ut(t[0].dims,t[1].dims,t[2].dims,t[3].dims,t[0].dims)],y=v=>{let b=Je("input",t[0].dataType,t[0].dims.length),x=Je("position_ids",t[1].dataType,t[1].dims.length),$=Je("cos_cache",t[2].dataType,t[2].dims.length),S=Je("sin_cache",t[3].dataType,t[3].dims.length),E=Ft("output",t[0].dataType,t[0].dims.length);return v.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:f.length},{name:"global_strides",type:"u32",length:m.length},{name:"input_output_strides",type:"u32",length:m.length}]),`
        ${v.declareVariables(b,x,$,S,E)}

        ${v.mainStart(Jm)}
          let half_rotary_emb_dim = uniforms.${$.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${v.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${x.broadcastedIndicesToOffset("bsnh.xy",Ft("",x.type.tensor,2))};
            let position_id =
                u32(${x.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${b.getByOffset("i")} * ${$.get("position_id","bsnh[3]")} -
                ${b.getByOffset("j")} * ${S.get("position_id","bsnh[3]")};
            ${E.setByOffset("i","re")}
            let im = ${b.getByOffset("i")} * ${S.get("position_id","bsnh[3]")} +
                ${b.getByOffset("j")} * ${$.get("position_id","bsnh[3]")};
            ${E.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${E.setByOffset("k",b.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:ur({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(He.size(f)/Jm)},programUniforms:g})}},eX=(t,e)=>{A7(t.inputs,e),t.compute(cx(t.inputs,e))}}),R7,D7,bS,O7,nX,t5e=ht(()=>{us(),rn(),IR(),YK(),ZK(),Zh(),tX(),In(),R7=(t,e)=>{if(e.doRotary&&t.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=t[0],r=t[1],s=t[2],i=t[3],o=t[4];if(e.doRotary!==0&&t.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(e.localWindowSize!==-1)throw new Error("Local attention is not supported");if(e.softcap!==0)throw new Error("Softcap is not supported");if(e.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(e.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let a=!1,l=n.dims[0],u=n.dims[1],c=n.dims.length===3?a?n.dims[2]/3:n.dims[2]:e.numHeads*n.dims[4],d=u,f=0,m=!r||r.dims.length===0,g=Math.floor(m?c/(e.numHeads+2*e.kvNumHeads):c/e.numHeads);m&&(c=g*e.numHeads);let y=i&&i.dims.length!==0,v=o&&o.dims.length!==0;if(y&&i.dims.length===4&&i.dims[0]===l&&i.dims[1]!==e.kvNumHeads&&i.dims[2]===e.kvNumHeads&&i.dims[3]===g)throw new Error("BSNH pastKey/pastValue is not supported");if(y&&v){if(i.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(o.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');f=i.dims[2]}else if(y||v)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let b=1;if(r&&r.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(r.dims.length===3){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');d=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==e.numHeads||r.dims[3]!==2||r.dims[4]!==g)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');d=r.dims[1]}else{if(r.dims[1]!==e.numHeads||r.dims[3]!==g)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=r.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==e.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');b=3}let x=0,$=!1,S=e.kvNumHeads?g*e.kvNumHeads:c;if(s&&s.dims.length>0){if(s.dims.length!==3&&s.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(s.dims.length===3){if(d!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');S=s.dims[2]}else{if(d!==s.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');S=s.dims[1]*s.dims[3],$=!0}}let E=t.length>4?t[5]:void 0;if(E&&E.dims.length!==1&&E.dims[0]!==l)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:u,pastSequenceLength:f,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:c,vHiddenSize:S,headSize:g,vHeadSize:Math.floor(S/e.kvNumHeads),numHeads:e.numHeads,kvNumHeads:e.kvNumHeads,nReps:e.numHeads/e.kvNumHeads,pastPresentShareBuffer:!1,maskType:x,scale:e.scale,broadcastResPosBias:!1,passPastInKv:$,qkvFormat:b}},D7=ur({perm:[0,2,1,3]}),bS=(t,e,n)=>{let r=e,s=n.kvNumHeads;return e.dims.length===3&&n.kvSequenceLength!==0&&(r=e.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize]),r=t.compute(Ea(r,D7.perm),{inputs:[r],outputs:[-1]})[0]),r},O7=(t,e,n,r)=>{let s=7,i=["type","type"],o=[t*e],a=t*e,l=[{type:12,data:a},{type:12,data:e},{type:12,data:t}],u=c=>{let d=Je("seq_lens",n.dataType,n.dims),f=Je("total_seq_lens",r.dataType,r.dims),m=Ft("pos_ids",s,o),g=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${c.registerUniforms(g).declareVariables(d,f,m)}
  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${f.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${d.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${m.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${m.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${m.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${t};${e}`,inputDependencies:i},getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:u}},nX=(t,e)=>{let n=R7(t.inputs,e);if(t.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(t.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let r=t.inputs[0],s=t.inputs[1]&&t.inputs[1].dims.length>0?t.inputs[1]:void 0,i=t.inputs[2]&&t.inputs[2].dims.length>0?t.inputs[2]:void 0,o=t.inputs[3]&&t.inputs[3].dims.length!==0?t.inputs[3]:void 0,a=t.inputs[4]&&t.inputs[4].dims.length!==0?t.inputs[4]:void 0,l=t.inputs.length>4?t.inputs[5]:void 0,u=t.inputs.length>5?t.inputs[6]:void 0,c=n.kvNumHeads?n.kvNumHeads:n.numHeads,d=ur({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,c*n.headSize,c*n.headSize]}),[f,m,g]=!s&&!i?t.compute(yC([r],d),{inputs:[r],outputs:[-1,-1,-1]}):[r,s,i],y,v;if(e.doRotary){let S=t.compute(O7(n.batchSize,n.sequenceLength,l,u),{inputs:[l,u],outputs:[-1]})[0],E=t.inputs[7],L=t.inputs[8],R=ur({interleaved:e.rotaryInterleaved!==0,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:e.scale}),D=[f,S,E,L],A=[-1];y=t.compute(cx(D,R),{inputs:D,outputs:A})[0],D.splice(0,1,m);let F=ur({interleaved:e.rotaryInterleaved!==0,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:e.scale});v=t.compute(cx(D,F),{inputs:D,outputs:A})[0]}let b=iy(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,e.doRotary?y:f,void 0,0),x=bS(t,e.doRotary?v:m,n),$=bS(t,g,n);jy(t,b,x,$,void 0,void 0,o,a,void 0,n,l,u)}}),xS,P7,F7,rX,n5e=ht(()=>{rn(),vn(),Zh(),In(),xS=(t,e,n,r,s,i,o,a)=>{let l=Jr(i),u=l===1?"f32":`vec${l}f`,c=l===1?"vec2f":`mat2x${l}f`,d=s*o,f=64;d===1&&(f=256);let m=[s,o,i/l],g=[s,o,2],y=["rank","type","type"],v=[];v.push(...Ut(m,g));let b=x=>{let $=Je("x",e.dataType,3,l),S=Je("scale",n.dataType,n.dims),E=Je("bias",r.dataType,r.dims),L=Ft("output",1,3,2),R=[$,S,E,L];return`
  var<workgroup> workgroup_shared : array<${c}, ${f}>;
  const workgroup_size = ${f}u;
  ${x.declareVariables(...R)}
  ${x.mainStart(f)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${u}(0);
    var squared_sum = ${u}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${u}(${$.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${c}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Vh("workgroup_shared[0][0]",l)} / f32(hight * ${l});
      let squared_sum_final = ${Vh("workgroup_shared[0][1]",l)} / f32(hight * ${l});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${a}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${a};${f}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:g,dataType:1}],dispatchGroup:{x:d},programUniforms:v}),getShaderSource:b},{inputs:[e,n,r],outputs:[-1]})[0]},P7=(t,e,n)=>{let r=e[0].dims,s=r,i=2,o=r[0],a=r[1],l=He.sizeFromDimension(r,i),u=Jr(l),c=He.size(s)/u,d=xS(t,e[0],e[1],e[2],o,l,a,n.epsilon),f=[o,a,l/u],m=[o,a],g=["type","none"],y=v=>{let b=Je("x",e[0].dataType,f.length,u),x=Je("scale_shift",1,m.length,2),$=Ft("output",e[0].dataType,f.length,u),S=[b,x,$];return`
  ${v.registerUniform("output_size","u32").declareVariables(...S)}
  ${v.mainStart()}
  ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${$.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${x.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${b.getByOffset("global_idx")} * ${$.type.value}(scale_shift.x) + ${$.type.value}(scale_shift.y);
      ${$.setByOffset("global_idx","value")};
  }`};t.compute({name:"InstanceNormalization",shaderCache:{hint:`${u}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...Ut(f,m,f)]}),getShaderSource:y},{inputs:[e[0],d]})},F7=(t,e,n)=>{let r=e[0].dims,s=r,i=r[0],o=r[r.length-1],a=He.sizeFromDimension(r,1)/o,l=Jr(o),u=He.size(s)/l,c=[{type:12,data:a},{type:12,data:Math.floor(o/l)}],d=["type","type"],f=!1,m=[0,r.length-1];for(let b=0;b<r.length-2;b++)f=f||r[b+1]!==1,m.push(b+1);f=f&&r[r.length-1]!==1;let g=f?t.compute(Ea(t.inputs[0],m),{inputs:[t.inputs[0]],outputs:[-1]})[0]:t.inputs[0].reshape(Array.from({length:r.length},(b,x)=>r[m[x]])),y=xS(t,g,e[1],e[2],i,a,o,n.epsilon),v=b=>{let x=si(e[0].dataType),$=l===1?"vec2f":`mat${l}x2f`,S=R=>{let D=R===0?"x":"y",A=l===1?"f32":`vec${l}f`;switch(l){case 1:return`${x}(${A}(scale.${D}))`;case 2:return`vec2<${x}>(${A}(scale[0].${D}, scale[1].${D}))`;case 4:return`vec4<${x}>(${A}(scale[0].${D}, scale[1].${D}, scale[2].${D}, scale[3].${D}))`;default:throw new Error(`Not supported compoents ${l}`)}},E=Je("input",e[0].dataType,e[0].dims,l),L=Ft("output",e[0].dataType,s,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${E.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${$}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${L.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${b.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${S(0)}, ${S(1)});
  }`};t.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:v},{inputs:[e[0],y]})},rX=(t,e)=>{e.format==="NHWC"?F7(t,t.inputs,e):P7(t,t.inputs,e)}}),L7,M7,sX,r5e=ht(()=>{rn(),vn(),In(),L7=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},M7=(t,e,n)=>{let r=e.simplified,s=t[0].dims,i=t[1],o=!r&&t[2],a=s,l=He.normalizeAxis(e.axis,s.length),u=He.sizeToDimension(s,l),c=He.sizeFromDimension(s,l),d=He.size(i.dims),f=o?He.size(o.dims):0;if(d!==c||o&&f!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${d} and bias size of ${f}`);let m=[];for(let E=0;E<s.length;++E)E<l?m.push(s[E]):m.push(1);let g=Jr(c),y=["type","type"],v=[{type:12,data:u},{type:1,data:c},{type:12,data:Math.floor(c/g)},{type:1,data:e.epsilon}];o&&y.push("type");let b=n>1,x=n>2,$=E=>{let L=si(t[0].dataType),R=[Je("x",t[0].dataType,t[0].dims,g),Je("scale",i.dataType,i.dims,g)];o&&R.push(Je("bias",o.dataType,o.dims,g)),R.push(Ft("output",t[0].dataType,a,g)),b&&R.push(Ft("mean_data_output",1,m)),x&&R.push(Ft("inv_std_output",1,m));let D=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${E.registerUniforms(D).declareVariables(...R)}
  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${lC("f32",g)};
    var mean_square_vector = ${lC("f32",g)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${wm(L,g,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Vh("mean_vector",g)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Vh("mean_square_vector",g)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${wm(L,g,"x[j + offset]")};
      let f32scale = ${wm(L,g,"scale[j]")};
      output[j + offset] = ${R[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale
        ${o?`+ ${wm(L,g,"bias[j]")}`:""}
      );
    }

    ${b?"mean_data_output[global_idx] = mean":""};
    ${x?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},S=[{dims:a,dataType:t[0].dataType}];return b&&S.push({dims:m,dataType:1}),x&&S.push({dims:m,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${g};${n};${r}`,inputDependencies:y},getRunData:()=>({outputs:S,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:v}),getShaderSource:$}},sX=(t,e)=>{L7(t.inputs),t.compute(M7(t.inputs,e,t.outputCount))}}),z7,iX,s5e=ht(()=>{vn(),ER(),kR(),z7=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},iX=t=>{z7(t.inputs);let e=Qm.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let n=e[e.length-1],r=t.inputs[0].dims[t.inputs[0].dims.length-1];if(n<8&&r<8)t.compute(CR(t.inputs,{activation:""},e));else{let s=e[e.length-2],i=He.size(t.inputs[0].dims.slice(0,-2)),o=He.size(t.inputs[1].dims.slice(0,-2));if(i!==1&&s===1&&o===1){let a=t.inputs[0].reshape([1,i,r]),l=t.inputs[1].reshape([1,r,n]),u=[1,i,n],c=[a,l];t.compute(ux(c,{activation:""},e,u),{inputs:c})}else t.compute(ux(t.inputs,{activation:""},e))}}}),V7,B7,U7,oX,aX,i5e=ht(()=>{rn(),vn(),us(),In(),V7=(t,e)=>{if(t.length<3||t.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=t[0],r=n.dims.length;if(n.dims[r-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((e.k+e.blockSize-1)/e.blockSize),i=e.blockSize/8*e.bits,o=t[1];if(!He.areEqual(o.dims,[e.n,s,i]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let a=t[2].dims;if(He.size(a)!==e.n*s)throw new Error("scales input size error.");if(t.length===4){let l=t[3].dims,u=e.n*(e.bits===8?s:Math.floor((s*e.bits+7)/8));if(He.size(l)!==u)throw new Error("zeroPoints input size error.")}},B7=(t,e)=>{let n=t[0].dims,r=n.length,s=n[r-2],i=e.k,o=e.n,a=n.slice(0,r-2),l=He.size(a),u=t[1].dims[2]/4,c=t[0].dataType,d=Jr(e.k),f=Jr(u),m=Jr(o),g=a.concat([s,o]),y=s>1&&o/m%2===0?2:1,v=He.size(g)/m/y,b=64,x=[],$=[l,s,i/d],S=He.convertShape(t[1].dims).slice();S.splice(-1,1,u/f),x.push(...Ut($)),x.push(...Ut(S)),x.push(...Ut(t[2].dims)),t.length===4&&x.push(...Ut(He.convertShape(t[3].dims)));let E=[l,s,o/m];x.push(...Ut(E));let L=R=>{let D=$.length,A=Je("a",t[0].dataType,D,d),F=Je("b",12,S.length,f),P=Je("scales",t[2].dataType,t[2].dims.length),K=[A,F,P],j=t.length===4?Je("zero_points",12,t[3].dims.length):void 0;j&&K.push(j);let se=E.length,fe=Ft("output",t[0].dataType,se,m),me=si(t[0].dataType),ye=(()=>{switch(d){case 1:return`array<${me}, 8>`;case 2:return`mat4x2<${me}>`;case 4:return`mat2x4<${me}>`;default:throw new Error(`${d}-component is not supported.`)}})(),oe=()=>{let Y=`
          // reuse a data
            var input_offset = ${A.indicesToOffset(`${A.type.indices}(batch, row, word_offset)`)};
            var a_data: ${ye};
            for (var j: u32 = 0; j < ${8/d}; j++) {
              a_data[j] = ${A.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let re=0;re<m*y;re++)Y+=`
            b_value = ${f===1?`b${re}_data`:`b${re}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${ye}(${Array.from({length:4},(Te,Pe)=>`${me}(b_value_lower[${Pe}]), ${me}(b_value_upper[${Pe}])`).join(", ")});
            b_dequantized_values = ${d===1?`${ye}(${Array.from({length:8},(Te,Pe)=>`(b_quantized_values[${Pe}] - ${j?`zero_point${re}`:"zero_point"}) * scale${re}`).join(", ")});`:`(b_quantized_values - ${ye}(${Array(8).fill(`${j?`zero_point${re}`:"zero_point"}`).join(",")})) * scale${re};`};
            workgroup_shared[local_id.x * ${y} + ${Math.floor(re/m)}]${m>1?`[${re%m}]`:""} += ${Array.from({length:8/d},(Te,Pe)=>`${d===1?`a_data[${Pe}] * b_dequantized_values[${Pe}]`:`dot(a_data[${Pe}], b_dequantized_values[${Pe}])`}`).join(" + ")};
          `;return Y},ue=()=>{let Y=`
            var col_index = col * ${m};
            ${j?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${me}(8);`}
            `;for(let re=0;re<m*y;re++)Y+=`
            let scale${re} = ${P.getByOffset("col_index * nBlocksPerCol + block")};
            ${j?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${j.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${re} = ${me}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return Y},_e=()=>{let Y=`col_index = col * ${m};`;for(let re=0;re<m*y;re++)Y+=`
            let b${re}_data = ${F.getByIndices(`${F.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return Y+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${ye};
            var b_dequantized_values: ${ye};`,Y};return`
        var<workgroup> workgroup_shared: array<${fe.type.value}, ${y*b}>;
        ${R.declareVariables(...K,fe)}
        ${R.mainStart([b,1,1])}
          let output_indices = ${fe.offsetToIndices(`(global_idx / ${b}) * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${b}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize/d};
            ${ue()}
            for (var word: u32 = 0; word < ${u}; word += ${f}) {
              ${_e()}
              for (var i: u32 = 0; i < ${f}; i++) {
                ${oe()}
                word_offset += ${8/d};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${y}) {
            var output_value: ${fe.type.value} = ${fe.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${b}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${y};
            }
            ${fe.setByIndices(`${fe.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${e.blockSize};${e.bits};${d};${f};${m};${y};${b}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:g,dataType:c}],dispatchGroup:{x:v},programUniforms:x}),getShaderSource:L}},U7=(t,e)=>{let n=t[0].dims,r=n.length,s=n[r-2],i=e.k,o=e.n,a=n.slice(0,r-2),l=He.size(a),u=t[1].dims[2]/4,c=t[0].dataType,d=Jr(e.k),f=Jr(u),m=a.concat([s,o]),g=128,y=o%8===0?8:o%4===0?4:1,v=g/y,b=v*f*8,x=b/d,$=b/e.blockSize,S=He.size(m)/y,E=[],L=[l,s,i/d],R=He.convertShape(t[1].dims).slice();R.splice(-1,1,u/f),E.push(...Ut(L)),E.push(...Ut(R)),E.push(...Ut(t[2].dims)),t.length===4&&E.push(...Ut(He.convertShape(t[3].dims)));let D=[l,s,o];E.push(...Ut(D));let A=F=>{let P=L.length,K=Je("a",t[0].dataType,P,d),j=Je("b",12,R.length,f),se=Je("scales",t[2].dataType,t[2].dims.length),fe=[K,j,se],me=t.length===4?Je("zero_points",12,t[3].dims.length):void 0;me&&fe.push(me);let ye=D.length,oe=Ft("output",t[0].dataType,ye),ue=si(t[0].dataType),_e=()=>{switch(d){case 1:return`
          let a_data0 = vec4<${ue}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${ue}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${ue}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${ue}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${d}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${K.type.value}, ${x}>;
        var<workgroup> inter_results: array<array<${oe.type.value}, ${v}>, ${y}>;
        ${F.declareVariables(...fe,oe)}
        ${F.mainStart([v,y,1])}
          let output_indices = ${oe.offsetToIndices(`workgroup_index * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${$} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${x};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${x}; a_offset += ${g})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${K.getByIndices(`${K.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${K.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${$} + local_id.x;
            ${me?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${me.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${ue}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${ue}(8);`}
            let scale = ${se.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${j.getByIndices(`${j.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize/d};
            for (var i: u32 = 0; i < ${f}; i++) {
              ${_e()}
              let b_value = ${f===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${ue}>(${Array.from({length:4},(Y,re)=>`${ue}(b_value_lower[${re}]), ${ue}(b_value_upper[${re}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${ue}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Y,re)=>`${`dot(a_data${re}, b_dequantized_values[${re}])`}`).join(" + ")};
              word_offset += ${8/d};
            }
            workgroupBarrier();
          }

          if (local_idx < ${y}) {
            var output_value: ${oe.type.value} = ${oe.type.value}(0);
            for (var b = 0u; b < ${v}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${oe.setByIndices(`${oe.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${e.blockSize};${d};${f};${v};${y}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:m,dataType:c}],dispatchGroup:{x:S},programUniforms:E}),getShaderSource:A}},oX=(t,e)=>{V7(t.inputs,e),e.blockSize===32&&t.adapterInfo.isVendor("intel")&&t.adapterInfo.isArchitecture("gen-12lp")?t.compute(U7(t.inputs,e)):t.compute(B7(t.inputs,e))},aX=t=>ur(t)}),W7,j7,G7,H7,q7,K7,X7,Y7,lX,o5e=ht(()=>{rn(),vn(),In(),W7=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1&&t[0].dataType!==10)throw new Error("Input type must be float or float16.");if(t.length>=2){let e=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(e=t[3].dims[0]*2===t[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},j7=(t,e,n)=>{let r="";for(let s=e-1;s>=0;--s)r+=`
            k = i32(${t.indicesGet("indices",s)}) - ${Mt("uniforms.pads",s,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Mt("uniforms.x_shape",s,e)})) {
              break;
            }
            offset += k * i32(${Mt("uniforms.x_strides",s,e)});
        `;return`
          value = ${t.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${r}
            value = x[offset];
          }
      `},G7=(t,e,n)=>{let r="";for(let s=e-1;s>=0;--s)r+=`
                k = i32(${t.indicesGet("indices",s)}) - ${Mt("uniforms.pads",s,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Mt("uniforms.x_shape",s,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Mt("uniforms.x_shape",s,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Mt("uniforms.x_strides",s,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},H7=(t,e,n)=>{let r="";for(let s=e-1;s>=0;--s)r+=`
                k = i32(${t.indicesGet("indices",s)}) - ${Mt("uniforms.pads",s,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Mt("uniforms.x_shape",s,e)})) {
                  k = i32(${Mt("uniforms.x_shape",s,e)}) - 1;
                }
                offset += k * i32(${Mt("uniforms.x_strides",s,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},q7=(t,e,n)=>{let r="";for(let s=e-1;s>=0;--s)r+=`
                k = i32(${t.indicesGet("indices",s)}) - ${Mt("uniforms.pads",s,n)};
                if (k < 0)  {
                  k += i32(${Mt("uniforms.x_shape",s,e)}]);
                }
                if (k >= i32(${Mt("uniforms.x_shape",s,e)})) {
                  k -= i32(${Mt("uniforms.x_shape",s,e)});
                }
                offset += k * i32(${Mt("uniforms.x_strides",s,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},K7=(t,e,n)=>{switch(n.mode){case 0:return j7(t,e,n.pads.length);case 1:return G7(t,e,n.pads.length);case 2:return H7(t,e,n.pads.length);case 3:return q7(t,e,n.pads.length);default:throw new Error("Invalid mode")}},X7=(t,e)=>{let n=He.padShape(t[0].dims.slice(),e.pads),r=t[0].dims,s=He.size(n),i=[{type:12,data:s},{type:6,data:e.pads}],o=t.length>=3&&t[2].data;e.mode===0&&i.push({type:o?t[2].dataType:1,data:e.value}),i.push(...Ut(t[0].dims,n));let a=["rank"],l=u=>{let c=Ft("output",t[0].dataType,n.length),d=Je("x",t[0].dataType,r.length),f=d.type.value,m=K7(c,r.length,e),g=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&g.push({name:"constant_value",type:o?f:"f32"}),`
            ${u.registerUniforms(g).declareVariables(d,c)}
            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${c.offsetToIndices("global_idx")};

            var value = ${f}(0);
            ${m}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}${o}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(He.size(n)/64)},programUniforms:i}),getShaderSource:l}},Y7=(t,e)=>{if(t.length>1){let n=t[1].getBigInt64Array(),r=t.length>=3&&t[2].data?t[2].dataType===10?t[2].getUint16Array()[0]:t[2].getFloat32Array()[0]:0,s=t[0].dims.length,i=new Int32Array(2*s).fill(0);if(t.length>=4){let a=t[3].getBigInt64Array();for(let l=0;l<a.length;l++)i[Number(a[l])]=Number(n[l]),i[Number(a[l])+s]=Number(n[l+a.length])}else n.forEach((a,l)=>i[Number(l)]=Number(a));let o=[];return i.forEach(a=>o.push(a)),{mode:e.mode,value:r,pads:o}}else return e},lX=(t,e)=>{W7(t.inputs);let n=Y7(t.inputs,e);t.compute(X7(t.inputs,n),{inputs:[0]})}}),P2,_S,IS,TS,SS,Q7,J7,$S,CS,uX,cX,ES,hX,dX,kS,fX,pX,mX,gX,a5e=ht(()=>{ul(),rn(),vn(),In(),P2=t=>{if(Er.webgpu.validateInputContent&&(!t||t.length!==1))throw new Error("Pool ops requires 1 input.")},_S=(t,e,n)=>{let r=e.format==="NHWC",s=t.dims.slice();r&&s.splice(1,0,s.pop());let i=Object.hasOwnProperty.call(e,"dilations"),o=e.kernelShape.slice(),a=e.strides.slice(),l=i?e.dilations.slice():[],u=e.pads.slice();ax.adjustPoolAttributes(n,s,o,a,l,u);let c=ax.computePoolOutputShape(n,s,a,l,o,u,e.autoPad),d=Object.assign({},e);i?Object.assign(d,{kernelShape:o,strides:a,pads:u,dilations:l,cacheKey:e.cacheKey}):Object.assign(d,{kernelShape:o,strides:a,pads:u,cacheKey:e.cacheKey});let f=c.slice();return f.push(f.splice(1,1)[0]),[d,r?f:c]},IS=(t,e)=>{let n=e.format==="NHWC",r=He.size(t),s=He.size(e.kernelShape),i=[{type:12,data:r},{type:12,data:s}],o=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let a=e.kernelShape[e.kernelShape.length-1],l=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],d=!!(u+c);i.push({type:12,data:a},{type:12,data:l},{type:12,data:u},{type:12,data:c}),o.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let f=!1;if(e.kernelShape.length===2){let m=e.kernelShape[e.kernelShape.length-2],g=e.strides[e.strides.length-2],y=e.pads[e.pads.length/2-2],v=e.pads[e.pads.length-2];f=!!(y+v),i.push({type:12,data:m},{type:12,data:g},{type:12,data:y},{type:12,data:v}),o.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[i,o,!0,d,f]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let a=He.computeStrides(e.kernelShape);i.push({type:12,data:a},{type:12,data:e.pads},{type:12,data:e.strides}),o.push({name:"kernelStrides",type:"u32",length:a.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let l=e.pads.reduce((u,c)=>u+c);return[i,o,!!l,!1,!1]}},TS=(t,e,n,r,s,i,o,a,l,u,c,d)=>{let f=s.format==="NHWC",m=e.type.value,g=Ft("output",e.type.tensor,r);if(s.kernelShape.length<=2){let y="",v="",b="",x=n-(f?2:1);if(c?y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${x}] < 0 || xIndices[${x}]
                      >= uniforms.x_shape[${x}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`:y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`,s.kernelShape.length===2){let $=n-(f?3:2);d?v=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${$}] < 0 || xIndices[${$}] >= uniforms.x_shape[${$}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:v=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sh - uniforms.phStart + j;
                `,b=`
              }
            `}return`
            ${t.registerUniforms(l).declareVariables(e,g)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${g.offsetToIndices("global_idx")};
              var xIndices = ${g.offsetToIndices("global_idx")};

              var value = ${m}(${a});
              var pad = 0;
              ${v}
              ${y}
              ${b}
              ${o}

              output[global_idx] = value;
            }`}else{if(f)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let y=s.kernelShape.length,v=s.pads.length,b="";return u?b=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }`:b=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${i}
            `,`
            ${t.registerUniforms(l).declareVariables(e,g)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${g.offsetToIndices("global_idx")};
              var xIndices = ${g.offsetToIndices("global_idx")};

              var offsets: array<u32, ${y}>;

              var value = ${m}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${y-1}u; j++) {
                  offsets[j] = offset / ${Mt("uniforms.kernelStrides","j",y)};
                  offset -= offsets[j] * ${Mt("uniforms.kernelStrides","j",y)};
                }
                offsets[${y-1}] = offset;

                isPad = false;
                for (var j = ${n-y}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${Mt("uniforms.strides",`j - ${n-y}u`,y)}
                    + offsets[j - ${n-y}u] - ${Mt("uniforms.pads","j - 2u",v)};
                  ${b}
              }
              ${o}

              output[global_idx] = value;
            }`}},SS=t=>`${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`,Q7=t=>`${SS(t)};${t.countIncludePad}`,J7=t=>`${SS(t)};${t.storageOrder};${t.dilations}`,$S=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),CS=(t,e,n,r)=>{let[s,i]=_S(e,r,n),o=Je("x",e.dataType,e.dims.length),a=o.type.value,l="value += x_val;",u="";s.countIncludePad?u+=`value /= ${a}(uniforms.kernelSize);`:u+=`value /= ${a}(i32(uniforms.kernelSize) - pad);`;let[c,d,f,m,g]=IS(i,s);c.push(...Ut(e.dims,i));let y=["rank"];return{name:t,shaderCache:{hint:`${r.cacheKey};${f};${m};${g}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(He.size(i)/64)},programUniforms:c}),getShaderSource:v=>TS(v,o,e.dims.length,i.length,s,l,u,0,d,f,m,g)}},uX=t=>{let e=t.count_include_pad!==0,n=$S(t);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:e,...n,cacheKey:""};return{...r,cacheKey:Q7(r)}},cX=(t,e)=>{P2(t.inputs),t.compute(CS("AveragePool",t.inputs[0],!1,e))},ES={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},hX=t=>{let e=t.format;return{format:e,...ES,cacheKey:e}},dX=(t,e)=>{P2(t.inputs),t.compute(CS("GlobalAveragePool",t.inputs[0],!0,e))},kS=(t,e,n,r)=>{let[s,i]=_S(e,r,n),o=`
      value = max(x_val, value);
    `,a="",l=Je("x",e.dataType,e.dims.length),u=["rank"],[c,d,f,m,g]=IS(i,s);return c.push(...Ut(e.dims,i)),{name:t,shaderCache:{hint:`${r.cacheKey};${f};${m};${g}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(He.size(i)/64)},programUniforms:c}),getShaderSource:y=>TS(y,l,e.dims.length,i.length,s,o,a,e.dataType===10?-65504:-1e5,d,f,m,g)}},fX=(t,e)=>{P2(t.inputs),t.compute(kS("MaxPool",t.inputs[0],!1,e))},pX=t=>{let e=t.storage_order,n=t.dilations,r=$S(t);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:e,dilations:n,...r,cacheKey:""};return{...s,cacheKey:J7(s)}},mX=t=>{let e=t.format;return{format:e,...ES,cacheKey:e}},gX=(t,e)=>{P2(t.inputs),t.compute(kS("GlobalMaxPool",t.inputs[0],!0,e))}}),Z7,eF,yX,wX,l5e=ht(()=>{rn(),vn(),us(),In(),Z7=(t,e)=>{if(t.length<2||t.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(t.length===3&&t[1].dims===t[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[0].dataType===6&&t.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(t[1].dims.length!==0&&t[1].dims.length!==1&&t[1].dims.length!==t[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(t.length>2){if(t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[1].dims.length!==t[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!t[1].dims.map((n,r)=>n===t[2].dims[r]).reduce((n,r)=>n&&r,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(e.blockSize>0){if(t[1].dims.length===0||t[1].dims.length===1&&t[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!t[1].dims.map((s,i)=>i===e.axis||s===t[0].dims[i]).reduce((s,i)=>s&&i,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(t[1].dims.length!==t[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=t[0].dims[e.axis],r=t[1].dims[e.axis];if(e.blockSize<Math.ceil(n/r)||e.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},eF=(t,e)=>{let n=He.normalizeAxis(e.axis,t[0].dims.length),r=t[0].dataType,s=r===3,i=t[0].dims,o=t[1].dataType,a=He.size(i),l=r===3||r===2,u=l?[Math.ceil(He.size(t[0].dims)/4)]:t[0].dims,c=t[1].dims,d=t.length>2?t[2]:void 0,f=d?l?[Math.ceil(He.size(d.dims)/4)]:d.dims:void 0,m=c.length===0||c.length===1&&c[0]===1,g=m===!1&&c.length===1,y=Jr(a),v=m&&(!l||y===4),b=v?y:1,x=v&&!l?y:1,$=Je("input",l?12:r,u.length,x),S=Je("scale",o,c.length),E=d?Je("zero_point",l?12:r,f.length):void 0,L=Ft("output",o,i.length,b),R=[$,S];E&&R.push(E);let D=[u,c];d&&D.push(f);let A=[{type:12,data:a/b},{type:12,data:n},{type:12,data:e.blockSize},...Ut(...D,i)],F=P=>{let K=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${P.registerUniforms(K).declareVariables(...R,L)}
      ${P.mainStart()}
          ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${L.offsetToIndices("global_idx")};

          // Set input x
          ${l?`
            let input = ${$.getByOffset("global_idx / 4")};
            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${b===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${$.getByOffset("global_idx")};`};

          // Set scale input
          ${m?`let scale_value= ${S.getByOffset("0")}`:g?`
            let scale_index = ${L.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${S.getByOffset("scale_index")};`:`
            var scale_indices: ${S.type.indices} = output_indices;
            let index = ${S.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${S.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${S.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${E?m?l?`
                let zero_point_input = ${E.getByOffset("0")};
                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${E.getByOffset("0")}`:g?l?`
                let zero_point_index = ${L.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${E.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${L.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${E.getByOffset("zero_point_index")};`:l?`
                let zero_point_offset = ${S.indicesToOffset("scale_indices")};
                let zero_point_input = ${E.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${E.getByIndices("scale_indices")};`:`let zero_point_value = ${l?s?"i32":"u32":$.type.value}(0);`};
      // Compute and write output
      ${L.setByOffset("global_idx",`${L.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:e.cacheKey,inputDependencies:E?["rank","rank","rank"]:["rank","rank"]},getShaderSource:F,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:Math.ceil(a/b/64),y:1,z:1},programUniforms:A})}},yX=(t,e)=>{Z7(t.inputs,e),t.compute(eF(t.inputs,e))},wX=t=>ur({axis:t.axis,blockSize:t.blockSize})}),tF,nF,vX,u5e=ht(()=>{ul(),rn(),In(),tF=(t,e,n)=>{let r=t===e,s=t<e&&n<0,i=t>e&&n>0;if(r||s||i)throw new Error("Range these inputs' contents are invalid.")},nF=(t,e,n,r)=>{let s=Math.abs(Math.ceil((e-t)/n)),i=[s],o=s,a=[{type:12,data:o},{type:r,data:t},{type:r,data:n},...Ut(i)],l=u=>{let c=Ft("output",r,i.length),d=c.type.value,f=[{name:"outputSize",type:"u32"},{name:"start",type:d},{name:"delta",type:d}];return`
        ${u.registerUniforms(f).declareVariables(c)}
        ${u.mainStart()}
        ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${d}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:a})}},vX=t=>{let e=0,n=0,r=0;t.inputs[0].dataType===6?(e=t.inputs[0].getInt32Array()[0],n=t.inputs[1].getInt32Array()[0],r=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(e=t.inputs[0].getFloat32Array()[0],n=t.inputs[1].getFloat32Array()[0],r=t.inputs[2].getFloat32Array()[0]),Er.webgpu.validateInputContent&&tF(e,n,r),t.compute(nF(e,n,r,t.inputs[0].dataType),{inputs:[]})}}),rF,sF,bX,xX,c5e=ht(()=>{rn(),vn(),us(),In(),rF=(t,e,n,r)=>{if(t!=="none"&&r!=="i32"&&r!=="u32"&&r!=="f32")throw new Error(`Input ${r} is not supported with reduction ${t}.`);let s=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,i=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(t){case"none":return`${e}=${n};`;case"add":return r==="i32"||r==="u32"?`atomicAdd(&${e}, bitcast<${r}>(${n}));`:`
              ${s}bitcast<${r}>(oldValue) + (${n})${i}`;case"max":return r==="i32"||r==="u32"?`atomicMax(&${e}, bitcast<${r}>(${n}));`:`
                ${s}max(bitcast<f32>(oldValue), (${n}))${i}`;case"min":return r==="i32"||r==="u32"?`atomicMin(&${e}, bitcast<${r}>(${n}));`:`${s}min(bitcast<${r}>(oldValue), (${n}))${i}`;case"mul":return`${s}(bitcast<${r}>(oldValue) * (${n}))${i}`;default:throw new Error(`Reduction ${t} is not supported.`)}},sF=(t,e)=>{let n=t[0].dims,r=t[1].dims,s=n,i=1,o=Math.ceil(He.sizeToDimension(r,r.length-1)/i),a=r[r.length-1],l=He.sizeFromDimension(n,a),u=[{type:12,data:o},{type:12,data:a},{type:12,data:l},...Ut(t[1].dims,t[2].dims,s)],c=d=>{let f=Je("indices",t[1].dataType,t[1].dims.length),m=Je("updates",t[2].dataType,t[2].dims.length,i),g=e.reduction!=="none"&&e.reduction!==""?XH("output",t[0].dataType,s.length):Ft("output",t[0].dataType,s.length,i);return`
      ${d.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(f,m,g)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${t[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${rF(e.reduction,"output[data_offset + i]","value",g.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${e.cacheKey}_${e.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:u}),getShaderSource:c}},bX=t=>ur({reduction:t.reduction}),xX=(t,e)=>{t.compute(sF(t.inputs,e),{inputs:[t.inputs[1],t.inputs[2]],outputs:[]})}}),iF,oF,aF,NS,lF,uF,cF,hF,dF,fF,pF,mF,AS,gF,yF,wF,vF,bF,_X,IX,h5e=ht(()=>{rn(),vn(),us(),In(),iF=(t,e)=>{if(t.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(e.mode==="linear"){if(!(t.length===2||t.length===3||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1||t.length===5&&t[0]===1&&t[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},oF=(t,e,n)=>{e.every(s=>s>=0&&s<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let r=new Array(n).fill(1);return e.forEach((s,i)=>r[s]=t[i]),r},aF=(t,e,n,r,s,i)=>{let[o,a,l]=n>10?[1,2,3]:[-1,t.length>1?1:-1,-1],u=t[0].dims.length;if(o>0&&t.length>o&&t[o].dims.length>0)t[o].getFloat32Array().forEach(c=>i.push(c));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&t.length>a&&t[a].dims.length===1&&t[a].dims[0]>0){if(t[a].getFloat32Array().forEach(c=>r.push(c)),r.length!==0&&r.length!==u&&n>=18&&r.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");iF(r,e),e.axes.length>0&&oF(r,e.axes,u).forEach((c,d)=>r[d]=c)}if(l>0&&t.length>l&&t[l].dims.length===1&&t[l].dims[0]>0&&(t[l].getBigInt64Array().forEach(c=>s.push(Number(c))),s.length!==0&&s.length!==u&&n>=18&&s.length!==e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(r.length!==0&&r.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(s.length!==0&&s.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof s<"u"&&r.length>0&&s.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},NS=(t,e,n,r)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${t}) * (${e});
  let whole = ${r}(big / (${n}));
  let fract = ${r}(big % (${n})) / ${r}(${n});
  return whole + fract;
`,lF=(t,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(t){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${NS("xResized","lengthOriginal","lengthResized",e)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${NS("xResized","lengthOriginal - 1","lengthResized - 1",e)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",uF=(t,e,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",cF=(t,e,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),s=t.length===0?r:t.slice();return e.length>0?(e.forEach((i,o)=>{r[i]=s[o],r[o+n]=s[e.length+o]}),r):s},hF=(t,e,n,r)=>{let s=[];if(n.length>0)if(r.length>0){if(t.forEach(i=>s.push(i)),Math.max(...r)>t.length)throw new Error("axes is out of bound");r.forEach((i,o)=>s[i]=n[o])}else n.forEach(i=>s.push(i));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");s=t.map((i,o)=>Math.round(i*e[o]))}return s},dF=(t,e,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(i=>e[i]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(i=>e[i]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let s=t.slice();return n.axes.length>0?(n.axes.forEach(i=>e[i]=r),n.axes.forEach(i=>s[i]=Math.round(t[i]*e[i]))):(e.fill(r,0,e.length),s.forEach((i,o)=>s[o]=Math.round(i*e[o]))),s},fF=(t,e,n,r,s)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${n.length}> {
      var original_indices: array<${t.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var scale = ${Mt("uniforms.scales","i",r)};
        var roi_low = ${Mt("uniforms.roi","i",s)};
        var roi_hi = ${Mt("uniforms.roi",`i + ${e.length}`,s)};
        if (scale == 1.0) {
          original_indices[i] = ${t.type.value}(output_index);
        } else {
          var input_shape_i = ${Mt("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${Mt("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,pF=(t,e,n,r,s,i,o)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
      var input_indices: ${t.type.indices};
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Mt("uniforms.scales","i",s)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Mt("uniforms.roi","i",i)};
          var roi_hi = ${Mt("uniforms.roi",`i + ${n.length}`,i)};
          var input_shape_i = ${Mt("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${Mt("uniforms.output_shape","i",r.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${o} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${t.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,mF=(t,e)=>`
    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${t.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Mt("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,AS=(t,e,n,r)=>t.rank>r?`
    ${t.indicesSet("input_indices",e,"channel")};
    ${t.indicesSet("input_indices",n,"batch")};
`:"",gF=(t,e,n,r,s)=>{let[i,o,a,l]=n.length===2?[-1,0,1,-1]:[0,2,3,1],u=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",o,`max(0, min(row, ${n[o]} - 1))`)};
      ${t.indicesSet("input_indices",a,`max(0, min(col, ${n[a]} - 1))`)};
      ${AS(t,l,i,2)}
      return ${t.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${u} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${u} = originalIndices[${o}];
      var col:${u} = originalIndices[${a}];
      ${r?`if (row < 0 || row > (${n[o]} - 1) || col < 0 || col > (${n[a]} - 1)) {
        return ${s};
      }`:""};
      row = max(0, min(row, ${n[o]} - 1));
      col = max(0, min(col, ${n[a]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${i}])`:"0"};
      var x11: ${u} = getInputValue(batch, channel, row1, col1);
      var x12: ${u} = getInputValue(batch, channel, row1, col2);
      var x21: ${u} = getInputValue(batch, channel, row2, col1);
      var x22: ${u} = getInputValue(batch, channel, row2, col2);
      var dx1: ${u} = abs(row - ${u}(row1));
      var dx2: ${u} = abs(${u}(row2) - row);
      var dy1: ${u} = abs(col - ${u}(col1));
      var dy2: ${u} = abs(${u}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},yF=(t,e,n,r,s,i,o,a,l,u)=>{let c=n.length===2,[d,f]=c?[0,1]:[2,3],m=t.type.value,g=y=>{let v=y===d?"row":"col";return`
      fn ${v}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${e.type.indices}) -> ${m} {
        var output_index = ${e.indicesGet("output_indices",y)};
        var originalIdx: ${m} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[y]},
        ${r[y]}, ${n[y]}, ${i[y]}, ${i[y]} + ${n.length});
        var fractOriginalIdx: ${m} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${n[y]} - 1))) {
          return ${l};
        }
        var data: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${v}: ${m} = originalIdx + ${m}(i);
          if (${v} < 0 || ${v} >= ${n[y]}) {
            ${u?`coefs[i + 1] = 0.0;
                        continue;`:a?`return ${l};`:`${v} = max(0, min(${v}, ${n[y]} - 1));`};
          }
        var input_indices_copy: ${t.type.indices} = input_indices;
          ${t.indicesSet("input_indices_copy",y,`u32(${v})`)};
          data[i + 1] = ${y===d?t.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${g(d)};
    ${g(f)};
  fn getCubicInterpolationCoefs(s: ${m}) -> array<${m}, 4> {
    var absS = abs(s);
    var coeffs: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${m} = 1.0 - absS;
    var twoMinusAbsS: ${m} = 2.0 - absS;
    var onePlusAbsS: ${m} = 1.0 + absS;
    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};
    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;
    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${m}, 4>, coefs: array<${m}, 4>) -> ${m} {
    var coefsSum: ${m} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${m} {
    var input_indices: ${t.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},wF=(t,e,n,r,s)=>{let[i,o,a,l,u]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],c=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${c} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",o,`max(0, min(depth, ${n[o]} - 1))`)};
      ${t.indicesSet("input_indices",a,`max(0, min(height, ${n[a]} - 1))`)};
      ${t.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};
      ${AS(t,u,i,3)}
      return ${t.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${c} = originalIndices[${o}];
      var height:${c} = originalIndices[${a}];
      var width:${c} = originalIndices[${l}];
      ${r?`if (depth < 0 || depth > (${n[o]} - 1) || height < 0 || height > (${n[a]} - 1) || width < 0 || (width > ${n[l]} - 1)) {
      return ${s};
        }`:""};

    depth = max(0, min(depth, ${n[o]} - 1));
      height = max(0, min(height, ${n[a]} - 1));
      width = max(0, min(width, ${n[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${i}])`:"0"};

      var x111: ${c} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${c} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${c} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${c} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${c} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${c} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${c} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${c} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${c} = abs(depth - ${c}(depth1));
      var dx2: ${c} = abs(${c}(depth2) - depth);
      var dy1: ${c} = abs(height - ${c}(height1));
      var dy2: ${c} = abs(${c}(height2) - height);
      var dz1: ${c} = abs(width - ${c}(width1));
      var dz2: ${c} = abs(${c}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},vF=(t,e,n,r,s,i)=>{let o=t.dims,a=cF(i,e.axes,o.length),l=hF(o,r,s,e.axes),u=r.slice();r.length===0&&(u=o.map((x,$)=>x===0?1:l[$]/x),e.keepAspectRatioPolicy!=="stretch"&&(l=dF(o,u,e)));let c=Ft("output",t.dataType,l.length),d=Je("input",t.dataType,o.length),f=He.size(l),m=o.length===l.length&&o.every((x,$)=>x===l[$]),g=e.coordinateTransformMode==="tf_crop_and_resize",y=e.extrapolationValue,v=d.type.value,b=x=>`
      ${m?"":`
      ${lF(e.coordinateTransformMode,v)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${mF(d,o)};
              ${uF(e.nearestMode,n,v)};
              ${pF(d,c,o,l,u.length,a.length,g)};
              `;case"linear":return`
              ${fF(c,o,l,u.length,a.length)};
              ${(()=>{if(o.length===2||o.length===4)return`${gF(d,c,o,g,y)}`;if(o.length===3||o.length===5)return`${wF(d,c,o,g,y)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(o.length===2||o.length===4)return`${yF(d,c,o,l,u,a,e.cubicCoeffA,g,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",a.length).declareVariables(d,c)}
      ${x.mainStart()}
        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${m?"output[global_idx] = input[global_idx];":`
        let output_indices = ${c.offsetToIndices("global_idx")};
        var input_indices: ${d.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${d.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${o.length===2||o.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${n}|${u.length>0?e.mode==="cubic"?u:u.length:""}|${s.length>0?s:""}|${a.length>0?a:""}|${m}|${e.mode==="nearest"?o.length:o}`,inputDependencies:["rank"]},getShaderSource:b,getRunData:()=>({outputs:[{dims:l,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},{type:1,data:u},{type:1,data:a},...Ut(o,l)]})}},bF=t=>{let e=t.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},_X=(t,e)=>{let n=[],r=[],s=[],i=bF(t);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");aF(t.inputs,e,i,n,r,s),t.compute(vF(t.inputs[0],e,i,n,r,s),{inputs:[0]})},IX=t=>{let e=t.antialias,n=t.axes,r=t.coordinateTransformMode,s=t.cubicCoeffA,i=t.excludeOutside!==0,o=t.extrapolationValue,a=t.keepAspectRatioPolicy,l=t.mode,u=t.nearestMode===""?"simple":t.nearestMode;return ur({antialias:e,axes:n,coordinateTransformMode:r,cubicCoeffA:s,excludeOutside:i,extrapolationValue:o,keepAspectRatioPolicy:a,mode:l,nearestMode:u})}}),xF,_F,TX,d5e=ht(()=>{rn(),vn(),In(),xF=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=t[0],n=t[1],r=t[2];if(e.dataType!==n.dataType||e.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let s=e.dims[e.dims.length-1],i=e.dims[e.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(r.dims.length!==1)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let o=t[3];if(o.dims.length!==1)throw new Error("Beta must be 1D");if(o.dims[o.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let o=t[4];if(o.dims.length!==1)throw new Error("Bias must be 1D");if(o.dims[o.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},_F=(t,e,n,r)=>{let s=e.simplified,i=t[0].dims,o=He.size(i),a=i,l=o,u=i.slice(-1)[0],c=r?i.slice(0,-1).concat(1):[],d=!s&&t.length>3,f=t.length>4,m=r&&n>1,g=r&&n>2,y=n>3,v=64,b=Jr(u),x=[{type:12,data:l},{type:12,data:b},{type:12,data:u},{type:1,data:e.epsilon}],$=E=>{let L=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],R=[Je("x",t[0].dataType,t[0].dims,b),Je("skip",t[1].dataType,t[1].dims,b),Je("gamma",t[2].dataType,t[2].dims,b)];d&&R.push(Je("beta",t[3].dataType,t[3].dims,b)),f&&R.push(Je("bias",t[4].dataType,t[4].dims,b)),R.push(Ft("output",t[0].dataType,a,b)),m&&R.push(Ft("mean_output",1,c)),g&&R.push(Ft("inv_std_output",1,c)),y&&R.push(Ft("input_skip_bias_sum",t[0].dataType,a,b));let D=si(t[0].dataType),A=si(1,b);return`

      ${E.registerUniforms(L).declareVariables(...R)}
      var<workgroup> sum_shared : array<${A}, ${v}>;
      var<workgroup> sum_squared_shared : array<${A}, ${v}>;

      ${E.mainStart([v,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${v};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${v};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${v-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${f?"bias[offset1d + i]":D+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${y?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${wm(D,b,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${v};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Vh("sum",b)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Vh("square_sum",b)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);
        ${m?"mean_output[global_idx] = mean;":""}
        ${g?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${s?"":`- ${D}(mean)`}) *
            ${D}(inv_std_dev) * gamma[offset1d + i]
            ${d?"+ beta[offset1d + i]":""};
        }
      }`},S=[{dims:a,dataType:t[0].dataType}];return n>1&&S.push({dims:c,dataType:1}),n>2&&S.push({dims:c,dataType:1}),n>3&&S.push({dims:i,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${b};${m};${g};${y}`,inputDependencies:t.map((E,L)=>"type")},getShaderSource:$,getRunData:()=>({outputs:S,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:x})}},TX=(t,e)=>{xF(t.inputs);let n=[0];t.outputCount>1&&n.push(-3),t.outputCount>2&&n.push(-3),t.outputCount>3&&n.push(3),t.compute(_F(t.inputs,e,t.outputCount,!1),{outputs:n})}}),IF,F2,TF,RS,SF,$F,SX,$X,f5e=ht(()=>{rn(),vn(),us(),In(),IF=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((n,r)=>{if(t[r+1].dataType!==6&&t[r+1].dataType!==7)throw new Error(`Input ${r} must be an array of int32 or int64`)})},F2=(t,e)=>{let n=[];if(t.length>e)if(t[e].dataType===7)t[e].getBigInt64Array().forEach(r=>n.push(Number(r)));else if(t[e].dataType===6)t[e].getInt32Array().forEach(r=>n.push(Number(r)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return n},TF=(t,e)=>{if(t.length>1){let n=F2(t,1),r=F2(t,2),s=F2(t,3);return s.length===0&&(s=[...Array(t[0].dims.length).keys()]),ur({starts:n,ends:r,axes:s})}else return e},RS=(t,e,n,r,s)=>{let i=t;return t<0&&(i+=n[r[e]]),s[e]<0?Math.max(0,Math.min(i,n[r[e]]-1)):Math.max(0,Math.min(i,n[r[e]]))},SF=(t,e,n)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
          var input_indices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${n.length-1}; i >= 0; i--) {
            let input_shape_i = ${Mt("uniforms.input_shape","i",n.length)};
            let steps_i = ${Mt("uniforms.steps","i",n.length)};
            let signs_i = ${Mt("uniforms.signs","i",n.length)};
            let starts_i = ${Mt("uniforms.starts","i",n.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${t.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,$F=(t,e)=>{let n=t[0].dims,r=He.size(n),s=e.axes.length>0?He.normalizeAxes(e.axes,n.length):[...Array(n.length).keys()],i=F2(t,4);i.forEach(b=>b!==0||(()=>{throw new Error("step cannot be 0")})),i.length===0&&(i=Array(s.length).fill(1));let o=e.starts.map((b,x)=>RS(b,x,n,s,i)),a=e.ends.map((b,x)=>RS(b,x,n,s,i));if(s.length!==o.length||s.length!==a.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let b=0;b<n.length;++b)s.includes(b)||(o.splice(b,0,0),a.splice(b,0,n[b]),i.splice(b,0,1));let l=i.map(b=>Math.sign(b));i.forEach((b,x,$)=>{if(b<0){let S=(a[x]-o[x])/b,E=o[x],L=E+S*i[x];o[x]=L,a[x]=E,$[x]=-b}});let u=n.slice(0);s.forEach((b,x)=>{u[b]=Math.ceil((a[b]-o[b])/i[b])});let c={dims:u,dataType:t[0].dataType},d=Ft("output",t[0].dataType,u.length),f=Je("input",t[0].dataType,t[0].dims.length),m=He.size(u),g=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:o.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:i.length}],y=[{type:12,data:m},{type:12,data:o},{type:6,data:l},{type:12,data:i},...Ut(t[0].dims,u)],v=b=>`
      ${b.registerUniforms(g).declareVariables(f,d)}
        ${SF(f,d,n)}
        ${b.mainStart()}
          ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${d.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${d.setByOffset("global_idx",f.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${o.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:v,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:y})}},SX=(t,e)=>{IF(t.inputs,e);let n=TF(t.inputs,e);t.compute($F(t.inputs,n),{inputs:[0]})},$X=t=>{let e=t.starts,n=t.ends,r=t.axes;return ur({starts:e,ends:n,axes:r})}}),CF,EF,CX,EX,p5e=ht(()=>{rn(),vn(),us(),Zh(),In(),CF=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},EF=(t,e)=>{let n=t.inputs[0],r=n.dims,s=He.size(r),i=r.length,o=He.normalizeAxis(e.axis,i),a=o<r.length-1,l,u=[];a?(u=Array.from({length:i},(R,D)=>D),u[o]=i-1,u[i-1]=o,l=t.compute(Ea(n,u),{inputs:[n],outputs:[-1]})[0]):l=n;let c=l.dims,d=c[i-1],f=s/d,m=Jr(d),g=d/m,y=64;f===1&&(y=256);let v=(R,D)=>D===4?`max(max(${R}.x, ${R}.y), max(${R}.z, ${R}.w))`:D===2?`max(${R}.x, ${R}.y)`:D===3?`max(max(${R}.x, ${R}.y), ${R}.z)`:R,b=Je("x",l.dataType,l.dims,m),x=Ft("result",l.dataType,l.dims,m),$=b.type.value,S=si(l.dataType)==="f32"?`var threadMax = ${$}(-3.402823e+38f);`:`var threadMax = ${$}(-65504.0h);`,E=R=>`
      var<workgroup> rowMaxShared : ${$};
      var<workgroup> rowSumShared : ${$};
      var<workgroup> threadShared : array<${$}, ${y}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${$} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${$}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${R.registerUniform("packedCols","i32").declareVariables(b,x)}
      ${R.mainStart(y)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${y};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${S}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${$}(${v("threadShared[0]",m)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${$}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${$}(${Vh("threadShared[0]",m)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${$}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`,L=t.compute({name:"Softmax",shaderCache:{hint:`${m};${y}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:c,dataType:l.dataType}],dispatchGroup:{x:f},programUniforms:[{type:6,data:g}]}),getShaderSource:E},{inputs:[l],outputs:[a?-1:0]})[0];a&&t.compute(Ea(L,u),{inputs:[L]})},CX=(t,e)=>{CF(t.inputs),EF(t,e)},EX=t=>ur({axis:t.axis})}),DS,kF,NF,AF,kX,m5e=ht(()=>{rn(),vn(),In(),DS=t=>Array.from(t.getBigInt64Array(),Number),kF=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==10&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(DS(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},NF=(t,e)=>{let n=[];for(let r=0;r<t.length;++r)n.push(t[r]*e[r]);return n},AF=(t,e)=>{let n=t[0].dims,r=e??DS(t[1]),s=NF(n,r),i=He.size(s),o=t[0].dataType,a=Je("input",o,n.length),l=Ft("output",o,s.length),u=c=>`
      const inputShape = ${a.indices(...n)};
      ${c.registerUniform("output_size","u32").declareVariables(a,l)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${a.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;

        ${a.indicesSet("input_indices","i","input_dim_value")}
      }
      ${l.setByOffset("global_idx",a.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...Ut(t[0].dims,s)]}),getShaderSource:u}},kX=t=>{kF(t.inputs),t.compute(AF(t.inputs),{inputs:[0]})}}),RF,DF,NX,g5e=ht(()=>{rn(),vn(),In(),RF=(t,e,n,r,s)=>{let i=Ft("output_data",s,n.length,4),o=Je("a_data",e[1].dataType,e[1].dims.length,4),a=Je("b_data",e[2].dataType,e[2].dims.length,4),l=Je("c_data",e[0].dataType,e[0].dims.length,4),u,c=(d,f,m)=>`select(${f}, ${d}, ${m})`;if(!r)u=i.setByOffset("global_idx",c(o.getByOffset("global_idx"),a.getByOffset("global_idx"),l.getByOffset("global_idx")));else{let d=(f,m,g="")=>{let y=`a_data[index_a${m}][component_a${m}]`,v=`b_data[index_b${m}][component_b${m}]`,b=`bool(c_data[index_c${m}] & (0xffu << (component_c${m} * 8)))`;return`
            let output_indices${m} = ${i.offsetToIndices(`global_idx * 4u + ${m}u`)};
            let offset_a${m} = ${o.broadcastedIndicesToOffset(`output_indices${m}`,i)};
            let offset_b${m} = ${a.broadcastedIndicesToOffset(`output_indices${m}`,i)};
            let offset_c${m} = ${l.broadcastedIndicesToOffset(`output_indices${m}`,i)};
            let index_a${m} = offset_a${m} / 4u;
            let index_b${m} = offset_b${m} / 4u;
            let index_c${m} = offset_c${m} / 4u;
            let component_a${m} = offset_a${m} % 4u;
            let component_b${m} = offset_b${m} % 4u;
            let component_c${m} = offset_c${m} % 4u;
            ${f}[${m}] = ${g}(${c(y,v,b)});
          `};s===9?u=`
            var data = vec4<u32>(0);
            ${d("data",0,"u32")}
            ${d("data",1,"u32")}
            ${d("data",2,"u32")}
            ${d("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:u=`
            ${d("output_data[global_idx]",0)}
            ${d("output_data[global_idx]",1)}
            ${d("output_data[global_idx]",2)}
            ${d("output_data[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(l,o,a,i)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${u}
      }`},DF=t=>{let e=t[1].dims,n=t[2].dims,r=t[0].dims,s=t[1].dataType,i=!(He.areEqual(e,n)&&He.areEqual(n,r)),o=e,a=He.size(e);if(i){let u=Qm.calcShape(Qm.calcShape(e,n,!1),r,!1);if(!u)throw new Error("Can't perform where op on the given tensors");o=u,a=He.size(o)}let l=Math.ceil(a/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:u=>RF(u,t,o,i,s),getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(a/64/4)},programUniforms:[{type:12,data:l},...Ut(r,e,n,o)]})}},NX=t=>{t.compute(DF(t.inputs))}}),AX,y5e=ht(()=>{ADe(),IR(),RDe(),DDe(),ODe(),PDe(),FDe(),BDe(),WDe(),jDe(),GDe(),HDe(),qDe(),KDe(),XDe(),YDe(),QDe(),JDe(),ZDe(),e5e(),t5e(),n5e(),r5e(),s5e(),i5e(),YK(),o5e(),a5e(),l5e(),u5e(),c5e(),_R(),h5e(),tX(),d5e(),f5e(),p5e(),ZK(),m5e(),Zh(),TR(),g5e(),AX=new Map([["Abs",[Tq]],["Acos",[Sq]],["Acosh",[$q]],["Add",[oK]],["ArgMax",[bq,cC]],["ArgMin",[vq,cC]],["Asin",[Cq]],["Asinh",[Eq]],["Atan",[kq]],["Atanh",[Nq]],["Attention",[xq]],["AveragePool",[cX,uX]],["BatchNormalization",[_q]],["BiasAdd",[Iq]],["BiasSplitGelu",[iK]],["Cast",[Rq,Aq]],["Ceil",[Oq]],["Clip",[Dq]],["Concat",[gK,yK]],["Conv",[gC,mC]],["ConvTranspose",[CK,$K]],["Cos",[Pq]],["Cosh",[Fq]],["CumSum",[EK,kK]],["DepthToSpace",[NK,AK]],["DequantizeLinear",[yX,wX]],["Div",[aK]],["Einsum",[RK,DK]],["Elu",[Lq,sy]],["Equal",[lK]],["Erf",[Mq]],["Exp",[zq]],["Expand",[OK]],["FastGelu",[PK]],["Floor",[Vq]],["FusedConv",[gC,mC]],["Gather",[LK,FK]],["GatherElements",[WK,UK]],["GatherBlockQuantized",[VK,BK]],["GatherND",[MK,zK]],["Gelu",[Bq]],["Gemm",[GK,jK]],["GlobalAveragePool",[dX,hX]],["GlobalMaxPool",[gX,mX]],["Greater",[dK]],["GreaterOrEqual",[pK]],["GridSample",[HK,qK]],["GroupQueryAttention",[nX]],["HardSigmoid",[Xq,Kq]],["InstanceNormalization",[rX]],["LayerNormalization",[sX]],["LeakyRelu",[Uq,sy]],["Less",[fK]],["LessOrEqual",[mK]],["Log",[rK]],["MatMul",[iX]],["MatMulNBits",[oX,aX]],["MaxPool",[fX,pX]],["Mul",[uK]],["MultiHeadAttention",[XK,KK]],["Neg",[jq]],["Not",[Wq]],["Pad",[lX]],["Pow",[cK]],["QuickGelu",[sK,sy]],["Range",[vX]],["Reciprocal",[Gq]],["ReduceMin",[pq]],["ReduceMean",[uq]],["ReduceMax",[fq]],["ReduceSum",[gq]],["ReduceProd",[mq]],["ReduceL1",[cq]],["ReduceL2",[hq]],["ReduceLogSum",[wq]],["ReduceLogSumExp",[dq]],["ReduceSumSquare",[yq]],["Relu",[Hq]],["Resize",[_X,IX]],["RotaryEmbedding",[eX]],["ScatterND",[xX,bX]],["Sigmoid",[qq]],["Sin",[Yq]],["Sinh",[Qq]],["Slice",[SX,$X]],["SkipLayerNormalization",[TX]],["Split",[QK,JK]],["Sqrt",[Jq]],["Softmax",[CX,EX]],["Sub",[hK]],["Tan",[Zq]],["Tanh",[eK]],["ThresholdedRelu",[nK,sy]],["Tile",[kX]],["Transpose",[QH,JH]],["Where",[NX]]])}),RX,w5e=ht(()=>{ul(),Tc(),In(),RX=class{constructor(t){this.backend=t,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n,r,s){Wl(t.programInfo.name);let i=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let a=[];for(let u of e)a.push({binding:a.length,resource:{buffer:u.buffer}});for(let u of n)a.push({binding:a.length,resource:{buffer:u.buffer}});s&&a.push({binding:a.length,resource:s});let l=i.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:a,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let u={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:l,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(u)}o.setPipeline(t.computePipeline),o.setBindGroup(0,l),o.dispatchWorkgroups(...r),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),sl(t.programInfo.name)}dispose(){}build(t,e){Wl(t.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(u=>{n.features.has(u.feature)&&r.push(`enable ${u.extension};`)});let s=YH(e,this.backend.device.limits),i=t.getShaderSource(s),o=`${r.join(`
`)}
${s.additionalImplementations}
${i}`,a=n.createShaderModule({code:o,label:t.name});qn("verbose",()=>`[WebGPU] ${t.name} shader code: ${o}`);let l=n.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return sl(t.name),{programInfo:t,computePipeline:l,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(t){let e=typeof t=="number"?t:t.x,n=typeof t=="number"?1:t.y||1,r=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=s&&n<=s&&r<=s)return[e,n,r];let i=e*n*r,o=Math.ceil(Math.sqrt(i));if(o>s){if(o=Math.ceil(Math.cbrt(i)),o>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}else return[o,o,1]}}}),DX={};W1(DX,{WebGpuBackend:()=>OX});var OF,PF,FF,OX,v5e=ht(()=>{ul(),rn(),Tc(),GH(),kDe(),y5e(),w5e(),OF=(t,e)=>{if(e.length!==t.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${t.length}.`);let n=[];for(let r=0;r<t.length;++r){let s=t[r].dataType;switch(e[r]){case"none":{n.push("");break}case"type":{n.push(`${s}`);break}case"rank":{let i=t[r].dims.length;n.push(`${s};${i}`);break}case"dims":{let i=t[r].dims.join(",");n.push(`${s};${i}`);break}default:throw new Error(`unsupported input dependency: ${e[r]}`)}}return n.join("|")},PF=(t,e,n)=>{let r=t.name;return t.shaderCache?.hint&&(r+="["+t.shaderCache.hint+"]"),r+=":"+n+`:${OF(e,t.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,r},FF=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},OX=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,e){this.env=t;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},s=i=>e.features.has(i)&&n.push(i)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups"),this.device=await e.requestDevice(r),this.adapterInfo=new FF(e.info||await e.requestAdapterInfo()),this.gpuDataManager=KH(this),this.programManager=new RX(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,wR(t.logLevel,!!t.debug),this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Wl(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let e=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let r=0;r<e.length/2;r++){let s=n[r],i=s.kernelId,o=this.kernels.get(i),a=o.kernelType,l=o.kernelName,u=s.programName,c=s.inputTensorViews,d=s.outputTensorViews,f=e[r*2],m=e[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=f);let g=Number(f-this.queryTimeBase),y=Number(m-this.queryTimeBase);if(!Number.isSafeInteger(g)||!Number.isSafeInteger(y))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:c.map(v=>({dims:v.dims,dataType:Ku(v.dataType)})),outputsMetadata:d.map(v=>({dims:v.dims,dataType:Ku(v.dataType)})),kernelId:i,kernelType:a,kernelName:l,programName:u,startTime:g,endTime:y});else{let v="";c.forEach((x,$)=>{v+=`input[${$}]: [${x.dims}] | ${Ku(x.dataType)}, `});let b="";d.forEach((x,$)=>{b+=`output[${$}]: [${x.dims}] | ${Ku(x.dataType)}, `}),console.log(`[profiling] kernel "${i}|${a}|${l}|${u}" ${v}${b}start time: ${g} ns, execution time: ${y-g} ns`)}Wy("GPU",`${u}::${f}::${m}`)}t.unmap(),this.pendingQueries.delete(t)}),sl()}run(t,e,n,r,s,i){Wl(t.name);let o=[];for(let x=0;x<e.length;++x){let $=e[x].data;if($===0)continue;let S=this.gpuDataManager.get($);if(!S)throw new Error(`no GPU data for input: ${$}`);o.push(S)}let{outputs:a,dispatchGroup:l,programUniforms:u}=t.getRunData(e),c=n.length===0?a.map((x,$)=>$):n;if(c.length!==a.length)throw new Error(`Output size ${c.length} must be equal to ${a.length}.`);let d=[],f=[];for(let x=0;x<a.length;++x){if(!Number.isInteger(c[x])||c[x]<-3||c[x]>=i)throw new Error(`Invalid output index: ${c[x]}`);if(c[x]===-3)continue;let $=c[x]===-1,S=c[x]===-2,E=$||S?s(a[x].dataType,a[x].dims):r(c[x],a[x].dataType,a[x].dims);if(d.push(E),E.data===0)continue;let L=this.gpuDataManager.get(E.data);if(!L)throw new Error(`no GPU data for output: ${E.data}`);if($&&this.temporaryData.push(L),S){let R=this.kernelPersistentData.get(this.currentKernelId);R||(R=[],this.kernelPersistentData.set(this.currentKernelId,R)),R.push(L)}f.push(L)}if(o.length!==e.length||f.length!==d.length){if(f.length===0)return sl(t.name),d;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let m;if(u){let x=0,$=[];u.forEach(R=>{let D=typeof R.data=="number"?[R.data]:R.data;if(D.length===0)return;let A=R.type===10?2:4,F,P;R.type===10?(P=D.length>4?16:D.length>2?8:D.length*A,F=D.length>4?16:A*D.length):(P=D.length<=2?D.length*A:16,F=16),x=Math.ceil(x/P)*P,$.push(x);let K=R.type===10?8:4;x+=D.length>4?Math.ceil(D.length/K)*F:D.length*A});let S=16;x=Math.ceil(x/S)*S;let E=new ArrayBuffer(x);u.forEach((R,D)=>{let A=$[D],F=typeof R.data=="number"?[R.data]:R.data;if(R.type===6)new Int32Array(E,A,F.length).set(F);else if(R.type===12)new Uint32Array(E,A,F.length).set(F);else if(R.type===10)new Uint16Array(E,A,F.length).set(F);else if(R.type===1)new Float32Array(E,A,F.length).set(F);else throw new Error(`Unsupported uniform type: ${Ku(R.type)}`)});let L=this.gpuDataManager.create(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(L.buffer,0,E,0,x),this.gpuDataManager.release(L.id),m={offset:0,size:x,buffer:L.buffer}}let g=this.programManager.normalizeDispatchGroupSize(l),y=g[1]===1&&g[2]===1,v=PF(t,e,y),b=this.programManager.getArtifact(v);if(b||(b=this.programManager.build(t,g),this.programManager.setArtifact(v,b),qn("info",()=>`[artifact] key: ${v}, programName: ${t.name}`)),u&&b.uniformVariablesInfo){if(u.length!==b.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${b.uniformVariablesInfo.length}, got ${u.length} in program "${b.programInfo.name}".`);for(let x=0;x<u.length;x++){let $=u[x],S=$.type,E=typeof $.data=="number"?1:$.data.length,[L,R]=b.uniformVariablesInfo[x];if(S!==L||E!==R)throw new Error(`Uniform variable ${x} mismatch: expect type ${L} with size ${R}, got type ${S} with size ${E} in program "${b.programInfo.name}".`)}}if(qn("info",()=>`[ProgramManager] run "${t.name}" (key=${v}) with ${g[0]}x${g[1]}x${g[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let x={kernelId:this.currentKernelId,programName:b.programInfo.name,inputTensorViews:e,outputTensorViews:d};this.pendingKernels.push(x),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(x)}return this.programManager.run(b,o,f,g,m),sl(t.name),d}upload(t,e){this.gpuDataManager.upload(t,e)}memcpy(t,e){this.gpuDataManager.memcpy(t,e)}async download(t,e){await this.gpuDataManager.download(t,e)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,e,n,r){let s=AX.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);let i={kernelType:t,kernelName:r,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(e,i)}releaseKernel(t){let e=this.kernelPersistentData.get(t);if(e){for(let n of e)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,e,n){let r=this.kernels.get(t);if(!r)throw new Error(`kernel not created: ${t}`);let s=r.kernelType,i=r.kernelName,o=r.kernelEntry,a=r.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${i}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),qn("info",()=>`[WebGPU] Start to run kernel "[${s}] ${i}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),o(e,a[1]),0}catch(u){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${i}" failed. ${u}`)),1}finally{l&&n.push(this.device.popErrorScope().then(u=>u?`GPU validation error for kernel "[${s}] ${i}": ${u.message}`:null));for(let u of this.temporaryData)this.gpuDataManager.release(u.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,e,n,r){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let i=s.get(e),o=this.gpuDataManager.registerExternalBuffer(n,r,i);return s.set(e,[o,n]),o}unregisterBuffers(t){let e=this.sessionExternalDataMapping.get(t);e&&(e.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let e=this.gpuDataManager.get(t);if(!e)throw new Error(`no GPU data for buffer: ${t}`);return e.buffer}createDownloader(t,e,n){return async()=>{let r=await aC(this,t,e);return vR(r.buffer,n)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){qn("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){qn("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){qn("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let r=0;r<n;r++){let s=this.getComputePassEncoder(),i=t[r];this.writeTimestamp(this.pendingDispatchNumber*2),s.setPipeline(i.computePipeline),s.setBindGroup(0,i.bindGroup),s.dispatchWorkgroups(...i.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}}),PX={};W1(PX,{init:()=>FX});var Dv,LF,FX,b5e=ht(()=>{rn(),Tc(),vn(),EDe(),Dv=class LX{constructor(e,n,r,s){this.module=e,this.dataType=n,this.data=r,this.dims=s}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=He.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=He.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=He.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let e=He.size(this.dims);return e===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(He.size(e)!==He.size(this.dims))throw new Error("Invalid new shape");return new LX(this.module,this.dataType,this.data,e)}},LF=class{constructor(t,e,n){this.module=t,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let r=t.PTR_SIZE,s=n/t.PTR_SIZE,i=r===4?"i32":"i64";this.opKernelContext=Number(t.getValue(r*s++,i));let o=Number(t.getValue(r*s++,i));this.outputCount=Number(t.getValue(r*s++,i)),this.customDataOffset=Number(t.getValue(r*s++,"*")),this.customDataSize=Number(t.getValue(r*s++,i));let a=[];for(let l=0;l<o;l++){let u=Number(t.getValue(r*s++,i)),c=Number(t.getValue(r*s++,"*")),d=Number(t.getValue(r*s++,i)),f=[];for(let m=0;m<d;m++)f.push(Number(t.getValue(r*s++,i)));a.push(new Dv(t,u,c,f))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,e){let n=e?.inputs?.map(o=>typeof o=="number"?this.inputs[o]:o)??this.inputs,r=e?.outputs??[],s=(o,a,l)=>new Dv(this.module,a,this.output(o,l),l),i=(o,a)=>{let l=Ed(o,a);if(!l)throw new Error(`Unsupported data type: ${o}`);let u=l>0?this.backend.gpuDataManager.create(l).id:0;return new Dv(this.module,o,u,a)};return this.backend.run(t,n,r,s,i,this.outputCount)}output(t,e){let n=this.module.stackSave();try{let r=this.module.PTR_SIZE,s=r===4?"i32":"i64",i=this.module.stackAlloc((1+e.length)*r);this.module.setValue(i,e.length,s);for(let o=0;o<e.length;o++)this.module.setValue(i+r*(o+1),e[o],s);return this.module._JsepOutput(this.opKernelContext,t,i)}catch(r){throw new Error(`Failed to generate kernel's output[${t}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${r}`)}finally{this.module.stackRestore(n)}}},FX=async(t,e,n,r)=>{let s=e.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(t==="webgpu"){let i=(v5e(),Uy(DX)).WebGpuBackend,o=new i;await o.initialize(n,r),s("webgpu",[o,a=>o.alloc(Number(a)),a=>o.free(a),(a,l,u,c=!1)=>{if(c)qn("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(a)}, dst=${Number(l)}, size=${Number(u)}`),o.memcpy(Number(a),Number(l));else{qn("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(a)}, gpuDataId=${Number(l)}, size=${Number(u)}`);let d=e.HEAPU8.subarray(Number(a>>>0),Number(a>>>0)+Number(u));o.upload(Number(l),d)}},async(a,l,u)=>{qn("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${l}, size=${u}`),await o.download(Number(a),()=>e.HEAPU8.subarray(Number(l)>>>0,Number(l+u)>>>0))},(a,l,u)=>o.createKernel(a,Number(l),u,e.UTF8ToString(e._JsepGetNodeName(Number(l)))),a=>o.releaseKernel(a),(a,l,u,c)=>{qn("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${a}, contextDataOffset=${l}`);let d=new LF(e,o,Number(l));return o.computeKernel(Number(a),d,c)},()=>o.captureBegin(),()=>o.captureEnd(),()=>o.replay()])}else{let i=new qH(n);s("webnn",[i,()=>i.reserveTensorId(),o=>i.releaseTensorId(o),async(o,a,l,u,c)=>i.ensureTensor(o,a,l,u,c),(o,a)=>{i.uploadTensor(o,a)},async(o,a)=>i.downloadTensor(o,a),(o,a)=>i.registerMLContext(o,a),!!n.trace])}}}),MF,NR,AR,Kc,zF,OS,hx,RR,DR,PS,OR,PR,FR,MX=ht(()=>{ul(),SDe(),$De(),rn(),Op(),pR(),BH(),MF=(t,e)=>{Tr()._OrtInit(t,e)!==0&&mr("Can't initialize onnxruntime.")},NR=async t=>{MF(t.wasm.numThreads,ox(t.logLevel))},AR=async(t,e)=>{Tr().asyncInit?.();let n=t.webgpu.adapter;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(n){if(typeof n.limits!="object"||typeof n.features!="object"||typeof n.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let r=t.webgpu.powerPreference;if(r!==void 0&&r!=="low-power"&&r!=="high-performance")throw new Error(`Invalid powerPreference setting: "${r}"`);let s=t.webgpu.forceFallbackAdapter;if(s!==void 0&&typeof s!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${s}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:r,forceFallbackAdapter:s}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(e==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");{let r=(b5e(),Uy(PX)).init;e==="webgpu"&&await r("webgpu",Tr(),t,n),e==="webnn"&&await r("webnn",Tr(),t)}},Kc=new Map,zF=t=>{let e=Tr(),n=e.stackSave();try{let r=e.PTR_SIZE,s=e.stackAlloc(2*r);e._OrtGetInputOutputCount(t,s,s+r)!==0&&mr("Can't get session input/output count.");let i=r===4?"i32":"i64";return[Number(e.getValue(s,i)),Number(e.getValue(s+r,i))]}finally{e.stackRestore(n)}},OS=(t,e)=>{let n=Tr(),r=n.stackSave(),s=0;try{let i=n.PTR_SIZE,o=n.stackAlloc(2*i);n._OrtGetInputOutputMetadata(t,e,o,o+i)!==0&&mr("Can't get session input/output metadata.");let a=Number(n.getValue(o,"*"));s=Number(n.getValue(o+i,"*"));let l=n.HEAP32[s/4];if(l===0)return[a,0];let u=n.HEAPU32[s/4+1],c=[];for(let d=0;d<u;d++){let f=Number(n.getValue(s+8+d*i,"*"));c.push(f!==0?n.UTF8ToString(f):Number(n.getValue(s+8+(d+u)*i,"*")))}return[a,l,c]}finally{n.stackRestore(r),s!==0&&n._OrtFree(s)}},hx=t=>{let e=Tr(),n=e._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},RR=async(t,e)=>{let n,r,s=Tr();Array.isArray(t)?[n,r]=t:t.buffer===s.HEAPU8.buffer?[n,r]=[t.byteOffset,t.byteLength]:[n,r]=hx(t);let i=0,o=0,a=0,l=[],u=[],c=[];try{if([o,l]=await VH(e),e?.externalData&&s.mountExternalData){let S=[];for(let E of e.externalData){let L=typeof E=="string"?E:E.path;S.push(yR(typeof E=="string"?E:E.data).then(R=>{s.mountExternalData(L,R)}))}await Promise.all(S)}for(let S of e?.executionProviders??[])if((typeof S=="string"?S:S.name)==="webnn"){if(s.shouldTransferToMLTensor=!1,typeof S!="string"){let E=S,L=E?.context,R=E?.gpuDevice,D=E?.deviceType,A=E?.powerPreference;L?s.currentContext=L:R?s.currentContext=await s.webnnCreateMLContext(R):s.currentContext=await s.webnnCreateMLContext({deviceType:D,powerPreference:A})}else s.currentContext=await s.webnnCreateMLContext();break}i=await s._OrtCreateSession(n,r,o),s.webgpuOnCreateSession?.(i),i===0&&mr("Can't create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.webnnRegisterMLContext(i,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[d,f]=zF(i),m=!!e?.enableGraphCapture,g=[],y=[],v=[],b=[],x=[];for(let S=0;S<d;S++){let[E,L,R]=OS(i,S);E===0&&mr("Can't get an input name."),u.push(E);let D=s.UTF8ToString(E);g.push(D),v.push(L===0?{name:D,isTensor:!1}:{name:D,isTensor:!0,type:Ku(L),shape:R})}for(let S=0;S<f;S++){let[E,L,R]=OS(i,S+d);E===0&&mr("Can't get an output name."),c.push(E);let D=s.UTF8ToString(E);y.push(D),b.push(L===0?{name:D,isTensor:!1}:{name:D,isTensor:!0,type:Ku(L),shape:R});{if(m&&e?.preferredOutputLocation===void 0){x.push("gpu-buffer");continue}let A=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[D]??"cpu",F=s.webnnIsGraphOutput;if(A==="cpu"&&F&&F(i,D)){x.push("ml-tensor-cpu-output");continue}if(A!=="cpu"&&A!=="cpu-pinned"&&A!=="gpu-buffer"&&A!=="ml-tensor")throw new Error(`Not supported preferred output location: ${A}.`);if(m&&A!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);x.push(A)}}let $=null;return x.some(S=>S==="gpu-buffer"||S==="ml-tensor"||S==="ml-tensor-cpu-output")&&(a=s._OrtCreateBinding(i),a===0&&mr("Can't create IO binding."),$={handle:a,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map(S=>S==="ml-tensor-cpu-output"?"ml-tensor":S).map(S=>iC(S))}),Kc.set(i,[i,u,c,$,m,!1]),[i,g,y,v,b]}catch(d){throw u.forEach(f=>s._OrtFree(f)),c.forEach(f=>s._OrtFree(f)),a!==0&&s._OrtReleaseBinding(a)!==0&&mr("Can't release IO binding."),i!==0&&s._OrtReleaseSession(i)!==0&&mr("Can't release session."),d}finally{s._free(n),o!==0&&s._OrtReleaseSessionOptions(o)!==0&&mr("Can't release session options."),l.forEach(d=>s._free(d)),s.unmountExternalData?.()}},DR=t=>{let e=Tr(),n=Kc.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[r,s,i,o,a]=n;o&&(a&&e._OrtClearBoundOutputs(o.handle)!==0&&mr("Can't clear bound outputs."),e._OrtReleaseBinding(o.handle)!==0&&mr("Can't release IO binding.")),e.jsepOnReleaseSession?.(t),e.webnnOnReleaseSession?.(t),e.webgpuOnReleaseSession?.(t),s.forEach(l=>e._OrtFree(l)),i.forEach(l=>e._OrtFree(l)),e._OrtReleaseSession(r)!==0&&mr("Can't release session."),Kc.delete(t)},PS=async(t,e,n,r,s,i,o=!1)=>{if(!t){e.push(0);return}let a=Tr(),l=a.PTR_SIZE,u=t[0],c=t[1],d=t[3],f=d,m,g;if(u==="string"&&(d==="gpu-buffer"||d==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let b=t[2].gpuBuffer;g=Ed(Cd(u),c);{let x=a.jsepRegisterBuffer;if(!x)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');m=x(r,i,b,g)}}else if(d==="ml-tensor"){let b=t[2].mlTensor;g=Ed(Cd(u),c);let x=a.webnnRegisterMLTensor;if(!x)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');m=x(r,b,Cd(u),c)}else{let b=t[2];if(Array.isArray(b)){g=l*b.length,m=a._malloc(g),n.push(m);for(let x=0;x<b.length;x++){if(typeof b[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);a.setValue(m+x*l,El(b[x],n),"*")}}else{let x=a.webnnIsGraphInput,$=a.webnnIsGraphOutput;if(u!=="string"&&x&&$){let S=a.UTF8ToString(s);if(x(r,S)||$(r,S)){let E=Cd(u);g=Ed(E,c),f="ml-tensor";let L=a.webnnCreateTemporaryTensor,R=a.webnnUploadTensor;if(!L||!R)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let D=await L(r,E,c);R(D,new Uint8Array(b.buffer,b.byteOffset,b.byteLength)),m=D}else g=b.byteLength,m=a._malloc(g),n.push(m),a.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,g),m)}else g=b.byteLength,m=a._malloc(g),n.push(m),a.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,g),m)}}let y=a.stackSave(),v=a.stackAlloc(4*c.length);try{c.forEach((x,$)=>a.setValue(v+$*l,x,l===4?"i32":"i64"));let b=a._OrtCreateTensor(Cd(u),m,g,v,c.length,iC(f));b===0&&mr(`Can't create tensor for input/output. session=${r}, index=${i}.`),e.push(b)}finally{a.stackRestore(y)}},OR=async(t,e,n,r,s,i)=>{let o=Tr(),a=o.PTR_SIZE,l=Kc.get(t);if(!l)throw new Error(`cannot run inference. invalid session id: ${t}`);let u=l[0],c=l[1],d=l[2],f=l[3],m=l[4],g=l[5],y=e.length,v=r.length,b=0,x=[],$=[],S=[],E=[],L=o.stackSave(),R=o.stackAlloc(y*a),D=o.stackAlloc(y*a),A=o.stackAlloc(v*a),F=o.stackAlloc(v*a);try{[b,x]=zH(i),vh("wasm prepareInputOutputTensor");for(let se=0;se<y;se++)await PS(n[se],$,E,t,c[e[se]],e[se],m);for(let se=0;se<v;se++)await PS(s[se],S,E,t,d[r[se]],y+r[se],m);bh("wasm prepareInputOutputTensor");for(let se=0;se<y;se++)o.setValue(R+se*a,$[se],"*"),o.setValue(D+se*a,c[e[se]],"*");for(let se=0;se<v;se++)o.setValue(A+se*a,S[se],"*"),o.setValue(F+se*a,d[r[se]],"*");if(f&&!g){let{handle:se,outputPreferredLocations:fe,outputPreferredLocationsEncoded:me}=f;if(c.length!==y)throw new Error(`input count from feeds (${y}) is expected to be always equal to model's input count (${c.length}).`);vh("wasm bindInputsOutputs");for(let ye=0;ye<y;ye++){let oe=e[ye];await o._OrtBindInput(se,c[oe],$[ye])!==0&&mr(`Can't bind input[${ye}] for session=${t}.`)}for(let ye=0;ye<v;ye++){let oe=r[ye];s[ye]?.[3]?o._OrtBindOutput(se,d[oe],S[ye],0)!==0&&mr(`Can't bind pre-allocated output[${ye}] for session=${t}.`):o._OrtBindOutput(se,d[oe],0,me[oe])!==0&&mr(`Can't bind output[${ye}] to ${fe[ye]} for session=${t}.`)}bh("wasm bindInputsOutputs"),Kc.set(t,[u,c,d,f,m,!0])}o.jsepOnRunStart?.(u),o.webnnOnRunStart?.(u);let P;f?P=await o._OrtRunWithBinding(u,f.handle,v,A,b):P=await o._OrtRun(u,D,R,y,F,v,A,b),P!==0&&mr("failed to call OrtRun().");let K=[],j=[];vh("wasm ProcessOutputTensor");for(let se=0;se<v;se++){let fe=Number(o.getValue(A+se*a,"*"));if(fe===S[se]){K.push(s[se]);continue}let me=o.stackSave(),ye=o.stackAlloc(4*a),oe=!1,ue,_e=0;try{o._OrtGetTensorData(fe,ye,ye+a,ye+2*a,ye+3*a)!==0&&mr(`Can't access output tensor data on index ${se}.`);let Y=a===4?"i32":"i64",re=Number(o.getValue(ye,Y));_e=o.getValue(ye+a,"*");let Te=o.getValue(ye+a*2,"*"),Pe=Number(o.getValue(ye+a*3,Y)),de=[];for(let Oe=0;Oe<Pe;Oe++)de.push(Number(o.getValue(Te+Oe*a,Y)));o._OrtFree(Te)!==0&&mr("Can't free memory for tensor dims.");let ge=de.reduce((Oe,Ve)=>Oe*Ve,1);ue=Ku(re);let Re=f?.outputPreferredLocations[r[se]];if(ue==="string"){if(Re==="gpu-buffer"||Re==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Oe=[];for(let Ve=0;Ve<ge;Ve++){let We=o.getValue(_e+Ve*a,"*"),nt=o.getValue(_e+(Ve+1)*a,"*"),ct=Ve===ge-1?void 0:nt-We;Oe.push(o.UTF8ToString(We,ct))}K.push([ue,de,Oe,"cpu"])}else if(Re==="gpu-buffer"&&ge>0){let Oe=o.jsepGetBuffer;if(!Oe)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Ve=Oe(_e),We=Ed(re,ge);if(We===void 0||!mR(ue))throw new Error(`Unsupported data type: ${ue}`);oe=!0,K.push([ue,de,{gpuBuffer:Ve,download:o.jsepCreateDownloader(Ve,We,ue),dispose:()=>{o._OrtReleaseTensor(fe)!==0&&mr("Can't release tensor.")}},"gpu-buffer"])}else if(Re==="ml-tensor"&&ge>0){let Oe=o.webnnEnsureTensor,Ve=o.webnnIsGraphInputOutputTypeSupported;if(!Oe||!Ve)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Ed(re,ge)===void 0||!gR(ue))throw new Error(`Unsupported data type: ${ue}`);if(!Ve(t,ue,!1))throw new Error(`preferredLocation "ml-tensor" for ${ue} output is not supported by current WebNN Context.`);let We=await Oe(t,_e,re,de,!1);oe=!0,K.push([ue,de,{mlTensor:We,download:o.webnnCreateMLTensorDownloader(_e,ue),dispose:()=>{o.webnnReleaseTensorId(_e),o._OrtReleaseTensor(fe)}},"ml-tensor"])}else if(Re==="ml-tensor-cpu-output"&&ge>0){let Oe=o.webnnCreateMLTensorDownloader(_e,ue)(),Ve=K.length;oe=!0,j.push((async()=>{let We=[Ve,await Oe];return o.webnnReleaseTensorId(_e),o._OrtReleaseTensor(fe),We})()),K.push([ue,de,[],"cpu"])}else{let Oe=D4(ue),Ve=new Oe(ge);new Uint8Array(Ve.buffer,Ve.byteOffset,Ve.byteLength).set(o.HEAPU8.subarray(_e,_e+Ve.byteLength)),K.push([ue,de,Ve,"cpu"])}}finally{o.stackRestore(me),ue==="string"&&_e&&o._free(_e),oe||o._OrtReleaseTensor(fe)}}f&&!m&&(o._OrtClearBoundOutputs(f.handle)!==0&&mr("Can't clear bound outputs."),Kc.set(t,[u,c,d,f,m,!1]));for(let[se,fe]of await Promise.all(j))K[se][2]=fe;return bh("wasm ProcessOutputTensor"),K}finally{o.webnnOnRunEnd?.(u),o.stackRestore(L),$.forEach(P=>o._OrtReleaseTensor(P)),S.forEach(P=>o._OrtReleaseTensor(P)),E.forEach(P=>o._free(P)),b!==0&&o._OrtReleaseRunOptions(b),x.forEach(P=>o._free(P))}},PR=t=>{let e=Tr(),n=Kc.get(t);if(!n)throw new Error("invalid session id");let r=n[0],s=e._OrtEndProfiling(r);s===0&&mr("Can't get an profile file name."),e._OrtFree(s)},FR=t=>{let e=[];for(let n of t){let r=n[2];!Array.isArray(r)&&"buffer"in r&&e.push(r.buffer)}return e}}),Xc,Xa,cm,L2,M2,Ov,FS,Pv,wd,vd,VF,zX,VX,BX,UX,WX,jX,GX,HX=ht(()=>{ul(),MX(),Op(),dR(),Xc=()=>!!Er.wasm.proxy&&typeof document<"u",cm=!1,L2=!1,M2=!1,Pv=new Map,wd=(t,e)=>{let n=Pv.get(t);n?n.push(e):Pv.set(t,[e])},vd=()=>{if(cm||!L2||M2||!Xa)throw new Error("worker not ready")},VF=t=>{switch(t.data.type){case"init-wasm":cm=!1,t.data.err?(M2=!0,FS[1](t.data.err)):(L2=!0,FS[0]()),Ov&&(URL.revokeObjectURL(Ov),Ov=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=Pv.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}}},zX=async()=>{if(!L2){if(cm)throw new Error("multiple calls to 'initWasm()' detected.");if(M2)throw new Error("previous call to 'initWasm()' failed.");if(cm=!0,Xc())return new Promise((t,e)=>{Xa?.terminate(),LH().then(([n,r])=>{try{Xa=r,Xa.onerror=i=>e(i),Xa.onmessage=VF,FS=[t,e];let s={type:"init-wasm",in:Er};!s.in.wasm.wasmPaths&&(n||sC)&&(s.in.wasm.wasmPaths={wasm:new URL("/assets/ort-wasm-simd-threaded.jsep-BGTZ4Y7F.wasm",import.meta.url).href}),Xa.postMessage(s),Ov=n}catch(s){e(s)}},e)});try{await fR(Er.wasm),await NR(Er),L2=!0}catch(t){throw M2=!0,t}finally{cm=!1}}},VX=async t=>{if(Xc())return vd(),new Promise((e,n)=>{wd("init-ep",[e,n]);let r={type:"init-ep",in:{epName:t,env:Er}};Xa.postMessage(r)});await AR(Er,t)},BX=async t=>Xc()?(vd(),new Promise((e,n)=>{wd("copy-from",[e,n]);let r={type:"copy-from",in:{buffer:t}};Xa.postMessage(r,[t.buffer])})):hx(t),UX=async(t,e)=>{if(Xc()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return vd(),new Promise((n,r)=>{wd("create",[n,r]);let s={type:"create",in:{model:t,options:{...e}}},i=[];t instanceof Uint8Array&&i.push(t.buffer),Xa.postMessage(s,i)})}else return RR(t,e)},WX=async t=>{if(Xc())return vd(),new Promise((e,n)=>{wd("release",[e,n]);let r={type:"release",in:t};Xa.postMessage(r)});DR(t)},jX=async(t,e,n,r,s,i)=>{if(Xc()){if(n.some(o=>o[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some(o=>o))throw new Error("pre-allocated output tensor is not supported for proxy.");return vd(),new Promise((o,a)=>{wd("run",[o,a]);let l=n,u={type:"run",in:{sessionId:t,inputIndices:e,inputs:l,outputIndices:r,options:i}};Xa.postMessage(u,FR(l))})}else return OR(t,e,n,r,s,i)},GX=async t=>{if(Xc())return vd(),new Promise((e,n)=>{wd("end-profiling",[e,n]);let r={type:"end-profiling",in:t};Xa.postMessage(r)});PR(t)}}),LS,BF,qX,x5e=ht(()=>{ul(),HX(),rn(),hR(),BH(),LS=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},BF=t=>{switch(t[3]){case"cpu":return new tl(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!mR(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:s}=t[2];return tl.fromGpuBuffer(n,{dataType:e,dims:t[1],download:r,dispose:s})}case"ml-tensor":{let e=t[0];if(!gR(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:s}=t[2];return tl.fromMLTensor(n,{dataType:e,dims:t[1],download:r,dispose:s})}default:throw new Error(`invalid data location: ${t[3]}`)}},qX=class{async fetchModelAndCopyToWasmMemory(t){return BX(await yR(t))}async loadModel(t,e){Wl();let n;typeof t=="string"?n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await UX(n,e),sl()}async dispose(){return WX(this.sessionId)}async run(t,e,n){Wl();let r=[],s=[];Object.entries(t).forEach(d=>{let f=d[0],m=d[1],g=this.inputNames.indexOf(f);if(g===-1)throw new Error(`invalid input '${f}'`);r.push(m),s.push(g)});let i=[],o=[];Object.entries(e).forEach(d=>{let f=d[0],m=d[1],g=this.outputNames.indexOf(f);if(g===-1)throw new Error(`invalid output '${f}'`);i.push(m),o.push(g)});let a=r.map((d,f)=>LS(d,()=>`input "${this.inputNames[s[f]]}"`)),l=i.map((d,f)=>d?LS(d,()=>`output "${this.outputNames[o[f]]}"`):null),u=await jX(this.sessionId,s,a,o,l,n),c={};for(let d=0;d<u.length;d++)c[this.outputNames[o[d]]]=i[d]??BF(u[d]);return sl(),c}startProfiling(){}endProfiling(){GX(this.sessionId)}}}),KX={};W1(KX,{OnnxruntimeWebAssemblyBackend:()=>vC,initializeFlags:()=>wC,wasmBackend:()=>XX});var wC,vC,XX,_5e=ht(()=>{ul(),HX(),x5e(),wC=()=>{(typeof Er.wasm.initTimeout!="number"||Er.wasm.initTimeout<0)&&(Er.wasm.initTimeout=0);let t=Er.wasm.simd;if(typeof t!="boolean"&&t!==void 0&&t!=="fixed"&&t!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${t}". Reset it to \`false\` and ignore SIMD feature checking.`),Er.wasm.simd=!1),typeof Er.wasm.proxy!="boolean"&&(Er.wasm.proxy=!1),typeof Er.wasm.trace!="boolean"&&(Er.wasm.trace=!1),typeof Er.wasm.numThreads!="number"||!Number.isInteger(Er.wasm.numThreads)||Er.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Er.wasm.numThreads=1;else{let e=typeof navigator>"u"?lDe("node:os").cpus().length:navigator.hardwareConcurrency;Er.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},vC=class{async init(t){wC(),await zX(),await VX(t)}async createInferenceSessionHandler(t,e){let n=new qX;return await n.loadModel(t,e),n}},XX=new vC});ul();ul();ul();var I5e="1.23.2",T5e=AH;{let t=(_5e(),Uy(KX)).wasmBackend;Rd("webgpu",t,5),Rd("webnn",t,5),Rd("cpu",t,10),Rd("wasm",t,10)}Object.defineProperty(Er.versions,"web",{value:I5e,enumerable:!0});const S5e=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return R4},get TRACE(){return Wy},get TRACE_EVENT_BEGIN(){return vh},get TRACE_EVENT_END(){return bh},get TRACE_FUNC_BEGIN(){return Wl},get TRACE_FUNC_END(){return sl},get Tensor(){return tl},default:T5e,get env(){return Er},get registerBackend(){return Rd}},Symbol.toStringTag,{value:"Module"}));window.ort=S5e;const MS="/models/yolov5s.onnx",z2=640,$5e=3,C5e=0,UF=67;function E5e({roomId:t="DEMO",role:e="candidate",onLeave:n}){const r=lr.useRef(null),s=lr.useRef(null),i=lr.useRef(null),o=lr.useRef(null),a=lr.useRef(z2),l=lr.useRef(0),u=lr.useRef(null),[c,d]=lr.useState({facePresent:!1,multipleFaces:!1,eyesClosed:!1,phoneDetected:!1,transcript:"",score:0}),[f,m]=lr.useState(!1),[g,y]=lr.useState(!1),v=lr.useRef(null),b=lr.useRef(null),x=lr.useRef(null),$=lr.useRef(""),S=typeof NT<"u"&&Object.keys(NT).length>0?NT:window.tf||null,E=typeof a8<"u"?a8:window.faceLandmarksDetection||null,L=typeof u8<"u"?u8:window.cocoSsd||null;S||console.warn("Warning: tf (TensorFlow) not found as import or global."),E||console.warn("Warning: faceLandmarksDetection not found as import or global."),L||console.warn("Warning: cocoSsd not found as import or global.");const R=lr.useRef(null),D=lr.useRef(0),A=lr.useRef(null);lr.useEffect(()=>(F(),()=>{if(P(),R.current){try{R.current()}catch{}R.current=null}}),[]),lr.useEffect(()=>((async()=>{try{console.log("Auto-start monitoring on mount...");try{wa.apiKey&&wa.apiKey!=="REPLACE_ME"&&await se()}catch(Re){console.warn("startSignalListener warning",Re)}await Y()}catch(Re){console.error("Auto-start monitoring error",Re)}})(),()=>{try{re()}catch{}}),[]);async function F(){try{console.log("Requesting camera & microphone...");const ge=await navigator.mediaDevices.getUserMedia({video:{width:{ideal:1280},height:{ideal:720},facingMode:"user"},audio:!0});u.current=ge,r.current?(r.current.srcObject=ge,console.log("Local camera stream attached")):console.warn("localVideoRef.current is NULL  video element not ready yet")}catch(ge){console.error("startLocalStream error:",ge),alert("Camera / mic access is required for the demo. "+(ge&&ge.message?ge.message:""))}}function P(){try{u.current?.getTracks().forEach(ge=>ge.stop()),i.current?.close(),re()}catch{}}async function K(){i.current=new RTCPeerConnection,u.current.getTracks().forEach(Oe=>i.current.addTrack(Oe,u.current));const ge=new MediaStream;i.current.ontrack=Oe=>{Oe.streams[0].getTracks().forEach(Ve=>ge.addTrack(Ve)),s.current&&(s.current.srcObject=ge)},i.current.onconnectionstatechange=()=>{m(i.current.connectionState==="connected"||i.current.connectionState==="completed")},i.current.onicecandidate=async Oe=>{Oe.candidate&&wa.apiKey!=="REPLACE_ME"&&await _v(t,{type:"ice",candidate:Oe.candidate})};const Re=await i.current.createOffer();await i.current.setLocalDescription(Re),wa.apiKey==="REPLACE_ME"?prompt("Share this offer with remote peer (copy entire JSON):",JSON.stringify(i.current.localDescription)):(await tDe(t,{owner:e}),await _v(t,i.current.localDescription))}async function j(ge){if(!i.current){i.current=new RTCPeerConnection,u.current.getTracks().forEach(Oe=>i.current.addTrack(Oe,u.current));const Re=new MediaStream;i.current.ontrack=Oe=>{Oe.streams[0].getTracks().forEach(Ve=>Re.addTrack(Ve)),s.current&&(s.current.srcObject=Re)},i.current.onconnectionstatechange=()=>{m(i.current.connectionState==="connected"||i.current.connectionState==="completed")},i.current.onicecandidate=async Oe=>{Oe.candidate&&wa.apiKey!=="REPLACE_ME"&&await _v(t,{type:"ice",candidate:Oe.candidate})}}if(ge.type==="offer"||ge.type==="answer"){const Re=ge;if(await i.current.setRemoteDescription(Re),Re.type==="offer"){const Oe=await i.current.createAnswer();await i.current.setLocalDescription(Oe),wa.apiKey==="REPLACE_ME"?prompt("Send this answer back to remote peer (copy):",JSON.stringify(i.current.localDescription)):await _v(t,i.current.localDescription)}}else if(ge.type==="ice"&&ge.candidate)try{await i.current.addIceCandidate(ge.candidate)}catch(Re){console.warn(Re)}}async function se(){if(wa.apiKey!=="REPLACE_ME"&&!R.current)try{R.current=nDe(t,ge=>{console.log("[signals] received",ge),ge&&j(ge).catch(Re=>console.error("handleIncomingSignal error",Re))}),console.log("[signals] listening for room",t)}catch(ge){console.error("startSignalListener error",ge)}}function fe(ge,Re=z2){const Oe=document.createElement("canvas");Oe.width=Re,Oe.height=Re;const Ve=Oe.getContext("2d"),We=ge.videoWidth||ge.width,nt=ge.videoHeight||ge.height,ct=Math.min(We,nt),Ct=Math.max(0,(We-ct)/2),Wt=Math.max(0,(nt-ct)/2);Ve.drawImage(ge,Ct,Wt,ct,ct,0,0,Re,Re);const Et=Ve.getImageData(0,0,Re,Re).data,vt=new Float32Array(3*Re*Re);for(let Ht=0;Ht<Re;Ht++)for(let Tt=0;Tt<Re;Tt++){const Pt=(Ht*Re+Tt)*4,Rt=Et[Pt]/255,Yt=Et[Pt+1]/255,mn=Et[Pt+2]/255,jt=Ht*Re+Tt;vt[jt]=Rt,vt[Re*Re+jt]=Yt,vt[2*Re*Re+jt]=mn}return new tl("float32",vt,[1,3,Re,Re])}function me(ge,Re=z2,Oe=.25){const Ve=ge.data,We=ge.dims;if(!We||We.length<3)return[];const nt=We[1],ct=We[2],Ct=ct-5,Wt=[];for(let Et=0;Et<nt;Et++){const vt=Et*ct,Ht=Ve[vt],Tt=Ve[vt+1],Pt=Ve[vt+2],Rt=Ve[vt+3],Yt=Ve[vt+4];let mn=-1,jt=0;for(let xr=0;xr<Ct;xr++){const fr=Ve[vt+5+xr];fr>jt&&(jt=fr,mn=xr)}const Fn=Yt*jt;if(Fn<Oe)continue;const Vn=Ht-Pt/2,Bn=Tt-Rt/2,Ln=Ht+Pt/2,Tn=Tt+Rt/2;Wt.push({x1:Vn,y1:Bn,x2:Ln,y2:Tn,score:Fn,classId:mn})}return Wt}function ye(ge,Re=.45){ge.sort((We,nt)=>nt.score-We.score);const Oe=[],Ve=(We,nt)=>{const ct=Math.max(We.x1,nt.x1),Ct=Math.max(We.y1,nt.y1),Wt=Math.min(We.x2,nt.x2),Et=Math.min(We.y2,nt.y2),vt=Math.max(0,Wt-ct),Ht=Math.max(0,Et-Ct),Tt=vt*Ht,Pt=(We.x2-We.x1)*(We.y2-We.y1),Rt=(nt.x2-nt.x1)*(nt.y2-nt.y1),Yt=Pt+Rt-Tt;return Yt===0?0:Tt/Yt};for(let We=0;We<ge.length;We++){let nt=!0;for(let ct=0;ct<Oe.length;ct++)if(Ve(ge[We],Oe[ct])>Re){nt=!1;break}nt&&Oe.push(ge[We])}return Oe}async function oe(ge=MS,Re=z2){try{return{session:await R4.create(ge,{executionProviders:["wasm"]}),inputSize:Re}}catch(Oe){throw console.error("loadYoloModel error",Oe),Oe}}async function ue(){try{console.log("loadModels: using createDetector path (face-landmarks-detection)");const ge=E||window.faceLandmarksDetection||null,Re=L||window.cocoSsd||null;let Oe=Re&&Re.default?Re.default:Re;if(!ge)throw console.error("loadModels: face-landmarks lib not available."),new Error("face-landmarks missing");const We=ge.SupportedModels&&(ge.SupportedModels.MediaPipeFaceMesh||ge.SupportedModels.mediapipeFacemesh)||"MediaPipeFaceMesh";console.log("loadModels: creating detector with model:",We);const nt=await ge.createDetector(We,{runtime:"tfjs",maxFaces:4,refineLandmarks:!0});if(console.log("loadModels: detector created"),v.current={estimateFaces:async ct=>{const Ct=ct&&ct.input?ct.input:ct;return await nt.estimateFaces(Ct,{flipHorizontal:!1})}},!Oe)throw console.error("loadModels: coco-ssd lib not available."),new Error("coco-ssd missing");b.current?console.log("loadModels: coco already loaded"):(b.current=await Oe.load(),console.log("loadModels: coco-ssd loaded"));try{if(!o.current){console.log("loadModels: loading YOLO ONNX from",MS);const{session:ct,inputSize:Ct}=await oe(MS,z2);o.current=ct,a.current=Ct,console.log("loadModels: YOLO loaded")}}catch(ct){console.warn("loadModels: YOLO load failed  continuing without YOLO",ct)}console.log("loadModels: done  models ready")}catch(ge){throw console.error("loadModels error",ge),ge}}async function _e(){const ge=r.current;if(!ge||ge.readyState<2)return;let Re={...c};try{if(b.current){const We=await b.current.detect(ge);Re.phoneDetected=We.some(nt=>{const ct=(nt.class||"").toLowerCase();return(ct.includes("phone")||ct.includes("cell"))&&(nt.score||0)>.45})}}catch(We){console.warn("obj detect error",We)}let Oe=[];try{if(o.current&&(l.current=(l.current+1)%$5e,l.current===0)){const We=fe(ge,a.current),nt=o.current.inputNames&&o.current.inputNames[0]||o.current._inputNames&&o.current._inputNames[0]||"images",ct={};ct[nt]=We;const Ct=await o.current.run(ct),Wt=Object.keys(Ct)[0],Et=Ct[Wt],vt=me(Et,a.current,.25),Ht=ye(vt,.45),Tt=ge.videoWidth||ge.width,Pt=ge.videoHeight||ge.height,Rt=Math.min(Tt,Pt),Yt=Math.max(0,(Tt-Rt)/2),mn=Math.max(0,(Pt-Rt)/2),jt=Rt/a.current;Oe=Ht.map(Fn=>{const Vn=Fn.x1*jt+Yt,Bn=Fn.y1*jt+mn,Ln=Fn.x2*jt+Yt,Tn=Fn.y2*jt+mn;return{x1:Vn,y1:Bn,x2:Ln,y2:Tn,score:Fn.score,classId:Fn.classId}})}}catch(We){console.warn("yolo inference error",We),Oe=[]}const Ve=Oe&&Oe.length>0?Oe.filter(We=>We.classId===C5e||We.classId===UF):[];Ve&&Ve.length>0&&(Re.facePresent=!0,Re.multipleFaces=Ve.length>1,Re.phoneDetected=Re.phoneDetected||Ve.some(We=>We.classId===UF));try{if(v.current){let We=null;if(Ve&&Ve.length>0){const ct=Ve[0],Ct=Math.max(96,Math.round(ct.x2-ct.x1)),Wt=Math.max(96,Math.round(ct.y2-ct.y1)),Et=document.createElement("canvas");Et.width=Ct,Et.height=Wt,Et.getContext("2d").drawImage(ge,ct.x1,ct.y1,ct.x2-ct.x1,ct.y2-ct.y1,0,0,Ct,Wt),We=await v.current.estimateFaces({input:Et,returnTensors:!1,flipHorizontal:!1})}else We=await v.current.estimateFaces({input:ge,returnTensors:!1,flipHorizontal:!1});const nt=We||[];if(Re.facePresent=Re.facePresent||!!(nt&&nt.length>0),Re.multipleFaces=Re.multipleFaces||!!(nt&&nt.length>1),console.log("faces (landmarks) count:",nt?.length),nt&&nt.length>0){const ct=nt[0],Ct={outerCorner:33,top1:160,top2:159,bottom1:145,bottom2:144,innerCorner:133},Wt={outerCorner:362,top1:385,top2:386,bottom1:374,bottom2:373,innerCorner:263},Et=(Tt,Pt)=>Math.hypot(Tt[0]-Pt[0],Tt[1]-Pt[1]),vt=ct?.scaledMesh||ct?.keypoints&&ct.keypoints.map(Tt=>[Tt.x,Tt.y,Tt.z])||null;let Ht=0;if(vt){const Tt=vt[Ct.outerCorner],Pt=vt[Ct.innerCorner],Rt=vt[Ct.top1],Yt=vt[Ct.top2],mn=vt[Ct.bottom1],jt=vt[Ct.bottom2],Fn=vt[Wt.outerCorner],Vn=vt[Wt.innerCorner],Bn=vt[Wt.top1],Ln=vt[Wt.top2],Tn=vt[Wt.bottom1],xr=vt[Wt.bottom2],fr=Un=>Un&&Un.every(Boolean);let Ar=0,Hs=0;fr([Tt,Rt,Yt,Pt,mn,jt])&&(Ar=(Et(Rt,jt)+Et(Yt,mn))/(2*Et(Tt,Pt))),fr([Fn,Bn,Ln,Vn,Tn,xr])&&(Hs=(Et(Bn,xr)+Et(Ln,Tn))/(2*Et(Fn,Vn)));const qr=((Ar>0?Ar:0)+(Hs>0?Hs:0))/((Ar>0?1:0)+(Hs>0?1:0)||1);Ht=isFinite(qr)?qr:0,(Ht>0?Ht<.2:!1)?D.current=Math.min(D.current+1,5):D.current=Math.max(D.current-1,0),Re.eyesClosed=D.current>=3}else{const Tt=ct?.annotations?.leftEyeUpper0,Pt=ct?.annotations?.leftEyeLower0;if(Tt&&Pt&&Tt[3]&&Pt[3]){const Rt=Tt[3],Yt=Pt[3];Math.hypot(Rt[0]-Yt[0],Rt[1]-Yt[1])<4?D.current=Math.min(D.current+1,5):D.current=Math.max(D.current-1,0),Re.eyesClosed=D.current>=3}else Re.eyesClosed=!1}console.log("face landmarks sample:",ct?.annotations||ct?.scaledMesh||ct?.keypoints),console.log("EAR avg:",Ht,"eyesClosedCounter:",D.current)}else D.current=0}}catch(We){console.warn("face detect error",We)}!Re.multipleFaces&&Oe&&Oe.length>1&&(Re.multipleFaces=!0),d(We=>({...We,...Re}))}async function Y(){if(g){console.log("startMonitoring: already running, skipping");return}y(!0);try{console.log("startMonitoring: loading models..."),await ue(),console.log("startMonitoring: models ready");try{(!u.current||!(u.current.getTracks&&u.current.getTracks().length))&&(console.log("startMonitoring: requesting local stream..."),await F())}catch(ge){console.warn(ge)}try{wa.apiKey&&wa.apiKey!=="REPLACE_ME"&&await se()}catch(ge){console.warn(ge)}try{Te()}catch(ge){console.warn(ge)}try{await _e()}catch(ge){console.warn("initial analyzeFrame failed",ge)}A.current&&clearInterval(A.current),A.current=setInterval(async()=>{try{await _e()}catch(ge){console.error("monitor loop error",ge)}},700),console.log("startMonitoring: monitoring loop started")}catch(ge){console.error("startMonitoring error",ge);try{re()}catch{}y(!1)}}function re(){y(!1),A.current&&clearInterval(A.current),Pe()}function Te(){const ge=window.SpeechRecognition||window.webkitSpeechRecognition;if(!ge){console.warn("SpeechRecognition not available"),d(Oe=>({...Oe,transcript:Oe.transcript||"SpeechRecognition not supported"}));return}const Re=new ge;Re.continuous=!0,Re.interimResults=!0,Re.lang="en-US",Re.onresult=Oe=>{const Ve=Array.from(Oe.results).map(nt=>nt[0].transcript).join(" ");let We=0;if($.current&&$.current.trim().length>0){const nt=sDe($.current,Ve);We=Math.max(0,100-Math.round(nt*100))}else{const nt=Ve.trim().split(/\s+/).filter(Boolean).length;We=Math.min(100,nt*5)}d(nt=>({...nt,transcript:Ve,score:We}))},Re.onerror=Oe=>{console.error("recog error",Oe)};try{Re.start(),x.current=Re,console.log("SpeechRecognition started")}catch(Oe){console.warn("SpeechRecognition start error",Oe)}}function Pe(){try{x.current?.stop(),x.current=null}catch{}}async function de(){if(wa.apiKey!=="REPLACE_ME"&&await se(),e==="interviewer")await K();else if(wa.apiKey==="REPLACE_ME"){const ge=prompt("Paste remote offer JSON here:");if(!ge)return;const Re=JSON.parse(ge);await j(Re)}else await se()}return et.jsxs("div",{className:"grid md:grid-cols-3 gap-4",children:[et.jsxs("div",{className:"md:col-span-2 space-y-4",children:[et.jsxs("div",{className:"flex items-center justify-between",children:[et.jsxs("div",{className:"text-lg font-semibold",children:["Room: ",t||"DEMO"]}),et.jsxs("div",{className:"space-x-2",children:[et.jsx("button",{onClick:()=>{P(),n()},className:"px-3 py-1 bg-red-600 text-white rounded-lg",children:"End Meeting"}),et.jsx("button",{onClick:()=>{P(),n()},className:"px-3 py-1 bg-slate-200 rounded-lg",children:"Logout"})]})]}),et.jsxs("div",{className:"grid md:grid-cols-2 gap-4",children:[et.jsx(oO,{title:"You (Local)",streamRef:r,muted:!0}),et.jsx(oO,{title:"Remote",streamRef:s,muted:!1})]}),et.jsxs("div",{className:"bg-white rounded-2xl p-4 shadow flex gap-2",children:[et.jsx("button",{onClick:de,className:"px-3 py-2 bg-indigo-600 text-white rounded-lg",children:"Create/Join (Auto)"}),wa.apiKey==="REPLACE_ME"&&et.jsxs(et.Fragment,{children:[et.jsx("button",{onClick:()=>{const ge=prompt("Paste remote offer JSON here:");ge&&j(JSON.parse(ge))},className:"px-3 py-2 bg-emerald-600 text-white rounded-lg",children:"Paste Offer"}),et.jsx("div",{className:"text-sm text-slate-500 self-center",children:"Manual copy/paste signaling if Firebase not configured."})]})]})]}),et.jsxs("div",{children:[et.jsx(pse,{status:c}),et.jsxs("div",{className:"mt-4 bg-white p-4 rounded-2xl shadow space-y-2",children:[et.jsx("button",{onClick:Y,disabled:g,className:"w-full py-2 bg-emerald-600 text-white rounded-lg",children:"Start Monitoring"}),et.jsx("button",{onClick:re,disabled:!g,className:"w-full py-2 bg-slate-200 rounded-lg",children:"Stop Monitoring"}),et.jsx("div",{className:"text-xs text-slate-500 mt-2",children:"Note: Models are loaded in-browser. First load may take a few seconds."})]})]})]})}function k5e({user:t,onLogout:e}){const[n,r]=lr.useState(""),[s,i]=lr.useState(!1),[o,a]=lr.useState(t?.role||"candidate"),l=()=>{const c=Math.random().toString(36).substring(2,7).toUpperCase();r(c),i(!0),a("interviewer")},u=()=>{if(!n)return alert("Enter room code to join");i(!0),a("candidate")};return s?et.jsx(E5e,{roomId:n,role:o,onLeave:()=>{i(!1),r("")}}):et.jsxs("div",{className:"max-w-5xl mx-auto grid gap-6",children:[et.jsxs("div",{className:"bg-white p-6 rounded-2xl shadow",children:[et.jsxs("h2",{className:"text-xl font-semibold mb-4",children:["Welcome, ",t.displayName||t.email]}),et.jsxs("div",{className:"space-y-3",children:[et.jsxs("div",{children:[et.jsx("label",{className:"text-sm",children:"Create Room (Interviewer)"}),et.jsx("div",{className:"flex gap-2 mt-2",children:et.jsx("button",{onClick:l,className:"px-4 py-2 bg-indigo-600 text-white rounded-lg",children:"Create Room"})})]}),et.jsxs("div",{children:[et.jsx("label",{className:"text-sm",children:"Join Room (Candidate)"}),et.jsxs("div",{className:"flex gap-2 mt-2",children:[et.jsx("input",{placeholder:"Room code e.g. ABC12",value:n,onChange:c=>r(c.target.value.toUpperCase()),className:"p-2 border rounded"}),et.jsx("button",{onClick:u,className:"px-4 py-2 bg-emerald-600 text-white rounded-lg",children:"Join Room"})]})]}),et.jsx("div",{className:"pt-4",children:et.jsx("button",{onClick:e,className:"px-4 py-2 bg-red-600 text-white rounded-lg",children:"Logout"})})]})]}),et.jsxs("div",{className:"bg-white p-6 rounded-2xl shadow",children:[et.jsx("h3",{className:"font-semibold",children:"How it works"}),et.jsxs("ol",{className:"list-decimal list-inside text-sm mt-2 space-y-1 text-slate-600",children:[et.jsx("li",{children:"Interviewer creates a room and shares the room code."}),et.jsx("li",{children:"Candidate joins using the room code."}),et.jsx("li",{children:"Video call starts; candidate monitoring runs in-browser and alerts appear."})]})]})]})}function N5e(){const[t,e]=lr.useState(null);return et.jsxs("div",{className:"min-h-screen flex flex-col",children:[et.jsx("header",{className:"bg-gradient-to-r from-indigo-600 to-sky-500 text-white p-4 shadow-lg",children:et.jsxs("div",{className:"container mx-auto flex items-center justify-between",children:[et.jsxs("div",{className:"flex items-center gap-3",children:[et.jsx("div",{className:"w-10 h-10 bg-white rounded-full flex items-center justify-center text-indigo-600 font-bold",children:"IM"}),et.jsx("h1",{className:"text-xl font-bold tracking-tight",children:"Interview MVP"})]}),et.jsxs("nav",{className:"space-x-4 text-sm opacity-90",children:[et.jsx("a",{href:"#",className:"hover:underline",children:"About"}),et.jsx("a",{href:"#",className:"hover:underline",children:"FAQs"}),et.jsx("a",{href:"#",className:"hover:underline",children:"Contact"})]})]})}),et.jsx("main",{className:"flex-1 container mx-auto p-6",children:t?et.jsx(k5e,{user:t,onLogout:()=>e(null)}):et.jsxs("div",{className:"max-w-5xl mx-auto grid md:grid-cols-2 gap-6",children:[et.jsx(dse,{onLogin:e}),et.jsx(fse,{onRegister:e})]})}),et.jsx("footer",{className:"bg-slate-900 text-slate-300 p-4",children:et.jsxs("div",{className:"container mx-auto text-sm flex justify-between",children:[et.jsxs("div",{children:[" ",new Date().getFullYear()," Interview MVP"]}),et.jsx("div",{children:"Contact us: demo@example.com"})]})})]})}YY.createRoot(document.getElementById("root")).render(et.jsx(jY.StrictMode,{children:et.jsx(N5e,{})}));
